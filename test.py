import os
import hashlib
from io       import open as ioOpen
from json      import loads as jLoads, dumps as jDumps
from glob      import glob as iGlob
from re       import match as iMatch, escape as iEscape
from re       import sub as iSub, subn as iSubn, split as iSplit
from re       import search as iSearch, compile as iCompile
from re       import findall as iFindall, finditer as iFinditer
from re       import IGNORECASE
from math      import floor as iFloor, ceil as iCeil, log as iLog
from time      import localtime, mktime, strftime, time as iTime
from time      import sleep as iSleep, timezone as iTimezone
from threading     import Thread as iThread, enumerate as iEnumerate
from threading     import currentThread
from datetime     import datetime, timedelta
from collections    import Counter as iCounter
from base64      import b64encode, b64decode
from sys      import version_info as pyVersion
from skin      import parseColor
from Tools.Directories   import resolveFilename, SCOPE_PLUGINS, SCOPE_FONTS
from Tools.Directories   import SCOPE_CURRENT_SKIN
from Plugins.Plugin    import PluginDescriptor
from Screens.Screen    import Screen
from Screens.ChannelSelection import ChannelContextMenu, ChannelSelectionBase
from Screens.ChannelSelection import service_types_tv, service_types_radio
from Screens.InfoBar   import InfoBar
from Tools.BoundFunction  import boundFunction as BF
from Tools.LoadPixmap   import LoadPixmap
from Components.PluginComponent import plugins as iPlugins
from Components.Harddisk  import harddiskmanager
from Components.Label   import Label
from Components.ScrollLabel  import ScrollLabel
from Components.Button   import Button
from Components.MenuList  import MenuList
from Components.ActionMap  import ActionMap
from Components.Pixmap   import Pixmap
from Components.NimManager  import nimmanager
from Components.Slider   import Slider
from enigma      import getDesktop, ePoint, eSize, gFont, eRect
from enigma      import eTimer, eDVBDB, addFont, fontRenderClass
from enigma      import iServiceInformation
from enigma      import eServiceReference, eServiceCenter
from enigma      import eListboxPythonMultiContent
from enigma      import RT_HALIGN_LEFT as LEFT
from enigma      import RT_HALIGN_RIGHT as RIGHT
from enigma      import RT_HALIGN_CENTER as CENTER
from enigma      import RT_VALIGN_CENTER
from Components.ConfigList  import ConfigListScreen
from Components.config   import config, ConfigSubsection, configfile
from Components.config   import getConfigListEntry, ConfigDirectory
from Components.config   import ConfigYesNo, ConfigElement, ConfigText
from Components.config   import ConfigSelection, ConfigSelectionNumber
from Components.config   import ConfigSubList, ConfigInteger
try:  import tarfile as iTar
except: iTar = None
try:  import zipfile as iZip
except: iZip = None
try: from xml.etree import ElementTree as iElem
except: iElem = None
try: from shutil import move as iMove, rmtree, copyfile as iCopyfile, copymode as iCopymode
except: iMove = iCopyfile = iCopymode = None
try:
 from urllib2 import Request as iRequest, urlopen as iUrlopen, URLError as iURLError, build_opener, install_opener, HTTPPasswordMgrWithDefaultRealm, HTTPDigestAuthHandler, HTTPHandler
 from urllib  import unquote as iUnquote, quote as iQuote
 from urlparse import urlparse as iUrlparse, parse_qs as iUrlparse_qs
except:
 try:
  from urllib.request import Request as iRequest, urlopen as iUrlopen, build_opener, install_opener, HTTPPasswordMgrWithDefaultRealm, HTTPDigestAuthHandler, HTTPHandler
  from urllib.error import URLError as iURLError
  from urllib.parse import unquote as iUnquote, quote as iQuote, urlparse as iUrlparse, parse_qs as iUrlparse_qs
 except:
  iRequest = iUrlopen = iURLError = iUnquote = iQuote = iUrlparse = build_opener = install_opener = HTTPPasswordMgrWithDefaultRealm = HTTPDigestAuthHandler = HTTPHandler = None
PLUGIN_NAME    = "AJPanel"
PLUGIN_DESCRIPTION  = "Enigma2 Tools"
VV8h7S   = "v10.5.1"
VVxjol    = "30-01-2025"
EASY_MODE    = 0
VVAgZf   = 0
VVLh1e   = 0
VVxQ5s  = resolveFilename(SCOPE_PLUGINS, base="Extensions/")
VVISpi  = resolveFilename(SCOPE_PLUGINS, base="SystemPlugins/")
VVXAzM   = "AJPan"
VV6RVR  = "AUTO FIND"
VVdfOm  = "Custom"
VVXOBf    = "/usr/share/enigma2/picon/"
VVgVTn   = "/etc/enigma2/"
VVlLfA   = VVgVTn + "settings"
VVnZCL = VVgVTn + "blacklist"
VVrOPV = VVgVTn + "whitelist_streamrelay"
VVi2UY    = ""
VVT0uN = "Regular"
VVspqx = "Fixed"
VV6Thi  = "AJP_Main"
VVDtIm = "AJP_Terminal"
VVIKra  = "AJP_Added"
VVTKvf = "AJP_System"
VV3IRX  = VVT0uN
VVQw1L    = ""
VVDs4N   = " && echo 'Successful' || echo 'Failed!'"
VVadcU  = "Cannot continue (No Enough Memory) !"
VVAKzT  = ["#119f1313","#11005500","#11a08000","#1118188b"]
VVVXjt    = ["KeyMap_RC"]
VVgDRh  = "utf8"
VVbM5H    = ("-" * 100, )
SEP      = "-" * 80
VVIlCj = 0
VVSm4H = 0
VVNkG2     = 0
VVPZ7F    = 1
VVZIqk    = 2
VV1UOW   = 3
VVIZbT   = 4
VVwsZy = 5
VVOuSW    = 6
VVa6GH    = 7
VV0v8m = 8
VV2rBO = 9
VV23Kz  = 10
VVi9he   = 11
VVGkIr  = 12
VVmMbY  = 13
VV2auk   = 14
VVLJjn    = 15
VVTxiS   = 16
VVTT4Q   = 17
VVAFxx    = 18
VVx4YV    = 19
VVwU8r  = 20
VV7rcW    = 21
VVfI5z   = 0
VVhlSe   = 1
VVoR3b   = 2
if not "VVNWd9" in globals(): VVNWd9 = set()
def FF1GWp(path, alias, scale=100, isRepl=0, save=True):
 try:
  addFont(path, alias, scale, isRepl)
  if save: VVNWd9.add(alias)
  return True
 except:
  try:
   addFont(path, alias, scale, isRepl, 0)
   if save: VVNWd9.add(alias)
   return True
  except:
   pass
 return False
def FFIXGD():
 lst = []
 try:
  from enigma import getFontFaces
  lst = getFontFaces()
 except:
  try:
   from skin import getFontFaces
   lst = getFontFaces()
  except:
   pass
 lst.extend(VVNWd9)
 if lst:
  global VV3IRX
  if VV6Thi in lst and CFG.fontPathMain.getValue(): VV3IRX = VV6Thi
  else               : VV3IRX = VVT0uN
  return sorted(list(set(lst)))
 else:
  return [VVT0uN]
config.plugins.AJPanel = ConfigSubsection()
CFG = config.plugins.AJPanel
CFG.showInMainMenu    = ConfigYesNo(default=False)
CFG.showInExtensionMenu   = ConfigYesNo(default=True)
CFG.showInChannelListMenu  = ConfigYesNo(default=True)
CFG.EventsInfoMenu    = ConfigYesNo(default=True)
CFG.keyboard     = ConfigSelection(default="v", choices=[("v", "Virtual Keyboard"),("s", "System Default")])
CFG.FileManagerExit    = ConfigSelection(default="d", choices=[("d", "Directory Up"),("e", "Exit")])
CFG.hotkey_signal    = ConfigSelection(default="lesc", choices=[("off", "Disable"),("lok", "Long-OK"),("lesc", "Long-Exit"),("lred", "Long-Red")])
CFG.subtDefaultEnc    = ConfigDirectory(default=VVgDRh)
CFG.screenshotFType    = ConfigSelection(default="jpg", choices=[("off", "Disable"),("jpg", "JPG"),("png", "PNG"),("bmp", "BMP")])
CFG.iptvAddToBouquetRefType  = ConfigSelection(default="4097", choices=[("1", "1     (DVB Stream)"),("4097", "4097 (ServiceMp3)"),("5001", "5001 (GST Player)"),("5002", "5002 (Ext-3 EPlayer)"),("8192", "8192 (HDMI input)"),("8193", "8193 (eServiceUri)"),("8793", "8793 (ServiceUrl)")])
CFG.autoResetFrozenIptvChan  = ConfigSelection(default="1", choices=[("off", "Off"),("on+", "Refresh + Notify"),("on", "Silent Refresh")])
CFG.hideIptvServerAdultWords = ConfigYesNo(default=False)
CFG.hideIptvServerChannPrefix = ConfigYesNo(default=False)
CFG.iptvHostsMode    = ConfigDirectory(default=VV6RVR, visible_width=45)
CFG.resumeMovies    = ConfigSelection(default="a", choices=[("off", "Disabled"),("a", "All"),("i", "IPTV Only"),("l", "All (Except IPTV)")])
CFG.MovieDownloadPath   = ConfigDirectory(default="/media/hdd/movie/", visible_width=45)
CFG.portalConnTimeout   = ConfigSelectionNumber(default=2, stepwidth=1, min=1, max=5, wraparound=False)
CFG.PIconsPath     = ConfigDirectory(default=VVXOBf, visible_width=45)
CFG.customMenuPath    = ConfigDirectory(default="/", visible_width=45)
CFG.backupPath     = ConfigDirectory(default="/", visible_width=45)
CFG.iptvHostsDirs    = ConfigText(default="")
CFG.subtitleEventLang   = ConfigSelection(default="o", choices=[("o", "Original"),("s", "English")])
CFG.subtitleFavPath    = ConfigText(default="/")
CFG.favServerPlaylist   = ConfigText(default="")
CFG.favServerPortal    = ConfigText(default="")
CFG.simplePortal    = ConfigYesNo(default=False)
CFG.browserStartPath   = ConfigText(default="/")
CFG.browserBookmarks    = ConfigText(default="/media/,/tmp/,/")
CFG.browserSortMode    = ConfigInteger(default=0, limits=(0, 5))
CFG.browserSortMix    = ConfigYesNo(default=False)
CFG.signalPos     = ConfigInteger(default=5, limits=(1, 9))
CFG.signalSize     = ConfigInteger(default=3, limits=(1, 13))
CFG.mixedColorScheme   = ConfigInteger(default=4, limits=(0, 4))
CFG.checkForUpdateAtStartup  = ConfigYesNo(default=False)
CFG.downloadAutoResume   = ConfigYesNo(default=True)
CFG.downloadMonitor    = ConfigYesNo(default=False)
CFG.lastTerminalCustCmdLineNum = ConfigInteger(default=0)
CFG.lastFileManFindPatt   = ConfigText(default="")
CFG.lastSubtFManFindDir   = ConfigText(default="/media/")
CFG.lastPkgProjDir    = ConfigText(default="/media/")
CFG.lastFeedPkgsDir    = ConfigText(default="/media/")
CFG.lastCustMenuPicDir   = ConfigText(default="")
CFG.lastCustMenuXmlDir   = ConfigText(default="")
CFG.lastCopyMoveDir    = ConfigText(default="")
CFG.lastFindTerminal   = ConfigText(default="")
CFG.lastFindServers    = ConfigText(default="")
CFG.lastFindIptv    = ConfigText(default="")
CFG.lastFindMovie    = ConfigText(default="")
CFG.lastFindSubtitle   = ConfigText(default="")
CFG.lastFindPackages   = ConfigText(default="")
CFG.lastFindServices   = ConfigText(default="")
CFG.lastFindSatName    = ConfigText(default="")
CFG.lastFindContextFind   = ConfigText(default="")
CFG.lastFindEditor    = ConfigText(default="")
CFG.lastFindGeneral    = ConfigText(default="")
CFG.lastFindRepl_fnd   = ConfigText(default="")
CFG.lastFindRepl_rpl   = ConfigText(default="")
CFG.fontPathMain    = ConfigText(default="")
CFG.fontPathTerm    = ConfigText(default="")
CFG.fontPathSys     = ConfigText(default="")
CFG.fontPathAdd     = ConfigText(default="")
CFG.transpColorPicons   = ConfigText(default="#11404040")
CFG.transpColorChannels   = ConfigText(default="#88004040")
CFG.epgLangTitle    = ConfigText(default="")
CFG.epgLangDescr    = ConfigText(default="")
CFG.lastFtpLocalPath   = ConfigText(default="")
CFG.lastNetworkDevice   = ConfigInteger(default=0)
CFG.terminalCmdFile    = ConfigText(default="ajpanel_cmd")
CFG.ConfirmTerminalExit   = ConfigYesNo(default=False)
CFG.terminalTextWrap   = ConfigYesNo(default=True)
CFG.terminalFontSizeCmd   = ConfigInteger(default=26, limits=(22, 35))
CFG.terminalFontSizeHist  = ConfigInteger(default=26, limits=(22, 35))
CFG.xmlTvNameCompRatio   = ConfigSelectionNumber(default=50, stepwidth=10, min=40, max=100)
CFG.xmlTvChannelRefFile   = ConfigText(default="")
CFG.wsAutoStart     = ConfigYesNo(default=True)
CFG.wsPort      = ConfigInteger(default=8383)
tmp = [("0", "No Timeout")]
for i in range(3,11): tmp.append((str(i), str(i)))
tmp.extend((("15", "15"), ("20", "20")))
CFG.playerPos     = ConfigInteger(default=0, limits=(0, 1))
CFG.playerJumpMin    = ConfigInteger(default=5, limits=(1, 10))
CFG.playerTimeout     = ConfigSelection(default="0", choices=tmp)
tmp = [("srt","FROM SRT FILE"),("#00FFFF","Aqua"),("#000000","Black"),("#0000FF","Blue"),("#FF00FF","Fuchsia"),("#808080","Gray"),("#008000","Green"),("#00FF00","Lime"),("#800000","Maroon"),("#000080","Navy"),("#808000","Olive"),("#800080","Purple"),("#FF0000","Red"),("#C0C0C0","Silver"),("#008080","Teal"),("#FFFFFF","White"),("#FFFF00","Yellow")]
CFG.subtBGTransp    = ConfigSelectionNumber(default=100, stepwidth=10, min=0, max=100, wraparound=False)
CFG.subtTextFg     = ConfigSelection(default="#FFFFFF", choices=tmp)
CFG.subtTextFont    = ConfigSelection(default=VV3IRX, choices=[(x,  x) for x in FFIXGD()])
CFG.subtTextSize    = ConfigSelectionNumber(default=50, stepwidth=5, min=30, max=100, wraparound=False)
CFG.subtTextAlign    = ConfigSelection(default="1", choices=[("0", "Left"),("1", "Center"),("2", "Right")])
CFG.subtShadowColor    = ConfigSelection(default="#000080", choices=tmp[1:])
CFG.subtShadowSize    = ConfigSelectionNumber(default=5, stepwidth=1, min=0, max=10, wraparound=False)
CFG.subtVerticalPos    = ConfigSelectionNumber(default=90, stepwidth=1, min=0, max=100, wraparound=False)
CFG.subtDelayMax    = ConfigSelectionNumber(default=10, stepwidth=10, min=10, max=60, wraparound=False)
CFG.subtDelaySec    = ConfigSelectionNumber(default=0, stepwidth=1, min=-CFG.subtDelayMax.getValue() * 60, max=CFG.subtDelayMax.getValue() * 60, wraparound=False)
del tmp
def FFk98P():
 mode = CFG.mixedColorScheme.getValue()
 if mode == 4:
  if os.path.isfile("/etc/apt/apt.conf"): return 0
  try:
   with open("/etc/issue", "r") as f:
    if iMatch(r"open.*vision", f.read(), IGNORECASE):
     return 1
  except: pass
  return 3
 else:
  return max(min(3, mode), 0)
VVfsez = FFk98P()
VV3Hcc = VV0p9P = VVPI2q = VVU4M8 = VVdLWL = VVWJEN = VV0MNp = VVaWxS = VVOQkl = VVWH8U = VVjojy = VVk4x7 = VV1l75 = VVv8b8 = VV2jvK = VVCQUS = ""
def FFLPQB()  : FF9D3K(FFBylk())
def FFa0BW()  : FF9D3K(FFFITj())
def FFL0nY(tDict): FF9D3K(jDumps(tDict, indent=4, sort_keys=True))
def FFOllP(*args): FFzSxR(1, 1,  *args)
def FF9D3K(*args) : FFzSxR(1 ,0,  *args)
def FFt2QP(*args): FFzSxR(0, 0,  *args)
def FFzSxR(addSep=1, isArray=1, *args):
 if not VVAgZf: return
 sep = (">>>> %s\n" % ("#" * 80)) if addSep else ""
 txt = sep
 if isArray:
  for item in args:
   if type(item) in (list, tuple, set):
    txt += ">>>> --> LIST START <--\n"
    for itm in item: txt += ".... %s\n" % str(itm)
    txt += ">>>> --> LIST END <--\n"
   elif isinstance(item, dict):
    txt += ">>>> LIST START <--\n"
    Len = 0
    for key, val in item.items(): Len = max(Len, len(str(key)))
    for key, val in item.items(): txt += ".... %s: %s\n" % (str(str(key).ljust(Len)), str(val))
    txt += ">>>> LIST END <--\n"
   else:
    txt += "---> %s\n" % str(item)
 else:
  cr = "\n" if addSep else ""
  txt += ">>>> %s%s" % (" , ".join(list(map(str, args))), cr)
 txt += sep.replace("#", "-")
 os.system("cat << '_EOF' \n" + str(txt) + "\n_EOF")
def FF1kvO(fnc):
 def VVKTb6(*args, **kwargs):
  t1 = iTime()
  fnc(*args, **kwargs)
  FF9D3K(">>>>>> Elapsed : %s sec\nargs = %s\nkwargs = %s" % (("%.6f" % (iTime() - t1)).rstrip("0"), args, kwargs))
 return VVKTb6
def FF5AqL(*args):
 t = "[%s] %s >> %s" % (PLUGIN_NAME, datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f'), " , ".join(list(map(str, args))))
 os.system("cat << '_EOF' \n%s\n_EOF" % t)
def FFHg5z(*args):
 with open("/tmp/ajpanel_log.txt", "a") as f:
  t =  datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')
  f.write("%s %s\n" % (t, " , ".join(list(map(str, args)))))
def FFQCZD(tDict): FFoZpv(jDumps(tDict, indent=4, sort_keys=True))
def FFoZpv(*args):
 if not VVAgZf: return
 path = "/tmp/ajp_log.txt"
 with open(path, "a") as f:
  f.write(">>>> %s\n" % (" , ".join(list(map(str, args)))))
 FFt2QP("Added to : %s" % path)
def FF6i3O(txt, isAppend=True, ignoreErr=False):
 if not VVAgZf: return
 tm = FFOVHG()
 err = "" if not ignoreErr else FFFITj()
 fileName = "/tmp/ajp_log.txt"
 with open(fileName, "a" if isAppend else "w") as f:
  if err: f.write(err)
  f.write("%s >> %s\n" % (tm, str(txt)))
 if err: FF9D3K(err)
 FF9D3K("Output Log File : %s" % fileName)
def FFFITj():
 try:
  from traceback import format_exc, format_stack
  trace = format_exc()
  if trace and len(trace) > 5:
   tm = FFOVHG()
   stack = format_stack()[:-1]
   sep = "*" * 70
   err = "\n%s\n*** %s\n%s\n\n" % (sep, tm, sep)
   err += "%s\n\n%s\n%s\n" % ("".join(stack), trace, sep)
   return err
 except:
  return "Cannot Trace !"
def FFBylk():
 import inspect
 lst = []
 for ndx, f in enumerate(inspect.stack()):
  if ndx > 0:
   lst.append("%s\t>> %s" % (os.path.basename(f[1]).ljust(20), f[3]))
 return "Last Fncs:\n" + "\n".join(lst)
VVsd8G = 0
def FFRxDm():
 global VVsd8G
 VVsd8G = iTime()
def FFsyx5(txt=""):
 FF9D3K(">>>>>> Elapsed : %s sec\t%s" % (("%.6f" % (iTime() - VVsd8G)).rstrip("0"), txt))
def FFns14(*args):
 for arg in args:
  if PLUGIN_NAME[:5].lower() in arg.lower():
   return True
 return False
VVVYmU = []
def FFtWSy(win):
 global VVVYmU
 if not win in VVVYmU:
  VVVYmU.append(win)
def FF5vVS(*args):
 global VVVYmU
 for win in VVVYmU:
  try: win.close()
  except: pass
 VVVYmU = []
def FF0JpZ(vTxt):
 if vTxt in globals(): del globals()[vTxt]
def FFSblG():
 BT_SCALE = BT_KEEP_ASPECT_RATIO = None
 try:
  from enigma import BT_SCALE, BT_KEEP_ASPECT_RATIO
 except:
  try  : from enigma import BT_SCALE, BT_FIXRATIO as BT_KEEP_ASPECT_RATIO
  except : pass
 if BT_SCALE and BT_KEEP_ASPECT_RATIO: return BT_SCALE | BT_KEEP_ASPECT_RATIO
 else        : return None
VVu0iP = FFSblG()
def getDescriptor(fnc, where, name, descr="", needsRestart=False):
 w = getDesktop(0).size().width()
 if w and w < 1920 : icon="icon.png"
 else    : icon="iconhd.png"
 if name == PLUGIN_NAME:
  descr = PLUGIN_DESCRIPTION
 else:
  if not descr:
   descr = "%s %s" % (PLUGIN_NAME, name or PLUGIN_DESCRIPTION)
  name = "AJ - %s" % name
 return PluginDescriptor(fnc=fnc, where=where, needsRestart=needsRestart, name=name, description=descr, icon=icon)
def FFni3h()  : return getDescriptor(FFAXYg , [ PluginDescriptor.WHERE_EXTENSIONSMENU ], "File Manager")
def FFcNlu() : return getDescriptor(FF5gD5  , [ PluginDescriptor.WHERE_EXTENSIONSMENU ], "IPTV Menu")
def FFJfv8()  : return getDescriptor(FFaOE1   , [ PluginDescriptor.WHERE_EXTENSIONSMENU ], "Movies Resume History")
def FFC2ni()  : return getDescriptor(FFNnrS  , [ PluginDescriptor.WHERE_EXTENSIONSMENU ], "Player Bar")
def FFAuFx(): return getDescriptor(FFTTz1, [ PluginDescriptor.WHERE_EXTENSIONSMENU ], "Plugin Browser")
def FF8JUs()  : return getDescriptor(FFHCKB   , [ PluginDescriptor.WHERE_EXTENSIONSMENU ], "Signal Monitor")
def FFRrQ4() : return getDescriptor(FFEYMZ  , [ PluginDescriptor.WHERE_EXTENSIONSMENU ], "Terminal")
def FFlNFN() : return getDescriptor(FFMvXn  , [ PluginDescriptor.WHERE_EXTENSIONSMENU ], CCKxBC.VVLYLV())
def FFoGZv()      : return getDescriptor(FFv5pr , [ PluginDescriptor.WHERE_EVENTINFO  ], "Service Information")
def Plugins(**kwargs):
 lst = [ getDescriptor(FFOYYI , [PluginDescriptor.WHERE_PLUGINMENU], PLUGIN_NAME, needsRestart=True)
  ,   getDescriptor(FF9nwa , [PluginDescriptor.WHERE_MENU]   , PLUGIN_NAME)
  ,   PluginDescriptor(fnc=FFRaGd, where=[PluginDescriptor.WHERE_SESSIONSTART], needsRestart=True, description="AJPanel Startup")
  ]
 if CFG.showInExtensionMenu.getValue():
  lst.append(FFni3h())
  lst.append(FFcNlu())
  lst.append(FFC2ni())
  lst.append(FFAuFx())
  lst.append(FF8JUs())
  lst.append(FFRrQ4())
  lst.append(FFlNFN())
  lst.append(FFJfv8())
 if CFG.EventsInfoMenu.getValue():
  lst.append(FFoGZv())
 return lst
def FFRaGd(reason, **kwargs):
 if reason == 0:
  FFrxHY()
  CCcR1B.VV6RMZ()
  if "session" in kwargs:
   session = kwargs["session"]
   FFo3hw(session)
   CCsyJ5(session)
   if CFG.wsAutoStart.getValue():
    CC3iMt(session).VVeHl3(True)
def FF9nwa(menuid, **kwargs):
 if menuid == "mainmenu" and CFG.showInMainMenu.getValue():
  return [(PLUGIN_NAME, FFOYYI, PLUGIN_NAME, 1)]
 else:
  return []
def FFOYYI(session, **kwargs):
 session.open(CC73QP)
def FFAXYg(session, **kwargs) : session.open(CC17eA)
def FF5gD5(session, **kwargs)  : session.open(CCTe4w)
def FFaOE1(session, **kwargs)    : session.open(CCnaRX)
def FFNnrS(session, **kwargs)  : CCsmqb.VVlIAT(session, VVYqW3=2)
def FFTTz1(session, **kwargs): CCBj8K.VVhtKh(session)
def FFHCKB(session, **kwargs)   : FFlUBp(session, reopen=True)
def FFEYMZ(session, **kwargs)  : session.open(CCu5WO)
def FFMvXn(session, **kwargs)  : CCKxBC.VVuwBy(session, True)
def FFv5pr(session, **kwargs):
 CCpebE.VVHeuY(session)
def FFo3hw(session):
 hk = None
 dm = FFdufB()
 if dm:
  try:
   from keymapparser import readKeymap
   readKeymap(VVoFUo + "keymap.xml")
   from GlobalActions import globalActionMap as hk
  except:
   pass
 else:
  cont = ["KeyMap_HK"]
  try: hk = ActionMap(contexts=cont, prio=1, parentScreen=session.screen)
  except: hk = ActionMap(contexts=cont, prio=0 if CCg47Y.VVKvUI() else 1)
  hk.execBegin()
 if hk:
  hk.actions["longOK"] = BF(FF9DzB, session, "lok")
  hk.actions["longCancel"]= BF(FF9DzB, session, "lesc")
  hk.actions["longRed"] = BF(FF9DzB, session, "lred")
  for k in (CCM6jS.VVNZ5c, CCM6jS.VVh5O6, CCM6jS.VV4OJI):
   hk.actions[k] = BF(CCM6jS.VVzUSZ, session, k, dm)
def FF9DzB(session, key):
 if CCM6jS.VVFFtV(session) or CFG.hotkey_signal.getValue() != key:
  return
 try:
  if CCHhER.VVjI5D:
   CCHhER.VVjI5D.close()
  if not CCsmqb.VVfMBZ:
   CCsmqb.VVlIAT(session, VVYqW3=1)
 except:
  pass
def FFBWtx(confItem, val):
 confItem.setValue(val)
 confItem.save()
 configfile.save()
def FFHY8B(confItem):
 if isinstance(confItem, ConfigSelectionNumber):
  if confItem.saved_value is None and str(confItem.value) == str(confItem.default):
   return False
  return str(confItem.value) != str(confItem.saved_value)
 else:
  return confItem.isChanged()
def FFNhKZ(SELF, title="", addLabel=False, addScrollLabel=False, VV9cxb=None, addCloser=False):
 Screen.__init__(SELF, SELF.session)
 if title: title = "  %s  " % title
 else : title = "" if SELF.VVmNvK["VVUjdH"] == VV7rcW else FFJ4QU()
 SELF["myTitle"] = Label(title)
 SELF["myBody"] = Label()
 SELF["myWP"] = Pixmap()
 SELF["myInfoFrame"] = Label()
 SELF["myInfoBody"] = Label()
 SELF.VV0lDu = eTimer()
 try: SELF.VVcM6c = SELF.VV0lDu.timeout.connect(BF(FFYK6n, SELF))
 except: SELF.VV0lDu.callback.append(BF(FFYK6n, SELF))
 SELF.onClose.append(SELF.VV0lDu.stop)
 FFYK6n(SELF)
 btnMode = SELF.VVmNvK["VVcmdl"]
 if btnMode in (1, 2): SELF["keyMenu"] = Pixmap()
 if btnMode in (2, 3): SELF["keyInfo"] = Pixmap()
 if SELF.VVmNvK["VVSwLg"] > 0:
  SELF["myBar"]  = Label()
  SELF["myLine"]  = Label()
  SELF["keyRed"]  = Label()
  SELF["keyGreen"] = Label()
  SELF["keyYellow"] = Label()
  SELF["keyBlue"]  = Label()
  SELF["keyRed"].hide()
  SELF["keyGreen"].hide()
  SELF["keyYellow"].hide()
  SELF["keyBlue"].hide()
 if addLabel:
  SELF["myLabel"] = Label()
 if addScrollLabel:
  SELF["myLabel"] = CC2Y8z(SELF)
 if VV9cxb:
  SELF["myMenu"] = MenuList(VV9cxb, True)
  FFrM8n(SELF,
  {
   "ok" : SELF.VVyuDa ,
   "cancel": SELF.close ,
  })
 if addCloser:
  FFrM8n(SELF,
  {
   "ok" : SELF.close,
   "cancel": SELF.close,
   "red" : SELF.close
  })
def FFrM8n(SELF, tDict, name="", prio=-1):
 name = name or "myActionMap"
 try: SELF[name] = ActionMap(contexts=VVVXjt, actions=tDict, prio=prio, parentScreen=SELF.session.screen)
 except: SELF[name] = ActionMap(contexts=VVVXjt, actions=tDict, prio=prio)
def FFmpyO(SELF, tDict, name=""):
 SELF[name or "myActionMap"].actions.update(tDict)
def FFJ4QU():
 return ("  %s" % VVQw1L)
def FFgo5c(SELF):
 global VVQw1L
 VVQw1L = SELF["myMenu"].l.getCurrentSelection()[0]
 return SELF["myMenu"].l.getCurrentSelection()[1]
def FFi79B(btn, txt):
 btn.setText(txt)
 if txt : btn.show()
 else : btn.hide()
def FFkEjh(txt):
 if r"\c" in txt:
  txt = iSub(r"\\c(.){8}" ,"" , txt, flags=IGNORECASE)
 return txt
def FFT7Bj(txt):
 while txt.startswith(("#f#", "#b#")):
  txt = txt[12:]
 return txt
def FFcUfR(color):
 return parseColor(color).argb()
def FFMhbx(obj, fg): FFPvX5(obj, fg, "", inv=True)
def FFgLA9(obj, bg): FFPvX5(obj, "", bg, inv=True)
def FFPvX5(obj, fg, bg, inv=True):
 if fg: obj.instance.setForegroundColor(parseColor(fg))
 if bg: obj.instance.setBackgroundColor(parseColor(bg))
 if inv: obj.instance.invalidate()
def FFuLAo(txt, color):
 if color:
  if "/" in txt: txt = txt.replace("/", r"\/")
  return r" | sed 's/%s/\\%s&\%s/gI'" % (txt, color, VVCQUS)
 else:
  return ""
def FFXgqw(word, color):
 if color: return r"echo -e '\%s%s\n--- %s\n%s\%s';" % (color, SEP, word, SEP, VVCQUS)
 else : return r"echo -e '%s\n--- %s\n%s';" % (SEP, word, SEP)
def FFKrMM(word, color, backToColor=None):
 if backToColor : return color + str(word) + backToColor
 else   : return color + str(word) + VVCQUS
def FFJMN1(color):
 if color: return "echo -e '%s' %s;" % (SEP, FFuLAo(SEP, VVjojy))
 else : return "echo -e '%s';" % SEP
def FFFGRS(title, color):
 title = "%s\n%s\n%s\n" % (SEP, title, SEP)
 return FFKrMM(title, color)
def FFvJ8o(menuObj, fg="#00ffffff", bg="#08005555"):
 menuObj.instance.setForegroundColorSelected(parseColor(fg))
 menuObj.instance.setBackgroundColorSelected(parseColor(bg))
def FFvfpL(fncCB):
 FFe43w(":", BF(FFrq0x, fncCB))
def FFrq0x(fncCB, result, retval):
 fncCB()
def FFdBYP(SELF, delay, fnc):
 SELF.timedFncTimer = eTimer()
 try: SELF.timedFncTimer_conn = SELF.timedFncTimer.timeout.connect(fnc)
 except: SELF.timedFncTimer.callback.append(fnc)
 SELF.timedFncTimer.start(delay, True)
def FF7iMz(SELF, fnc, title="Processing ...", clearMsg=True):
 FFoTZI(SELF, title)
 FFe43w(":", BF(FFtnxk, SELF, fnc, clearMsg))
def FFtnxk(SELF, fnc, clearMsg, result, retval):
 fnc()
 if clearMsg:
  FFoTZI(SELF)
def FF8385(session, fnc, title="Processing ..."):
 session.open(CCmH8P, fnc, title)
def FFJRPn(title="Processing ...", clearMsg=True, par=0):
 def VVuMpQ(fnc):
  def VVKTb6(*args, **kwargs):
   FF7iMz(args[par], BF(fnc, *args, **kwargs), title, clearMsg)
  return VVKTb6
 return VVuMpQ
def FF4aqG(cmd):
 from subprocess import Popen, PIPE
 try:
  process = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE, universal_newlines=True, shell=True)
  stdout, stderr = process.communicate()
  stdout = stdout.strip()
  stderr = stderr.strip()
  if stderr : return stderr
  else  : return stdout
 except Exception as e:
  if "memory" in str(e).lower(): return VVadcU
  else       : return ""
def FFQ1wB(cmd, trim=True):
 lst = FF4aqG(cmd).splitlines()
 if trim : return list(map(str.strip, lst))
 else : return lst
def FF2ndj(cmd):
 lines = FFQ1wB(cmd)
 if lines: return lines[0]
 else : return ""
def FFux9U(cmd):
 tFile = "/tmp/ajp_lines"
 FFnE7j(tFile)
 FF4aqG("%s > %s" % (cmd, tFile))
 lst = FF2kXa(tFile)
 FFnE7j(tFile)
 return lst
def FFe43w(cmd, cbFnc):
 global VVdwZ0
 VVdwZ0 = CCDRFn()
 VVdwZ0.VV70Ea(cmd, cbFnc)
def FFlonU(cmd):
 return os.system(FFQWwc(cmd)) == 0
def FFZZgw(cmd):
 return os.system(FForIE(cmd)) == 0
def FFQWwc(cmd)  : return cmd.rstrip("\t; ") + " > /dev/null 2>&1;"
def FForIE(cmd) : return cmd.rstrip("\t; ") + " 2> /dev/null;"
def FFClck(    SELF, cmd, **kwargs): SELF.session.open(CCYInC, VVtT2v=cmd, VVWRZK=True, VV5wgt=VVhlSe, **kwargs)
def FFUKoP(  SELF, cmd, **kwargs): SELF.session.open(CCYInC, VVtT2v=cmd, **kwargs)
def FF75rg(   SELF, cmd, **kwargs): SELF.session.open(CCYInC, VVtT2v=cmd, VVpqw1=True, VVGSDE=True, VV5wgt=VVhlSe, **kwargs)
def FFg05d(  SELF, cmd, **kwargs): SELF.session.open(CCYInC, VVtT2v=cmd, VVpqw1=True, VVGSDE=True, VV5wgt=VVoR3b, **kwargs)
def FF6NKJ(  SELF, cmd, **kwargs): SELF.session.open(CCYInC, VVtT2v=cmd, VV2BYW=True , **kwargs)
def FFbZB6(  session, cmd, **kwargs):      session.open(CCYInC, VVtT2v=cmd, VV2BYW=True , **kwargs)
def FF9CWb( SELF, cmd, **kwargs): SELF.session.open(CCYInC, VVtT2v=cmd, VVHJZR=True  , **kwargs)
def FFW91j(cmd):
 return FFlonU("which %s" % cmd)
def FF3mxO(cmd):
 if FFW91j(cmd): return True, "BusyBox" in FF4aqG("%s --help" % cmd)
 else   : return False, False
def FFJMbF():
 cmd = "if [ -f /etc/apt/apt.conf ]; then echo dpkg; else if [ -f /etc/opkg/opkg.conf ]; then echo opkg; else if which dpkg; then echo dpkg; else if which opkg; then echo opkg; else if which ipkg; then echo ipkg; else echo ''; fi; fi; fi; fi; fi"
 return FF2ndj(cmd)
def FFdufB():
 return FFKbVo("/etc/apt/apt.conf")
def FFbt47(mode, moreDirs=None):
 if mode == 0:
  dirs = [ "*boot*", "*/ba", "/proc" ]
 else:
  dirs = [  "*boot*"
    , "*picon*"
    , "*/ba"
    , "/bin"
    , "/dev"
    , "/hdd"
    , "/lib"
    , "/linuxrc"
    , "/mnt"
    , "/newroot"
    , "/proc"
    , "/run"
    , "/sbin"
    , "/sys"
    , "/usr"
    ]
 if moreDirs:
  dirs.extend(moreDirs)
 paths = []
 for item in dirs:
  paths.append("-ipath '%s'" % item)
 txt = " -o ".join(paths)
 return r"-type d \( %s \) -prune -o " % txt
VVEuxp     = 0
VVgalZ      = 1
VV68Kk      = 2
VV6g4l      = 3
VVuPdC     = 4
VVSqiD     = 5
VVw2da     = 6
VVNtuq = 7
VVT1hn = 8
VVhy5N = 9
VVV9EQ  = 10
VVBjy1     = 11
VVeNPM  = 12
VVbseS  = 13
VVu89s      = 14
VVgNsi     = 15
def FFMXCy(parmNum, grepTxt=""):
 if   parmNum == VVEuxp: param = ["update" , "apt-get update" ]
 elif parmNum == VVgalZ : param = ["list" , "apt list"  ]
 pkg = FFJMbF()
 if   pkg in ("ipkg", "opkg"): return "%s %s %s" % (pkg, param[0], grepTxt)
 elif pkg == "dpkg"   : return "%s %s" % (param[1]  , grepTxt)
 return ""
def FF4zTV(mode, package):
 if   mode == VV68Kk      : param = ["info"      , "apt show"]
 elif mode == VV6g4l     : param = ["files"      , "dpkg -L"]
 elif mode == VVuPdC     : param = ["search"      , "dpkg -S"]
 elif mode == VVSqiD     : param = ["download"     , "apt-get download"]
 elif mode == VVw2da     : param = ["install"     , "apt-get install -y"]
 elif mode == VVNtuq : param = ["install --force-reinstall" , "apt-get install --reinstall -y"]
 elif mode == VVT1hn : param = ["install --force-overwrite" , "dpkg -i --force-all"]
 elif mode == VVhy5N : param = ["install --force-downgrade" , "apt-get install --allow-downgrades -y"]
 elif mode == VVV9EQ : param = ["install --force-depends" , "apt-get install --no-install-recommends -y"]
 elif mode == VVBjy1     : param = ["remove"      , "apt-get purge --auto-remove -y"]
 elif mode == VVeNPM  : param = ["remove --force-remove"  , "dpkg --purge --force-all"]
 elif mode == VVbseS : param = ["remove --force-depends"  , "dpkg --remove --force-depends"]
 elif mode == VVu89s      : param = ["flag hold"     , "apt-mark hold"]
 elif mode == VVgNsi     : param = ["flag user"     , "apt-mark unhold"]
 else           : return ""
 if package:
  package = "'%s'" % package
 pkg = FFJMbF()
 if   pkg in ("ipkg", "opkg"): return "%s %s %s" % (pkg, param[0], package)
 elif pkg == "dpkg"   : return "%s %s" % (param[1], package)
def FF6SON():
 result = FF2ndj("ar -V 2> /dev/null | grep 'GNU ar'")
 if result.startswith("GNU ar"):
  cmd = " allOK='1';"
 else:
  notFoundCmd = " echo -e 'GNU \"ar\" command not found!';"
  installCmd = FF4zTV(VVw2da, "")
  if installCmd:
   verCmd = "FOUND=$(ar -V 2> /dev/null | grep 'GNU ar');"
   failed1 = "Please update your software or manually install \"ar\" command and try again."
   failed2 = "(\"ar\" is available in the packages : \"opkg-tools\" or \"binutils\")"
   failed3 = "Process Failed."
   cmd  = " allOK='0';"
   cmd += verCmd
   cmd += 'if [[ -z "$FOUND" ]]; then '
   cmd +=   notFoundCmd
   cmd += "  echo -e 'Trying to install \"opkg-Tools\" ...';"
   cmd +=    FFQWwc("%s enigma2-plugin-extensions-opkg-tools" % installCmd)
   cmd +=   verCmd
   cmd += ' if [[ -z "$FOUND" ]]; then '
   cmd += " echo -e 'Trying to install \"binutils\" ...';"
   cmd +=   FFQWwc("%s binutils" % installCmd)
   cmd += " fi;"
   cmd +=   verCmd
   cmd += ' if [[ -z "$FOUND" ]]; then '
   cmd += "  echo -e 'Installation failed !';"
   cmd += "  echo -e '%s' %s;"  % (failed1, FFuLAo(failed1, VVjojy))
   cmd += "  echo -e '%s' %s;"  % (failed2, FFuLAo(failed2, VVjojy))
   cmd += "  echo -e '\n%s' %s;" % (failed3, FFuLAo(failed3, VVPI2q))
   cmd += " else"
   cmd += "  echo -e 'Installed successfully.';"
   cmd += "  allOK='1';"
   cmd += " fi;"
   cmd += "else"
   cmd += "  allOK='1';"
   cmd += "fi;"
  else:
   cmd = " allOK='0';"
   cmd += notFoundCmd
 return cmd
def FF61q5(commandTool, toolPkgName, displayedName):
 cmd1 = ""
 installCmd = FF4zTV(VVw2da , "")
 if installCmd:
  failed1 = "Please update your software and try again."
  failed2 = "Process Failed."
  cmd1 += " echo -e '%s not found.';" % displayedName
  cmd1 += " echo -e 'Trying to install ...';"
  cmd1 +=   FFQWwc("%s %s" % (installCmd, toolPkgName))
  cmd1 += " FOUND=$(which  %s);"  % commandTool
  cmd1 += ' if [[ -z "$FOUND" ]]; then '
  cmd1 += "  echo -e 'Installation failed !';"
  cmd1 += "  echo -e '%s\n' %s;" % (failed1, FFuLAo(failed1, VVjojy))
  cmd1 += "  echo -e '%s' %s;" % (failed2, FFuLAo(failed2, VVPI2q))
  cmd1 += " else"
  cmd1 += "  echo -e 'Installed successfully.';"
  cmd1 += "  allOK='1';"
  cmd1 += " fi;"
 else:
  cmd1 += " echo -e '%s not found.';" % displayedName
 cmd  = " allOK='0';"
 cmd += "FOUND=$(which %s);" % commandTool
 cmd += 'if [[ -z "$FOUND" ]]; then '
 cmd +=   cmd1
 cmd += "else"
 cmd += "  allOK='1';"
 cmd += "fi;"
 return cmd
def FF4AtW():
 pFound, pBBox = FF3mxO("xz")
 if pFound:
  if pBBox:
   failed1 = "Please update your software and try again."
   failed2 = "Process Failed."
   cmd  = " allOK='0';"
   cmd += "echo -e 'Found BusyBox xz';"
   cmd += "echo -e 'Upgrading xz ...';"
   cmd +=  FFQWwc("%s" % FF4zTV(VVw2da , "xz"))
   cmd += "if [ $? -eq 0 ]; then"
   cmd += " echo -e 'Installed successfully.';"
   cmd += " allOK='1';"
   cmd += "else"
   cmd += " echo -e 'Installation failed !';"
   cmd += " echo -e '%s' %s;" % (failed1, FFuLAo(failed1, VVjojy))
   cmd += " echo -e '\n\n%s' %s;" % (failed2, FFuLAo(failed2, VVPI2q))
   cmd += "fi;"
   return cmd
  else:
   return " allOK='1';"
 else:
  return FF61q5("xz", "xz", "XZ")
def FFmx8y(path, maxSize=-1, encLst=None):
 if   encLst is None    : encLst = CC6ntZ.VVHZM4()
 elif isinstance(encLst, str) : encLst = [encLst]
 txt = ""
 for enc in encLst:
  try:
   with ioOpen(path, "r", encoding=enc) as f:
    txt = f.read(maxSize)
    txt = str(txt)
   break
  except:
   pass
 if txt.startswith(chr(239) + chr(187) + chr(191)):
  txt = txt[3:]
 return txt
def FF2kXa(path, keepends=False, maxSize=-1, encLst=None):
 txt = FFmx8y(path, maxSize, encLst=encLst)
 return txt.splitlines(keepends)
def FFjTOc(SELF, path, encLst=None):
 title = os.path.basename(path)
 if FFKbVo(path):
  maxSize = 60000
  if (FFLjtI(path) > maxSize):
   title="File too big (showing first 60kB only)"
  else:
   maxSize = -1
  lines = FFmx8y(path, maxSize=maxSize, encLst=encLst)
  if lines: FFSMJz(SELF, lines, title=title, VV5wgt=VVhlSe, width=1600, height=1000, VVAQi3=30, resize=False)
  else : FFJkFk(SELF, path, title=title)
 else:
  FFWfGZ(SELF, path, title)
def FFY7F5(SELF, fName, title):
 path = VVK8DT + fName
 if FFKbVo(path):
  txt = FFmx8y(path)
  for k, v in {"#W#":VVCQUS,"#Y#":VVk4x7,"#G#":VV0p9P,"#Gn#":VVOQkl,"#C#":VVv8b8,"#P#":VVdLWL}.items():
   txt = txt.replace(k, v)
  FFSMJz(SELF, txt, title=title, width=1600)
 else:
  FFWfGZ(SELF, path, title)
def FF4gEM(path):
 if VVkY7E(path):
  tList = os.listdir(path)
  if tList:
   dirs = []
   for item in tList:
    if os.path.isdir(path + item):
     dirs.append(item)
   if dirs:
    dirs.sort()
    return dirs
 return []
VVkY7E = os.path.exists
def FFKbVo(f, mode="r"):
 return os.access(f, {"r": os.R_OK, "w":os.W_OK}.get(mode, os.F_OK)) if f else False
def FFqXDL(f):
 return (os.path.exists(f) or os.path.islink(f)) if f else False
def FFdwbd(path, addTrailingSlash):
 parent = os.path.abspath(os.path.join(path, os.pardir))
 if addTrailingSlash : return FF9Uvy(parent)
 else    : return FFsxFo(parent)
def FFiZj6(path):
 return os.path.basename(os.path.normpath(path))
def FFz4NZ(path):
 try:
  os.mkdir(path)
  return "" if VVkY7E(path) else "Cannot create dir !"
 except Exception as e:
  return str(e)
def FFLjtI(path):
 try:
  if os.path.islink(FFsxFo(path)): return os.lstat(path).st_size
  elif os.path.isfile(path)    : return os.path.getsize(path)
 except:
  pass
 return -1
def FF1cqE(path):
 p = FFsxFo(path)
 if   os.path.islink(p) : return "SymLink"
 elif os.path.ismount(p) : return "Mount"
 elif os.path.isfile(p) : return "File"
 elif os.path.isdir(p) : return "Directory"
 else     : return ""
def FFxsAV(path):
 size = 0
 for Dir, dirs, files in os.walk(path):
  files = os.listdir(Dir)
  for f in files:
   fp = os.path.join(Dir, f)
   try:
    if os.path.islink(FFsxFo(fp)) : size += os.lstat(fp).st_size
    elif os.path.isfile(fp)     : size += os.path.getsize(fp)
   except:
    pass
 return size
def FFrfrn(path):
 totDir = totFile = totLink = 0
 for Dir, dirs, files in os.walk(path):
  files = os.listdir(Dir)
  for f in files:
   fp = os.path.join(Dir, f)
   if os.path.islink(FFsxFo(fp)) : totLink += 1
   elif os.path.isfile(fp)     : totFile += 1
   else         : totDir += 1
 return totDir, totFile, totLink
def FFnE7j(path):
 try: os.remove(path)
 except: pass
def FFqOnh(path):
 try: rmtree(path)
 except: pass
def FFy8Vf(path):
 FFlonU("chattr -AacDdijsStu '%s' &> /dev/null; rm -fr '%s'" % (path, path))
 FFnE7j(path)
 FFqOnh(path)
def FFc1M2():
 FFlonU("rm -rf /tmp/ajp_*")
def FF03ch(path):
 with open(path, "rb+") as f:
  try:
   f.seek(-1, 2)
   if ord(f.read(1)) not in (10, 13):
    f.write(b"\n")
  except:
   pass
def FFwvAe(path):
 return FFlonU("cp -f '%s' '%s.bak'" % (path, path))
def FF9Uvy(path):
 if not path.endswith("/"):
  path += "/"
 return path
def FFsxFo(path):
 if not path == "/":
  path = path.rstrip("/")
 return path
def FFYvtE(path, patt):
 if "[" in path or "]" in path:
  newPath = ""
  for char in path:
   if   char == "[": char = "[[]"
   elif char == "]": char = "[]]"
   newPath += char
 else:
  newPath = path
 return iGlob("%s%s" % (FF9Uvy(newPath), patt))
def FFhcsN():
 sigFile = "ajpanel_res_marker"
 try:
  p = os.path.abspath(os.path.dirname(__file__))
  if p:
   mainP = os.path.join(p, "")
   resP = os.path.join(p, "res", "")
   if FFKbVo(os.path.join(resP, sigFile)):
    return mainP, resP
 except:
  pass
 paths = []
 paths.append(VVxQ5s)
 paths.append(VVxQ5s.replace("lib", "lib64"))
 ba = "/media/ba/ba/"
 list = FF4gEM(ba)
 for p in list:
  p = ba + p + VVxQ5s
  paths.append(p)
 for p in paths:
  p = os.path.join(p, VVXAzM, "")
  if FFKbVo(os.path.join(p, "res", sigFile)):
   mainP = os.path.join(p, "")
   resP = os.path.join(mainP, "res", "")
   return mainP, resP
 mainP = os.path.join(VVxQ5s, VVXAzM , "")
 resP = os.path.join(mainP, "res", "")
 return mainP, resP
VVoFUo, VVK8DT = FFhcsN()
def FFrxHY(SELF=None):
 tLst = ("/media/hdd/", "/media/usb/", "/media/mmc/", "/media/", "/")
 bDir = FFJv8S()
 if not VVkY7E(bDir) or bDir in tLst:
  for p in tLst:
   newP = p + "ajpanel_backup/"
   if VVkY7E(p) and FFlonU("mkdir -p %s" % newP):
    bDir = newP
    break
 VVVviD = ""
 mvDir = FF9Uvy(CFG.MovieDownloadPath.getValue())
 if not VVkY7E(mvDir) or not mvDir.endswith("/movie/"):
  for p in ("/media/hdd/", "/media/usb/", "/media/mmc/", "/media/", bDir, "/"):
   tmpP = p + "movie/"
   if VVkY7E(p) and FFlonU("mkdir -p %s" % tmpP):
    CFG.MovieDownloadPath.setValue(tmpP)
    CFG.MovieDownloadPath.save()
    VVVviD = mvDir
    break
 def VV1VdM(item):
  path = item.getValue()
  if not VVkY7E(path) or path in tLst:
   item.setValue(bDir)
   item.save()
   return path
  return ""
 VVrFrt  = VV1VdM(CFG.backupPath)
 VVhVUy = VV1VdM(CFG.customMenuPath)
 if any((VVrFrt or VVhVUy or VVVviD)):
  configfile.save()
  if SELF:
   VVqz4B = lambda subj, oldP, newP: "%s:\n    From\t: %s\n    To\t: %s\n\n" % (FFKrMM(subj, VVk4x7), FFKrMM(oldP, VVPI2q), FFKrMM(newP, VVWH8U)) if oldP and newP and oldP != "/" and oldP != newP else ""
   txt  = VVqz4B("Backup/Restore Path"    , VVrFrt   , CFG.backupPath.getValue())
   txt += VVqz4B("Custom Menu"      , VVhVUy  , CFG.customMenuPath.getValue())
   txt += VVqz4B("Movie/Series Download"   , VVVviD , CFG.MovieDownloadPath.getValue())
   if txt.strip():
    txt = "The following directories were reset to default:\n\n%s\nYou can change paths from Settings.\n" % txt
    FFSMJz(SELF, txt, title="Settings Paths")
def FFJv8S():    return FF9Uvy(CFG.backupPath.getValue())
def FF5KK0():   return FFxmhY("iptv")
def FFNaQp():     return FFxmhY("logo")
def FF18rY(): return FFxmhY("pkg_download")
def FFl55O():  return FFxmhY("pkg_project")
def FFrCUc():   return FFxmhY("screenshot")
def FFeg8m():  return FFxmhY("export")
def FF4FYM():  return FFxmhY("share")
def FFxmhY(p):
 bPath = FFJv8S()
 p = bPath + FF9Uvy("ajpanel_" + p)
 return p if (VVkY7E(p) or FFlonU("mkdir -p '%s'" % p)) else bPath
def FFyWkH():
 lst = []
 for nm in ("Portal", "Playlist"): lst.extend(FFYvtE(FFJv8S(), "%s_Bookmarks*.txt" % nm))
 for oldF in lst:
  if os.path.isfile(oldF):
   newF = FF5KK0() + os.path.basename(oldF)
   if not FFKbVo(newF): FFlonU("mv '%s' '%s'" % (oldF, newF))
def FFaA3e():
 lst = []
 for nm in ("ref", "data"): lst.extend(FFYvtE(FFJv8S(), "ajpanel_share_%s_*.xml" % nm))
 for oldF in lst:
  if os.path.isfile(oldF):
   newF = FF4FYM() + os.path.basename(oldF)
   if not FFKbVo(newF): FFlonU("mv '%s' '%s'" % (oldF, newF))
def FFb7uh():
 lst = FFYvtE(FFJv8S(), "ajpanel_package_*")
 for oldP in lst:
  if os.path.isdir(oldP):
   newP = FFl55O() + os.path.basename(oldP)
   if not VVkY7E(newP):
    FFlonU("cp -r '%s' '%s' && rm -r '%s'" % (oldP, newP, oldP))
def FF0T6e(path):
 path = FFsxFo(path)
 target = ""
 try:
  if VVkY7E(path) and os.path.islink(path):
   target = os.readlink(path)
 except:
  pass
 return target
def FFeo1z(SELF):
 btnMode = SELF.VVmNvK["VVcmdl"]
 if btnMode in (1, 2): FFHTca(SELF["keyMenu"], "menu")
 if btnMode in (2, 3): FFHTca(SELF["keyInfo"], "info")
def FFbRME(pixmap, path):
 p = FF7uiV(path)
 if p:
  pixmap.instance.setScale(1)
  pixmap.instance.setPixmap(p)
 return p
def FFHTca(pixmap, fName):
 return FFbRME(pixmap, "%s%s%s" % (VVK8DT, fName, ".png"))
def FF7uiV(path):
 try:
  p = LoadPixmap(path)
  if p: return p
 except:
  pass
 return None
def FFUti6(satNum):
 satNum  = int(satNum)
 if   satNum == 0xeeee: return "DVB-T"
 elif satNum == 0xffff: return "DVB-C"
 else:
  satName = ""
  try:
   satName = nimmanager.getSatName(satNum)
  except:
   pass
  if not satName or "N/A" in satName:
   satName = FFYCut(satNum)
  return satName
def FFYCut(satNum):
 satNum  = int(satNum)
 if   satNum == 0xeeee: return "DVB-T"
 elif satNum == 0xffff: return "DVB-C"
 else:
  satDir = "E"
  if satNum > 1800:
   satDir = "W"
   satNum = 3600 - satNum
  satNum /= 10.0
  return "%s%s" % (str(satNum), satDir)
def FFgAAw(VVq9SN, isLong):
 sat = ""
 if VVq9SN.count(":") > 8:
  nameSpace = VVq9SN.split(":")[6]
  s   = nameSpace.zfill(8)[:4]
  val   = int(s, 16)
  if isLong : sat = FFUti6(val)
  else  : sat = FFYCut(val)
 return sat
def FFfCll(sat):
 try:
  s = sat.upper()
  if s.endswith("E") or s.endswith("W"):
   num = float(sat[:-1]) * 10
   if s.endswith("W"):
    num = 3600 - num
   return FFUti6(num)
 except:
  pass
 return sat
def FFPjK2(satNumStr):
 satDir = "E"
 satNum = int(satNumStr)
 if satNum < 0:
  satDir = "W"
 satNum /= 10.0
 return "%s%s" % (str(abs(satNum)), satDir)
def FFLlAM(SELF):
 s = CCZv30(SELF.session)
 return s.VVq9SN, s.VVadS0, s.VVjgtq, s.VVVmGQ, s.VVUwmk
def FFbhVV(info, param):
 if info:
  v = info.getInfo(param)
  if   v == -1  : return ""
  elif v in (-2, 1) : return info.getInfoString(param)
  else    : return str(v)
 else:
  return ""
def FF7iI0(info, param):
 if info:
  v = info.getInfo(param)
  if   v == -1: return ""
  elif v == -2: return info.getInfoString(param)
  else  : return str(v)
 else:
  return ""
def FFeWgN(VVq9SN, VVVmGQ, VVUwmk):
 if VVVmGQ : return VVVmGQ.replace(":" + VVUwmk, "")
 else  : return VVq9SN
def FFEnx2(VVq9SN):
 info = FFEKXQ(VVq9SN)
 return info and info.getName(eServiceReference(VVq9SN)) or ""
def FFikHv(VVq9SN):
 try:
  ns = VVq9SN.split(":")[6]
  ns = ns.zfill(8)[:4]
 except:
  ns = ""
 return ns.upper()
def FFtLHn(path, fName):
 if os.path.isfile(path + fName):
  return fName
 else:
  if fName.count("_") > 8:
   parts = fName.split("_")
   parts[2] = "1"
   fName = "_".join(parts)
   if os.path.isfile(path + fName):
    return fName
 return ""
def FFEKXQ(VVq9SN):
 service = eServiceReference(VVq9SN)
 info = None
 if service:
  VVimsO = eServiceCenter.getInstance()
  if VVimsO:
   info = VVimsO.info(service)
 return info
def FF9SoI(session, VVq9SN, checkParentalControl=False):
 if VVq9SN.count(":") > 8:
  serviceRef = eServiceReference(str(VVq9SN))
  servRef = eServiceReference(VVq9SN)
  session.nav.playService(servRef, checkParentalControl=checkParentalControl)
 try:
  VV2RgF = InfoBar.instance
  if VV2RgF:
   VVVnHH = VV2RgF.servicelist
   if VVVnHH:
    servRef = eServiceReference(VVq9SN)
    VVVnHH.saveChannel(servRef)
 except:
  pass
def FFQ2Oi(session, serviceRef, checkParentalControl=False):
 session.nav.playService(serviceRef, checkParentalControl=checkParentalControl)
def FFC4pX(VVq9SN):
 return iMatch(r"([A-Fa-f0-9]+[:]){10}.+\/\/.+", VVq9SN)
def FFgTKx(ref):
 return bool(iMatch(r"^[A-Fa-f0-9]+:64:", ref or ""))
def FF0mVx(ref):
 return "FROM BOUQUET " in ref.upper()
def FFKeSw(ref):
 if "chcm=" in ref.lower(): return False
 else      : return bool(iMatch(r".*https?(:|%3a)\/\/((127|0)\.\d+\.\d+\.\d+|localhost)(:|%3a)\d+\/.*", ref, IGNORECASE))
def FFkgyl(url)  : return CCGSVa.VVqRH8(url)
def FFgAmw(url)  : return FFkgyl(url) == "VOD"
def FFgcYJ(url)  : return FFkgyl(url) == "Series"
def FFn8GR(url): return FFkgyl(url) in ("VOD", "Series")
def FF5ov5(url):
 if url and iUnquote : return iUnquote(url)
 else    : return url
def FFTnsB(url):
 if url and iQuote : return iQuote(url)
 else    : return url
def FF5c8a(txt):
 return hashlib.md5(txt.encode("UTF-8")).hexdigest()
def FFaC9A(txt):
 try:
  return str(b64encode(txt.encode("utf-8")).decode("utf-8"))
 except:
  return txt
def FF9fW8(txt):
 try:
  return str(b64decode(txt).decode("utf-8"))
 except:
  return txt
def FFvVUT(txt):
 try:
  return FFaC9A(FF9fW8(txt)) == txt
 except:
  return False
def FFlUBp(session, reopen=False):
 if reopen:
  try:
   session.openWithCallback(BF(FFlUBp, session), CCHhER)
  except:
   try:
    FFvOl9(session, "Cannot launch Signal Monitor !", title="Signal Monitor")
   except:
    pass
def FFaKr0(VVq9SN):
 tp = CCrDr0()
 if tp.VVrbgC(VVq9SN) : return True
 else        : return False
def FF97G8(VVq9SN, isHide, skipReload=False):
 if VVq9SN.count(":") > 8:
  sRef = eServiceReference(VVq9SN)
  if sRef:
   db = eDVBDB.getInstance()
   if db:
    if isHide : ret = db.addFlag(sRef , 0x2)
    else  : ret = db.removeFlag(sRef, 0x2)
    if skipReload:
     return True if ret == 0 else False
    elif ret == 0:
     FFANYL(True)
     return True
 return False
def FFANYL(save=False):
 db = eDVBDB.getInstance()
 if db:
  if save:
   db.saveServicelist()
  db.reloadServicelist()
  db.reloadBouquets()
 FFD6Al()
def FFD6Al():
 VV2RgF = InfoBar.instance
 if VV2RgF:
  VVVnHH = VV2RgF.servicelist
  if VVVnHH:
   VVVnHH.setMode()
def FFM85b(root, mode=0):
 lst = []
 try:
  servicelist  = root and eServiceCenter.getInstance().list(root)
  VVimsO = eServiceCenter.getInstance()
  if servicelist:
   while True:
    service = servicelist.getNext()
    if not service.valid():
     break
    flags = service.flags
    if mode == 0 and service.flags & (eServiceReference.isDirectory | eServiceReference.isMarker):
     continue
    ref, info = service.toString(), VVimsO.info(service)
    name = info.getName(service)
    if   mode == 0: lst.append((ref, name))
    elif mode == 1: lst.append((ref, name, flags))
 except:
  pass
 return lst
def FFmCsn():
 VVlt7s = {0x01:"TV MPEG-2 SD",0x02:"Radio MPEG-1",0x03:"Teletext",0x04:"NVOD SD",0x05:"NVOD SD T.Shift",0x06:"Mosaic",0x07:"FM Radio",0x08:"DVB SRM",0x09:"Res. 9",0x0A:"Radio Adv. Codec",0x0B:"AVC Mosaic",0x0C:"Data",0x0D:"CI",0x0E:"RCS Map",0x0F:"RCS FLS",0x10:"DVB MHP",0x11:"TV HD MPEG-2",0x16:"TV SD H.264",0x17:"NVOD SD T.Sh.",0x18:"NVOD SD Ref.",0x19:"TV HD H.264",0x1A:"NVOD HD T.Sh.",0x1B:"NVOD HD Ref.",0x1C:"TV HD H.264",0x1D:"NVOD HD T.Sh.",0x1E:"NVOD HD Ref.",0x1F:"TV HEVC",0x20:"TV HEVC (HDR)",0x80:"User Def.",0x64:"Custom",0x81:"Custom",0x82:"Custom",0x84:"Custom",0x95:"Custom",0x98:"Custom",0x9B:"Custom",0xAB:"Custom",0xB4:"Custom",0xB5:"Custom",0xC6:"Custom",0xFA:"Custom",0xFB:"Custom",0xFC:"Custom"}
 VVuDJZ = list(VVlt7s)
 return VVuDJZ, VVlt7s
def FFLgRo():
 try:
  iPlugins.clearPluginList()
  iPlugins.readPluginList(resolveFilename(SCOPE_PLUGINS))
 except:
  pass
def FFiMxY(delta=0):
 Time = datetime.now() + timedelta(delta)
 midnight = Time.replace(hour=0, minute=0, second=0, microsecond=0)
 return mktime(midnight.timetuple())
def FFG6of(unixTime, wDay=False):
 return datetime.fromtimestamp(unixTime).strftime("%Y-%m-%d %H:%M:%S" + (" %a" if wDay else ""))
def FFENz0():
 year, month, day, hour, minute, second, weekDay, yearDay, dayLight = localtime()
 return "%04d-%02d-%02d %02d:%02d:%02d" % (year, month, day, hour, minute, second)
def FFyCC4(): return datetime.now().strftime("%Y-%m-%d %H:%M:%S")
def FFOVHG(): return datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")
def FFRIlf():
 return FFENz0().replace(" ", "_").replace("-", "").replace(":", "")
def FFrTEd(secs):
 m, s = divmod(secs, 60)
 h, m = divmod(m   , 60)
 return "%02d:%02d:%02d" % (h, m, s)
def FFUzwU(url, outFile, timeout=3, mustBeImage=False, tmpPath=""):
 tmpDir = tmpPath or "/tmp/"
 outFile = tmpDir + outFile
 span = iSearch(r".*data.+base64,(.+)", url, IGNORECASE)
 if span:
  b64 = span.group(1)
  with open(outFile, "wb") as f:
   f.write(b64decode(b64))
  return outFile, ""
 if not CCTe4w.VVqy70(url, justValidate=True):
  return "", "Invalid URL"
 if not iRequest:
  return "" , "Cannot import URLLIB/URLLIB2 !"
 try:
  req = iRequest(url.strip())
  req.add_header("User-Agent", CCTe4w.VVNsFc())
  res = iUrlopen(req, timeout=timeout)
  resCode = res.code
  if resCode == 200 :
   if mustBeImage and "text/html" in res.headers.get("Content-Type"):
    return "", "Received TEXT/HTML (instead of image)"
   with open(outFile, "wb") as f:
    f.write(res.read())
   cont = res.headers.get("content-disposition")
   if cont:
    phpFile = ""
    span = iSearch(r'filename=["*](.+)["*]', str(cont), IGNORECASE)
    if span:
     phpFile = span.group(1)
     phpFiLe = phpFile.replace(".", "")
     fName, ext = os.path.splitext(phpFile)
     fName = CCTe4w.VVXxU8(fName)
     phpFile = tmpDir + fName + ext
     FFlonU("mv -f '%s' '%s'" % (outFile, phpFile))
     outFile = phpFile
   if FFKbVo(outFile) : return outFile, ""
   else     : return "", "Cannot create file."
  else:
   if   resCode == 401 : err = "Unauthorized"
   elif resCode == 402 : err = "Payment Required"
   elif resCode == 408 : err = "Request Timeout"
   else    : err = "err=%d" % resCode
   return "", "Download Failed (%s)" % err
 except iURLError as e:
  return "",  FFxcy7(e)
 except Exception as e:
  return "", str(e)
def FFxcy7(e):
 err = ""
 if hasattr(e, "code") : err = "Error Code : %s\n" % str(e.code)
 if hasattr(e, "reason") : err += "Reason : %s\n" % str(e.reason)
 if not err    : err += "Error : %s"  % str(e)
 return err.strip()
def FFXclX(numStr):
 return iMatch(r"^([-+]?\d+(\.\d*)?$)", numStr) is not None
def FFaRsj(num):
 return "s" if num > 1 else ""
def FFbn8W(num, minNum, maxNum):
 return max(min(maxNum, num), minNum)
def FFtcG5(s):
 return ''.join([chr(int(s[i:i+2], 16)) for i in range(0, len(s), 2)])
def FFvKOW(txt, repl):
 return iSub(r"[^\x00-\x7F]", repl, txt)
def FFgYic(txt, repl):
 return iSub(r"[^A-Za-z0-9._-]", repl, txt)
def FFDJVB(txt, repl="_"):
 for ch in " ():/\\,;*/:*?<>|\"'": txt = txt.replace(ch, repl)
 txt = txt.replace("_-_", repl).replace("-_-", repl)
 txt = FFhTcV(txt, repl)
 return txt.strip(".") or "File"
def FFhTcV(txt, repl):
 while repl * 2 in txt: txt = txt.replace(repl * 2, repl)
 return txt.strip(repl) or repl
def FFel7I(OldValue, OldMin, OldMax, NewMin, NewMax):
 return (((OldValue - OldMin) * (NewMax - NewMin)) / (OldMax - OldMin)) + NewMin
def FFevFd(a, b):
 return (a > b) - (a < b)
def FFZoJv(a, b):
 def VV0kgX(var):
  return [ (int(c) if c.isdigit() else c) for c in iSplit(r'(\d+)', var) ]
 a = VV0kgX(a)
 b = VV0kgX(b)
 return (a > b) - (a < b)
def FFlhXH(mycmp):
 class CCLYHI(object):
  def __init__(self, obj, *args) : self.obj = obj
  def __lt__(self, other): return mycmp(self.obj, other.obj) < 0
  def __gt__(self, other): return mycmp(self.obj, other.obj) > 0
  def __eq__(self, other): return mycmp(self.obj, other.obj) == 0
  def __le__(self, other): return mycmp(self.obj, other.obj) <= 0
  def __ge__(self, other): return mycmp(self.obj, other.obj) >= 0
  def __ne__(self, other): return mycmp(self.obj, other.obj) != 0
 return CCLYHI
def FF4jcy(elem):
 return str(elem.text.encode("UTF-8").decode()).strip() if elem is not None and elem.text else ""
def FFfkDl(elem, attrib):
 return str(elem.attrib.get(attrib, "").encode("UTF-8").decode()).strip() if elem is not None else ""
def FFd3Fl(elem, child):
 return FF4jcy(elem.find(child))
def FFFjxV(elem, child, attrib):
 x = elem.find(child)
 if not x is None:
  return str(x.attrib.get(attrib, "").encode("UTF-8").decode()).strip()
 return ""
def FFih6H(elem, child):
 lst = []
 for el in elem.findall(child):
  lst.append(FF4jcy(el))
 return lst
def FFPwu2(elem):
 return str(iElem.tostring(elem, encoding="utf-8").decode()).strip()
def FFSlBO(item, key, isDate=False, is_base64=False, isToHHMMSS=False):
 if key in item:
  val = str(item[key])
  try:
   if   isDate  : val = FFG6of(int(val))
   elif is_base64 : val = FF9fW8(val)
   elif isToHHMMSS : val = FFrTEd(float(val))
  except:
   pass
  if val == "None": return ""
  else   : return val.strip()
 else:
  return ""
def FF0onH(SELF, message, title="", VVhK3C=None):
 SELF.session.openWithCallback(VVhK3C, CCu7jG, title=title, message=message, VV4n1E=True)
def FFSMJz(SELF, message, title="", VV5wgt=VVhlSe, VVhK3C=None, **kwargs):
 return SELF.session.openWithCallback(VVhK3C, CCu7jG, title=title, message=message, VV5wgt=VV5wgt, **kwargs)
def FFd2In(SELF, txt):
 SELF.session.open(CCk1tY, txt)
def FFv2op(session, *args, **kwargs):
 session.open(CCDBE6, *args, **kwargs)
def FFbBGq(SELF, message, title="")  : FFvOl9(SELF.session, message, title)
def FFWfGZ(SELF, path, title="") : FFvOl9(SELF.session, "File not found:\n\n%s" % path, title)
def FFJkFk(SELF, path, title="") : FFvOl9(SELF.session, "File is empty !\n\n%s"  % path, title)
def FFWaiD(SELF, title="")  : FFvOl9(SELF.session, "No Packaging Tools:\n\n(OPKG / IPKG / DPKG )", title)
def FFvOl9(session, message, title="") : session.open(BF(CCJq9D, title=title, message=message))
def FFoTZI(SELF, txt="", timeout=0, isGrn=False):
 if len(txt) > 0:
  try:
   FFgLA9(SELF["myInfoBody"], "#00004040" if isGrn else "#00550000")
   SELF["myInfoFrame"].show()
   SELF["myInfoBody"].show()
   SELF["myInfoBody"].setText(str(txt))
   if timeout > 0: SELF.VV0lDu.start(timeout, True)
  except: pass
 else: FFYK6n(SELF)
def FFxHED(SELF, txt="", timeout=1000):
 FFoTZI(SELF, txt, timeout=timeout, isGrn=True)
def FFtn0P(SELF, txt="", timeout=1000):
 FFvfpL(BF(FFoTZI, SELF, txt=txt, timeout=timeout, isGrn=True))
def FF8bV6(*kargs, **kwargs):
 FFvfpL(BF(FFoTZI, *kargs, **kwargs))
def FFYK6n(SELF):
 try:
  SELF.VV0lDu.stop()
  SELF["myInfoFrame"].hide()
  SELF["myInfoBody"].hide()
 except:
  pass
def FFNMah(SELF):
 try: return SELF["myInfoBody"].visible
 except: return False
def FFANcN(SELF, VVhK3C, title="", defaultText="", message=""):
 mode = CFG.keyboard.getValue()
 allOK = False
 if mode == "v":
  try:
   from Screens.VirtualKeyBoard import VirtualKeyBoard
   obj = SELF.session.openWithCallback(VVhK3C, VirtualKeyBoard, title=message, text=defaultText)
   allOK = True
   obj.setTitle(title)
  except:
   pass
 elif mode == "s":
  try:
   from Screens.InputBox import InputBox
   SELF.session.openWithCallback(VVhK3C, InputBox, windowTitle=title, title=message.replace("\n", " "), text=defaultText)
   allOK = True
  except:
   pass
 if not allOK:
  try:
   FFbBGq(SELF, "Cannot run the Input Dialog (keyboard) !", title="Keyboard Error")
  except:
   pass
def FF6pUe(SELF, callBack_Yes, VVqg4G, callBack_No=None, title="", VVv5tA=False, VVi3FS=True, VVYqW3=False):
 session = SELF if VVYqW3 else SELF.session
 return session.openWithCallback(BF(FF4bzy, callBack_Yes, callBack_No)
         , BF(CCk8ae, title=title, VVqg4G=VVqg4G, VVi3FS=VVi3FS, VVv5tA=VVv5tA))
def FF4bzy(callBack_Yes, callBack_No, FF6pUeed):
 if FF6pUeed : callBack_Yes()
 elif callBack_No: callBack_No()
def FFCXsL(SELF, callBackFunc, **kwargs):
 try:
  if callBackFunc : win = SELF.session.openWithCallback(callBackFunc, BF(CC4ngo, **kwargs))
  else   : win = SELF.session.open(BF(CC4ngo, **kwargs))
  FFtWSy(win)
  return win
 except:
  return None
def FFO9kU(SELF, callBackFunc, **kwargs):
 win = SELF.session.openWithCallback(callBackFunc, BF(CCZ5Xa, **kwargs))
 FFtWSy(win)
 return win
def FFZ27n(pixmapObj, path, VVYCun=None, fncCb_ok=None, fncCb_fail=None):
 return CCqCr4(pixmapObj, path, VVYCun, fncCb_ok, fncCb_fail).VVyG0J()
def FFT7cF(txt):
 return ("--[ %s ]%s" % (txt,  "-" * 100), )
def FFH04v(txt, ref, cond, color=""):
 return (color + txt, ref) if cond else (txt,)
def FFuwGk(SELF, isTopBar=False):
 if isTopBar : names = [ "keyRedTop" , "keyGreenTop" , "keyYellowTop", "keyBlueTop"  ]
 else  : names = [ "keyRed" , "keyGreen" , "keyYellow" , "keyBlue"  ]
 for name in names:
  try:
   FF0u5o(SELF[name], "#000000", 3)
  except:
   pass
def FF0u5o(label, color, w):
 try:
  inst = label.instance
  inst.setBorderColor(parseColor(color))
  inst.setBorderWidth(w)
 except:
  try:
   inst = label.instance
   inst.setShadowColor(parseColor(color))
   inst.setShadowOffset(ePoint(-2, -2))
  except:
   pass
def FFfPCL(SELF, menuObj):
 try:
  menuObj.instance.setFont(gFont(VV3IRX, SELF.VVmNvK["VVYvMU"]))
 except:
  try: menuObj.l.setFont(gFont(VV3IRX, SELF.VVmNvK["VVYvMU"]))
  except: pass
def FFaGqd(menuObj, offset):
 if hasattr(menuObj.instance, "setTextOffset"):
  menuObj.instance.setTextOffset(ePoint(offset, 0))
 else:
  try:
   menuObj.l.setLeftOffset(offset)
   menuObj.l.setRightOffset(offset)
  except:
   pass
def FFNUiO(SELF, menuObj=None, VV3an7=0, offset=20):
 if not menuObj:
  menuObj = SELF["myMenu"]
 FFfPCL(SELF, menuObj)
 FFaGqd(menuObj, offset)
 winInst  = SELF.instance
 menuInst = menuObj.instance
 maxH = SELF.VVmNvK["height"]
 winW = winInst.size().width()
 winH = winInst.size().height()
 menuW = menuInst.size().width()
 menuH = menuInst.size().height()
 lineH = menuObj.l.getItemSize().height()
 menuH1 = (max(VV3an7, len(menuObj.list))) * lineH
 diff = menuH1 - menuH
 winNewH = winH + diff
 btnDiff = diff
 if winNewH > winH:
  if winH + lineH <= maxH:
   btnDiff = lineH
   menuH = menuH + lineH
   menuInst.resize(eSize(*(menuW, menuH)))
   winInst.resize(eSize(*(winW, winH + lineH)))
  else:
   btnDiff = 0
  pos  = menuObj.getPosition()
  part = menuInst.size().height() % lineH
  half = int(part / 2)
  menuInst.resize(eSize(*(menuW, menuH - part)))
  menuInst.move(ePoint(pos[0], pos[1] + half))
 else:
  menuInst.resize(eSize(*(menuW, menuH + diff)))
  winInst.resize(eSize(*(winW, winNewH)))
 winH = winInst.size().height()
 screenSize = getDesktop(0).size()
 winInst.move(ePoint((screenSize.width() - winW) // 2, (screenSize.height() - winH) // 2))
 names = [ "keyRed", "keyGreen", "keyYellow", "keyBlue", "myBar", "myLine" ]
 for name in names:
  try:
   obj = SELF[name]
   pos = obj.getPosition()
   obj.instance.move(ePoint(pos[0], pos[1] + btnDiff))
  except:
   pass
 winSize = winInst.size()
 w, h = winSize.width(), winSize.height()
 SELF["myWP"].instance.resize(eSize(*(w, h)))
 FFg1s2(SELF, w, h)
def FFg1s2(SELF, w, h):
 fSize = SELF["myInfoFrame"].instance.size()
 bSize = SELF["myInfoBody"].instance.size()
 SELF["myInfoFrame"].instance.move(ePoint((w - fSize.width()) // 2, (h - fSize.height()) // 2))
 SELF["myInfoBody"].instance.move(ePoint((w - bSize.width()) // 2, (h - bSize.height()) // 2))
def FFbKGy(win, mode):
 inst = win.instance
 pos, sz = inst.position(), inst.size()
 x, y = pos.x(), pos.y()
 w, h = sz.width(), sz.height()
 sz = getDesktop(0).size()
 sW, sH = sz.width(), sz.height()
 if   mode == 0: x = (sW - w) // 2
 elif mode == 1: y = (sH - h) // 2
 elif mode == 2: x, y = (sW - w) // 2,  (sH - h) // 2
 inst.move(ePoint(int(x), int(y)))
def FFJaib(w):
 pos, sz = w.instance.position(), w.instance.size()
 return pos.x(), pos.y(), sz.width(), sz.height()
def FFcBkL():
 s = getDesktop(0).size()
 return (s.width(), s.height())
def FFP9a3(VVPYL1):
 screenSize  = FFcBkL()
 screenH   = screenSize[1]
 ratioH   = screenH / 1080.0
 VVYvMU = int(ratioH  * VVPYL1)
 return VVYvMU
def FFkCSf(VVPYL1, extraSpace):
 font = gFont(VV3IRX, VVPYL1)
 VVCW3G = fontRenderClass.getInstance().getLineHeight(font) or (VVPYL1 * 1.25)
 return int(VVCW3G + VVCW3G * extraSpace)
def FFQaOH(VVUjdH, width, height, VVAQi3, VVvs2f, VVXAYU, VVx8BU, VViaEk, VVYvMU, VVSwLg=0, VVoZRH=0, VVcmdl=0, VVwv0z=0.15, VV05bd=None, VV1j0B=False, VVDPpb=1, VVNLQc=True, VVzlf0=0, VVIZ5t={}):
 screenSize = FFcBkL()
 screenW = int(screenSize[0] * VVDPpb)
 screenH = int(screenSize[1] * VVDPpb)
 if width == 0 : width  = screenW
 if height == 0: height = screenH
 retPar   = None
 ratioW   = screenW / 1920.0
 ratioH   = screenH / 1080.0
 width   = int(ratioW  * width)
 height   = int(ratioH  * height)
 titleH   = int(ratioH  * 50)
 VVvs2f  = int(ratioW  * VVvs2f)
 VVXAYU  = int(ratioH  * VVXAYU)
 VVYvMU = int(ratioH  * VVYvMU)
 VVSwLg  = int(ratioH  * VVSwLg)
 VVoZRH  = int(ratioW  * VVoZRH)
 VVXAYU  = max(1, VVXAYU)
 scrollBarW  = int(ratioW * 15)
 bodyFontStr  = 'font="%s;%d"' % (VV3IRX, VVYvMU)
 alignCenter  = 'halign="center" valign="center"'
 alignLeftTop = 'halign="left" valign="top"'
 alignLeftCenter = 'halign="left" valign="center"'
 alignRightCenter= 'halign="right" valign="center"'
 VVAQi3 = min(int(ratioH  * VVAQi3), int(0.7  * titleH))
 bodyLineH  = FFkCSf(VVYvMU, VVwv0z)
 bodyW   = width - VVvs2f * 2
 bodyTop   = titleH + 1 + VVXAYU
 bodyH   = height - bodyTop - VVXAYU
 if VVSwLg > 0: bodyH -= VVSwLg
 zPos = 'zPosition="10000000"' if VVUjdH == VVwU8r else ""
 tmp  = '<screen position="center,center" size="%d,%d" backgroundColor="%s" title="%s" flags="wfNoBorder" %s >' % (width, height, VViaEk, PLUGIN_NAME, zPos)
 tmp += '<widget  name="myBody" position="0,0" size="%d,%d" zPosition="-1" backgroundColor="%s" />' % (width, height, VViaEk)
 if VVNLQc:
  tmp += '<eLabel position="0,%d" size="%d,1" zPosition="1" backgroundColor="#00666666" />' % (titleH + 1, width)
 tmp += '<widget name="myTitle" position="0,0" size="%d,%d" zPosition="2" noWrap="1" backgroundColor="%s" font="%s;%d" foregroundColor="#ffffbb" %s />' % (width, titleH, VVx8BU, VV3IRX, VVAQi3, alignLeftCenter)
 tmp += '<widget name="myWP" position="0,0" size="%d,%d" alphatest="blend" />' % (width, height)
 if VVUjdH == VV7rcW:
  pass
 elif VVUjdH in (VVNkG2, VVPZ7F):
  if VVUjdH == VVPZ7F : menuName = "config"
  else      : menuName = "myMenu"
  menuW = bodyW - int(bodyW * VVzlf0 / 100.0) - VVvs2f if VVzlf0 else bodyW
  tmp += '<widget name="%s" position="%d,%d" size="%d,%d" zPosition="3" backgroundColor="%s" itemHeight="%d" scrollbarMode="showOnDemand" />' % (menuName, VVvs2f, bodyTop, menuW, bodyH, VViaEk, bodyLineH)
  if VVzlf0:
   param = 'backgroundColor="%s" foregroundColor="#ffffff" %s' % (VViaEk, bodyFontStr)
   x, w, gap = menuW + VVvs2f * 2, bodyW - menuW - VVvs2f, int(VVvs2f / 2.0)
   tmp += '<widget name="myLabelFrm" position="%d,%d" size="%d,%d" zPosition="3" %s />' % (x - gap, bodyTop, w + gap * 2, bodyH, param)
   tmp += '<widget name="myLabelTit" position="%d,%d" size="%d,%d" zPosition="4" %s %s />' % (x, bodyTop + 10, w, titleH, alignCenter, param)
   tmp += '<widget name="myLabelTxt" position="%d,%d" size="%d,%d" zPosition="4" noWrap="1" %s %s />' % (x, bodyTop + titleH + gap , w, bodyH - titleH - gap * 2, alignLeftCenter, param)
 elif VVUjdH == VVwU8r:
  tmp += '<widget name="myWinTitle" position="0,0" size="%d,%d" zPosition="3" noWrap="1" transparent="1" foregroundColor="#ffffff" shadowColor="#440000" shadowOffset="-2,-2" %s %s />' % (width, titleH, bodyFontStr, alignCenter)
 elif VVUjdH == VVx4YV:
  names = ("Red", "Green", "Yellow", "Blue")
  colors = [ "#229f1313", "#22005500", "#22a08000", "#2218188b"]
  totBtns = len(names)
  gap  = 5
  btnW = int(width * 0.09)
  btnH = int(titleH * 0.7)
  left = width - btnW - titleH * 2
  top  = int((titleH - btnH) / 2.0)
  fSize = int(0.45  * titleH)
  for i in range(totBtns-1, -1, -1):
   tmp += '<widget name="key%s" position="%d,%d" size="%d,%d" zPosition="3" font="%s;%d" backgroundColor="%s" %s />' % (names[i], left, top, btnW, btnH, VV3IRX, fSize, colors[i], alignCenter)
   left -= (btnW + gap)
  names = ("Del", "BGTr", "TxtFg", "TxtFnt", "TxtSiz", "Align", "ShadFg", "ShadSiz", "Pos")
  totBtns = len(names)
  btnW = int((width - gap * (totBtns + 1)) / totBtns)
  btnH = titleH
  left = gap
  param = 'size="%d,%d" zPosition="3" backgroundColor="#33222222" %s %s ' % (btnW, btnH, bodyFontStr, alignCenter)
  for i in range(totBtns):
   tmp += '<widget name="mySubt%s"  position="%d,%d" foregroundColor="#00cccccc" %s />' % (names[i], left, titleH + gap  , param)
   tmp += '<widget name="mySubt%s1" position="%d,%d" foregroundColor="#00ffff88" %s />' % (names[i], left, titleH + btnH + 1, param)
   left += btnW + gap
  tmp += '<widget name="mySubtCursor" position="0,%d" size="%d,%d" zPosition="2" backgroundColor="#00ffff00" />' % (titleH + 1, btnW + gap * 2, btnH * 2 + gap - 1)
  top = titleH + 1 + btnH * 2 + gap
  tmp += '<widget name="mySubtCover" position="0,0" size="%d,%d" zPosition="5" backgroundColor="#ff000000" />' % (width, top - 1)
  tmp += '<widget name="mySubtFr" position="0,%d" size="%d,%d" zPosition="3" backgroundColor="#ff002233" />' % (top, width, height - top)
  for i in range(4):
   tmp += '<widget name="mySubtSep%d" position="1,%d" size="%d,1" zPosition="7" backgroundColor="#00555555" />' % (i, top + 1, width - 2)
   if i < 3:
    tmp += '<widget name="mySubt%d" position="1,%d" size="%d,%d" zPosition="6" noWrap="1" backgroundColor="#00000000" %s %s />' % (i, top + 1, width - 2, titleH - 2, bodyFontStr, alignCenter)
   top += titleH
  y, w1, = 1, int(width / 3.0)
  x = int((width - w1) / 2.0)
  tmp += '<widget name="mySubtChng0" position="%d,0" size="%d,%d" zPosition="8" backgroundColor="#22555555" />' % (x-1, w1+2, btnH*3 + 5)
  fnt = 'font="%s;%d"' % (VV3IRX, int(btnH * 0.63))
  for i in range(1, 4):
   fg, bg = ("#00FFFF00", "#22220000") if i == 1 else ("#00ffffff", "#33002233")
   tmp += '<widget name="mySubtChng%d" position="%d,%d" size="%d,%d" zPosition="9" foregroundColor="%s" backgroundColor="%s" %s %s />' % (i, x, y, w1, btnH, fg, bg, fnt, alignCenter)
   y += btnH + 1
  w = int(w1 / 6.5)
  h = int(btnH * 0.65)
  gap = int((btnH - h)/ 2)
  x += w1 - w - gap
  y = y - btnH + gap
  tmp += '<widget name="myRest1" position="%d,%d" size="%d,%d" zPosition="90" backgroundColor="#22a08000" font="%s;%d" %s />' % (x, y, w, h, VV3IRX, int(h * 0.7), alignCenter)
 elif VVUjdH == VVLJjn:
  barH = int((bodyH + VVXAYU - VVXAYU * 3.0) / 3.0)
  picW = int(bodyW * 0.07)
  barW = bodyW - picW - VVvs2f
  b1Top = bodyTop
  b2Top = b1Top + barH + VVXAYU
  b3Top = b2Top + barH + VVXAYU
  timeW = int(barW * 0.1)
  b2Left1 = VVvs2f
  b2Left2 = timeW + VVvs2f * 2
  b2Left4 = barW - timeW + VVvs2f
  b2Left3 = b2Left4 - VVvs2f - timeW
  pLeft = width - picW - VVvs2f
  FF0onHL = b2Left2 + timeW + VVvs2f
  FF0onHW = b2Left3 - VVvs2f - FF0onHL
  name = "myPlay"
  tmp += '<widget name="%sBarF"  position="%d,%d" size="%d,%d" zPosition="1" backgroundColor="#0a444444" />' % (name, VVvs2f, b1Top, barW, barH)
  tmp += '<widget name="%sBarBG" position="%d,%d" size="%d,%d" zPosition="2" backgroundColor="#11000000" />' % (name, VVvs2f + 1, b1Top + 1, barW - 2, barH - 2)
  tmp += '<widget name="%sBar"   position="%d,%d" size="%d,%d" zPosition="3" backgroundColor="#06445566" />' % (name, VVvs2f + 1, b1Top + 1, barW - 2, barH - 2)
  tmp += '<widget name="%sMov"   position="%d,%d" size="%d,%d" zPosition="4" backgroundColor="#0aff8000" />' % (name, VVvs2f + 1, b1Top - 4, 3, barH + 8)
  tmp += '<widget name="%sVal"   position="%d,%d" size="%d,%d" zPosition="5" backgroundColor="#0a005555" foregroundColor="#ffffff" transparent="1" shadowColor="#00000000" shadowOffset="-1,-1" %s %s />' % (name, VVvs2f + 1, b1Top + 1, barW - 2, barH - 2, bodyFontStr, alignCenter)
  param = 'zPosition="1" noWrap="1" backgroundColor="%s" %s' % (VViaEk, bodyFontStr)
  tmp += '<widget name="%sPos"  position="%d,%d" size="%d,%d" %s foregroundColor="#00aacccc" %s />' % (name, b2Left1, b2Top, timeW, barH, param, alignLeftCenter)
  tmp += '<widget name="%sSkp"  position="%d,%d" size="%d,%d" %s foregroundColor="#00ffff00" %s />' % (name, b2Left2, b2Top, timeW, barH, param, alignCenter)
  tmp += '<widget name="%sMsg"  position="%d,%d" size="%d,%d" %s foregroundColor="#00ffffff" %s />' % (name, FF0onHL , b2Top, FF0onHW , barH, param, alignCenter)
  tmp += '<widget name="%sRem"  position="%d,%d" size="%d,%d" %s foregroundColor="#00CDAE77" %s />' % (name, b2Left3, b2Top, timeW, barH, param, alignCenter)
  tmp += '<widget name="%sDur"  position="%d,%d" size="%d,%d" %s foregroundColor="#00B1C177" %s />' % (name, b2Left4, b2Top, timeW, barH, param, alignRightCenter)
  sepTop = int(b3Top - VVXAYU / 2.0)
  tmp += '<widget name="myPlaySep" position="0,%d" size="%d,1" zPosition="1" backgroundColor="#11444444" />' % (sepTop, pLeft)
  color = ["#0a004400", "#00555555", "#00bbbb55", "#00bbbb55", "#00999999", "#00999999", "#00999999", "#00FFFF88" , "#0a18188b"]
  names = ["Grn"  , "Jmp"   , "Dat"   , "Tim"    , "Res"   , "Fps"   , "Asp"   , "Yel"  , "Blu"]
  Len  = len(names)
  b3W  = int((barW - VVvs2f * (Len - 1)) / Len)
  left = VVvs2f
  for i in range(Len):
   if i in (0, Len-1) : bg = 'foregroundColor="#00FFFFFF" backgroundColor="%s"' % color[i]
   else     : bg = 'foregroundColor="%s"'        % color[i]
   tmp += '<widget name="myPlay%s" position="%d,%d" size="%d,%d" zPosition="1" noWrap="1" %s %s %s />' % (names[i], left, b3Top + 1, b3W, barH, bodyFontStr, alignCenter, bg)
   if names[i] == "Blu":
    txtW = 25
    barH2 = (barH - 8) // 3
    barTop = b3Top + 2
    barTL = left + 15
    barL = barTL + txtW + 5
    bW  = pLeft - barL - VVvs2f
    fSz  = int(barH2 * 0.9)
    namesB = ("SNR", "AGC", "BER")
    for i1 in range(3):
     tmp += '<widget name="mySliderTxt%s" position="%d,%d" size="%d,%d" zPosition="4" noWrap="1" font="%s;%d" foregroundColor="#00aaaaaa" backgroundColor="#1100102a" %s />' % (namesB[i1], barTL, barTop, txtW, barH2, VV3IRX, fSz, alignRightCenter)
     tmp += '<widget name="mySliderFrm%s" position="%d,%d" size="%d,%d" zPosition="4" backgroundColor="#333333" />' % (namesB[i1], barL-1, barTop-1, bW+2, barH2+2)
     tmp += '<widget name="mySliderBak%s" position="%d,%d" size="%d,%d" zPosition="5" backgroundColor="%s" />' % (namesB[i1], barL, barTop, bW, barH2, VViaEk)
     tmp += '<widget name="mySliderPic%s" position="%d,%d" size="%d,%d" zPosition="6" alphatest="blend" />' % (namesB[i1], barL, barTop, bW, barH2)
     tmp += '<widget name="mySliderCov%s" position="%d,%d" size="%d,%d" zPosition="7" />' % (namesB[i1], barL, barTop, bW, barH2)
     barTop += barH2 + 4
   left += b3W + VVvs2f
  pTop = titleH + 6
  pW  = width - pLeft - 8
  pH  = height - pTop - 4
  tmp += '<eLabel position="%d,%d" size="1,%d" zPosition="1" backgroundColor="#00333333" />' % (pLeft, titleH + 2, height - titleH + 1)
  tmp += '<widget name="myPlayPic" position="%d,%d" size="%d,%d" zPosition="1" alphatest="blend" />' % (pLeft + 4, pTop, pW, pH)
  tmp += '<widget name="myPlayTyp" position="%d,%d" size="%d,%d" zPosition="1" backgroundColor="#1100202a" %s %s />' % (pLeft + 4, pTop, pW, pH, alignCenter, bodyFontStr)
  sz = int(titleH * 0.6)
  top = int((titleH - sz) / 2.0)
  gap = 6
  lft = width - sz - (titleH * 2 + gap * 2)
  for nm in ( "myPlayCc", "myPlayAud", "myPlayDnld", "myPlayRpt"):
   tmp += '<widget name="%s" position="%d,%d" size="%d,%d" zPosition="10" alphatest="blend" />' % (nm, lft, top, sz, sz)
   lft -= sz + gap
  params = 'zPosition="10" backgroundColor="#11444411"'
  tmp += '<eLabel %s position="0,0"  size="%d,1" />' % (params, width)
  tmp += '<eLabel %s position="0,%d" size="%d,1" />' % (params, height - 1, width)
  tmp += '<eLabel %s position="0,0"  size="1,%d" />' % (params, height)
  tmp += '<eLabel %s position="%d,0" size="1,%d" />' % (params, width - 1, height -1)
 elif VVUjdH == VVTxiS:
  w  = int((width - 10) / 4.0)
  h  = bodyH - 10
  left = 5
  top  = bodyTop + 5
  tmp += '<widget name="myColorF" position="%d,%d" size="%d,%d" zPosition="1" backgroundColor="#00ffffff" />' % (left, top, w, h)
  for i in range(4):
   tmp += '<widget name="myColor%d" position="%d,%d" size="%d,%d" zPosition="2" backgroundColor="%s" foregroundColor="#ffffff" %s %s />' % (i, left + 4, top + 4, w - 8, h - 8, VViaEk, bodyFontStr, alignLeftCenter)
   left += w
 elif VVUjdH == VVOuSW:
  itemsH  = bodyLineH * 2.0
  menuH  = int(bodyLineH * 2.5)
  menuW  = int(ratioW  * 200)
  menuLeft = int((width - menuW) / 2.0)
  textH  = bodyH - menuH
  menuTop  = bodyTop + textH
  itemsTop = int(menuTop + VVXAYU / 2.0 + (menuH - itemsH) / 2.0)
  tmp += '<widget name="myLine"  position="0,%d"  size="%d,1"  zPosition="3" backgroundColor="#11444444" />' % (menuTop, width)
  tmp += '<widget name="myLabel" position="%d,%d" size="%d,%d" zPosition="3" backgroundColor="%s" foregroundColor="#ffffff" %s %s />' % (VVvs2f, bodyTop, bodyW, textH, VViaEk, alignCenter, bodyFontStr)
  tmp += '<widget name="myMenu"  position="%d,%d" size="%d,%d" zPosition="3" backgroundColor="%s" foregroundColor="#ffffff" scrollbarMode="showOnDemand" itemHeight="%d" />' % (menuLeft, itemsTop, menuW, itemsH, VViaEk, bodyLineH)
 elif VVUjdH == VVZIqk:
  tmp += '<widget name="myTableH" position="%d,%d" size="%d,%d" zPosition="3" backgroundColor="%s" scrollbarMode="showOnDemand" scrollbarWidth="%d" />' % (VVvs2f, bodyTop, bodyW, 0, VViaEk, scrollBarW)
  tmp += '<widget name="myTable"  position="%d,%d" size="%d,%d" zPosition="3" backgroundColor="%s" scrollbarMode="showOnDemand" scrollbarWidth="%d" />' % (VVvs2f, bodyTop, bodyW, bodyH, VViaEk, scrollBarW)
 elif VVUjdH == VV1UOW:
  perc1, perc2, tbg1, tbg2, bg1, bg2 = VVIZ5t["perc1"], VVIZ5t["perc2"], VVIZ5t["tbg1"], VVIZ5t["tbg2"], VVIZ5t["bg1"], VVIZ5t["bg2"]
  lblH = int(titleH * 0.75)
  lblF = int(lblH * 0.65)
  mnuF = int(lblH * 0.7)
  w1 = int((width - VVvs2f * 4) * perc1 / 100.0)
  w2 = int((width - VVvs2f * 4) * (100 - perc1) / 100.0)
  wt1 = int(w2 * perc2 / 100.0)
  wt2 = w2 - wt1
  bgW = width // 2
  lft2 = VVvs2f + w1 + VVvs2f * 2
  mTop = bodyTop + lblH + 3
  h = bodyH - lblH
  h = height - VVSwLg - mTop - VVXAYU
  lblP = 'noWrap="1" font="%s;%d" %s' % (VV3IRX, lblF, alignCenter)
  tmp += '<widget position="%d,%d" size="%d,%d" name="myTitle1" backgroundColor="%s" %s />' % (VVvs2f, bodyTop, w1, lblH, tbg1, lblP)
  tmp += '<widget position="%d,%d" size="%d,%d" name="myTitle2" backgroundColor="%s" %s />' % (lft2, bodyTop , wt1-3, lblH, tbg2, lblP)
  tmp += '<widget position="%d,%d" size="%d,%d" name="myTitle3" backgroundColor="%s" %s />' % (lft2 + wt1 + 2, bodyTop, wt2-2, lblH, tbg2, lblP)
  tmp += '<widget position="%d,%d" size="%d,%d" name="myFrm1" backgroundColor="%s" />' % (VVvs2f, mTop, w1, h, bg1)
  tmp += '<widget position="%d,%d" size="%d,%d" name="myFrm2" backgroundColor="%s" />' % (lft2, mTop, w2, h, bg2)
  gap, gap2 = 8, 16
  mnuP = 'transparent="1" scrollbarMode="showOnDemand" scrollbarWidth="%d"' % scrollBarW
  tmp += '<widget position="%d,%d" zPosition="2" size="%d,%d" name="list"   %s />' % (VVvs2f + gap, mTop + gap, w1 - gap2, h - gap2, mnuP)
  tmp += '<widget position="%d,%d" zPosition="2" size="%d,%d" name="myMenu" %s />' % (lft2 + gap, mTop + gap, w2 - gap2, h - gap2, mnuP)
 elif VVUjdH == VVIZbT:
  titleFont = int(VVYvMU * 0.6)
  boxFont  = int(VVYvMU * 1.2)
  boxH  = int(VVYvMU * 2.0)
  digitW  = int(VVYvMU * 1.3)
  names  = ["year", "month", "day", "gap", "hour", "min", "sec"]
  boxW  = [  4   ,    2   ,   2  ,   1  ,   2   ,   2  ,   2  ]
  gap   = 4
  boxLeft  = int((width - digitW * 15) / 2.0 - gap)
  btnTitleH = titleFont * 2
  titleTop = int(bodyTop + (height - VVSwLg - bodyTop - (btnTitleH + boxH + gap)) / 2.0)
  boxTop  = titleTop + btnTitleH + gap
  tmp += '<widget name="curTime" position="0,%d" size="%d,%d" zPosition="2" foregroundColor="white" transparent="1" %s %s />' % (titleH + 1, width, titleTop - titleH - 2, bodyFontStr, alignCenter)
  par = 'zPosition="3" foregroundColor="white" backgroundColor="#11404040" %s' % alignCenter
  for i in range(0, 7):
   tmpW = digitW * boxW[i]
   tmp += '<widget name="%s" position="%d,%d" size="%d,%d" font="%s;%d" %s />' % (names[i]+"Title", boxLeft, titleTop, tmpW - gap, btnTitleH, VV3IRX, titleFont, par)
   tmp += '<widget name="%s" position="%d,%d" size="%d,%d" font="%s;%d" %s />' % (names[i], boxLeft, boxTop, tmpW - gap, boxH, VV3IRX, boxFont, par)
   boxLeft += tmpW + boxW[i]
 elif VVUjdH == VVwsZy:
  titleFont = int(VVYvMU * 0.6)
  boxFont  = int(VVYvMU * 1.2)
  boxH  = int(VVYvMU * 2.0)
  digitW  = int(VVYvMU * 1.3)
  names, boxW = ["sign", "hour", "min"], [2, 4, 4]
  gap   = 6
  boxLeft  = int((width - digitW * 10) / 2.0 - gap)
  btnTitleH = titleFont * 2
  titleTop = int(bodyTop + (height - VVSwLg - bodyTop - (btnTitleH + boxH + gap)) / 2.0)
  boxTop  = titleTop + btnTitleH + gap
  par   = 'zPosition="3" foregroundColor="white" backgroundColor="%s" %s' % (VViaEk, alignCenter)
  for i in range(0, 3):
   tmpW = digitW * boxW[i]
   tmp += '<widget name="%s" position="%d,%d" size="%d,%d" font="%s;%d" %s />' % (names[i]+"Title", boxLeft, titleTop, tmpW - gap, btnTitleH, VV3IRX, titleFont, par)
   tmp += '<widget name="%s" position="%d,%d" size="%d,%d" font="%s;%d" %s />' % (names[i], boxLeft, boxTop, tmpW - gap, boxH, VV3IRX, boxFont, par)
   boxLeft += tmpW + boxW[i]
 elif VVUjdH == VVGkIr:
  barW = int(ratioW  * 500)
  infH = int(titleH * 0.8)
  infTop = height - infH
  infFont = int(0.5  * infH)
  bAreaH = int(height - titleH - infH)
  barH = int((bAreaH - VVXAYU * 4) / 3)
  barTop = titleH + VVXAYU
  barL = int(width - barW - titleH / 2)
  txtW = barL - VVvs2f - 4
  name = [ "SNR", "AGC", "BER"]
  tmp += '<widget name="mySNRdB" text="0 dB" position="%d,%d" size="%d,%d" %s %s zPosition="4" transparent="1" foregroundColor="white" />' % (0, 0, width - 20, titleH, bodyFontStr, alignRightCenter)
  for i in range(3):
   tmp += '<eLabel position="%d,%d" size="%d,%d" zPosition="5" text="%s" %s %s backgroundColor="%s" foregroundColor="white" />' % (VVvs2f, barTop, txtW, barH, name[i], bodyFontStr, alignLeftCenter, VViaEk)
   tmp += '<eLabel position="%d,%d" size="%d,%d" zPosition="4" backgroundColor="#ffffff" />' % (barL-1, barTop-1, barW+2, barH+2)
   tmp += '<eLabel position="%d,%d" size="%d,%d" zPosition="4" backgroundColor="%s" />' % (barL, barTop, barW, barH, VViaEk)
   tmp += '<widget name="mySlider%s" position="%d,%d" size="%d,%d" zPosition="5" alphatest="blend" />' % (name[i], barL, barTop, barW, barH)
   tmp += '<widget name="mySliderCov%s" position="%d,%d" size="%d,%d" zPosition="6" />' % (name[i], barL, barTop, barW, barH)
   tmp += '<widget name="my%s" position="%d,%d" size="%d,%d" %s %s zPosition="7" text="0 " foregroundColor="#ffffff" transparent="1" shadowColor="#00000000" shadowOffset="-1,-1" />' % (name[i], barL, barTop, barW, barH, bodyFontStr, alignCenter)
   barTop += barH + VVXAYU
  tmp += '<widget name="myTPInfo" position="0,%d" size="%d,%d" zPosition="8" backgroundColor="%s" font="%s;%d" %s />' % (infTop, width, infH, VVx8BU, VV3IRX, infFont, alignCenter)
  tmp += '<eLabel position="0,%d"  size="%d,1"  zPosition="9" backgroundColor="#22aaaaaa" />' % (infTop -1, width)
 elif VVUjdH == VVTT4Q:
  h1  = int(bodyH / 2.0) if VVIZ5t == 2 else bodyH
  barL = VVvs2f
  barT = bodyTop
  barW = bodyW
  barH = int((height - bodyTop - VVXAYU * 2 ) / 2.0) if VVIZ5t == 2 else int(height - bodyTop - VVXAYU)
  fontH= int(0.7  * barH)
  for i in range(1, 3):
   tmp += '<widget name="myProgFr%s" position="%d,%d" size="%d,%d" zPosition="2" backgroundColor="#ffffff" />' % (i, barL-1, barT-1, barW+2, barH+2)
   tmp += '<widget name="myProgBG%s" position="%d,%d" size="%d,%d" zPosition="3" backgroundColor="%s" />' % (i, barL, barT, barW, barH, VViaEk)
   tmp += '<widget name="myProgFG%s" position="%d,%d" size="%d,%d" zPosition="4" backgroundColor="#884422" foregroundColor="#ffffff" />' % (i, barL, barT, barW, barH)
   tmp += '<widget name="myProgVal%s" position="%d,%d" size="%d,%d" zPosition="5" foregroundColor="#ffffff" transparent="1" shadowColor="#00000000" shadowOffset="-1,-1" font="%s;%d" %s />' % (i, barL, barT, barW, barH, VV3IRX, fontH, alignCenter)
   barT += h1 + int(VVXAYU / 2.0)
 elif VVUjdH in (VVmMbY, VV2auk):
  totRows , totCols= VVIZ5t.get("rows"), VVIZ5t.get("cols")
  picR , lblR  = VVIZ5t.get("picR"), VVIZ5t.get("lblR")
  w1  , w2  = int(width * VVIZ5t.get("w1R")), int(width * VVIZ5t.get("w2R"))
  transpBG = VVIZ5t.get("trC")
  upSBar  = VVIZ5t.get("upSBar", False)
  bGap  = VVIZ5t.get("bGap", 0)
  infH = int(height * 0.092)
  addH = int(infH * (1000 - height) / 1000.0)
  infH += addH if addH > 0 else 0
  infT = titleH + 1
  boxT = infT + infH + VVXAYU + 2
  boxW = int((width - bGap * (totCols - 1) - (0 if upSBar else VVoZRH) - VVvs2f * 2)  / totCols)
  boxH = int((height - bGap  * (totRows - 1)  - VVSwLg - boxT - VVXAYU) / totRows)
  s = '<widget name="myPiconInf%d" position="%d,%d" size="%d,%d" zPosition="1" foregroundColor="%s" noWrap="1" backgroundColor="%s" font="%s;%d" %s />'
  h = int(infH * 0.3333)
  y = infT
  fg= "#00ffffff"
  if VVUjdH == VVmMbY:
   totInf = 6
   fntSz, bg = int(h * 0.7), ("#00002828", "#00003333", "#00004444", "#00002233", "#00003344", "#00004455")
   for i in range(3):
    tmp += s % (i  , 0   , y, w1, h, fg, bg[i]  , VV3IRX, fntSz, alignLeftCenter)
    tmp += s % (i+3, w1+1, y, w2, h, fg, bg[i+3], VV3IRX, fntSz, alignLeftCenter)
    y += h
  else:
   totInf = 4
   h1, h2 = int(infH * 0.58), int(infH * 0.42)
   tmp += s % (0, 0, y  , w1, h1 , "#0088ff88", "#00333333", VV3IRX, int(h1 * 0.7), alignLeftCenter)
   tmp += s % (1, 0, y + h1, w1, h2 , "#00aaaaaa", "#002a2a2a", VV3IRX, int(h2 * 0.7), alignLeftCenter)
   h, fntSz, fg, bg = int(infH * 0.50), int(h2 * 0.60), "#00888888", "#0a111111"
   tmp += s % (2, w1, y , w2, h, fg, bg, VV3IRX, fntSz, alignCenter)
   tmp += s % (3, w1, y + h, w2, h, fg, bg, VV3IRX, fntSz, alignCenter)
  retPar = VVvs2f, boxT, boxW, boxH, infT, infH, totInf, bGap
  tmp += '<eLabel position="0,%d"  size="%d,1"  zPosition="1" backgroundColor="#00555555" />' % (infT + infH, width)
  pT = infT + 3
  pH = infH - 6
  pW = int(pH * 1.66)
  pL = width - pW - 12
  tmp += '<widget name="myPiconF"   position="%d,%d" size="%d,%d" zPosition="2" backgroundColor="#0a555500" />' % (pL    , pT    , pW  , pH)
  tmp += '<widget name="myPiconBG"  position="%d,%d" size="%d,%d" zPosition="3" backgroundColor="#0a220000" />' % (pL + 1, pT + 1, pW - 2 , pH - 2)
  tmp += '<widget name="myPiconPic" position="%d,%d" size="%d,%d" zPosition="4" alphatest="blend" />'    % (pL + 2, pT + 2, pW - 4 , pH - 5)
  tmp += '<widget name="myCursorLbl" position="%d,%d" size="%d,%d" zPosition="5" backgroundColor="#00ffff66" />' % (VVvs2f, boxT + VVXAYU, boxW-2, boxH-2)
  tmp += '<widget name="myCursorPic" position="%d,%d" size="%d,%d" zPosition="5" alphatest="on" scale="1" />' % (VVvs2f, boxT + VVXAYU, boxW-2, boxH-2)
  picBgTr = 'transparent="1"' if VVIZ5t.get("picBgTr", 0) else ""
  lblTr = 'transparent="1"' if VVIZ5t.get("lblTr", 0) else ""
  lblFR = VVIZ5t.get("lblFR", 0.65)
  lblFg = VVIZ5t.get("lblFg", "#00ffffff")
  lblBg = VVIZ5t.get("lblBg", VViaEk)
  gapX = VVIZ5t.get("gapX", 4)
  gapY = VVIZ5t.get("gapY", 4)
  midGap = VVIZ5t.get("mGap", 0)
  percBar = VVIZ5t.get("percBar", 0)
  areaW = boxW - gapX * 2
  areaH = boxH - gapY * 2 - midGap
  picT = boxT + gapY
  picH = int(areaH * picR)
  lblH = int(areaH * lblR)
  lblT = boxT + gapY + picH + midGap
  lblFS= int(lblH * lblFR)
  transpBG = 'backgroundColor="%s"'% transpBG if transpBG else ""
  boxT1 = boxT
  for row in range(totRows):
   left = VVvs2f + gapX
   for col in range(totCols):
    tmp += '<widget name="myPosterBak%d%d" position="%d,%d" size="%d,%d" zPosition="4" alphatest="blend" scale="1" />' % (row, col, left-gapX, boxT1, boxW, boxH)
    tmp += '<widget name="myPosterRep%d%d" position="%d,%d" size="%d,%d" zPosition="6" %s %s />' % (row, col, left, picT, areaW, picH, transpBG, picBgTr)
    tmp += '<widget name="myPosterLbl%d%d" position="%d,%d" size="%d,%d" zPosition="7" foregroundColor="%s" backgroundColor="%s" noWrap="1" %s font="%s;%d" %s />' % (row, col, left, lblT, areaW, lblH, lblFg, lblBg, lblTr, VV3IRX, lblFS, alignCenter)
    tmp += '<widget name="myPosterPic%d%d" position="%d,%d" size="%d,%d" zPosition="13" alphatest="blend" />' % (row, col, left, picT, areaW, picH)
    if percBar:
     x, y, w, h =  left, lblT + lblH + 5, areaW, lblH // 3
     tmp += '<widget name="myPercFr%d%d" position="%d,%d" size="%d,%d" zPosition="10" backgroundColor="#00ffffff" />' % (row, col, x, y, w, h)
     tmp += '<widget name="myPercBG%d%d" position="%d,%d" size="%d,%d" zPosition="11" backgroundColor="%s" />'   % (row, col, x+1, y+1, w-2, h-2, lblBg)
     tmp += '<widget name="myPercFG%d%d" position="%d,%d" size="%d,%d" zPosition="12" backgroundColor="#0055aabb" />' % (row, col, x+1, y+1, w-2, h-2)
    left += boxW + bGap
   boxT1 += boxH + bGap
   picT += boxH + bGap
   lblT += boxH + bGap
 elif VVUjdH == VVAFxx:
  totRows = 6
  totCols = 8
  tstW = int(width - VVvs2f  * 2)
  tstH = int(height * 0.15)
  tstT = int(height - VVSwLg - tstH)
  boxT = titleH + 2
  boxW = int(width  / totCols)
  boxH = int((height - VVSwLg - tstH - boxT) / totRows)
  tmp += '<widget name="myColorPtr" position="%d,%d" size="%d,%d" zPosition="1" backgroundColor="#00aaaa00" />' % (0, boxT, boxW, boxH)
  gap  = VVXAYU
  gap1 = int(gap / 2.0)
  for row in range(totRows):
   boxL = 0
   for col in range(totCols):
    tmp += '<widget name="myColor%d%d" position="%d,%d" size="%d,%d" zPosition="2" backgroundColor="#00000000" />' % (row, col, boxL+gap1, boxT+gap1, boxW-gap, boxH-gap)
    boxL += boxW
   boxT += boxH
  tmp += '<widget name="myColorTst" position="%d,%d" size="%d,%d" zPosition="2" backgroundColor="#00aaaaaa" %s %s />' % (VVvs2f, tstT, tstW, tstH, alignCenter, bodyFontStr)
 elif VVUjdH == VVa6GH:
  tmp += '<widget name="myPic" position="0,%d" size="%d,%d" zPosition="4" alphatest="blend" />' % (bodyTop+1, bodyW, bodyH-1)
 else:
  if   VVUjdH == VV2rBO : align = alignLeftCenter
  elif VVUjdH == VV0v8m : align = alignLeftTop
  else          : align = alignCenter
  if VVUjdH == VVi9he:
   iconSize = 60
   iconLeft = int(ratioH  * 20)
   iconTop  = int(bodyTop + (height - bodyTop - iconSize) / 2.0)
   iconW  = iconSize + iconLeft * 2
   VVvs2f += iconW
   bodyW  -= iconW
   tmp += '<widget name="errPic" position="%d,%d" size="%d,%d" zPosition="4" alphatest="blend" />' % (iconLeft, iconTop, iconSize, iconSize)
  fontName = VV3IRX
  if VV1j0B and VVUjdH == VV0v8m:
   fLst = FFIXGD()
   if   VVDtIm in fLst and CFG.fontPathTerm.getValue(): fontName = VVDtIm
   elif VVspqx in fLst         : fontName = VVspqx
  VV0zzv = 'backgroundColor="%s" foregroundColor="#ffffff" font="%s;%d" %s ' % (VViaEk, fontName, VVYvMU, align)
  tmp += '<widget name="myLabel" position="%d,%d" size="%d,%d" zPosition="4" %s />' % (VVvs2f, bodyTop, bodyW, bodyH, VV0zzv)
 infoW  = int(ratioW  * 500)
 infoH  = int(ratioH  * 100)
 infoLeft = int((width - infoW) / 2.0)
 infoTop  = int((height - infoH) / 2.0)
 VVPYL1 = int(ratioH  * 30)
 tmp += '<widget name="myInfoFrame" position="%d,%d" size="%d,%d" zPosition="20" backgroundColor="#aaaa00" />' % (infoLeft, infoTop, infoW, infoH)
 tmp += '<widget name="myInfoBody"  position="%d,%d" size="%d,%d" zPosition="21" backgroundColor="#550000" foregroundColor="#ffff00" font="%s;%d" %s />' % (infoLeft+2, infoTop+2, infoW-4, infoH-4, VV3IRX, VVPYL1, alignCenter)
 if VVcmdl > 0:
  gap = 6
  sz = titleH - gap * 2
  mnuL= width - sz - gap * 2
  infL= mnuL if VVcmdl == 3 else mnuL - sz - gap
  par = 'size="%d,%d" zPosition="20" alphatest="blend"' % (sz, sz)
  if VVcmdl in (1, 2): tmp += '<widget name="keyMenu" position="%d,%d" %s />' % (mnuL, gap, par)
  if VVcmdl in (2, 3): tmp += '<widget name="keyInfo" position="%d,%d" %s />' % (infL, gap, par)
  if VVUjdH == VVZIqk:
   w = int(ratioH  * 200)
   tmp += '<widget name="myTotSel" position="%d,%d" size="%d,%d" zPosition="20" backgroundColor="#550055" font="%s;%d" %s />' % (infL - gap - w, gap, w, sz, VV3IRX, int(sz * 0.6), alignCenter)
 if VVSwLg > 0:
  lineTop = height - VVSwLg
  topGap = max(3, int(ratioH  * 3))
  btnTop = lineTop + topGap
  btnH = height - btnTop - topGap
  barFont = int(0.7  * btnH)
  gap  = btnH
  spaceW = gap * (5)
  btnW = int((width - spaceW) / 4)
  left = gap
  name = [ "keyRed"   , "keyGreen" , "keyYellow", "keyBlue"  ]
  tmp += '<widget name="myBar"  position="0,%d"  size="%d,%d" zPosition="7" backgroundColor="%s" font="%s;%d" %s />' % (lineTop, width, height - lineTop, VVx8BU, VV3IRX, barFont, alignLeftCenter)
  tmp += '<widget name="myLine" position="0,%d"  size="%d,1"  zPosition="8" backgroundColor="#22aaaaaa" />' % (lineTop, width)
  for i in range(4):
   tmp += '<widget name="%s" position="%d,%d" size="%d,%d" zPosition="9" backgroundColor="%s" font="%s;%d" foregroundColor="white" noWrap="1" %s />' % (name[i], left, btnTop, btnW, btnH, VVAKzT[i], VV3IRX, barFont, alignCenter)
   left += btnW + gap
 if VVoZRH:
  par = 'position="0,0" size="20,20"'
  tmp += '<widget name="mySbFrm" zPosition="13" %s />' % par
  tmp += '<widget name="mySbBak" zPosition="14" %s />' % par
  tmp += '<widget name="mySbSld" zPosition="15" %s />' % par
 if VVUjdH == VV0v8m:
  name = [ "keyRedTop", "keyGreenTop" , "keyYellowTop", "keyBlueTop" ]
  btnW = int(ratioW  * 85)
  btnH = int(titleH * 0.6)
  btnTop = int(titleH * 0.2)
  btnLeft = width - (btnW + btnTop) * 4
  btnFont = int(btnH * 0.65)
  for i in range(4):
   tmp += '<widget name="%s1" position="%d,%d" size="%d,%d" zPosition="10" backgroundColor="#0affffff" />' % (name[i], btnLeft, btnTop, btnW, btnH)
   tmp += '<widget name="%s"  position="%d,%d" size="%d,%d" zPosition="11" backgroundColor="%s" font="%s;%d" foregroundColor="white" %s />' % (name[i], btnLeft+1, btnTop+1, btnW-2, btnH-2, VVAKzT[i], VV3IRX, btnFont, alignCenter)
   btnLeft += (btnW + btnTop)
 if VV05bd:
  w, h = VV05bd
  w = int(ratioW  * w) if w > 0 else int(width  * 0.2)
  h = int(ratioH  * h) if h > 0 else int(w * 0.75)
  x, y = width - w - VVvs2f - scrollBarW * 2, bodyTop
  tmp += '<widget name="myPicF" position="%d,%d" size="%d,%d" zPosition="2" backgroundColor="#0affffff" />' % (x-1, y-1, w+2, h+2)
  tmp += '<widget name="myPicB" position="%d,%d" size="%d,%d" zPosition="3" backgroundColor="%s" />'   % (x, y, w, h, VViaEk)
  tmp += '<widget name="myPic"  position="%d,%d" size="%d,%d" zPosition="4" alphatest="blend" />'    % (x, y, w, h)
  retPar = x, y, w, h
 tmp += '</screen>'
 VVmNvK = {"VVUjdH":VVUjdH, "width":width, "height":height, "titleH":titleH, "VVvs2f":VVvs2f, "VVXAYU":VVXAYU, "VVx8BU":VVx8BU, "VViaEk":VViaEk, "VVYvMU":VVYvMU, "VVSwLg":VVSwLg, "VVcmdl":VVcmdl, "bodyLineH":bodyLineH, "scrollBarW":scrollBarW, "VVwv0z":VVwv0z, "retPar":retPar, "VVIZ5t":VVIZ5t}
 return tmp, VVmNvK
class CC73QP(Screen):
 def __init__(self, session, args=0):
  self.skin, self.VVmNvK = FFQaOH(VVNkG2, 800, 1050, 40, 40, 20, "#1a002244", "#10002233", 33, VVSwLg=40, VVcmdl=2)
  self.session  = session
  self.VVpdFl = ""
  self.VV2oal  = r"0{4}t{2}f?$"
  self.themsList  = []
  self.Title   = "%s - %s" % (PLUGIN_NAME, VV8h7S)
  self.timer   = eTimer()
  self.chkVerResult = ""
  self.VV0wMr = True
  VV9cxb = []
  if VVLh1e:
   VV9cxb.append(("-- MY TEST --", "myTest" ))
  VV9cxb.append(("File Manager"  , "fMan" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("IPTV"    , "iptv" ))
  VV9cxb.append(("Movies Browser" , "movie" ))
  VV9cxb.append(("Services/Channels", "chan" ))
  VV9cxb.append(("Bouquet Editor" , "bouq" ))
  VV9cxb.append(("PIcons"   , "picon" ))
  VV9cxb.append(("EPG"    , "epg"  ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Terminal"   , "term" ))
  VV9cxb.append(("SoftCam"   , "soft" ))
  VV9cxb.append(("Plugins"   , "plug" ))
  VV9cxb.append(("Backup & Restore" , "bakup" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Date/Time"  , "date" ))
  VV9cxb.append(("Network"   , "net"  ))
  FFNhKZ(self, title=self.Title, VV9cxb=VV9cxb)
  FFi79B(self["keyRed"] , "Exit")
  FFi79B(self["keyGreen"] , "Settings")
  FFi79B(self["keyYellow"], "Dev. Info.")
  FFi79B(self["keyBlue"] , "Color/Font")
  FFmpyO(self,
  {
   "red" : self.close     ,
   "green" : self.VVbJQU    ,
   "yellow": self.VV8n9z    ,
   "blue" : self.VVHj5x   ,
   "info" : self.VVAmnn    ,
   "menu" : self.VVkY0Y  ,
   "text" : BF(self.VVS7zW, "t")  ,
   "f4" : BF(self.VVS7zW, "f")  ,
   "0"  : BF(self.VVgiFs, 0) ,
   "1"  : BF(self.VV5QnJ, "fMan") ,
   "2"  : BF(self.VV5QnJ, "iptv") ,
   "3"  : BF(self.VV5QnJ, "movie") ,
   "4"  : BF(self.VV5QnJ, "chan") ,
   "5"  : BF(self.VV5QnJ, "bouq") ,
   "6"  : BF(self.VV5QnJ, "picon") ,
   "7"  : BF(self.VV5QnJ, "epg") ,
   "8"  : BF(self.VV5QnJ, "term") ,
   "9"  : BF(self.VV5QnJ, "soft") ,
   "last" : BF(self.VV5QnJ, "plug") ,
   "next" : BF(self.VV5QnJ, "bakup")
  })
  self.onShown.append(self.VVf1Ra)
  self.onClose.append(self.onExit)
  global VVIlCj, VVSm4H, VVloQE
  VVIlCj = VVSm4H = 0
  VVloQE = 1
 def VVyuDa(self):
  self.VV5QnJ(self["myMenu"].l.getCurrentSelection()[1])
 def VV5QnJ(self, item):
  if item is not None:
   for ndx, param in enumerate(self["myMenu"].list):
    if len(param) > 1 and param[1] == item:
     self["myMenu"].moveToIndex(ndx)
     break
   global VVQw1L
   VVQw1L = self["myMenu"].l.getCurrentSelection()[0].strip()
   if   item == "myTest" : self.VVObru()
   elif item == "fMan"  : self.session.open(CC17eA)
   elif item == "iptv"  : self.session.open(CCTe4w)
   elif item == "movie" : CCbZVM.VV0LPB(self)
   elif item == "chan"  : self.session.open(CC2Ekb)
   elif item == "bouq"  : self.session.open(CCM4Rv)
   elif item == "picon" : self.VV6tzI()
   elif item == "epg"  : self.session.open(CCtAi7)
   elif item == "term"  : self.session.open(CCu5WO)
   elif item == "soft"  : FF7iMz(self, BF(self.session.open, CCCusX))
   elif item == "plug"  : self.session.open(CCz0DD)
   elif item == "bakup" : self.session.open(CCmWdL)
   elif item == "date"  : self.session.open(CC06Cg)
   elif item == "net"  : self.session.open(CCQdT4)
 def VVf1Ra(self):
  FFNUiO(self)
  if self.VV0wMr:
   self.VV0wMr = False
   FFvJ8o(self["myMenu"])
   FFuwGk(self)
   FFeo1z(self)
   self.VVCaMF()
 def VVCaMF(self):
  if not hasattr(self["myMenu"].instance, "setTextOffset"):
   for ndx, item in enumerate(self["myMenu"].list):
    if len(item) == 2:
     self["myMenu"].list[ndx] = ("   %s" % item[0], item[1])
  FFrxHY(self)
  self.VVpb4T()
  if (EASY_MODE or VVAgZf or VVLh1e):
   FFgLA9(self["myTitle"], "#ff0000")
  var = "PLUGIN" + "_VERSION"
  if var in globals():
   FFoTZI(self, "Welcome", 300)
  if CFG.checkForUpdateAtStartup.getValue():
   self["myTitle"].instance.setFont(gFont(VV3IRX, 30))
   self["myTitle"].setText("  %s      %s" % (PLUGIN_NAME, FFKrMM("Checking for updates ...", VV0p9P)))
   try: self.timer_conn = self.timer.timeout.connect(self.VV7Wtg)
   except: self.timer.callback.append(self.VV7Wtg)
   self.timer.start(500, False)
   myThread = iThread(name="ajp_chk_ver", target=self.VVGGmm)
   myThread.start()
 def VV7Wtg(self):
  if self.chkVerResult:
   self.timer.stop()
   if self.chkVerResult == "no":
    fnt = gFont(VV3IRX, 33)
    txt = self.Title
   else:
    fnt = gFont(VV3IRX, 30)
    txt = "%s    (v%s available)" % (self.Title, self.chkVerResult)
   self["myTitle"].instance.setFont(fnt)
   self["myTitle"].setText("  %s" % txt)
 def VVGGmm(self):
  url = CCLbil.VVv9JN()
  curVer = VV8h7S
  path, err = FFUzwU(url + "version", "ajp_tmp.ver", timeout=2)
  if err or not FFKbVo(path):
   self.chkVerResult = "no"
  else:
   cVer, wVer, isHigher = CCz0DD.VVQmy3(curVer, FFmx8y(path))
   FFnE7j(path)
   self.chkVerResult = wVer if isHigher else "no"
 def onExit(self):
  self.timer.stop()
  FFc1M2()
  global VVIlCj, VVSm4H
  VVIlCj = VVSm4H = 0
  FF0JpZ("VVloQE")
 def VVgiFs(self, digit):
  self.VVpdFl += str(digit)
  ln = len(self.VVpdFl)
  global VVIlCj
  if ln == 4:
   if self.VVpdFl == "0" * ln:
    VVIlCj = 0
    FFgLA9(self["myTitle"], "#11805040")
   else:
    self.VVpdFl = "x"
 def VVS7zW(self, s):
  self.VVpdFl += s
  if iMatch(self.VV2oal, self.VVpdFl):
   global VVSm4H
   VVSm4H, c = (2, "#ff8000") if self.VVpdFl.endswith("f") else (1, "#dd5588")
   FFgLA9(self["myTitle"], c)
 def VV6tzI(self):
  found = False
  pPath = CCRGqC.VV5G3P()
  if VVkY7E(pPath):
   for fName, fType in CCRGqC.VVkuaE(pPath):
    if fName:
     found = True
     break
  if found:
   self.session.open(CCRGqC)
  else:
   VV9cxb = []
   VV9cxb.append(("PIcons Tools" , "CCRGqC" ))
   VV9cxb.append(VVbM5H)
   VV9cxb.append(CCRGqC.VVQxFT())
   VV9cxb.append(VVbM5H)
   VV9cxb += CCRGqC.VV61gs()
   FFO9kU(self, self.VVeUr0, VV9cxb=VV9cxb)
 def VVeUr0(self, item=None):
  if item:
   if   item == "CCRGqC"   : self.session.open(CCRGqC)
   elif item == "VVS4Ez"  : CCRGqC.VVS4Ez(self)
   elif item == "VVpYJB"  : CCRGqC.VVpYJB(self)
   elif item == "findPiconBrokenSymLinks" : CCRGqC.VVEu2X(self, True)
   elif item == "FindAllBrokenSymLinks" : CCRGqC.VVEu2X(self, False)
 @FFJRPn()
 def VVAmnn(self):
  fil = VVK8DT + "_changeLog.txt"
  title = "%s %s  -  %s  (by AMAJamry)" % (PLUGIN_NAME, VV8h7S, PLUGIN_DESCRIPTION)
  if FFKbVo(fil):
   txt = "\n%s%s\n" % (FFKrMM("Home Page : ", VVk4x7), FFKrMM(CCLbil.VVSHHu(), VVWH8U))
   lines  = FF2kXa(fil)
   for line in lines:
    line = line.strip()
    if line and not line.startswith("#"):
     if line.startswith("[") and line.endswith("]"):
      line = line.replace("[", "").replace("]", "")
      line = FFKrMM("\n%s\n%s\n%s" % (SEP, line, SEP), VVjojy, VVCQUS)
     elif line.strip().startswith("-"): line = "\n" + line
     elif line.strip().startswith(".."): line = FFKrMM(line, VV3Hcc, VVCQUS)
     txt += line +"\n"
   FFSMJz(self, txt.strip(), title=title, VVPYL1=28, width=1600, height=1000, titleBg="#11000020", VVYCun="#0a00000a")
  else:
   FFbBGq(self, "Change Log file not found:\n\n%s" % fil, title=title)
 def VVkY0Y(self):
  VV9cxb = []
  VV9cxb.append(("Open Custom Menu ", "cMenu"))
  VV9cxb.append(("Custom Menu Help" , "cmHlp"))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Movies Resume History", "resum"))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("%s Optional Dependencies" % PLUGIN_NAME, "libr"))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("General Guide", "ghHlp" ))
  VV9cxb.append(("Keys Help" , "hlp"  ))
  FFO9kU(self, self.VVP4iP, VV9cxb=VV9cxb, width=650, title="Options")
 def VVP4iP(self, item=None):
  if item:
   if   item == "cMenu": CCKxBC.VVuwBy(self)
   elif item == "cmHlp": FFY7F5(self, "_help_cmenu", "Custom Menu Help")
   elif item == "resum": self.session.open(CCnaRX)
   elif item == "libr" : self.VVFR3j()
   elif item == "ghHlp": self.VV7u27()
   elif item == "hlp" : FFY7F5(self, "_help_main", "Main Page (Keys Help)")
 def VV7u27(self):
  d = { "Archive Files & Directories from Different Paths"     : "Archive_from_different_paths.jpg"
   , "Channels Browser"             : "ChannelsBrowser.jpg"
   , "Custom Menu - Samples"            : "Custom_Menu_Samples.jpg"
   , "File Manager - Remove a Plugin Related to a Package File"   : "Remove_package_using_pkg_file.jpg"
   , "File Manager - View Non-UTF8 Encoded Text Files"      : "View_non_UTF8_file.jpg"
   , "Hotkeys - Assign to Fucntions"          : "HotkeysAssign.jpg"
   , "IPTV - Change Reference for a Bouquet"        : "IPTV_ChangeReferenceForBouquets.jpg"
   , "IPTV - Favourite Servers"           : "IPTV_FavouriteServers.jpg"
   , "Player Bar - Colors"             : "PlayerBarColors.jpg"
   , "Player Bar - Seek Jump Time"           : "PlayerBar_SeekJumpTime.jpg"
   , "Screenshot - Hotkeys"            : "Screenshot_Hotkeys.jpg"
   , "Screenshot - OSD File Name"           : "Screenshot_OSDFileName.jpg"
   , "Share EPG"               : "ShareEPG.jpg"
   , "Signal Monitor - Access Methods"          : "SignalMonitor_accees.jpg"
   , "Subtitle - Searching Local Files for Suitable Subtitle (srt file)" : "Subtitle_find_local_srt.jpg"
   , "Subtitle - Subtitle Text Color"          : "SubtitleTextColor.jpg"
   , "Terminal - Custom Commands File"          : "CustomCommandsFile.jpg"
   }
  VV9cxb = [(k, v) for k, v in d.items()]
  FFO9kU(self, None, title="General Guide", VV9cxb=sorted(VV9cxb), width=1200, height=1000, VVfWsQ="#11101100", VVB5I5="#11112222", VVQ4hk=self.VVp2W9, VVDkqE=True)
 def VVp2W9(self, item=None):
  if item:
   VVhzhr, title, pic, ndx = item
   self.VVDdm9(VVhzhr, title, pic)
 @FFJRPn("Loading ...", par=1)
 def VVDdm9(self, VVhzhr, title, pic):
  url = CCLbil.VVv9JN()
  path, err = FFUzwU(url + "help/%s" % pic, "ajp_tmp%s" % os.path.splitext(pic)[1], timeout=2)
  if err or not FFKbVo(path) : FFbBGq(self, "Cannot get help file from server !", title=title)
  else       : CCZQAz.VVRX4k(self, path, title=title)
  FFnE7j(path)
 def VVbJQU(self) : self.session.open(CCLbil)
 def VV8n9z(self) : self.session.open(CCg47Y)
 def VVHj5x(self):
  title = "Colors and Fonts"
  c1, c2, c3, c4, c5 = VVv8b8, VVU4M8, VVk4x7, VVWH8U, VVWJEN
  added = CFG.fontPathAdd.getValue()
  VV9cxb = []
  VV9cxb.append((c1 + "Change Title Colors"   , "title"  ))
  VV9cxb.append((c1 + "Change Menu Area Colors"  , "body"  ))
  VV9cxb.append((c1 + "Change Menu Pointer Colors" , "cursor"  ))
  VV9cxb.append((c1 + "Change Bottom Bar Colors" , "bar"   ))
  VV9cxb.append((c2 + "Reset Colors"    , "resetColor" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append((c3 + "Change %s Font" % PLUGIN_NAME, "mainFont" ))
  VV9cxb.append((c3 + "Change Terminal Font"   , "termFont" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(FFH04v("Add Extra Font to System" , "addFont", not added , c4))
  VV9cxb.append(FFH04v("Replace Extra Font"  , "rplFont", added  , c4))
  VV9cxb.append(FFH04v("Remove Extra Font"  , "delFont", added  , c4))
  VV9cxb.append(VVbM5H)
  VV9cxb.append((c5 + "Change System Font"     , "sysFont" ))
  FFO9kU(self, BF(self.VVR7Nd, title), VV9cxb=VV9cxb, width=600, height=1000, title=title, VVfWsQ="#11001122", VVB5I5="#11001122")
 def VVR7Nd(self, title, item=None):
  if item:
   if item in ("title", "body", "cursor", "bar"):
    tDict = self.VVCxyO()
    fg = tDict.get("main_%s_fg" % item, "")
    bg = tDict.get("main_%s_bg" % item, "")
    self.session.openWithCallback(BF(self.VVSB8y, tDict, item), CCybrT, defFG=fg, defBG=bg)
   elif item == "resetColor" : FF6pUe(self, self.VVkJcn, "Reset to default colors ?", title=title)
   elif item == "mainFont"  : self.VVp5WI(VV6Thi)
   elif item == "termFont"  : self.VVp5WI(VVDtIm)
   elif item == "addFont"  : self.VVp5WI(VVIKra)
   elif item == "rplFont"  : self.VVp5WI(VVIKra)
   elif item == "delFont"  : FF6pUe(self, self.VVDKZr, "Remove Extra Font and Restart GUI ?", title="Remove Extra Font")
   elif item == "sysFont"  : self.VVp5WI(VVTKvf)
 def VVDKZr(self):
  FFBWtx(CFG.fontPathAdd, "")
  CCYInC.VViFfG(self)
 @FFJRPn()
 def VVFR3j(self):
  title = "%s Optional Dependencies (for more features)" % PLUGIN_NAME
  VVuGUx = self.VV32Du()
  VVwqVu = ("Install"    , BF(self.VVTCdj, title), [])
  VViMvb  = ("Update Sys. Packages", self.VVLLv6 , [])
  header  = ("Library", "State", "Usage" )
  widths  = (20   , 25  , 55  )
  VV4Uoc = (LEFT  , CENTER , LEFT  )
  VVAIxO = FFCXsL(self, None, title=title, header=header, VVXpNQ=VVuGUx, VV4Uoc=VV4Uoc, VV8boH=widths, VVPYL1=28, width=1350, VVwqVu=VVwqVu, VViMvb=VViMvb, VVRtfk=2)
 def VVTCdj(self, Title, VVAIxO, title, txt, colList):
  pkg, state, usage = colList
  cbFnc = BF(self.VVlAqF, VVAIxO)
  if pkg == "xz" and "BusyBox" in state:
   FF6NKJ(self, FF4zTV(VVw2da, pkg), VVu7vM=cbFnc, title=Title)
  elif "Installed" in state:
   FFxHED(VVAIxO, "Already installed.")
  else:
   pkgDict = self.VVO0bc()
   if   pkg == "requests" : CC6V53.VVZTHq(self, cbFnc=cbFnc)
   elif pkg == "Imaging" : CCM6jS.VVWpl0(self, Title, False, cbFnc=cbFnc)
   elif pkg == "ar"  : FF6NKJ(self, FF6SON(), VVu7vM=cbFnc, title=Title)
   elif pkg in pkgDict  : FF6NKJ(self, FF61q5(pkgDict[pkg], pkg, pkg.capitalize()), VVu7vM=cbFnc, title=Title)
 def VVLLv6(self, VVAIxO, title, txt, colList):
  CCz0DD.VVd7pK(self)
 def VVlAqF(self, VVAIxO):
  VVuGUx = self.VV32Du()
  VVAIxO.VVsu0I(VVuGUx[VVAIxO.VVoxea()])
 def VV32Du(self):
  tDict = {}
  path = VVK8DT + "_sup_lib"
  if FFKbVo(path):
   for line in FF2kXa(path):
    lib, _, txt = line.partition("=")
    tDict[lib] = txt
  def VVqz4B(lib, ok):
   txt = tDict.get(lib, "")
   if ok: return (lib, "#f#0000ff00#" + "Installed" , txt)
   else : return (lib, "#f#00ff8000#" + "Not installed", txt)
  VVuGUx = []
  VVuGUx.append(VVqz4B("requests", CC6V53.VVZTHq(self, install=False)))
  VVuGUx.append(VVqz4B("Imaging" , CCM6jS.VVWpl0(self, "", False, install=False)))
  VVuGUx.append(VVqz4B("ar"   , CCz0DD.VVY56J()))
  for pkg, cmd in self.VVO0bc().items():
   row = VVqz4B(pkg, FFW91j(cmd))
   if pkg == "xz":
    pFound, pBBox = FF3mxO(pkg)
    if pFound and pBBox:
     c1 = VVPI2q
     stt = FFKrMM("BusyBox xz (old)", c1)
     usg = "%s  ...  %s" % (row[2], FFKrMM("xz v5 recommended", c1))
     row = (pkg, stt, usg)
   VVuGUx.append(row)
  VVuGUx.sort(key=lambda x: x[0].lower())
  return VVuGUx
 def VVO0bc(self):
  d = {}
  for pkg in ("xz", "zip", "p7zip", "unrar", "bzip2", "ffmpeg"):
   d[pkg] = pkg
  d["p7zip"] = "7za"
  return d
 def VVvSX0(self):
  return FFJv8S() + "ajpanel_colors"
 def VVCxyO(self):
  tDict = { "main_title_fg" : ""
    , "main_title_bg" : ""
    , "main_body_fg" : ""
    , "main_body_bg" : ""
    , "main_cursor_fg" : ""
    , "main_cursor_bg" : ""
    , "main_bar_fg"  : ""
    , "main_bar_bg"  : ""
    }
  p = self.VVvSX0()
  if FFKbVo(p):
   txt = FFmx8y(p)
   lst = iFindall(r"(.*[^\s])\s*=\s*(#(?:[A-Fa-f0-9]{8}))", txt, IGNORECASE)
   for txt, c in lst:
    tDict[txt] = c
  return tDict
 def VVSB8y(self, tDict, item, fg, bg):
  if fg:
   self.VVh904(item, fg)
   self.VVnRJg(item, bg)
   tDict["main_%s_fg" % item] = fg
   tDict["main_%s_bg" % item] = bg
   self.VVYbmu(tDict)
 def VVYbmu(self, tDict):
   p = self.VVvSX0()
   with open(p, "w") as f:
    for key, val in tDict.items():
     f.write("%s=%s\n" % (key, val))
 def VVh904(self, item, fg):
  if   item == "title" : FFMhbx(self["myTitle"], fg)
  elif item == "body"  :
   FFMhbx(self["myMenu"], fg)
   FFMhbx(self["myBody"], fg)
  elif item == "cursor" : self["myMenu"].instance.setForegroundColorSelected(parseColor(fg))
  elif item == "bar"  :
   for item in ("myBar", "keyRed", "keyGreen", "keyYellow", "keyBlue"): FFMhbx(self[item], fg)
 def VVnRJg(self, item, bg):
  if   item == "title" : FFgLA9(self["myTitle"], bg)
  elif item == "body"  :
   FFgLA9(self["myMenu"], bg)
   FFgLA9(self["myBody"], bg)
  elif item == "cursor" : self["myMenu"].instance.setBackgroundColorSelected(parseColor(bg))
  elif item == "bar"  : FFgLA9(self["myBar"], bg)
 def VVkJcn(self):
  FFlonU("rm '%s'" % self.VVvSX0())
  self.close()
 def VVpb4T(self):
  tDict = self.VVCxyO()
  for item in ("title", "body", "cursor", "bar"):
   self.VVKVdY(tDict, item)
 def VVKVdY(self, tDict, name):
  fg = tDict.get("main_%s_fg" % name, "")
  bg = tDict.get("main_%s_bg" % name, "")
  if fg: self.VVh904(name, fg)
  if bg: self.VVnRJg(name, bg)
 def VVp5WI(self, which):
  if   which == VV6Thi  : rest, defFnt, title = False, CFG.fontPathMain.getValue(), PLUGIN_NAME
  elif which == VVDtIm : rest, defFnt, title = False, CFG.fontPathTerm.getValue(), "Terminal "
  elif which == VVIKra  : rest, defFnt, title = True , CFG.fontPathAdd.getValue() , "Add to System"
  elif which == VVTKvf  : rest, defFnt, title = True , CFG.fontPathSys.getValue() , "System"
  CCYJTf.VVyC0j(self, "Change %s Font" % title, defFnt, rest, BF(self.VVFOvi, which))
 def VVFOvi(self, which, path=None):
  if path:
   path = "" if path == "DEFAULT" else path
   if   which == VV6Thi  : FFBWtx(CFG.fontPathMain, path)
   elif which == VVDtIm: FFBWtx(CFG.fontPathTerm, path)
   elif which == VVIKra  : FFBWtx(CFG.fontPathAdd , path)
   elif which == VVTKvf  : FFBWtx(CFG.fontPathSys , path)
   err = CC73QP.VVUGUn(which)
   if err          : FFbBGq(self, err, title=title)
   elif which == VV6Thi   : self.close()
   elif which == VVDtIm  : FFxHED(self, "Terminal font applied", 1500)
   elif which == VVIKra and path : FFxHED(self, "Font Added", 1500)
   elif which == VVTKvf and path: FFxHED(self, "System font applied", 1500)
   elif which == VVTKvf   : FF6pUe(self, BF(CCYInC.VViFfG, self), "Font changed (will take effect after GUI Restart).\n\nRestart GUI ?", title="Reset font to default")
 @staticmethod
 def VVUGUn(name):
  if   name == VV6Thi : path, repl = CFG.fontPathMain.getValue(), 0
  elif name == VVDtIm: path, repl = CFG.fontPathTerm.getValue(), 0
  elif name == VVIKra  : path, repl = CFG.fontPathAdd.getValue() , 1
  elif name == VVTKvf : path, repl = CFG.fontPathSys.getValue() , 1
  if not path:
   FFIXGD()
   return ""
  elif not FFKbVo(path):
   return "Font file not found"
  nameLst = []
  if name == VVTKvf:
   nameLst = []
   for nm in FFIXGD():
    if not nm in (VV6Thi, VVDtIm):
     nameLst.append(nm)
  else:
   nameLst = [name]
  totDone = 0
  for fntName in nameLst:
   if FF1GWp(path, fntName, isRepl=repl):
    totDone += 1
  if totDone > 0: FFIXGD()
  else    : return "Could not add font"
 def VVObru(self):
  CCsmqb.VVlIAT(self.session)
class CC3iMt():
 VVvhTJ = "ajpWebServer"
 def __init__(self, session):
  self.session = session
  tw = skt = srv = None
  try: from twisted.internet import reactor as tw
  except: pass
  try: import SocketServer as skt
  except:
   try: import socketserver as skt
   except: pass
  try: import SimpleHTTPServer as srv
  except:
   try: import http.server as srv
   except: pass
  self.VVIBOo, self.VVJ54y, self.VVzPfB = skt, srv, tw
 def VV8dVL(self):
  if not self.VVIBOo or not self.VVJ54y: return
  fnc = self.VVN7or
  VVzPfB = self.VVzPfB
  class CCzLi3(self.VVJ54y.SimpleHTTPRequestHandler):
   def do_GET(self):
    self.VV4Qgr("")
   def do_POST(self):
    length = int(self.headers["Content-Length"])
    data = str(self.rfile.read(length))
    self.VV4Qgr(data)
   def VV4Qgr(self, data):
    if   len(self.path) > 100: mode, rCode, rTxt = 1, 414, "URI Too Long"
    elif not VVzPfB   : mode, rCode, rTxt = 1, 400, "Missing Twisted Module"
    else      : mode, rCode, rTxt = fnc(self.path, data)
    if mode == 1:
     cType = "application/json"
     dic = {PLUGIN_NAME: VV8h7S, "Request": self.path, "Result" : rTxt}
     rTxt = jDumps(dic).encode()
    else:
     cType = "text/html"
    self.send_response(rCode)
    self.send_header("Content-type", cType)
    self.end_headers()
    self.wfile.write(rTxt)
  try:
   global VVskLA
   handler = CCzLi3
   self.VVIBOo.TCPServer.allow_reuse_address = True
   VVskLA = self.VVIBOo.TCPServer(("", CFG.wsPort.getValue()), handler)
   th = iThread(name=CC3iMt.VVvhTJ, target=VVskLA.serve_forever)
   th.setDaemon(True)
   th.start()
  except:
   pass
 def VVN7or(self, uPath, data):
  uPath = uPath.lower()
  if  uPath.startswith("/player"): rCode, rTxt = self.VV0n3z(data)
  else       : rCode, rTxt = 400, "Unknown request"
  mode = 1
  return mode, rCode, rTxt
 def VVXjml(self, fnc):
  def VVxN3u():
   if currentThread().getName() == "MainThread": fnc()
  if self.VVzPfB: self.VVzPfB.callFromThread(VVxN3u)
 def VV0n3z(self, data):
  try: dic = jLoads(data)
  except: dic = {}
  tab = lambda x: FF5ov5(str(dic[x]).strip()) if x in dic else ""
  url = tab("url")
  ref = tab("ref")
  name= tab("name")
  logo= tab("logo")
  endRef= tab("endRef")
  if not name and url.startswith("/"): name = os.path.splitext(os.path.basename(url))[0]
  name = name or "No Name"
  if ref and not iMatch(r"^((?:[A-Fa-f0-9]+[:]){10})$", ref)   : return 400, "Incorrect ref format"
  if endRef and not iMatch(r"^((?:[A-Fa-f0-9]+[:]){10}).*", endRef): return 400, "Incorrect endRef format"
  chUrl = ""
  if url:
   ref = ref or "%s:0:1:0:0:0:0:0:0:0:" % CFG.iptvAddToBouquetRefType.getValue()
   if  url.startswith("http") : url = FFTnsB(url)
   elif url.startswith("/") : pass
   else      : return 400, "Incorrect URL"
   chUrl = "%s%s:%s" % (ref.upper(), url, name)
  elif ref:
   chUrl = ref
  if CCsmqb.VVfMBZ:
   txt = "Channel Changed" if ref else "Player is already shown"
   fnc = BF(CCsmqb.VVfMBZ.VVCGcn, chUrl, endRef, logo)
  else:
   txt = "Player Started"
   fnc = BF(CCsmqb.VVlIAT, self.session, VVdxJv=chUrl, endRef=endRef, VVHkge=logo)
  self.VVXjml(fnc)
  return 200, txt
 def VVeHl3(self, trunOn):
  err = ""
  if not all((self.VVIBOo, self.VVJ54y)):
   err = "Missing Python libraries"
  else:
   isOn = CC3iMt.VVuzZb()
   if trunOn:
    if isOn : err = "Already running"
    else : self.VV8dVL()
   else:
    if isOn : CC3iMt.VVIL7b()
    else : err = "Already stopped"
  return err, CC3iMt.VV1zto()
 @staticmethod
 def VVIL7b():
  if "VVskLA" in globals():
   global VVskLA
   if hasattr(VVskLA, "_BaseServer__shutdown_request"):
    VVskLA._BaseServer__shutdown_request = True
   VVskLA.shutdown()
   VVskLA.server_close()
   FF0JpZ("VVskLA")
 @staticmethod
 def VV1zto():
  return "Turned %s" % ("ON" if CC3iMt.VVuzZb() else "OFF")
 @staticmethod
 def VVuzZb():
  thrListUrls = []
  for thr in iEnumerate():
   if thr.name == CC3iMt.VVvhTJ:
    return True
  else:
   return False
class CCZv30():
 def __init__(self, session):
  self.Session = session
  self.servPtr  = CCZv30.VV8hGu(self.Session)
  self.VVq9SN  = ""
  self.VVadS0  = ""
  self.VVjgtq  = ""
  self.VVVmGQ  = ""
  self.VVUwmk   = ""
  self.prov   = ""
  self.state   = ""
  self.isMarker  = False
  self.info   = self.servPtr and self.servPtr.info()
  if self.info:
   self.VVUwmk  = self.info.getName()
   ref     = FFbhVV(self.info, iServiceInformation.sServiceref)
   state   = FFbhVV(self.info, iServiceInformation.sDVBState)
   self.prov  = FFbhVV(self.info, iServiceInformation.sProvider)
   self.isMarker = FFgTKx(ref)
   if self.isMarker:
    self.state = "Marker"
    self.VVq9SN = ref.rstrip(":")
    self.VVUwmk = self.VVzw8z()
   else:
    self.VVVmGQ = ref if self.VVadS0 else ""
    self.state = self.VVtXYq(state)
    self.VVq9SN, self.VVadS0, self.VVjgtq, self.VVVmGQ = CCZv30.VVXF8h(ref)
  self.servRef = CCZv30.VVc37c(self.Session)
  if self.servRef:
   self.Name  = self.servRef.getName()
   self.VVZWTf = self.servRef.toString()
   self.VVOhyp = self.servRef.toCompareString()
   self.refType = str(self.servRef.type)
   self.Path  = self.servRef.getPath()
   self.isValid = self.servRef.valid()
   self.flags  = self.servRef.flags
   try: self.chNum = self.servRef.getChannelNum()
   except: self.chNum = 0
  else:
   self.Name  = ""
   self.VVZWTf = ""
   self.VVOhyp = ""
   self.refType = ""
   self.Path  = ""
   self.isValid = False
   self.flags  = 0
   self.chNum  = 0
  span = iSearch(r"^((?:[A-F0-9]+[:]){9}(?:[A-F0-9]+))", self.VVq9SN or self.VVZWTf, IGNORECASE)
  self.VVF8zm = span.group(1).upper().rstrip(":") if span else ""
  span = iSearch(r"http.+\/((?:[A-Fa-f0-9]+:){10}):", self.VVadS0)
  self.VVHK1O = span.group(1).rstrip(":") if span else ""
  self.isLocal = self.isIptv = self.isFtp = self.isDvb = self.isDvbS = self.isDvbC = self.isDvbT = self.VVlAIM = False
  typ = ""
  if   "file?file" in self.VVZWTf or ":ftp%3a//" in self.VVZWTf : typ, self.isFtp = "FTP", True
  elif FFKeSw(self.VVZWTf) or self.VVHK1O    : typ, self.VVlAIM= "S. Relay", True
  elif FFC4pX(self.VVZWTf)          : typ, self.isIptv = "IPTV", True
  elif self.Path.startswith("/")         : typ, self.isLocal = "Local Media", True
  elif not self.Path:
   self.isDvb = True
   ns = FFikHv(self.VVZWTf)
   if   ns.startswith("EEEE") : typ, self.isDvbT = "DVB-T", True
   elif ns.startswith("FFFF") : typ, self.isDvbC = "DVB-C", True
   else      : typ, self.isDvbS = "DVB-S", True
  self.streamType = typ
  span = iSearch(r"(.+)(mode=.+end=)", self.VVadS0, IGNORECASE)
  if span:
   self.VV85mj = span.group(1).rstrip("&?")
   self.myPhp = span.group(2)
  else:
   self.VV85mj = ""
   self.myPhp = ""
  self.uniqueId = self.myPhp if self.myPhp else self.Path or self.VVq9SN
  self.userTxt = self.VV85mj or self.Path or self.VVq9SN
 def VVzw8z(self):
  for r, n, f in CC8i1k.VV2lFz(mode=1):
   if self.VVq9SN in r:
    return n
  return self.VVUwmk + " (Marker)"
 def VVtXYq(self, s):
  if   not s :s=""
  elif s=="0" :s="*No free tuner"
  elif s=="1" :s="*Tune Failed"
  elif s=="2" :s="*Timeout reading PAT"
  elif s=="3" :s="*SID not found in PAT"
  elif s=="4" :s="*Timeout reading PMT"
  elif s=="5" :s="New program info"
  elif s=="6" :s="Tuned"
  elif s=="7" :s="Pre-Start"
  elif s=="8" :s="SOF"
  elif s=="9" :s="EOF"
  elif s=="10":s="*Check tuner configuration"
  elif s=="11":s="HBBTV Info"
  elif s=="12":s="*Stopped"
  elif s=="13":s="Channel Allocated"
  return s
 @staticmethod
 def VVc37c(session):
  return session.nav.getCurrentlyPlayingServiceReference()
 @staticmethod
 def VV8hGu(session):
  return session.nav.getCurrentService()
 @staticmethod
 def VVXF8h(ref):
  if ref.endswith(("%3a", "%3A")): ref = ref[:-3]
  span = iSearch(r"((?:[A-Fa-f0-9]+[:]){10})(.+\/\/.+)", ref)
  if span:
   VVq9SN = span.group(1).upper().rstrip(":")
   VVjgtq = span.group(2)
   return VVq9SN, FF5ov5(VVjgtq), VVjgtq, VVq9SN + ":" + VVjgtq
  else:
   VVq9SN = ref
  return VVq9SN.rstrip(":"), "", "", ""
class CCwyMT():
 def __init__(self, SELF, tableObj, colNum=0):
  self.SELF  = SELF
  self.tableObj = tableObj
  self.colNum  = colNum
  self.VVnVSC = -1
  self.SERVICE = 0
  self.STRING  = 1
  self.MULTI  = 2
  s = str(type(self.tableObj.l))
  if   s == "<class 'enigma.eListboxServiceContent'>"  : self.mode = self.SERVICE
  elif s == "<class 'enigma.eListboxPythonStringContent'>": self.mode = self.STRING
  elif s == "<class 'enigma.eListboxPythonMultiContent'>" : self.mode = self.MULTI
  else             : return
  from Tools.NumericalTextInput import NumericalTextInput
  self.numericalTextInput = NumericalTextInput(nextFunc=self.VVkHd5)
  self.numericalTextInput.setUseableChars('1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ')
  FFmpyO(SELF, {str(i):BF(self.VVmvcM, i) for i in range(10)})
 def VVmvcM(self, key):
  self.VVnVSC = self.numericalTextInput.getKey(key)
  for group in ("1", "2ABC", "3DEF", "4GHI", "5JKL", "6MNO", "7PQRS", "8TUV", "9WXYZ", "0"):
   if self.VVnVSC in group:
    if VVCQUS:
     txt = " ".join(group)
     txt = txt.replace(self.VVnVSC, VVCQUS + self.VVnVSC + VV0p9P)
     txt = VV0p9P + txt
    else:
     sep = "    "
     txt = sep + sep.join(group) + sep
     txt = txt.replace(sep + self.VVnVSC + sep, "   [%s]   " % self.VVnVSC)
    FFoTZI(self.SELF, txt)
 def VVkHd5(self):
  FFoTZI(self.SELF)
  try:
   if not self.tableObj:
    return
   if self.mode == self.SERVICE:
    try: self.tableObj.moveToChar(self.VVnVSC)
    except: self.tableObj.moveToChar(self.VVnVSC.encode())
   elif self.tableObj.list:
    for ndx in range(len(self.tableObj.list)):
     item = self.tableObj.list[ndx]
     if self.mode == self.STRING : item = item[self.colNum]
     else      : item = item[self.colNum + 1][7]
     item = FFkEjh(item).strip().encode().decode()
     if item.upper()[:1] == self.VVnVSC:
      self.tableObj.moveToIndex(ndx)
      break
  except:
   pass
class CCVlLA(Screen):
 def __init__(self, session, isMove, VVXpNQ, srcDir, dstDir):
  self.skin, self.VVmNvK = FFQaOH(VV0v8m, 1600, 1000, 50, 40, 20, "#11003040", "#11001122", 30)
  self.session  = session
  self.isMove   = isMove
  self.VVXpNQ   = VVXpNQ
  self.srcDir   = FF9Uvy(srcDir)
  self.dstDir   = FF9Uvy(dstDir)
  self.isMoveFast  = isMove and CC17eA.VVXQIL(self.srcDir) == CC17eA.VVXQIL(self.dstDir)
  self.files   = []
  self.dirs   = []
  self.others   = []
  self.action   = "move" if isMove else "copy"
  self.Title   = self.action.capitalize()
  self.resText  = ""
  self.totPaths  = 0
  self.curItem  = ""
  self.curErr   = ""
  FFNhKZ(self, addScrollLabel=True, title=self.Title)
  FFmpyO(self, { "ok": self.VV3iIJ, "cancel": self.VV3iIJ })
  self.onShown.append(self.VVf1Ra)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  self["myLabel"].VVesH9()
  err = ""
  itemExists = False
  if self.srcDir == self.dstDir:
   self.VVJf3H("Cannot %s to same directory" % self.action)
  else:
   itself = "Cannot %s a directory to itself" % self.action
   for name in self.VVXpNQ:
    err = ""
    path = os.path.join(self.srcDir, name)
    if path == self.dstDir:
     err = itself
    elif os.path.islink(FFsxFo(path)):
     self.totPaths += 1
    elif os.path.ismount(path):
     err = "Cannot include mount"
    elif os.path.isdir(path):
     self.totPaths += 1
     if FF9Uvy(path) == self.dstDir:
      err = itself
     else:
      totDir, totFile, totLink = FFrfrn(path)
      self.totPaths += totDir + totFile + totLink
    else:
     self.totPaths += 1
    if err:
     self.VVJf3H("%s\n\n%s" % (err, path))
     return
    elif FFKbVo(os.path.join(self.dstDir, FFiZj6(path))):
     itemExists = True
  if itemExists: FF6pUe(self, self.VV9hgH, "Overwrite items in destination ?", callBack_No=self.close, title=self.Title)
  else   : self.VV9hgH()
 def VV3iIJ(self):
  self.close()
 def VVOhJD(self, txt):
  self["myLabel"].appendText(str(txt))
 def VVJf3H(self, txt):
  FFbBGq(self, txt, title=self.Title)
  self.VV3iIJ()
 def VV9hgH(self):
  totBars = 1 if self.isMoveFast else 2
  CCV3Gw.VVgWD3(self, VVN6I4=self.Title, VV32kU=CCV3Gw.VVQFxC, titleBg="#22220022", bodyBg="#22220022", totBars=totBars
      , VVuSHu  = self.VV0Yp1
      , VVhK3C = self.VVE2jv )
 def VV0Yp1(self, VVqeT6):
  VVqeT6.VVfT17(self.totPaths)
  for name in self.VVXpNQ:
   srcPath = os.path.join(self.srcDir, name)
   dstPath = os.path.join(self.dstDir, name)
   self.curItem = srcPath
   if not VVqeT6 or VVqeT6.isCancelled:
    return
   if os.path.islink(FFsxFo(srcPath)):
    self.VVBm4o(srcPath, dstPath, VVqeT6)
   elif os.path.isdir(srcPath):
    for Dir, subdirs, files in os.walk(srcPath):
     if not VVqeT6 or VVqeT6.isCancelled:
      return
     if not subdirs and not files:
      VVqeT6.VVqE9L(1)
      dstDir = os.path.join(self.dstDir, Dir[len(self.srcDir):].lstrip("/"))
      try:
       if not VVkY7E(dstDir):
        os.makedirs(dstDir)
      except Exception as e:
       self.curErr = str(e)
       VVqeT6.VVY97Z()
       return
     else:
      VVqeT6.VVqE9L(1)
      for name in files:
       dstDir = os.path.join(self.dstDir, Dir[len(self.srcDir):].lstrip("/"))
       try:
        if not VVkY7E(dstDir):
         os.makedirs(dstDir)
       except Exception as e:
        self.curErr = str(e)
        VVqeT6.VVY97Z()
        return
       self.VVBm4o(os.path.join(Dir, name), os.path.join(dstDir, name), VVqeT6)
    if self.isMove: FFy8Vf(srcPath)
   else:
    self.VVBm4o(srcPath, dstPath, VVqeT6)
 def VVBm4o(self, srcPath, dstPath, VVqeT6):
  title = "../" + os.path.join(FFiZj6(FFdwbd(srcPath, True)), os.path.basename(srcPath))
  VVqeT6.VVX5nT(title)
  self.curItem = srcPath
  size = FFLjtI(srcPath)
  if size == -1:
   size = 0
  VVqeT6.VVuDjj(0)
  VVqeT6.VVH2AI(size)
  VVqeT6.VVqE9L(1)
  if os.path.islink(FFsxFo(srcPath)):
   FFy8Vf(dstPath)
   try:
    os.symlink(os.readlink(srcPath), dstPath)
   except:
    self.curErr = "Cannot copy SymLink"
    VVqeT6.VVY97Z()
    return
  elif self.isMoveFast:
   if not FFlonU("mv -f '%s' '%s'" % (srcPath, dstPath)):
    VVqeT6.VVY97Z()
    return
  else:
   with open(srcPath, "rb") as srcF:
    with open(dstPath, "wb") as dstF:
     while True:
      if not VVqeT6 or VVqeT6.isCancelled:
       FFnE7j(dstPath)
       return
      try:
       data = srcF.read(1024)
       if not data:
        break
       dstF.write(data)
       VVqeT6.VVpqYW(len(data))
      except Exception as e:
       self.curErr = str(e)
       FFnE7j(dstPath)
       VVqeT6.VVY97Z()
       return
     VVqeT6.VVX5nT(FFKrMM(title, VVOQkl))
  try: iCopymode(srcPath, dstPath)
  except: pass
  if self.isMove: FFy8Vf(srcPath)
 def VVE2jv(self, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  txt  = "Total\t: %s\n" % self.totPaths
  txt += "%s\t: %s\n" % ("Moved" if self.isMove else "Copied", FFKrMM(threadCounter, VVOQkl if threadCounter == self.totPaths else VVdLWL))
  if not VV6ZvL or self.curErr or threadErr or threadCounter != self.totPaths:
   txt += FFKrMM("\n\nLast processed file:\n", VVdLWL)
   txt += "%s\n" % self.curItem
  self.VVOhJD(txt)
  self["myLabel"].VVJS7j()
class CC3TwO():
 def __init__(self):
  self.nmUselessWords  = ('4k','8k','a','aac5','am','ar','arabic','avc','blueray','bluray','brrip','ddp5','dts','en','english','evo','hd','hdr','hdrip','hevc','mora','multi','multisub','mx','netflix','nf','remux','srt','sub','utf8','web','webrip','xvid','yify','yts')
  self.nmComp2yearsPatt = iCompile(r".*\d{4}.+\d{4}")
  self.nmSkip2yearsPatt = iCompile(r"(.*\d{4}.+)\d{4}\s*(.*)")
  self.nmSkip1yearsPatt = iCompile(r" \d{4}")
  self.nmSkipWordsPatt = iCompile( r"\d{3,4}p"
           r"|[A-Za-z]\d{3}"
           r"|\d{1,3}bit[s]?"
           r"|25r|25rat|25rate"
           r"|[A-Za-z]{2}\d"
           , IGNORECASE)
  try:
   from difflib import get_close_matches as iClosest
   self.iClosest = iClosest
  except:
   self.iClosest = None
 def VVbNkN(self, textToFind, pathLst, maxRes=0, cutoff=0.3):
  if   not pathLst  : return [] , ""
  elif not self.iClosest : return [], 'Missing "difflib" library'
  if maxRes == 0:
   maxRes = len(pathLst)
  refLst = []
  for ndx, path in enumerate(pathLst):
   fName = os.path.splitext(os.path.basename(path))[0]
   fName = iSub(r"([^A-Za-z0-9])", " ", fName).strip()
   words = []
   for word in fName.split():
    if not word.lower() in self.nmUselessWords and not iMatch(self.nmSkipWordsPatt, word):
     words.append(word)
   txt = " ".join(words)
   if iMatch(self.nmComp2yearsPatt, txt): txt = iSub(self.nmSkip2yearsPatt, r"\1\2", txt).rstrip();
   else         : txt = iSub(self.nmSkip1yearsPatt, "", txt)
   if txt:
    refLst.append("%d,%s" % (ndx, txt))
  bestLst = self.iClosest(textToFind, refLst, n=maxRes, cutoff=cutoff)
  lst = []
  if bestLst:
   for item in bestLst:
    ndx, fName = item.split(",", 1)
    lst.append(pathLst[int(ndx)])
  return lst, ""
 def VVUE79(self, SELF, cbFnc, textToFind, pathLst, maxRes=0, cutoff=0.3):
  if  not pathLst  : cbFnc([] , "")
  elif not self.iClosest : cbFnc([], 'Missing "difflib" library')
  else:
   CCV3Gw.VVgWD3(self, VVN6I4="Searching ...", titleBg="#22220022", bodyBg="#22220022", VV32kU=CCV3Gw.VVQFxC
       , VVuSHu  = BF(self.VVi9ur, textToFind, pathLst, maxRes, cutoff, cbFnc)
       , VVhK3C = BF(self.VV0RZI, SELF, textToFind, pathLst, maxRes, cutoff, cbFnc))
 def VVi9ur(self, textToFind, pathLst, maxRes, cutoff, cbFnc, VVqeT6):
  VVqeT6.VVfT17(len(pathLst))
  VVqeT6.VVL8uX = []
  if maxRes == 0:
   maxRes = len(pathLst)
  for ndx, path in enumerate(pathLst):
   if not VVqeT6 or VVqeT6.isCancelled:
    return
   VVqeT6.VVqE9L(1)
   fName = os.path.splitext(os.path.basename(path))[0]
   fName = iSub(r"([^A-Za-z0-9])", " ", fName).strip()
   words = []
   for word in fName.split():
    if not word.lower() in self.nmUselessWords and not iMatch(self.nmSkipWordsPatt, word):
     words.append(word)
   txt = " ".join(words)
   if iMatch(self.nmComp2yearsPatt, txt): txt = iSub(self.nmSkip2yearsPatt, r"\1\2", txt).rstrip();
   else         : txt = iSub(self.nmSkip1yearsPatt, "", txt)
   if txt and VVqeT6 and not VVqeT6.isCancelled:
    VVqeT6.VVL8uX.append("%d,%s" % (ndx, txt))
 @FFJRPn("Filtering ...", par=1)
 def VV0RZI(self, SELF, textToFind, pathLst, maxRes, cutoff, cbFnc, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  bestLst = self.iClosest(textToFind, VVL8uX, n=maxRes, cutoff=cutoff)
  lst = []
  if bestLst:
   for item in bestLst:
    ndx, fName = item.split(",", 1)
    lst.append(pathLst[int(ndx)])
  cbFnc(lst, "")
class CCQdT4(Screen):
 def __init__(self, session, args=0):
  self.skin, self.VVmNvK = FFQaOH(VVNkG2, 800, 950, 40, 50, 30, "#22300030", "#0a202020", 33)
  self.session  = session
  self.netEntryFile = FFJv8S() + "ajpanel_network"
  c1, c2 = VVk4x7, VVWH8U
  VV9cxb = []
  VV9cxb.append((c1 + "Network Storage (FTP)"   , "dev" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Network Scanner (ping)"    , "ping"))
  VV9cxb.append(("Port Scanner (scan for famous ports)" , "port"))
  VV9cxb.append(VVbM5H)
  VV9cxb.append((c2 + "Check Internet Connection"  , "intr"))
  FFNhKZ(self, title="Network Tools", VV9cxb=VV9cxb)
  self.onShown.append(self.VVf1Ra)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  FFvJ8o(self["myMenu"])
  FFNUiO(self)
 def VVyuDa(self):
  item = FFgo5c(self)
  if   item == "dev" : self.VV85qp()
  elif item == "ping" : self.VVGxyU()
  elif item == "port" : CC9qM0.VVHnlI(self, self.VVYNls, title="Select host to scan")
  elif item == "intr" : self.session.open(CCNLYy)
 @FFJRPn("Reading Devices ...")
 def VV85qp(self, canCencel=False):
  title = "Network Devices"
  VVuGUx = self.VVSn4V()
  if VVuGUx:
   bg = "#0a223333"
   VVuGUx.sort(key=lambda x: x[0].lower())
   VVpW7I = BF(self.VV8YGN, canCencel)
   VVj7lw  = ("Start FTP"   , self.VVcLTw    , [])
   VV46TD = ("Entry Options"  , self.VV5syL  , [])
   VViMvb = ("Scan for Devices" , self.VVaZt8 , [])
   header  = ("Num" , "IP-Address", "Username", "Password", "Default Path", "Remarks" )
   widths  = (7  , 25   , 19  , 19  , 0.01   , 30  )
   VV4Uoc = (CENTER , LEFT   , LEFT  , LEFT  , LEFT   , LEFT  )
   VVAIxO = FFCXsL(self, None, title=title, header=header, VVXpNQ=VVuGUx, VV4Uoc=VV4Uoc, width=1500, height=900, VV8boH=widths, VVPYL1=28, VVj7lw=VVj7lw, VVpW7I=VVpW7I, VV46TD=VV46TD, VViMvb=VViMvb
       , VVfWsQ=bg, VVB5I5=bg, VVYCun=bg, VVzVW9="#11ffff00", VVmErq="#11220000", VVK8UQ="#00333333", VVgSJJ="#11400040")
   ndx = CFG.lastNetworkDevice.getValue()
   if isinstance(ndx, int):
    VVAIxO.VVt5t9(ndx)
  else:
   FF6pUe(self, BF(self.VVdl6v, canCencel=canCencel), "No devices found !\n\nScan network ?", callBack_No=BF(self.VV8YGN, canCencel), title=title)
 def VV5syL(self, VVAIxO, title, txt, colList):
  VV9cxb = []
  VV9cxb.append(("Change Username"   , "user"))
  VV9cxb.append(("Change Password"   , "pass"))
  VV9cxb.append(("Change Remarks"   , "rem"))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Remove Selected Server" , "del"))
  FFO9kU(self, BF(self.VVGrEt, VVAIxO), VV9cxb=VV9cxb, title="Entry Options")
 def VVGrEt(self, VVAIxO, item=None):
  if item:
   if   item == "user" : self.VVVkrM("u", VVAIxO)
   elif item == "pass" : self.VVVkrM("p", VVAIxO)
   elif item == "rem" : self.VVVkrM("r", VVAIxO)
   elif item == "del" : FF6pUe(self, BF(self.VV9kv3, VVAIxO), "Continue ?", title="Delete Entry")
 def VV8YGN(self, canCencel, VVAIxO=None):
  if VVAIxO: VVAIxO.cancel()
  if canCencel : self.close()
 def VVcLTw(self, VVAIxO, title, txt, colList):
  num, ip, u, p, path, rem = colList
  entry = (ip, u, p, path, rem)
  FFBWtx(CFG.lastNetworkDevice, VVAIxO.VVoxea())
  self.session.openWithCallback(BF(self.VVT8CH, entry, VVAIxO), CCEcn7, entry)
 def VVT8CH(self, entry, VVAIxO, newPath=None):
  if newPath:
   ip, u, p, path, rem = entry
   if path != newPath:
    self.VVj5n9("d", newPath, ip, u, p, path, rem)
    self.VVwKpf(VVAIxO)
 @FFJRPn("Scanning Network ...", clearMsg=False, par=1)
 def VVaZt8(self, VVAIxO, title, txt, colList):
  self.VVdl6v(mainTableInst=VVAIxO)
 @FFJRPn("Scanning ...")
 def VVdl6v(self, canCencel=False, mainTableInst=None):
  title = "Network Devices"
  ftpLst, err = CC9qM0.VVvspF(CC9qM0.VVTnee)
  if err:
   FFbBGq(self, err, title=title)
   return
  telLst, err = CC9qM0.VVvspF(CC9qM0.VVn7lL)
  if err:
   FFbBGq(self, err, title=title)
   return
  tLst = list(set(ftpLst + telLst))
  lst = []
  for item in tLst:
   typ = []
   if item in ftpLst: typ.append("FTP")
   if item in telLst: typ.append("Telnet")
   lst.append((item[0], item[1], " / ".join(typ)))
  ftpLst = telLst = tLst = None
  if mainTableInst:
   mainTableInst.VVEL2E()
  if lst:
   def VVMy7P(p1, p2): return FFZoJv(p1[0], p2[0])
   lst.sort(key=FFlhXH(VVMy7P))
   bg = "#0a202020"
   VVpW7I = BF(self.VV8YGN, canCencel)
   VVj7lw  = ("Add to Devices" , BF(self.VVmLOq, mainTableInst, canCencel), [])
   header  = ("IP-Address" , "MAC-Address" , "Open Ports" )
   widths  = (40   , 34   , 26   )
   VV4Uoc = (LEFT   , CENTER  , CENTER  )
   FFCXsL(self, None, title=title, header=header, VVXpNQ=lst, VV4Uoc=VV4Uoc, VV8boH=widths, width=1200, VVPYL1=30, VVj7lw=VVj7lw, VVpW7I=VVpW7I, VVRtfk=2
     , VVfWsQ=bg, VVB5I5=bg, VVYCun=bg, VVmErq="#0a225555", VVgSJJ="#11403040")
  else:
   FFbBGq(self, "No devices found !", title=title)
 @FFJRPn("Scanning ...")
 def VVGxyU(self):
  title = 'Hosts that responded to "ping"'
  lst, err = CC9qM0.VVvspF(-1)
  if err:
   FFbBGq(self, err, title=title)
  elif lst:
   def VVMy7P(p1, p2): return FFZoJv(p1[0], p2[0])
   lst.sort(key=FFlhXH(VVMy7P))
   bg = "#0a202020"
   header  = ("IP-Address" , "MAC-Address" )
   widths  = (50   , 50   )
   VV4Uoc = (LEFT   , LEFT   )
   FFCXsL(self, None, title=title, header=header, VVXpNQ=lst, VV4Uoc=VV4Uoc, VV8boH=widths, width=1000, height=700, VVPYL1=30
     , VVfWsQ=bg, VVB5I5=bg, VVYCun=bg, VVmErq="#0a225555", VVgSJJ="#11403040")
  else:
   FFbBGq(self, "Network scanning failed !", title=title)
 @FFJRPn("Scanning")
 def VVYNls(self, ip=None):
  if not ip: return
  dct = {20: "FTP Data Transfer", 21: "FTP Control", 22: "SSH", 23: "Telnet", 25: "SMTP (eMail)", 80: "HTTP", 443: "HTTPS"}
  txt  = "IP:\n   %s\n\n" % ip
  txt += "Ping Result:\n   %s\n\n" % ("OK" if CC9qM0.VVR838(ip) else "Failed")
  txt += "Available Ports:\n"
  ports = ""
  for port, subj in dct.items():
   ok = CC9qM0.VVKWMp(ip, port, timeout=0.5)
   if ok:
    ports += "   %d : %s\n" % (port, subj)
  FFSMJz(self, txt + (ports or "   None"), title="Scanned ports : %s" % str(list(dct)).strip("[]"))
 def VVSn4V(self):
  tLst = []
  if FFKbVo(self.netEntryFile):
   txt = FFmx8y(self.netEntryFile)
   data = iFindall(r"host\s*=(.+),\s*user\s*=(.+),\s*pass\s*=(.*),\s*path\s*=(.*),\s*rem\s*=(.*)", txt, IGNORECASE)
   for ip, u, p, path, rem in data:
    ip, u, p, path, rem = ip.strip(), u.strip(), p.strip(), path.strip() or "/", rem.strip()
    tLst.append((ip, u, p, path, rem))
  def VVMy7P(p1, p2): return FFZoJv(p1[0], p2[0])
  tLst.sort(key=FFlhXH(VVMy7P))
  lst = []
  for num1, item in enumerate(tLst, start=1):
   ip, u, p, path, rem = item
   lst.append((str(num1), ip, u, p, path, rem))
  return lst
 def VVmLOq(self, mainTableInst, canCencel, VVAIxO, title, txt, colList):
  ip, mac, typ = VVAIxO.VVBWxt(VVAIxO.VVoxea())
  if "Own" in ip:
   FFoTZI(VVAIxO, "Cannot add your device", 1500)
  else:
   gw = "Gateway"
   if gw in ip : ip, u, p, path, rem = ip.split()[0].strip(), "admin", "123456", "/", gw
   else  : ip, u, p, path, rem = ip, "root", "dreambox", "/", "No-name"
   for entry in self.VVSn4V():
    num1, ip1, u1, p1, path1, rem1 = entry
    if (ip, u, p, path, rem) == (ip1, u1, p1, path1, rem1):
     break
   else:
    if FFKbVo(self.netEntryFile):
     FF03ch(self.netEntryFile)
    with open(self.netEntryFile, "a") as f:
     f.write(self.VV3Ssl(ip, u, p, path, rem))
   if mainTableInst: self.VVwKpf(mainTableInst, [ip, u, p, path, rem])
   else   : self.VV85qp(canCencel)
   VVAIxO.cancel()
 def VV3Ssl(self, ip, u, p, path, rem):
  return "host=%s,user=%s,pass=%s,path=%s,rem=%s\n" % (ip, u, p, path, rem)
 @FFJRPn("Deleting ...", par=1)
 def VV9kv3(self, VVAIxO):
  num, ip, u, p, path, rem = VVAIxO.VVBWxt(VVAIxO.VVoxea())
  lst = self.VVSn4V()
  tot = 0
  with open(self.netEntryFile, "w") as f:
   for item in lst:
    num1, ip1, u1, p1, path1, rem1 = item
    if not (ip1, u1, p1, path1, rem1) == (ip, u, p, path, rem):
     f.write(self.VV3Ssl(ip1, u1, p1, path1, rem1))
     tot += 1
  if tot:
   self.VVwKpf(VVAIxO)
  else:
   VVAIxO.cancel()
 def VVVkrM(self, col, VVAIxO):
  num, ip, u, p, path, rem = VVAIxO.VVBWxt(VVAIxO.VVoxea())
  if   col == "u": orig, subj = u  , "User"
  elif col == "p": orig, subj = p  , "Password"
  elif col == "r": orig, subj = rem, "Remarks"
  FFANcN(self, BF(self.VV7Pmr, col, orig, VVAIxO, num, ip, u, p, path, rem), defaultText=orig, title="Change %s" % subj, message="Enter %s:" % subj)
 def VV7Pmr(self, col, orig, VVAIxO, num, ip, u, p, path, rem, newTxt):
  if not newTxt == None:
   newTxt = newTxt.strip()
   if orig == newTxt:
    FFoTZI(VVAIxO, "No change", 1500)
   elif not newTxt and col == "u":
    FFoTZI(VVAIxO, "No user !", 2000)
   else:
    self.VVj5n9(col, newTxt, ip, u, p, path, rem)
    self.VVwKpf(VVAIxO)
 def VVj5n9(self, col, newTxt, ip, u, p, path, rem):
  lst = self.VVSn4V()
  oldItem = (ip, u, p, path, rem)
  with open(self.netEntryFile, "w") as f:
   for item in lst:
    num1, ip1, u1, p1, path1, rem1 = item
    if (ip1, u1, p1, path1, rem1) == oldItem:
     if   col == "u": u1  = newTxt
     elif col == "p": p1  = newTxt
     elif col == "d": path1 = newTxt
     elif col == "r": rem1 = newTxt
    f.write(self.VV3Ssl(ip1, u1, p1, path1, rem1))
 def VVwKpf(self, VVAIxO, newEntry=None):
  VVuGUx = self.VVSn4V()
  if VVuGUx : VVAIxO.VVEEBV(VVuGUx, VVyoYa=BF(self.VVyfpM, newEntry))
  else  : VVAIxO.cancel()
 def VVyfpM(self, newEntry, VVAIxO, title, txt, colList):
  if newEntry:
   for ndx, row in enumerate(VVAIxO.VVGpBN()):
    if row[1:] == newEntry:
     VVAIxO.VVt5t9(ndx)
 def VV8YGN(self, canCencel, VVAIxO=None):
  if VVAIxO: VVAIxO.cancel()
  if canCencel : self.close()
class CC9qM0():
 VVTnee = 21
 VVn7lL = 23
 def __init__(self):
  self.VVxcBO()
 def VVxcBO(self):
  self.ftp  = None
  self.ftpIp  = ""
  self.ftpUser = ""
  self.ftpPass = ""
  self.ftpSys  = ""
 def VVpnCZ(self, ip, User, Pass, timeout=5):
  myIp = CC9qM0.VV5rLa()
  if ip != myIp:
   if CC9qM0.VVKWMp(ip, CC9qM0.VVTnee):
    self.VVxcBO()
    err = ""
    try:
     from ftplib import FTP
     self.ftp  = FTP(ip, user=User, passwd=Pass, timeout=timeout)
     self.ftp.set_pasv(False)
     self.ftpIp  = ip
     self.ftpUser = User
     self.ftpPass = Pass
    except Exception as e:
     err = str(e)
   else:
    err = "Connection timed out !\n\n%s" % ip
  else:
   err = "Cannot FTP to your Device-IP:\n\n%s" % ip
  return err
 def VVq1Di(self):
  try: return self.ftp.sendcmd("SYST")
  except: return ""
 def VVhJxU(self):
  try: return self.ftp.sendcmd("NOOP")
  except: return ""
 def VVKujw(self, timeout=3):
  t1 = iTime()
  while True:
   state = self.VVhJxU()
   if not state or state == "200 OK" or iTime() - t1 >= timeout:
    break
 def VVMp1D(self):
  try: return self.ftp.sendcmd("STAT")
  except: return ""
 def VVUe4q(self, Dir, isLong=False):
  files, err = [], ""
  if self.ftp and self.VV3XVJ(Dir):
   try:
    if isLong: self.ftp.dir(files.append)
    else  : self.ftp.nlst()
   except Exception as e:
    err = str(e)
  else:
   err = "No FTP Connection !"
  return files, err
 def VVamW7(self):
  try: return self.ftp.pwd()
  except: return ""
 def VVB5aL(self, path):
  try:
   size = self.ftp.sendcmd("SIZE %s" % path)
   return "f"
  except:
   VVpGvX = self.VVamW7()
   if self.VV3XVJ(path) : typ = "d"
   else      : typ = "b"
   self.VV3XVJ(VVpGvX)
   return typ
 def VVgPyK(self, path):
  try: return self.ftp.size(path)
  except: return -1
 def VV3XVJ(self, path):
  try:
   self.ftp.cwd(path)
   return True
  except:
   return False
 def VVRAQg(self, path):
  try:
   self.ftp.mkd(path)
   return True
  except:
   return False
 def VVCwGP(self, path, flag):
  try:
   if flag == "d" : self.ftp.rmd(path)
   else   : self.ftp.delete(path)
   return True
  except:
   return False
 def VVIEVt(self, fromN, toN):
  try:
   self.ftp.rename(fromN, toN)
   return True
  except:
   return False
 def VV9prX(self, remFile, locFile="", maxSz=10000000):
  sz = self.VVgPyK(remFile)
  if   sz == -1 : return "", sz, "Cannot read file size."
  elif sz > maxSz : return "", sz, "File too big."
  else   : err= ""
  locFile = locFile or "/tmp/%s" % os.path.basename(remFile)
  try:
   self.ftp.retrbinary("RETR %s" % remFile, open(locFile, "wb").write)
   if FFKbVo(locFile) : return locFile, sz, ""
   else     : return "", sz, "Download Failed."
  except Exception as e:
   FFnE7j(locFile)
   return "", sz, str(e)
 def VV9avV(self):
  if self.ftp:
   try: self.ftp.quit()
   except: pass
  self.VVxcBO()
 @staticmethod
 def VV4tZg():
  from uuid import getnode
  return ':'.join(iFindall('..', '%012x' % getnode())).upper()
 @staticmethod
 def VV5rLa():
  from socket import socket, setdefaulttimeout, AF_INET, SOCK_DGRAM
  try:
   setdefaulttimeout(1)
   s = socket(AF_INET, SOCK_DGRAM)
   s.connect(("1.1.1.1", 80))
   ip = s.getsockname()[0]
   s.close()
   return ip
  except:
   return ""
 @staticmethod
 def VV1eB0():
  myIp = CC9qM0.VV5rLa()
  if myIp.count(".") == 3:
   parts = myIp.split('.')
   return ".".join(parts[:3]) + "."
  return ""
 @staticmethod
 def VVB6Yi():
  span = iSearch(r"((?:\d+.){3}\.\d+)", FF2ndj("ip route | grep default"), IGNORECASE)
  return span.group(1) if span else ""
 @staticmethod
 def VVCEmb(port=-1):
  lst = []
  def VVxN3u(ip):
   if port > -1: ok = CC9qM0.VVKWMp(ip, port)
   else  : ok = CC9qM0.VVR838(ip)
   if ok:
    lst.append(ip)
  try:
   baseIp = CC9qM0.VV1eB0()
   thLst  = []
   for num in range(1, 255):
    ip = "%s%d" % (baseIp, num)
    th = iThread(name="ajp_scanIp%d" % num, target=BF(VVxN3u, ip))
    th.start()
    thLst.append(th)
   for th in thLst: th.join()
   return lst, ""
  except Exception as e:
   err = str(e)
   return [], err + '\n\nMax Threads = %d\nCheck your system "Max User Processes" with "ulimit -u"' % len(thLst) if "can't start new thread" in err else ""
 @staticmethod
 def VVvspF(port):
  myIp = CC9qM0.VV5rLa()
  myGw = CC9qM0.VVB6Yi()
  tDict = { myIp: CC9qM0.VV4tZg() }
  devLst, err = CC9qM0.VVCEmb(port)
  if err:
   return [], err
  else:
   for ip in devLst:
    span = iSearch(r"((?:\d+.){3}\.\d+).+\s+((?:[a-f\d]{2}:){5}[a-f\d]{2})", FF4aqG("arp -n %s" % ip), IGNORECASE)
    if span    : tDict[ip] = span.group(2).upper()
    elif not ip == myIp : tDict[ip] = ""
   lst = []
   for key, val in tDict.items():
    if   key == myIp: txt = " %s Own" % VVk4x7
    elif key == myGw: txt = " %s Gateway" % VVk4x7
    else   : txt = ""
    lst.append((key + txt, val))
   return lst, ""
 @staticmethod
 def VVR838(ip):
  return FFlonU("ping -W1 -q -c1 %s" % ip)
 @staticmethod
 def VVKWMp(host, port, timeout=1.0):
  from socket import socket, setdefaulttimeout, AF_INET, SOCK_STREAM
  setdefaulttimeout(timeout)
  try:
   socket(AF_INET, SOCK_STREAM).connect((host, port))
   return True
  except:
   return False
 @staticmethod
 def VVQ0uB(ip="1.1.1.1", timeout=1):
  if CC9qM0.VVKWMp(ip, 53, timeout):
   return True
  if CC9qM0.VVR838(ip):
   return True
  return FFlonU("wget -q -T %d -t 1 --spider %s" % (timeout, ip))
 @staticmethod
 def VVHnlI(SELF, okFnc, title):
  baseIp = CC9qM0.VV1eB0()
  lst = []
  for num in range(1, 255):
   item = "%s%d" % (baseIp, num)
   lst.append((item, item))
  FFO9kU(SELF, okFnc, VV9cxb=lst, width=600, title=title, VVfWsQ="#222222", VVB5I5="#222222")
class CCEcn7(Screen, CC9qM0):
 def __init__(self, session, entry):
  self.skin, self.VVmNvK = FFQaOH(VVNkG2, 1400, 920, 40, 50, 30, "#11333344", "#08303030", 30, VVSwLg=40, VVcmdl=2)
  self.session  = session
  self.ftpEntry  = entry
  self.VVPYL1  = self.VVmNvK["VVYvMU"]
  self.VVCW3G  = self.VVmNvK["bodyLineH"]
  self.VV2InR  = self.VVmNvK["width"]
  self.VVpGvX   = "/"
  self.list   = []
  self.png_fil  = CC00KO.VVjXJx("fil")
  self.png_dir  = CC00KO.VVjXJx("dir")
  self.png_dirup  = CC00KO.VVjXJx("dirup")
  self.png_slwfil  = CC00KO.VVjXJx("slwfil")
  self.png_slbfil  = CC00KO.VVjXJx("slbfil")
  self.png_slwdir  = CC00KO.VVjXJx("slwdir")
  self.serverOrigData = None
  self.Title   = "FTP (%s)" % entry[0]
  CC9qM0.__init__(self)
  VV9cxb = [("Item-%d" % x,) for x in range(50)]
  FFNhKZ(self, title=self.Title, VV9cxb=VV9cxb)
  FFi79B(self["keyRed"] , "Exit")
  self["myMenu"] = MenuList(VV9cxb, True, eListboxPythonMultiContent)
  self["myMenu"].l.setFont(0, gFont(VV3IRX, self.VVPYL1))
  self["myMenu"].l.setItemHeight(self.VVCW3G)
  FFrM8n(self,
  {
   "red" : BF(self.VV3iIJ, True) ,
   "ok" : self.VVyuDa    ,
   "cancel": self.VV3iIJ    ,
   "menu" : self.VVKJj3   ,
   "info" : self.VVZl2x  ,
   "pageUp": self.VVji1l    ,
   "chanUp": self.VVji1l
  })
  self.onShown.append(self.VVf1Ra)
  self.onClose.append(self.onExit)
  self["myMenu"].onSelectionChanged.append(self.VVrI3T)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  FFvJ8o(self["myMenu"])
  FFNUiO(self)
  FFuwGk(self)
  FFeo1z(self)
  FFgLA9(self["keyBlue"], "#11333333")
  self.VVEbDw()
 @FFJRPn("Connecting ...")
 def VVEbDw(self):
  ip, u, p, path, rem = self.ftpEntry
  err = self.VVpnCZ(ip, u, p)
  if err:
   FFbBGq(self, err, title=self.Title)
   FFi79B(self["keyBlue"] , "")
   self.close()
  elif self.ftp:
   FFi79B(self["keyBlue"], self.ftpIp)
   if not self.VV3XVJ(path):
    path = "/"
   self.VVG4sx(path)
   self.serverOrigData = (ip, u, p, path, rem)
 def onExit(self):
  self["myMenu"].onSelectionChanged = []
  if self.VVhJxU():
   self.VV9avV()
 def VVyuDa(self):
  if self.VV8STX():
   sel = self["myMenu"].l.getCurrentSelection()
   if sel:
    name, target, targetState, flag, sortSeq = sel[0]
    if   flag == "d" or targetState == "d" : self.VVG4sx(os.path.join(self.VVpGvX, name))
    elif flag == "x"      : self.VVji1l()
    else         : self.VVnVqT(os.path.join(self.VVpGvX, name))
 def VV3iIJ(self, force=False):
  if force or CFG.FileManagerExit.getValue() == "e": self.close(self.VVpGvX)
  else            : self.VVji1l()
 def VV8STX(self):
  if self.VVhJxU():
   return True
  else:
   FFbBGq(self, "FTP Server is now diconnected !", title=self.Title)
   return False
 def VVnVqT(self, path):
  cat = CC00KO.VVuedz(path)
  if cat in ("pic"):
   self.VVT1PJ(path)
  elif cat in ("mov", "mus"):
   if CCTe4w.VV9RvZ("5002"):
    url = "ftp%%3a//%s%%3a%s@%s%s" % (self.ftpUser, self.ftpPass, self.ftpIp, path)
    rType = "5002"
   else:
    rType = CFG.iptvAddToBouquetRefType.getValue()
    url = "http%%3a//%s/file?file=%s" % (self.ftpIp, path)
   FF7iMz(self, BF(CC17eA.VVGtUI, self, url, rType=rType), title="Playing Media ...")
 @FFJRPn()
 def VVT1PJ(self, path):
  locFile, size, err = self.VV9prX(path)
  if err: FFbBGq(self, err, title="View Picture File")
  else  : CCZQAz.VVRX4k(self, locFile, fakePath="ftp:/%s" % path, cbFnc=BF(FFnE7j))
 def VVrI3T(self):
  sel = self["myMenu"].l.getCurrentSelection()
  if sel: title = "  %s  " % os.path.join(self.VVpGvX, "" if sel[0][0] == CC00KO.VVDRmr else sel[0][0])
  else  : title=  VVPI2q + "  No Files Found !"
  self["myTitle"].setText(title)
 def VVji1l(self):
  if self.VV8STX():
   lastPart = FFiZj6(self.VVpGvX)
   parentDir = os.path.abspath(os.path.join(self.VVpGvX, os.pardir))
   self.VVG4sx(parentDir, lastPart, "d")
 @FFJRPn()
 def VVG4sx(self, Dir, moveTo="", moveToType=""):
  files, err = self.VVUe4q(Dir, isLong=True)
  self.VVpGvX = self.VVamW7() or "/"
  self.VVPBFV(files)
  if moveTo:
   for ndx, item in enumerate(self.list):
    name, target, targetState, flag, sortSeq = item[0]
    if moveTo == name:
     if not moveToType or moveToType == flag:
      self["myMenu"].moveToIndex(ndx)
      break
  else:
   self["myMenu"].moveToIndex(0)
 def VVPBFV(self, files):
  self.list = []
  if self.VVpGvX != "/":
   self.list.append(self.VVbh5t(CC00KO.VVDRmr, CC00KO.VVDRmr, "", "", "x"))
  for item in files:
   linkTo = ""
   isDir = isFile = isLink = False
   item = item.strip()
   if   item.startswith("l")     : flag = "l"
   elif item.startswith("d") or "<DIR>" in item: flag = "d"
   else          : flag = "f"
   gaps = 3 if item[:1].isdigit() else 8
   name = item.split(None, gaps)[gaps]
   linkSep = " -> "
   origName = name
   target = targetState = ""
   if linkSep in name:
    flag = "l"
    name, _, target = name.partition(linkSep)
    if not target.startswith("/"):
     target = "/" + target
    targetState = self.VVB5aL(target)
    color = VVPI2q if targetState == "b" else VVOQkl
    origName = name + VVjojy + linkSep + color + " "+ target
   self.list.append(self.VVbh5t(origName, name, target, targetState, flag))
  self.list.sort(key=lambda x: (x[0][4], x[0][0]))
  self["myMenu"].l.setList(self.list)
 def VVbh5t(self, origName, name, target, targetState, flag):
  if flag == "f":
   png = self.png_fil
   ext = os.path.splitext(name)[1]
   if ext:
    cat = CC00KO.VVuedz(name)
    if cat: png = LoadPixmap("%s%s.png" % (VVK8DT, cat))
  elif flag == "d": png = self.png_dir
  elif flag == "l":
   if   targetState == "f" : png = self.png_slwfil
   elif targetState == "d" : png = self.png_slwdir
   elif targetState == "b" : png = self.png_slbfil
   else      : png = self.png_slwfil
  elif flag == "x": png = self.png_dirup
  else   : png = self.png_fil
  if   origName == CC00KO.VVDRmr: sortSeq = 0
  elif flag == "d" or targetState == "d"  : sortSeq = 1
  else          : sortSeq = 2
  tableRow = [ (name, target, targetState, flag, sortSeq) ]
  tableRow.append((eListboxPythonMultiContent.TYPE_TEXT, self.VVCW3G + 10, 0, self.VV2InR, self.VVCW3G, 0, LEFT | RT_VALIGN_CENTER, origName))
  tableRow.append(CC4ngo.VVvFdD(0, 2, self.VVCW3G-4, self.VVCW3G-4, png))
  return tableRow
 def VVKJj3(self):
  sel = self["myMenu"].l.getCurrentSelection()
  if sel : name, target, targetState, flag, sortSeq = sel[0]
  else : name = target = targetState = flag = ""
  isTop  = name == CC00KO.VVDRmr
  isDir  = flag == "d" or targetState == "d"
  isFile = flag == "f" or targetState == "f"
  def VV9At5(titl, ref, chk, color=""):
   if chk: return VV9cxb.append((color + titl, ref))
   else  : return VV9cxb.append((titl, ))
  VV9cxb = []
  VV9At5("Properties", "VVZl2x", not isTop)
  c = VVk4x7
  VV9cxb.append(VVbM5H)
  VV9At5("Download Selected File ..."    , "VV7bSr", isFile, c)
  VV9At5("Upload a Local File to Remote Server ...", "VVDYgT" , True  , c)
  VV9cxb.append(VVbM5H)
  VV9At5("Create new directory", "VVWIyU", True)
  VV9At5("Rename", "VVdMpA", not isTop)
  VV9At5("DELETE", "VVtnse", not isTop, VVdLWL)
  VV9cxb.append(VVbM5H)
  VV9At5("FTP Server Information", "VVh6wX", True)
  VV9cxb.append(VVbM5H)
  VV9At5("Refresh File List", "refresh", True)
  FFO9kU(self, self.VV7NrL, VV9cxb=VV9cxb, title="Options")
 def VV7NrL(self, item=None):
  if item:
   if   item == "VVZl2x"     : self.VVZl2x()
   elif item == "VV7bSr"   : self.VV7bSr()
   elif item == "VVDYgT"   : self.VVDYgT()
   elif item == "VVWIyU"   : self.VVWIyU()
   elif item == "VVdMpA"   : self.VVdMpA()
   elif item == "VVtnse"   : self.VVtnse()
   elif item == "VVh6wX"    : self.VVh6wX()
   elif item == "refresh" and self.VV8STX(): self.VVG4sx(self.VVpGvX)
 def VVZl2x(self):
  if self.VV8STX():
   sel = self["myMenu"].l.getCurrentSelection()
   if sel:
    name, target, targetState, flag, sortSeq = sel[0]
    path = os.path.join(self.VVpGvX, name)
    txt = "%s:\n%s\n\n" % (FFKrMM("Path", VVk4x7), path)
    typ = {"d": "Directory", "f": "File", "l": "SymLink", "x": ""}.get(flag, "")
    if typ: txt += "Type\t: %s%s\n" % (typ, " (Broken)" if targetState == "b" else "")
    if target: txt += "Target\t: %s\n" % target
    sz = self.VVgPyK(path)
    if sz > -1: txt += "Size\t: %s" % CC17eA.VVxNgx(sz)
   else:
    txt = "Nothing selected"
   FFSMJz(self, txt, title="Properties")
 def VVh6wX(self):
  if self.VV8STX():
   Sys  = self.VVq1Di() or " -"
   txt = "%s\n  %s\n\n" % (FFKrMM("System:", VVk4x7), Sys[4:] if Sys.startswith("215 ") else Sys)
   Stat = self.VVMp1D() or " -"
   txt += "%s\n" % (FFKrMM("Status:", VVk4x7))
   for line in Stat.splitlines():
    txt += "  %s\n" % (line[4:] if line.startswith("211-") or line.startswith("211 ") else line)
   FFSMJz(self, txt, title="FTP Server Information")
 def VVWIyU(self, name=""):
  if self.VV8STX():
   title = "Add New Directory"
   FFANcN(self, BF(self.VVdwFR, title), defaultText=name, title=title, message="Enter Directory name")
 def VVdwFR(self, title, name):
  if name and name.strip():
   if self.VVRAQg(name) : self.VVG4sx(self.VVpGvX, name, "d")
   else     : FFbBGq(self, "Failed to create : %s" % name, title)
 def VVdMpA(self):
  if self.VV8STX():
   sel = self["myMenu"].l.getCurrentSelection()
   if sel:
    title = "Rename"
    name, target, targetState, flag, sortSeq = sel[0]
    FFANcN(self, BF(self.VVblq0, title, name, flag), defaultText=name, title=title, message="Enter new name")
 def VVblq0(self, title, name, flag, newName):
  if newName and newName.strip():
   if self.VVIEVt(name, newName.strip()) : self.VVG4sx(self.VVpGvX, newName, flag)
   else          : FFbBGq(self, "Failed to rename to : %s" % newName, title)
 def VVtnse(self):
  if self.VV8STX():
   sel = self["myMenu"].l.getCurrentSelection()
   if sel:
    name, target, targetState, flag, sortSeq = sel[0]
    FF6pUe(self, BF(self.VVit8F, name, flag), "Delete ?\n\n%s" % name, title="Delete")
 @FFJRPn("Deleting ...")
 def VVit8F(self, name, flag):
  if self.VVCwGP(name, flag) : self.VVG4sx(self.VVpGvX)
  else         : FFbBGq(self, "Failed to delete:\n\n%s" % name, "Delete")
 def VV7bSr(self):
  if self.VV8STX():
   sel = self["myMenu"].l.getCurrentSelection()
   if sel:
    title = "Download File"
    name, target, targetState, flag, sortSeq = sel[0]
    remFile = os.path.join(self.VVpGvX, name)
    size = self.VVgPyK(remFile)
    if size == -1:
     FFbBGq(self, "Cannot get file size for:\n\n%s" % remFile, title=title)
    else:
     Dir = CFG.lastFtpLocalPath.getValue() if VVkY7E(CFG.lastFtpLocalPath.getValue()) else FFJv8S()
     self.session.openWithCallback(BF(self.VVxTdo, title, remFile, name, size), BF(CC17eA, mode=CC17eA.VVAcq8, VVhKiJ="Download here", VVqNQm=Dir, width=1200, height=840, pickTitleBG="#11002222", pickBodyBG="#11003333", VVfINZ="#11005566"))
 def VVxTdo(self, title, remFile, name, size, locPath):
  if locPath:
   FFBWtx(CFG.lastFtpLocalPath, locPath)
   locFile = os.path.join(locPath, name)
   CCV3Gw.VVgWD3(self, VVN6I4="Downloading ...", titleBg="#22220022", bodyBg="#22220022"
       , VVuSHu  = BF(self.VV99Wl, remFile, size, locFile)
       , VVhK3C = BF(self.VVi197, remFile, size, locFile))
 def VV99Wl(self, remFile, size, locFile, VVqeT6):
  VVqeT6.VVfT17(size)
  VVqeT6.VVL8uX = ""
  with open(locFile, "wb") as locFileObj:
   try:
    def VV4J0S(data):
     if not VVqeT6 or VVqeT6.isCancelled:
      return
     locFileObj.write(data)
     VVqeT6.VVqE9L(len(data))
    self.ftp.retrbinary("RETR %s" % remFile, VV4J0S)
   except Exception as e:
    VVqeT6.VVL8uX = str(e)
 def VVi197(self, remFile, size, locFile, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  title = "File Download"
  delF = False
  if VVL8uX:
   FFbBGq(self, "%s\n\nftp:/%s" % (VVL8uX, remFile), title="Download Error")
   delF = True
  elif not VV6ZvL:
   FFbBGq(self, "Download cancelled for:\n\nftp:/%s" % remFile, title=title)
   delF = True
  else:
   if size == FFLjtI(locFile):
    txt = "Successfully downloaded to:\n\n%s" % locFile
    FF0onH(self, txt, title=title)
   else:
    FFbBGq(self, "Incorrect downloaded file size for:\n\nftp:/%s" % remFile, title=title)
    delF = True
  if delF:
   FFnE7j(locFile)
 def VVDYgT(self):
  if self.VV8STX():
   Dir = CFG.lastFtpLocalPath.getValue() if VVkY7E(CFG.lastFtpLocalPath.getValue()) else FFJv8S()
   self.session.openWithCallback(self.VV1eRh, BF(CC17eA, VVhKiJ="Upload selected file", VVqNQm=Dir, VV8JM3="all", width=1200, height=850, pickTitleBG="#11001122", pickBodyBG="#11330033", VVfINZ="#11662200"))
 def VV1eRh(self, locFile):
  if locFile:
   title = "Upload File to Remote Server"
   FFBWtx(CFG.lastFtpLocalPath, os.path.dirname(locFile))
   size = FFLjtI(locFile)
   if size == -1:
    FFbBGq(self, "Cannot get file size for:\n\n%s" % locFile, title=title)
   else:
    remFile = os.path.join(self.VVpGvX, os.path.basename(locFile))
    CCV3Gw.VVgWD3(self, VVN6I4="Uploading ...", titleBg="#22220022", bodyBg="#22220022"
        , VVuSHu  = BF(self.VV9FyU, locFile, size, remFile)
        , VVhK3C = BF(self.VVi0px, locFile, size, remFile))
 def VV9FyU(self, locFile, size, remFile, VVqeT6):
  VVqeT6.VVfT17(size)
  VVqeT6.VVL8uX = ""
  with open(locFile, "rb") as locFileObj:
   try:
    def VVy1Ty(data):
     if not VVqeT6 or VVqeT6.isCancelled:
      VVqeT6.VVL8uX = "Upload cancelled"
      locFileObj.close()
      return
     VVqeT6.VVqE9L(len(data))
    self.ftp.storbinary("STOR %s" % remFile, locFileObj, callback=VVy1Ty)
   except Exception as e:
    VVqeT6.VVL8uX = VVqeT6.VVL8uX or str(e)
 def VVi0px(self, locFile, size, remFile, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  title = "File Upload"
  err = ""
  if VV6ZvL:
   if size == FFLjtI(locFile) : FF0onH(self, "Successfully uploaded to:\n\n%s" % remFile, title=title)
   else       : err = "Incorrect uploaded file size for:\n\nftp:/%s" % remFile
  elif VVL8uX : err = "%s\n\n%s" % (VVL8uX, locFile)
  else    : err = "Incomplete file transfer:\n\n%s" % locFile
  if err:
   FFbBGq(self, err, title=title)
   self.VVKujw()
   self.VVCwGP(remFile, "")
  self.VVG4sx(self.VVpGvX)
class CCM6jS():
 VVNZ5c  = "all"
 VVh5O6 = "vid"
 VV4OJI  = "osd"
 VVxUex = "dreamboxctl"
 VVKFzf  = "grab"
 @staticmethod
 def VVzUSZ(session, k, dm):
  if CCM6jS.VVFFtV(session) or CFG.screenshotFType.getValue() == "off":
   return
  title = "%s Screenshot" % PLUGIN_NAME
  err = ""
  if   not FFW91j(CCM6jS.VVKFzf)   : err = "g"
  elif dm and not FFW91j(CCM6jS.VVxUex): err = "gd"
  if err:
   FFvOl9(session, "Missing %s-command !" % err, title=title)
   return
  winShown = session.current_dialog.shown
  if k == CCM6jS.VVh5O6 and winShown: session.current_dialog.hide()
  FFvfpL(BF(CCM6jS.VVz9l6, title, session, k, winShown, dm))
 @staticmethod
 def VVz9l6(title, session, k, winShown, dm):
  fTitle = skinName = ""
  x = y = w = h = 0
  if k == CCM6jS.VV4OJI:
   if not winShown:
    FFvOl9(session, "No Window to capture !", title=title)
    return
   if not CCM6jS.VVWpl0(session, title, True):
    return
   valid, origTitle, clnTitle, skinName, x, y, w, h = CCM6jS.VVo22q(session)
   fTitle = "%s_(%s)" % (clnTitle, skinName)
   if not valid:
    FFvOl9(session, "Cannot get Window Dimensions !", title=title)
    return
  if not fTitle:
   s = CCZv30(session)
   fTitle = FFgYic(s.VVUwmk.strip(), "-") or s.VVF8zm.replace(":", "_")
  ext = CFG.screenshotFType.getValue()
  path = "%sscreenshot_%s_%s.%s" % (FFrCUc(), fTitle, FFRIlf(), ext)
  fnc = BF(CCM6jS.VVYCs6, path, title, session, k, winShown, x, y, w, h)
  if dm:
   CCDRFn().VV70Ea("%s screenshot -f '%s'" % (CCM6jS.VVxUex, path), fnc)
  else:
   FFZZgw("%s -q -s %s > '%s'" % (CCM6jS.VVKFzf, {"jpg":"-j 100", "png":"-p"}.get(ext, ""), path))
   fnc()
 @staticmethod
 def VVYCs6(path, title, session, k, winShown, x, y, w, h, *args):
  if k == CCM6jS.VVh5O6 and winShown:
   session.current_dialog.show()
  elif k == CCM6jS.VV4OJI:
   ok = CCM6jS.VVriDd(path, x, y, w, h)
   if not ok:
    FFnE7j(path)
    FFvOl9(session, "Error while cropping image file !", title=title)
    return
  if FFKbVo(path) : session.open(CCZQAz, VVezFg=path, title=path, menuFnc=CCM6jS.VV1zPT)
  else    : FFvOl9(session, "Error while capturing screen !", title=title)
 @staticmethod
 def VV1zPT(pvObj):
  def VVDZ7f():
   FFnE7j(pvObj.VVezFg)
   pvObj.close()
  FF6pUe(pvObj, VVDZ7f, "Delete Screenshot File ?\n\n%s" % pvObj.VVezFg, title="Screen Shot")
 @staticmethod
 def VVWpl0(SELF, title, VVYqW3, install=True, cbFnc=None):
  try:
   from PIL import Image
   return True
  except:
   if install:
    FF6pUe(SELF, BF(CCM6jS.VVpvdu, SELF, VVYqW3, cbFnc=cbFnc), "Imaging Library is required.\n\nInstall ?", title=title, VVYqW3=VVYqW3)
   return False
 @staticmethod
 def VVpvdu(SELF, VVYqW3, cbFnc=None):
  if pyVersion[0] >= 3: name = "python3-pillow"
  else    : name = "python-imaging"
  if VVYqW3: fnc = BF(FFbZB6, VVu7vM=cbFnc)
  else    : fnc = BF(FF6NKJ , VVu7vM=cbFnc)
  fnc(SELF, FF4zTV(VVw2da, name), VVAH4n=True, title="Installing Imaging Library")
 @staticmethod
 def VVo22q(session):
  valid = False
  origTitle = clnTitle = skinName = ""
  x = y = w = h = 0
  obj = session.current_dialog
  if obj:
   skinName = obj.skinName
   if isinstance(skinName, list) : skinName = "-".join(skinName)
   else       : skinName = str(skinName)
   inst = obj.instance
   if inst:
    origTitle = inst.getTitle()
    pos, size = inst.position(), inst.size()
    x, y, w, h = pos.x(), pos.y(), size.width(), size.height()
    valid = w != 0 and h !=0
    clnTitle = FFgYic(origTitle.strip(), r"-")
    clnTitle = FFhTcV(clnTitle, "-")
  return valid, origTitle, clnTitle, skinName, x, y, w, h
 @staticmethod
 def VVFFtV(session):
  valid, origTitle, clnTitle, skinName, x, y, w, h = CCM6jS.VVo22q(session)
  return skinName.lower() in ("hotkeysetup", "buttonsetup", "spaQButton")
 @staticmethod
 def VVriDd(path, x, y, w, h, scaleToScreen=True):
  try:
   from PIL import Image
   im = Image.open(path)
   x1 = w + x
   y1 = h + y
   if scaleToScreen:
    scrW, scrH = FFcBkL()
    w, h = im.size
    if w != scrW or h != scrH:
     x  = FFel7I(x , 0, scrW, 0, w)
     y  = FFel7I(y , 0, scrH, 0, h)
     x1 = FFel7I(x1, 0, scrW, 0, w)
     y1 = FFel7I(y1, 0, scrH, 0, h)
   im = im.crop((x, y, x1, y1))
   im.save(path)
   return True
  except:
   return False
 @staticmethod
 def VVQPrD(path):
  size = FFLjtI(path)
  sizeTxt = CC17eA.VVxNgx(size) if size > -1 else ""
  try:
   from PIL import Image
   im = Image.open(path)
   form = im.format
   mode = im.mode
   resTxt = "%d x %d" % im.size
  except:
   resTxt = form = mode = ""
  return size, sizeTxt, resTxt, form, mode
 @staticmethod
 def VVk3nS(path):
  try:
   from PILs import Image
   im = Image.open(path)
   w, h = im.size
   return w, h, ""
  except IOError as e:
   return -1, -1, "Error: %s" % str(e)
  except:
   pass
  res = FF2ndj("ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=X:p=0 '%s' 2> /dev/null" % path)
  if "X" in res:
   w, h = res.split("X")
   if w.isdigit() and h.isdigit():
    w, h, = int(w), int(h)
    if w > 0 and h > 0:
     return w, h, ""
  return -1, -1, res or "Error"
 @staticmethod
 def VVqVLH(path, headers=""):
  tab1 = lambda x, y: "%s\t: %s\n" % (x, y) if y else ""
  tab2 = lambda Dic, nm, k: tab1(nm, FFSlBO(Dic, k))
  mExt, mCat, mTitle = CCM6jS.VVSgyN(path)
  if not mExt:
   return ""
  txt  = "\n" + FFFGRS(("%s Metadata" % mTitle).strip(), VVk4x7 )
  try:
   res = FF4aqG("ffprobe -loglevel 0 %s -of json -show_format -show_streams -show_chapters '%s'" % (headers, path))
   d = jLoads(res)
   d1 = d["format"]
   dur = FFSlBO(d1, "duration")
   if FFXclX(dur):
    dur = "%s\t( %s sec )" % (FFrTEd(float(dur)), dur.rstrip("0").rstrip("."))
   sz = FFSlBO(d1, "size")
   if sz.isdigit():
    sz = "%s\t( %s )" % (sz, CC17eA.VVxNgx(int(sz), mode=4))
   txt += tab1("Duration"  , dur   )
   txt += tab1("File Size"  , sz   )
   txt += tab2(d1, "Bit Rate" , "bit_rate" )
   txt += tab2(d1, "Format" , "format_name" )
   txt += tab2(d1, "Streams" , "nb_streams" )
   txt += tab1("Chapters"  , len(d["chapters"]))
   if "tags" in d1:
    d1 = d1["tags"]
    tm = FFSlBO(d1, "creation_time")
    span = iSearch(r"(.+)T(.+)\.", tm)
    txt += tab2(d1, "Encoder" , "encoder")
    txt += tab1("Created", "  ".join(span.groups()) if span else tm)
   for d1 in d["streams"]:
    ind = FFSlBO(d1, "index"  )
    typ = FFSlBO(d1, "codec_type" )
    frmR= FFSlBO(d1, "r_frame_rate")
    frmR= frmR if frmR != "0/0" else ""
    w = FFSlBO(d1, "width" )
    h = FFSlBO(d1, "height" )
    dim = " x ".join((w, h)) if w and h else ""
    txt += "\n"
    txt += FFKrMM(tab1("Stream - %s" % ind, typ.title()), VVv8b8)
    txt += tab2(d1, "Codec"   , "codec_name"  )
    txt += tab1("Dimensions"  , dim    )
    txt += tab2(d1, "Aspect Ratio" , "display_aspect_ratio")
    txt += tab2(d1, "Pixel Format"  , "pix_fmt"   )
    txt += tab1("Frame Rate"  , frmR    )
    txt += tab2(d1, "Sample Rate" , "sample_rate"  )
    txt += tab2(d1, "Frames"  , "nb_frames"  )
    txt += tab2(d1, "Channels"  , "channels"  )
    txt += tab2(d1, "Ch. Layout"  , "channel_layout" ).title()
    if "tags" in d1:
     txt += tab2(d1["tags"], "Title"  , "title" )
     txt += tab2(d1["tags"], "Language"  , "language").title()
   return txt
  except:
   return ""
 @staticmethod
 def VVfGXZ(path, headers=""):
  lst = []
  try:
   res = FF4aqG("ffprobe -loglevel 0 %s -of json -show_chapters '%s'" % (headers, path))
   for item in jLoads(res)["chapters"]:
    try:
     tm = float(FFSlBO(item, "start_time"))
     if tm > 0:
      tmTxt = FFrTEd(tm)
      pts = int(tm * 90000)
      name = ""
      if "tags" in item:
       name = FFSlBO(item["tags"], "title")
      lst.append(("%s   %s" % (tmTxt, name), pts))
    except:
     pass
  except:
   pass
  return lst
 @staticmethod
 def VVMW8Y(VVadS0, VVUwmk):
  path = headers = ""
  if FFn8GR(VVadS0):
   url = VVadS0.replace(":" + VVUwmk, "")
   if "chCode=" in url:
    if "j.php" in url:
     pass
    else:
     path = iSub(r"[&?]mode=.+end=", r"", url, flags=IGNORECASE)
     p, err = CCr0nV.VVHzpJ(VVadS0)
     head = p.portal_latestResponse["headers"] if p else ""
     auth = "Authorization"
     if head and auth in head:
      headers  = '-headers "%s: %s"' % (auth, head[auth])
      headers += " -headers $'Cookie: mac=%s; stb_lang=en\r\n'" % p.VVfHA5
   else:
    path = url
  return path, headers
 @staticmethod
 def VVSgyN(path):
  ext = os.path.splitext(path)[1]
  mExt = mCat = mName = ""
  for cat, lst in CC00KO.VVgJJJ().items():
   if cat in ("mov", "pic", "mus"):
    if ext in lst:
     mExt, mCat = ext, cat
     break
    else:
     for x in lst:
      if "." + x in path:
       mExt, mCat = x, cat
       break
  return mExt, mCat, {"mov": "Video", "pic": "Picture", "mus": "Audio"}.get(mCat, "")
 @staticmethod
 def VVlTAV():
  try:
   import pickle, zlib
   with open("%sMisc/inf.png" % FFJv8S(), 'rb') as f:
    return pickle.loads(zlib.decompress(f.read().split(bytearray.fromhex("6082"))[1]))
  except:
   return None
 @staticmethod
 def VVy3nL(i):
  try: return FFtcG5(CCM6jS.VVlTAV()[i][1:-1])
  except: return None
class CCYJTf(Screen):
 def __init__(self, session, title, fontsList, defFnt, withRestart):
  self.skin, self.VVmNvK = FFQaOH(VVNkG2, 1400, 1000, 40, 40, 30, "#0a001100", "#10110000", 30, VVSwLg=220)
  self.session  = session
  self.fontsList  = fontsList
  self.defFnt   = defFnt
  txt = FFKrMM(" (Requires GUI Restart)", VVWJEN) if withRestart else ""
  VV9cxb = []
  for path in self.fontsList:
   VV9cxb.append((os.path.splitext(os.path.basename(path))[0], path))
  VV9cxb.sort(key=lambda x: x[0].lower())
  VV9cxb.insert(0, VVbM5H)
  VV9cxb.insert(0, ("Reset to Default%s" % txt, "DEFAULT"))
  VVETIE = 0
  if self.defFnt:
   for ndx, item in enumerate(VV9cxb):
    if len(item) == 2 and item[1] == self.defFnt:
     VV9cxb[ndx] = (VVOQkl + item[0], item[1])
     VVETIE = ndx
     break
  else:
   VV9cxb[VVETIE] = (VVOQkl + VV9cxb[VVETIE][0], VV9cxb[VVETIE][1])
  FFNhKZ(self, VV9cxb=VV9cxb, title=title)
  FFmpyO(self, {"cancel": self.cancel})
  self.onShown.append(self.VVf1Ra)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  FFvJ8o(self["myMenu"])
  FFNUiO(self)
  self["myBar"].setText(self.VVts73())
  self["myBar"].instance.setHAlign(1)
  self["myMenu"].onSelectionChanged.append(self.VVBcX2)
  self.VVBcX2()
 def VVyuDa(self):
  self["myMenu"].onSelectionChanged = []
  self.close(self["myMenu"].l.getCurrentSelection()[1])
 def cancel(self):
  self["myMenu"].onSelectionChanged = []
  self.close("")
 def VVBcX2(self):
  path = self["myMenu"].l.getCurrentSelection()[1]
  if FFKbVo(path):
   fnt = "AJP_Sample"
   FF1GWp(path, fnt, isRepl=1, save=False)
  else:
   fnt = VVT0uN
  try:
   inst = self["myMenu"].instance
   inst.setFont(gFont(fnt, self.VVmNvK["VVYvMU"]))
   inst.invalidate()
  except:
   try:
    l = self["myMenu"].l
    l.setFont(gFont(fnt, self.VVmNvK["VVYvMU"]))
    l.invalidate()
   except:
    pass
  self["myBar"].instance.setFont(gFont(fnt, int(self.VVmNvK["VVYvMU"] * 1.3)))
  self["myBar"].instance.invalidate()
 def VVts73(self):
  txt = ""
  for i in range(65, 91): txt += chr(i)
  txt += "\n"
  for i in range(97, 123): txt += chr(i)
  txt += "  "
  for i in range(48, 58): txt += chr(i)
  txt += "\n"
  txt += u"\u0623\u0628\u062c\u062f \u0647\u0648\u0632 \u062d\u0637\u064a \u0643\u0644\u0645\u0646 \u0633\u0639\u0641\u0635 \u0642\u0631\u0634\u062a \u062b\u062e\u0630 \u0636\u0638\u063a  \u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669"
  return str(txt)
 @staticmethod
 def VVyC0j(SELF, title, defFnt, rest, VVhK3C):
  fntPath = resolveFilename(SCOPE_FONTS)
  fontsList = FFYvtE(fntPath, "*.[tToO][tT][fF]")
  if fontsList: SELF.session.openWithCallback(VVhK3C, CCYJTf, title, fontsList, defFnt, rest)
  else  : FFbBGq(self, "No fonts found in:\n\n%s" % fntPath, title=title)
class CCxQ37(Screen):
 def __init__(self, session, path, VV9cxb, title):
  self.skin, self.VVmNvK = FFQaOH(VVNkG2, 1700, 1000, 40, 40, 30, "#11001122", "#11002233", 30, VVzlf0=50)
  self.session = session
  self.path  = path
  FFNhKZ(self, VV9cxb=VV9cxb, title=title)
  self["myLabelFrm"] = Label()
  self["myLabelTit"] = Label("Result Sample")
  self["myLabelTxt"] = Label()
  FFrM8n(self,
  {
   "ok"  : self.VVyuDa   ,
   "cancel" : self.cancel   ,
   "pageUp" : self.VVRoOB,
   "chanUp" : self.VVRoOB,
   "pageDown" : self.VVzdMl ,
   "chanDown" : self.VVzdMl ,
  })
  self.onShown.append(self.VVf1Ra)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  FFvJ8o(self["myMenu"])
  FFNUiO(self)
  FFgLA9(self["myLabelFrm"], "#11110000")
  FFgLA9(self["myLabelTit"], "#11663322")
  FFgLA9(self["myLabelTxt"], "#11110000")
  self["myMenu"].onSelectionChanged.append(self.VVHew0)
  self.VVHew0()
 def VVHew0(self):
  if FFKbVo(self.path): txt = FFmx8y(self.path, maxSize=1000, encLst=[self["myMenu"].l.getCurrentSelection()[1]])
  else     : txt = "Review error !"
  self["myLabelTxt"].setText(txt.strip())
 def VVyuDa(self):
  self["myMenu"].onSelectionChanged = []
  self.close(self["myMenu"].l.getCurrentSelection()[1])
 def cancel(self):
  self["myMenu"].onSelectionChanged = []
  self.close("")
 def VVRoOB(self) : self["myMenu"].moveToIndex(0)
 def VVzdMl(self) : self["myMenu"].moveToIndex(len(self["myMenu"].list) - 1)
class CC6ntZ():
 @staticmethod
 def VVHZM4():
  return [None, "utf-8"] + ["iso-8859-%d" % i for i in range(1,17)] + ["windows-125%d" % i for i in range(1,9)]
 @staticmethod
 def VVQVNc(SELF):
  import sys, locale
  lst = []
  c1 = "#f#00ffbbff#"
  c2 = "#f#00ffffaa#"
  lst.append(("Language Code"     , locale.getdefaultlocale()[0]  ))
  lst.append(("Default Locale Encoding"  , locale.getdefaultlocale()[1]  ))
  lst.append((c1 + "Preferred Encoding"  , c1 + locale.getpreferredencoding(False)))
  lst.append((c2 + "System Default Encoding" , c2 + sys.getdefaultencoding()  ))
  lst.append((c2 + "Filesystem Encoding"  , c2 + sys.getfilesystemencoding() ))
  c = "#f#11aaffff#"
  for item in locale.setlocale(locale.LC_ALL).split(";"):
   parts = item.split("=")
   if len(parts) == 2:
    lst.append((c + parts[0], c +
    parts[1]))
  FFCXsL(SELF, None, VVXpNQ=lst, VVPYL1=30, VVRtfk=1)
 @staticmethod
 def VVC1NW(path, SELF=None):
  for enc in CC6ntZ.VVHZM4():
   try:
    with ioOpen(path, "r", encoding=enc) as f:
     for line in f:
      pass
    return enc
   except:
    pass
  if SELF:
   FFbBGq(SELF, "Cannot detect file encoding for:\n\n%s" % path)
  return -1
 @staticmethod
 def VVrBqT(path):
  for enc in CC6ntZ.VVHZM4():
   try:
    c = 0
    with ioOpen(path, "r", encoding=enc) as f:
     for line in f:
      c += 1
    return enc, c
   except:
    pass
  return -1, 0
 @staticmethod
 def VVAYqs(path, enc):
  try:
   with ioOpen(path, "r", encoding=enc) as f:
    for line in f:
     pass
   return True
  except:
   return False
 @staticmethod
 def VVuzBx(SELF, path, cbFnc, curEnc=VVgDRh, title="Select Encoding"):
  lst = CC6ntZ.VVP96x(SELF, path, "")
  if lst:
   SELF.session.openWithCallback(cbFnc, CCxQ37, path, lst, title)
 @staticmethod
 def VVS4qb(SELF, cbFnc, curEnc=VVgDRh, title="Select Encoding"):
  lst = CC6ntZ.VVP96x(SELF, "", "")
  if lst:
   FFO9kU(SELF, cbFnc, title=title, VV9cxb=lst, width=1000, height=1000, VVfWsQ="#22220000", VVB5I5="#22220000")
 @staticmethod
 def VVP96x(SELF, path, curEnc):
  lst = CC6ntZ.VVhWSl(path)
  if lst:
   VV9cxb = []
   for name, enc in lst:
    txt = "%s (%s)" % (name, enc)
    if   enc == curEnc   : c = VVOQkl
    elif enc == VVgDRh: c = VVjojy
    else      : c = ""
    VV9cxb.append((c + txt, enc))
   return VV9cxb
  else:
   FF8bV6(SELF, "No proper encoding", 2000)
 @staticmethod
 def VVhWSl(path=""):
  encLst = []
  cPath = VVK8DT + "_sup_codecs"
  if FFKbVo(cPath):
   lines = FF2kXa(cPath)
   for line in lines:
    parts = line.split("\t")
    if len(parts) == 2:
     encLst.append((parts))
  if not encLst:
   tmp = list(CC6ntZ.VVHZM4())
   tmp.pop(0)
   encLst = [("General", ",".join(tmp))]
  lst = []
  for item in encLst:
   for enc in (item[1].split(",")):
    if path:
     try:
      with ioOpen(path, "r", encoding=enc) as f:
       for line in f:
        pass
      lst.append((item[0], enc))
     except:
      pass
    else:
     lst.append((item[0], enc))
  return lst
class CCg47Y(Screen):
 def __init__(self, session, args=0):
  self.skin, self.VVmNvK = FFQaOH(VVNkG2, 900, 950, 50, 40, 30, "#22003300", "#22001100", 30)
  self.session  = session
  VV9cxb = []
  VV9cxb.append(("Settings File"   , "SettingsFile" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Box Info"     , "VVz93R"  ))
  VV9cxb.append(("Tuners Info"    , "VVZX6R" ))
  VV9cxb.append(("Python Version"   , "VV8Q0P" ))
  VV9cxb.append(("Stream Relay Patch"  , "VVQvC9" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Screen Size"    , "ScreenSize"  ))
  VV9cxb.append(("Language/Locale"   , "Locale"   ))
  VV9cxb.append(("Processor"    , "Processor"  ))
  VV9cxb.append(("Operating System"   , "VV6s0b" ))
  VV9cxb.append(("Drivers (Kernel Object)"     , "VVULUG"))
  VV9cxb.append(("Drivers (Loadable Kernel Modules - LKM)" , "VV4FHI" ))
  VV9cxb.append(("Drivers (Built-in Kernel Modules)"  , "VVH4Da" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("System Users"    , "SystemUsers"   ))
  VV9cxb.append(("Logged-in Users"   , "LoggedInUsers"  ))
  VV9cxb.append(("Uptime"     , "Uptime"    ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Host Name"    , "HostName"   ))
  VV9cxb.append(("MAC Address"    , "MACAddress"   ))
  VV9cxb.append(("Network Configuration" , "NetworkConfiguration"))
  VV9cxb.append(("Network Status"   , "NetworkStatus"  ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Disk Usage"    , "VVDa7O"   ))
  VV9cxb.append(("Mount Points"    , "VVsIP6"  ))
  VV9cxb.append(("File System Table (FSTAB)", "VVX4vK"  ))
  VV9cxb.append(("USB Devices"    , "USB_Devices"   ))
  VV9cxb.append(("Block-Devices List"  , "blockDevices"  ))
  VV9cxb.append(("Directory Size"   , "DirectorySize"  ))
  VV9cxb.append(("Memory"     , "Memory"    ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Running Processes"  , "RunningProcesses" ))
  VV9cxb.append(("Processes with open files", "ProcessesOpenFiles" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Bootloader Second-stage (old DreamBox only)" , "DreamBoxBootloader"))
  FFNhKZ(self, VV9cxb=VV9cxb, title="Device Information")
  self.onShown.append(self.VVf1Ra)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  FFvJ8o(self["myMenu"])
  FFNUiO(self)
 def VVyuDa(self):
  item = FFgo5c(self)
  if item is not None:
   if   item == "SettingsFile"   : self.session.open(CCKabK)
   elif item == "VVz93R"   : self.VVz93R()
   elif item == "VVZX6R"  : self.VVZX6R()
   elif item == "VV8Q0P"  : self.VV8Q0P()
   elif item == "VVQvC9"  : self.VVQvC9()
   elif item == "ScreenSize"   : FFSMJz(self, "Width\t: %s\nHeight\t: %s" % (FFcBkL()[0], FFcBkL()[1]))
   elif item == "Locale"    : CC6ntZ.VVQVNc(self)
   elif item == "Processor"   : self.VVY7rP()
   elif item == "VV6s0b"  : self.VV6s0b()
   elif item == "VVULUG"  : self.VVULUG()
   elif item == "VV4FHI"  : self.VV4FHI()
   elif item == "VVH4Da"  : self.VVH4Da()
   elif item == "SystemUsers"   : FFClck(self, "id")
   elif item == "LoggedInUsers"  : FFClck(self, "who -a")
   elif item == "Uptime"    : FFClck(self, "uptime")
   elif item == "HostName"    : FFClck(self, "hostname")
   elif item == "MACAddress"   : self.VVma59()
   elif item == "NetworkConfiguration" : FFClck(self, "ifconfig %s %s" % (FFuLAo("HWaddr", VV2jvK), FFuLAo("addr:", VVjojy)))
   elif item == "NetworkStatus"  : FFClck(self, "netstat -tulpn", VVPYL1=24)
   elif item == "VVDa7O"   : self.VVDa7O()
   elif item == "VVsIP6"  : self.VVsIP6()
   elif item == "VVX4vK"  : self.VVX4vK()
   elif item == "USB_Devices"   : FFClck(self, "lsusb")
   elif item == "blockDevices"   : FFClck(self, "blkid")
   elif item == "DirectorySize"  : FFClck(self, "du -shc /* 2> /dev/null | sed '/total/i-----\t-------------' | sed 's/total/TOTAL/g'")
   elif item == "Memory"    : FFClck(self, "cat /proc/meminfo | sed 's/ //g' | sed 's/:/\t: /g' | sed '/MemAvailable/a%s'" % ("-" * 25), consFont=False)
   elif item == "RunningProcesses"  : FFClck(self, "ps")
   elif item == "ProcessesOpenFiles" : FFClck(self, "lsof")
   elif item == "DreamBoxBootloader"  : self.VVLUtp()
   else        : self.close()
 def VVma59(self):
  res = FF4aqG("ip link")
  list = iFindall(r"[0-9]+:\s+(.+):\s+.+\n.+\s+(.+)brd", res, IGNORECASE)
  if list:
   txt = ""
   for item in list:
    brd = item[0].upper()
    mac = item[1].upper()
    if not brd == "LO":
     txt += "%s\t: %s\n" % (item[0].upper(), item[1].upper())
   FFSMJz(self, txt)
  else:
   FFClck(self, "ip link")
 @FFJRPn()
 def VVDa7O(self):
  VVuGUx, cols = [], 0
  for cmd, cols in (("df -aTh", 7), ("df -ah", 6)):
   txt = FF4aqG(cmd)
   if not "invalid option" in txt:
    for line in txt.split("\n"):
     parts = line.split()
     if len(parts) >= cols and not "Mounted on" in line:
      VVuGUx.append(parts[:cols])
    break
  if VVuGUx:
   if cols == 7:
    header  = ("Filesystem" , "Type", "Size", "Used", "Available" , "Use %", "Mounted on" )
    widths  = (25   , 12 , 10 , 9  , 10   , 9  , 25   )
    VV4Uoc = (LEFT   , CENTER, CENTER, CENTER, CENTER  , CENTER, LEFT   )
   else:
    header  = ("Filesystem" , "Size", "Used", "Available" , "Use %", "Mounted on" )
    widths  = (30   , 11 , 11 , 11   , 11 , 26   )
    VV4Uoc = (LEFT   , CENTER, CENTER, CENTER  , CENTER, LEFT   )
   VVuGUx.sort(key=lambda x: x[0].lower())
   FFCXsL(self, None, header=header, VVXpNQ=VVuGUx, VV4Uoc=VV4Uoc, width=1700, height=1000, VVdZd9=True, VV8boH=widths, VVPYL1=28)
  else:
   FFbBGq(self, "Cannot get data !")
 def VVsIP6(self):
  lines = FFQ1wB("mount")
  VVuGUx = []
  for line in lines:
   span = iSearch(r"(.+)\son\s(.+)\stype\s(.+)\s\((.+)\)", line, IGNORECASE)
   if span:
    VVuGUx.append(span.groups())
  if VVuGUx:
   VVuGUx.sort(key=lambda x: x[0].lower())
   header  = ("Device/FS" , "Mount Point" , "VFS Type", "Mount Options")
   widths  = (20   , 25   , 13  , 42 )
   VV4Uoc = (LEFT   , LEFT   , CENTER , LEFT )
   FFCXsL(self, None, header=header, VVXpNQ=VVuGUx, VV4Uoc=VV4Uoc, VV8boH=widths, VVPYL1=26, VVdZd9=True)
  else:
   FFbBGq(self, "Cannot process data.")
 def VVX4vK(self):
  lst =  []
  for line in FF2kXa("/etc/fstab"):
   s1 = line.strip().split()
   if len(s1) == 6:
    lst.append(s1)
  if lst:
   bg = "#11000600"
   lst.sort(key=lambda x: x[0].lower())
   header  = ("Device" , "Mount Point" , "FS Type" , "Options" , "Backup" , "FS Check")
   widths  = (24  , 24   , 10  , 24  , 9   , 9   )
   VV4Uoc = (LEFT  , LEFT   , CENTER , LEFT  , CENTER , CENTER )
   FFCXsL(self, None, header=header, VVXpNQ=lst, VV4Uoc=VV4Uoc, VV8boH=widths, VVPYL1=26, VVdZd9=True, VVfWsQ=bg, VVB5I5=bg, VVYCun=bg, VVmErq="#00004455", VVK8UQ="#0a282828")
  else:
   FFbBGq(self, "Cannot read FSTAB !\n\n( or no data )")
 @FFJRPn()
 def VVH4Da(self):
  def VVxN3u(p1, bg=""):
   tLst =  []
   for line in FFQ1wB("find '%s' -maxdepth 1 -type f | sort" % p1):
    vals = FF2kXa(os.path.join(p1, line))
    if vals:
     tLst.append((bg + FFiZj6(line).strip().capitalize(), vals[0].strip()))
   return sorted(tLst, key=lambda x: x[0].lower())
  lst =  []
  for line in FFQ1wB("cat /lib/modules/$(uname -r)/modules.builtin"):
   if line.startswith("kernel"):
    driv = os.path.splitext(os.path.basename(line))[0]
    p1 = "/sys/module/%s/" % driv
    p2 = os.path.join(p1, "parameters/")
    tot1 = len([f for f in os.listdir(p1) if FF2kXa(p1 + f)]) if VVkY7E(p1) else 0
    tot2 = len([f for f in os.listdir(p2) if FF2kXa(p2 + f)]) if VVkY7E(p2) else 0
    lst.append((driv, line, "Yes" if tot1 + tot2 > 0 else ""))
  if lst:
   bg = "#11000600"
   lst.sort(key=lambda x: x[0].lower())
   VVmolf = ("", self.VVV7jC, [])
   header  = ("Driver" , "Name", "Info")
   widths  = (36   , 57 , 7  )
   VV4Uoc = (LEFT  , LEFT, CENTER )
   FFCXsL(self, None, header=header, VVXpNQ=lst, VV4Uoc=VV4Uoc, VV8boH=widths, VVdZd9=True, VVPYL1=28, VVmolf=VVmolf, VVfWsQ=bg, VVB5I5=bg, VVYCun=bg, VVmErq="#00004455", VVK8UQ="#0a282828")
  else:
   FFbBGq(self, "Cannot read Builtin Drivers List !")
 @FFJRPn()
 def VVULUG(self):
  lst = []
  for line in FFQ1wB("find /lib/modules/ -iname *.ko"):
   lst.append((os.path.splitext(os.path.basename(line))[0], line))
  if lst : FFCXsL(self, None, header=("Driver", "Path"), VVXpNQ=sorted(lst, key=lambda x: x[0].lower()), VV8boH=(20, 80), VVdZd9=True, VVPYL1=26)
  else : FFbBGq(self, "No list found !")
 @FFJRPn()
 def VV4FHI(self):
  lst =  []
  for line in FFQ1wB("lsmod"):
   s1 = line.split()
   Len = len(s1)
   if Len >= 3 and s1[1] != "Size":
    if   Len == 3: lst.append(s1)
    else   : lst.append(s1[:2] + [" ".join(s1[2:])])
  if lst:
   bg = "#11000600"
   lst.sort(key=lambda x: x[0].lower())
   VVmolf = ("", self.VVV7jC, [])
   header  = ("Module" , "Size", "Used By" )
   widths  = (30  , 15 , 55  )
   VV4Uoc = (LEFT  , CENTER, LEFT  )
   FFCXsL(self, None, header=header, VVXpNQ=lst, VV4Uoc=VV4Uoc, VV8boH=widths, VVdZd9=True, VVPYL1=28, VVmolf=VVmolf, VVfWsQ=bg, VVB5I5=bg, VVYCun=bg, VVmErq="#00004455", VVK8UQ="#0a282828")
  else:
   FFbBGq(self, "Cannot get drivers Info !")
 @FFJRPn(par=1)
 def VVV7jC(self, VVAIxO, title, txt, colList):
  driv = colList[0]
  lst1, lst3 = [], []
  for line in FFQ1wB("modinfo %s" % driv):
   if ":" in line:
    subj, _, val = line.partition(":")
    subj, val = subj.strip().capitalize(), val.strip()
    if not val.startswith("ERROR"):
     tLst = lst1 if subj in ("Filename", "Version", "Author", "Description", "License", "Srcversion", "Depends", "Vermagic") else lst3
     tLst.append((subj, val))
  def VVxN3u(p1, bg=""):
   tLst =  []
   for line in FFQ1wB("find '%s' -maxdepth 1 -type f | sort" % p1):
    vals = FF2kXa(os.path.join(p1, line))
    if vals:
     tLst.append((bg + FFiZj6(line).strip().capitalize(), vals[0].strip()))
   return sorted(tLst, key=lambda x: x[0].lower())
  path = "/sys/module/%s" % driv
  lst2 = [("#b#0a220000#" + a, b) for (a,b) in VVxN3u(path) if (a,b) not in lst1]
  lst4 = VVxN3u(os.path.join(path, "parameters"), "#b#0a221133#")
  lst1 = [("#b#11000a0f#" + a,b) for a,b in lst1]
  lst3 = [("#b#0a003344#" + a,b) for a,b in lst3]
  VVXpNQ = lst1 + lst2 + lst3 + lst4
  bg, title = "#11001122", "Driver : %s" % driv
  if VVXpNQ: FFCXsL(self, None, title=title, VVXpNQ=VVXpNQ, VV8boH=(40, 60), VVRtfk=1, VVfWsQ=bg, VVB5I5=bg, VVYCun=bg, VVmErq="#00883300", VVK8UQ="#0a444444")
  else  : FFbBGq(self, "No Driver Info !", title=title)
 def VVY7rP(self):
  cmd  = "RES=$(uname -m | awk '{print toupper($0)}');"
  cmd += "if [ -z \"$RES\" ] ; then RES=$(uname -a | awk '{print toupper($12)}'); fi;"
  cmd += "if [ -z \"$RES\" ] ; then echo 'Could not read Info.!'; else echo $RES; fi"
  FFClck(self, cmd)
 def VV6s0b(self):
  FFClck(self, "uname -a")
 def VVLUtp(self):
  cmd = FFMXCy(VVgalZ, "| grep secondstage")
  if cmd : FFClck(self, 'output=$(%s); if [ -z "$output" ] ; then echo "Not found for this receiver."; else echo $output; fi' % cmd)
  else : FFWaiD(self)
 def VVz93R(self):
  c1, c2, c3 = "#b#11000a0f#", "#b#0a220000#", "#b#0a003344#"
  VVXpNQ = []
  VVXpNQ.append((c1 + "Box Type"  , self.VVHRi4("boxtype").upper() ))
  VVXpNQ.append((c1 + "Board Version" , self.VVHRi4("board_revision") ))
  VVXpNQ.append((c1 + "Chipset"  , self.VVHRi4("chipset")   ))
  VVXpNQ.append((c1 + "S/N"   , self.VVHRi4("sn")    ))
  VVXpNQ.append((c1 + "Version"  , self.VVHRi4("version")   ))
  VVoDc6   = []
  VVaNNM = ""
  try:
   from Components.SystemInfo import SystemInfo
   keysList = list(SystemInfo)
   if keysList:
    for key in keysList:
     if key == "canMultiBoot":
      VVaNNM = SystemInfo[key]
     else:
      VVoDc6.append((c3 + str(key), str(SystemInfo[key])))
  except:
   pass
  if VVaNNM:
   VVtkeD = self.VVqYgV(VVaNNM, c2)
   if VVtkeD:
    VVtkeD.sort(key=lambda x: x[0].lower())
    VVXpNQ += VVtkeD
  if VVoDc6:
   VVoDc6.sort(key=lambda x: x[0].lower())
   VVXpNQ += VVoDc6
  if VVXpNQ:
   header  = ("Subject" , "Value")
   widths  = (40    , 60)
   FFCXsL(self, None, header=header, VVXpNQ=VVXpNQ, VV8boH=widths, VVPYL1=28, VVRtfk=1, VVzVW9="#00ffff00", VVmErq="#0a884400")
  else:
   FFSMJz(self, "Could not read info!")
 def VVHRi4(self, fileName):
  fileName = "/proc/stb/info/" + fileName
  if FFKbVo(fileName):
   try:
    txt = FF2kXa(fileName)[0]
    if txt:
     return txt
   except:
    pass
  return "-"
 def VVqYgV(self, mbDict, bg):
  try:
   mbList = list(mbDict)
   VVXpNQ = []
   for key in mbList:
    bootDict = mbDict[key]
    device  = bootDict.get("device"  , "")
    rootsubdir = bootDict.get("rootsubdir" , "")
    startupfile = bootDict.get("startupfile", "")
    subject  = "Multiboot-" + str(key)
    value  = ""
    if startupfile : subject += " ... "      + startupfile
    if rootsubdir : value  += "Root-Sub-Dir = %s  ...  " % rootsubdir
    if device  : value  += "Device = "     + device
    if not value:
     value  = str(bootDict)
    VVXpNQ.append((bg + subject, value))
  except:
   pass
  return VVXpNQ
 def VVZX6R(self):
  title = "Tuners"
  c1 = "#f#00ffff88#"
  sName = [c1 + "Slot Name"]
  Type = [c1 + "Type"]
  Descr = [c1 + "Description"]
  conn = [c1 + "Connectable to"]
  fId  = [c1 + "Frontend ID"]
  sId  = [c1 + "Slot ID"]
  mType = [c1 + "Multi-Type"]
  mStream = [c1 + "Multi-Stream"]
  FCB  = [c1 + "FCB"]
  bScan = [c1 + "Supports Blind-Scan"]
  tot = 0
  for ndx, slot in enumerate(nimmanager.nim_slots):
   if slot.frontend_id is not None:
    tot += 1
    sName.append(slot.getSlotName())
    Type.append(slot.getType())
    Descr.append(slot.getFriendlyFullDescription())
    conn.append(" , ".join(slot.connectableTo()))
    fId.append(str(slot.frontend_id))
    sId.append(slot.getSlotID())
    mType.append("Yes" if slot.isMultiType() else "No")
    try:  mStream.append("Yes" if slot.isMultistream() else "No")
    except:  mStream.append("?")
    try:  FCB.append("Yes" if slot.isFBCTuner() else "No")
    except:  FCB.append("?")
    try:  bScan.append("Yes" if slot.supportsBlindScan() else "No")
    except:  bScan.append("?")
  if tot:
   VVuGUx = []
   VVuGUx.append(sName)
   VVuGUx.append(Type)
   VVuGUx.append(Descr)
   VVuGUx.append(conn)
   VVuGUx.append(fId)
   VVuGUx.append(sId)
   VVuGUx.append(mType)
   VVuGUx.append(mStream)
   VVuGUx.append(FCB)
   VVuGUx.append(bScan)
   FFCXsL(self, None, title="%s (Total = %s)" % (title, tot), VVXpNQ=VVuGUx, width=1700, height=1000, VVRtfk=1)
  else:
   FFbBGq(self, "No Tuner Info.", title=title)
 def VV8Q0P(self):
  major   = pyVersion[0]
  minor   = pyVersion[1]
  micro   = pyVersion[2]
  releaselevel = pyVersion[3]
  serial   = pyVersion[4]
  txt = "Version\t: %d.%d.%d\n" % (major, minor, micro)
  txt += "Release\t: %s\n"  % releaselevel
  txt += "Serial\t: %d\n"   % serial
  FFSMJz(self, txt)
 def VVQvC9(self):
  if CC2Ekb.VVEUkc():
   tab = lambda x, y: "%s\t: %s\n" % (x, y)
   txt = tab("Stream Relay", "Supported")
   host, port = CC2Ekb.VVOTBF()
   txt += tab("Hosts List", host or "?")
   txt += tab("Port", port or "?")
   txt += tab("Total Services", len(CC2Ekb.VV0kGE()))
   FFSMJz(self, txt, width=900)
  else:
   FFbBGq(self, "Patch not found.")
 @staticmethod
 def VVvjvY():
  def VVqz4B(v, ndx):
   lst = v.split(";")[ndx].split(",")
   return {lst[i]: lst[i + 1] for i in range(0, len(lst), 2)}
  v = "openbox,OpenBox,openpli,OpenPLI,openvision,OpenVision;areadeltasat,ArEaDeltaSat,cobralibero,Cobralibero,opentr,OpenTR,peter,PeterPan,Gemini,Gemini;italysat,ItalySat,oozoon,OoZooN,openatv,openATV,openeight,OpenEight,openmips,OpenMips,opennfr,OpenNFR,openplus,OpenPlus,openspa,OpenSPA,pure2,Pure2,rudream,ruDream,teamblue,teamBlue,titannit,OpenAFF_Titan"
  v = {"/etc/issue": VVqz4B(v,0), "/etc/issue.net": VVqz4B(v,1), "/etc/image-version": VVqz4B(v,2)}
  for p1, d in v.items():
   img = CCg47Y.VVDihr(p1, d)
   if img: return img
  v = "Blackhole,Blackhole,DE,Dream-Elite,EGAMI,Egami,LT,LT,MediaSat,MediaSat,OPENDROID,OpenDroid,Bp/geminimain,GP3;Domica,Domica,SatLodge,Satlodge,Satdreamgr,SatdreamGr,TSimage,OpenTS_Ts,newnigma2,newnigma2;DemonisatManager,DDD-Demoni,VTIPanel,VTI,ViX,OpenVIX;AddOnManager,Merlin3,DreamOSatcamManager,DreamOSat CamManager,ExtraAddonss,OpenESI,HDF-Toolbox,OpenHDF,HDMUCenter,HDMU,LDteam,OpenLD,NssPanel,NonSoloSat,PKT,PKT,PowerboardCenter,PBNigma-VX,TDW,TDW"
  p = "/usr/lib/enigma2/python/"
  v = {p: VVqz4B(v,0), p + "Plugins/": VVqz4B(v,1), VVISpi: VVqz4B(v,2), VVxQ5s: VVqz4B(v,3)}
  for p1, d in v.items():
   img = CCg47Y.VVbTkK(p1, d)
   if img: return img
  return "OpenBlackhole" if iGlob("%sScreens/BpBlue.p*" % p) else ""
 @staticmethod
 def VVDihr(path, d):
  if FFKbVo(path):
   txt = FFmx8y(path).lower()
   for key, val in d.items():
    if key.lower() in txt: return val
  return ""
 @staticmethod
 def VVbTkK(path, d):
  for key, val in d.items():
   if VVkY7E(path + key): return val
  return ""
 @staticmethod
 def VVKvUI():
  return VVkY7E(VVISpi + "VTIPanel")
class CCKabK(Screen):
 def __init__(self, session, args=0):
  self.skin, self.VVmNvK = FFQaOH(VVNkG2, 700, 630, 50, 40, 30, "#22003300", "#22001100", 32)
  self.session  = session
  VV9cxb = []
  VV9cxb.append(("Settings (All)"   , "all" ))
  VV9cxb.append(("Settings (Hot Keys)"  , "hk" ))
  VV9cxb.append(("Settings (Tuner/DiSEqC)" , "tun" ))
  VV9cxb.append(("Settings (Plugins)"  , "plug"))
  VV9cxb.append(("Settings (Usage)"   , "usg" ))
  VV9cxb.append(("Settings (Time Zone)"  , "tz" ))
  VV9cxb.append(("Settings (Skin)"   , "sk" ))
  FFNhKZ(self, VV9cxb=VV9cxb)
  self.onShown.append(self.VVf1Ra)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  FFvJ8o(self["myMenu"])
  FFNUiO(self)
 def VVyuDa(self):
  item = FFgo5c(self)
  if item is not None:
   if   item == "all" : g = ""
   elif item == "hk" : g = ("config.misc.ButtonSetup." if CCmWdL.VV1oHD() else "config.misc.hotkey.")
   elif item == "tun" : g = "config.Nims."
   elif item == "plug" : g = ".plugins."
   elif item == "usg" : g = ".usage."
   elif item == "tz" : g = ".timezone."
   elif item == "sk" : g = ".skin."
   title = self["myMenu"].l.getCurrentSelection()[0]
   lst = []
   for line in FFQ1wB("cat %s%s" % (VVlLfA, (" | grep %s" % g) if g else "")):
    k, _, v = line.partition("=")
    k, v = k.strip(), v.strip() or "-"
    if not g or g in line:
     lst.append((k.strip() or "-", v.strip() or "-"))
   if lst : FFCXsL(self, None, title=title, header=("Key", "Value"), VVXpNQ=lst, VVPYL1=28, VVdZd9=True)
   else : FFbBGq(self, "No settings changes found.", title=title)
class CCCusX(Screen):
 def __init__(self, session, args=0):
  self.skin, self.VVmNvK = FFQaOH(VVNkG2, 950, 800, 50, 40, 30, "#22003300", "#22001100", 30)
  self.VVb9Ap, VVDRno, VVBK9v, camCommand = CCCusX.VVp200()
  self.session  = session
  self.VVDRno  = VVDRno
  self.camInfo_cmd = camCommand + " -V 2> /dev/null"
  camName = "SoftCam"
  nC = oC = c = ""
  if VVDRno:
   c = VVWH8U if VVBK9v else VVv8b8
   if   "oscam" in VVDRno : camName, oC = "OSCam", c
   elif "ncam"  in VVDRno : camName, nC = "NCam" , c
  VV9cxb = []
  VV9cxb.append(("OSCam Files" , "OSCamFiles" ))
  VV9cxb.append(("NCam Files" , "NCamFiles" ))
  VV9cxb.append(("CCcam Files" , "CCcamFiles" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append((VVk4x7 + 'Convert "/etc/CCcam.cfg" to OSCam/NCam Readers', "VVGimr"))
  VV9cxb.append(VVbM5H)
  VV9cxb.append((oC + "OSCam Readers" , "OSCamReaders"))
  VV9cxb.append((nC + "NCam Readers" , "NSCamReaders"))
  VV9cxb.append(VVbM5H)
  camCmd = os.path.basename(camCommand)
  txt = "%s Settings%s" % (camName, "" if camCmd in ("oscam", "ncam") else " ( %s )" % camCmd)
  VV9cxb.append(FFH04v(txt, "camInfo", VVDRno, c))
  VV9cxb.append(VVbM5H)
  camLst = ((c + camName + " Live Status" , "camLiveStatus" )
    , (c + camName + " Live Log" , "camLiveLog"  ))
  if VVDRno:
   for item in camLst: VV9cxb.append(item)
  else:
   for item in camLst: VV9cxb.append((item[0], ))
  FFNhKZ(self, title="SoftCam Tools", VV9cxb=CCCusX.VVpILg(VV9cxb, 5))
  self.onShown.append(self.VVf1Ra)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  FFvJ8o(self["myMenu"])
  FFNUiO(self)
 def VVyuDa(self):
  item = FFgo5c(self)
  if item is not None:
   if   item == "OSCamFiles"  : self.session.open(BF(CCSy7n, "oscam"))
   elif item == "NCamFiles"  : self.session.open(BF(CCSy7n, "ncam"))
   elif item == "CCcamFiles"  : self.session.open(BF(CCSy7n, "cccam"))
   elif item == "VVGimr" : self.VVGimr()
   elif item == "VV3koW" : self.VV3koW()
   elif item == "OSCamReaders"  : self.VVSbgQ("os")
   elif item == "NSCamReaders"  : self.VVSbgQ("n")
   elif item == "camInfo"   : self.VVdXw9(self.camInfo_cmd)
   elif item == "camLiveStatus" : CCCusX.VVD2oD(self.session, True)
   elif item == "camLiveLog"  : CCCusX.VVD2oD(self.session, False)
   else       : self.close()
 def VVdXw9(self, cmd):
  lines = FFQ1wB(cmd)
  VVuGUx = []
  for line in lines:
   line = line.strip()
   if ":" in line:
    parts = line.split(":")
    key  = parts[0].strip()
    val  = parts[1].strip()
    VVuGUx.append((key, val))
   elif line:
    VVuGUx.append((line, ""))
  if VVuGUx:
   header   = ("Parameter" , "Value" )
   widths   = (50    , 50  )
   FFCXsL(self, None, header=header, VVXpNQ=VVuGUx, VV8boH=widths, VVPYL1=28, VVdZd9=True)
  else:
   FFClck(self, cmd)
 def VVGimr(self):
  path = CCCusX.VVVyvP()
  outFile = "%scccam_to_reader_%s.txt" % (FFJv8S(), FFRIlf())
  if FFKbVo(path):
   lines = FF2kXa(path)
   lst = []
   for line in lines:
    line = line.strip()
    if line.startswith("C:"):
     while "  " in line: line = line.replace("  ", " ")
     parts = line.split(" ")
     if len(parts) == 5:
      CTxt, host, port, User, Pass = parts
      lst.append((host, port, User, Pass))
   newLine = []
   if lst:
    VVqz4B = lambda txt, val: "%s= %s\n" % (txt.ljust(30), str(val))
    with open(outFile, "w") as f:
     for ndx, item in enumerate(lst, start=1):
      host, port, User, Pass = item
      f.write("[reader]\n")
      f.write(VVqz4B("label"    , "CCcam-Line-%d" % ndx))
      f.write(VVqz4B("description"  , "CCcam-Line-%d" % ndx))
      f.write(VVqz4B("protocol"   , "cccam"))
      f.write(VVqz4B("device"    , "%s,%s" % (host, port)))
      f.write(VVqz4B("user"    , User))
      f.write(VVqz4B("password"   , Pass))
      f.write(VVqz4B("fallback"   , "1"))
      f.write(VVqz4B("group"    , "64"))
      f.write(VVqz4B("cccversion"   , "2.3.2"))
      f.write(VVqz4B("audisabled"   , "1"))
      f.write(VVqz4B("ccckeepalive"  , "1"))
      f.write("\n")
    tot = len(lst)
    FF0onH(self, "Output = %d Reader%s in:\n\n%s" % (tot, FFaRsj(tot), outFile))
   else:
    FFoTZI(self, "No valid CCcam lines", 1500)
  else:
   FFoTZI(self, "%s not found" % path, 1500)
 def VV3koW(self):
  CCV3Gw.VVgWD3(self, VVuSHu=self.VVhpiJ, VVhK3C=self.VVZPnW)
 def VVhpiJ(self, VVqeT6):
  ttl = "Processing ..."
  VVqeT6.VVL8uX = ("", "Not found")
  dic = CCM6jS.VVlTAV()
  if dic : VVqeT6.VVfT17(len(dic[1]) + 4)
  else : return
  lst1 = []
  uErr = []
  uNoLn = []
  for uNum, u in enumerate(dic[1], start=1):
   u = FFtcG5(u[1:-1])
   if not VVqeT6 or VVqeT6.isCancelled: return
   VVqeT6.VVX5nT(u.partition("/")[0] if VVSm4H else ttl)
   VVqeT6.VVqE9L(1)
   res, err = CClaHD.VVmPDA("https://%s" % u, timeout=4)
   if res:
    span = iSearch(r"(C: \S+ \d+ \S+ [^\s<]+)", res.text, IGNORECASE)
    if span : lst1.append(str(span.group(1)).strip().replace("c:", "C:"))
    else : uNoLn.append(u)
   elif err:
    uErr.append(u)
  lst2 = []
  u = FFtcG5(dic[2][1:-1])
  if not VVqeT6 or VVqeT6.isCancelled: return
  VVqeT6.VVX5nT((u + " (P1)") if VVSm4H else ttl)
  VVqeT6.VVqE9L(1)
  res, err = CClaHD.VVmPDA("https://%s" % u, timeout=2)
  if res:
   span = iSearch(r'<a href="(.+)">%s<\/a>' % FF9fW8("RnJlZSBDQ2NhbSBzZXJ2ZXJz"), res.text, IGNORECASE)
   if span:
    if not VVqeT6 or VVqeT6.isCancelled: return
    VVqeT6.VVX5nT((u + " (P2)") if VVSm4H else ttl)
    VVqeT6.VVqE9L(1)
    res, err = CClaHD.VVmPDA(span.group(1), timeout=2)
    if res:
     lst2 = iFindall(r"(C:\s+.+)#", res.text) or []
     lst2 = list(map(str.strip, list(map(str, lst2))))
     lst2.sort()
    elif err: uErr.append(u)
  elif err: uErr.append(u)
  if not lst2: uNoLn.append(u)
  lst3 = []
  u = FFtcG5(dic[3][1:-1])
  if not VVqeT6 or VVqeT6.isCancelled: return
  VVqeT6.VVX5nT(u  if VVSm4H else ttl)
  VVqeT6.VVqE9L(1)
  res, err = CClaHD.VVmPDA("https://%s" % u, timeout=2)
  if res:
   lst3 = iFindall(r"(C:\s+.+)<\/a>", res.text) or []
   lst3 = list(map(str.strip, list(map(str, lst3))))
   lst3.sort()
  elif err: uErr.append(u)
  if not lst3: uNoLn.append(u)
  if not lst1 and not lst2 and not lst3:
   VVqeT6.VVL8uX = ("", "No lines found")
   return
  sep1 = "#" + " %s %s %s" % ("=" * 15, FFyCC4(), "=" * 15)
  sep2 = "#" + " " + "-" * 51
  lst = ["", sep1]
  lst.extend(lst1)
  if lst1 and lst2: lst.append(sep2)
  lst.extend(lst2)
  if lst1 or lst2: lst.append(sep2)
  lst.extend(lst3)
  totL = len(lst1) + len(lst2) + len(lst3)
  def VVVmck(p):
   patt = r"^#\s={10,}\s.+\s={10,}"
   fLines, totR  = [], 0
   oldLines = FF2kXa(p)
   Max = len(oldLines) - 1
   for ndx, ln in enumerate(oldLines):
    ln = str(ln).strip()
    if ndx < Max:
     nextL = oldLines[ndx + 1].strip()
     if   iMatch(patt, ln) and (iMatch(patt, nextL) or not nextL or nextL.startswith("#")) : continue
     elif (ln == sep2) and (not nextL or nextL == sep2 or iMatch(patt, nextL))    : continue
    if not ln or ln.startswith("#"):
     fLines.append(ln)
    else:
     Code = ln.partition("#")[0].strip()
     if not Code in lst : fLines.append(ln)
     elif Code   : totR += 1
   return fLines, totR
  def VVbpfc(p, lines):
   fTxt = "\n".join(lines).strip()
   while "\n\n\n" in fTxt: fTxt = fTxt.replace("\n\n\n", "\n\n")
   with open(p, "w") as f: f.write("%s\n" % fTxt)
  f1 = CCCusX.VVVyvP()
  fLines, totR1 = VVVmck(f1)
  fLines.extend(lst)
  VVbpfc(f1, fLines)
  f2 = CCCusX.VVnapK()
  totR2 = 0
  if FFKbVo(f2):
   fLines, totR2 = VVVmck(f2)
   fLines.extend(lst)
   VVbpfc(f2, fLines)
  c1 = VVk4x7
  ttl = lambda x: "%s:\n" % FFKrMM(x, c1)
  txt1  = ttl("Updated Files")
  txt1 += "  %s%s\n" % (f1, ("   (Replaced : %s)" % totR1) if totR1 else "")
  if FFKbVo(f2): txt1 += "  %s%s\n" % (f2, ("   (Replaced : %s)" % totR2) if totR2 else "")
  if VVSm4H:
   txt = txt1
   if uErr:
    txt += "\n" + ttl("With Errors")
    txt += "  %s\n" % "\n  ".join(uErr)
   if uNoLn:
    txt += "\n" + ttl("With no Lines")
    txt += "  %s\n" % "\n  ".join(uNoLn)
   txt += "\n%s" % FFFGRS("Added Lines (%s)" % totL, VVWH8U)
   txt += "\n".join(lst)
  else:
   txt  = ttl("Added Lines")
   txt += "  %s\n\n" % totL
   txt += txt1
  VVqeT6.VVL8uX = (txt, "")
 def VVZPnW(self, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  if VV6ZvL:
   txt, err = VVL8uX
   if err  : FFbBGq(self, err)
   elif not txt: FFbBGq(self, "Not found")
   else:
    FFSMJz(self, txt)
    CCCusX.VV28ou(self.session)
 @FFJRPn()
 def VVSbgQ(self, VV3jVw):
  VVuGUx = CCCusX.VVvsqV(self, VV3jVw)
  if VVuGUx:
   VVuGUx.sort(key=lambda x: int(x[0]))
   if self.VVDRno and self.VVDRno.startswith(VV3jVw):
    VVjW3s = ("Delete Reader" , BF(self.VV8XWU, VV3jVw) , [])
    VVwqVu = ("Toggle State"  , self.VVRo14, [VV3jVw]     , "Changing State ...")
    VVdZd9 = False
   else:
    VVjW3s = VVwqVu = None
    VVdZd9 = True
   bg = "#22000011"
   header   = ("No." , "State" , "Label" , "Description" , "Host", "Port", "Protocol", "User", "Password")
   widths   = (4  , 5    , 28    , 16   , 14 , 6   , 9   , 9  , 9   )
   VV4Uoc  = (CENTER , CENTER , LEFT   , LEFT   , LEFT , CENTER, LEFT  , LEFT , LEFT  )
   FFCXsL(self, None, header=header, VVXpNQ=VVuGUx, VV4Uoc=VV4Uoc, VV8boH=widths, width=1800, height=1000, VVPYL1=24, VVdZd9=VVdZd9, VVjW3s=VVjW3s, VVwqVu=VVwqVu, VVoNmU=True
     , VVfWsQ="#22002030", VVB5I5=bg, VVYCun=bg, VVmErq="#00664411", VVK8UQ="#00444444", VVgSJJ="#08442211")
 def VVPN2M(self, VVAIxO, VV3jVw):
  VVuGUx = CCCusX.VVvsqV(self, VV3jVw)
  if VVuGUx : VVAIxO.VVEEBV(VVuGUx)
  else  : VVAIxO.cancel()
 def VVvsqV(self, VV3jVw):
  rFile = "%s%scam.server" % (self.VVb9Ap, VV3jVw)
  if FFKbVo(rFile):
   lst = CCCusX.VVPcyP(rFile)
   if not lst: FFbBGq(self, "No readers found !")
   return lst
  else:
   FFWfGZ(self, rFile)
   return []
 def VV8XWU(self, VV3jVw, VVAIxO, title, txt, colList):
  num, stt, lbl, dscr, hst, prt, prot, usr, pas = colList
  FF6pUe(self, BF(CCCusX.VVln8I, VVAIxO, lbl, cbFnc=BF(self.VVPN2M, VVAIxO, VV3jVw)), "%s\n\nDelete ?" % lbl, title="Delete Reader")
 def VVRo14(self, VVAIxO, VV3jVw):
  confFile = "%s%scam.conf" % (self.VVb9Ap, VV3jVw)
  readerState = VVAIxO.VVYmuZ(1)
  readerLabel = VVAIxO.VVYmuZ(2)
  if "off" in readerState.lower() : newState = "enable"
  else       : newState = "disable"
  urlAction = "&label=%s&action=%s" % (FFTnsB(readerLabel), newState)
  uReq = CCCusX.VVV2aW(self, VV3jVw, confFile, "readerlist", urlAction)
  if uReq:
   try:
    page = iUrlopen(uReq, timeout=4)
   except Exception as e:
    VVAIxO.VVEL2E()
    FFbBGq(self, "Cannot connect to SoftCAM !\n\nError = %s" % str(e))
    return
   self.VVPN2M(VVAIxO, VV3jVw)
  else:
   VVAIxO.VVEL2E()
 @staticmethod
 def VVV2aW(SELF, VV3jVw, confFile, urlPart, urlAction, typ="html"):
  if FFKbVo(confFile):
   lines = FF2kXa(confFile)
   user = "root"
   pwd  = port = ""
   if lines:
    webif = False
    for line in lines:
     line = line.strip().lower()
     if "[webif]" in line:
      webif = True
     if webif and "=" in line:
      if   line.startswith("httpuser"): user = line.split("=")[1].strip()
      elif line.startswith("httppwd") : pwd = line.split("=")[1].strip()
      elif line.startswith("httpport"): port = line.split("=")[1].strip()
   if not webif:
    FFbBGq(SELF, "Cannot connect to SoftCAM Web Interface !")
    return None
   elif not port:
    FFbBGq(SELF, "SoftCAM Web Port not found in file:\n\n%s" % confFile)
    return None
  else:
   FFWfGZ(SELF, confFile)
   return None
  if not iRequest:
   FFbBGq(SELF, "Module not found\n\nurllib/urllib2")
   return None
  try:
   url = "http://127.0.0.1:%s/%scamapi.%s?part=%s%s" % (port, VV3jVw, typ, urlPart, urlAction)
   acceccManager = HTTPPasswordMgrWithDefaultRealm()
   acceccManager.add_password(None, url, user, pwd)
   handlers= HTTPDigestAuthHandler(acceccManager)
   opener = build_opener(HTTPHandler, handlers)
   install_opener(opener)
   return iRequest(url)
  except Exception as e:
   FFbBGq(SELF, "Error while preparing URL Request !\n\n %s" % str(e))
   return None
 @staticmethod
 def VVp200():
  VVb9Ap = "/etc/tuxbox/config/"
  VVDRno = None
  VVBK9v  = None
  camCommand = FF2ndj(r"lsof | grep 'oscam\|ncam' | tail -1 | awk '{print $2}'")
  if camCommand:
   camCmd = os.path.basename(camCommand).lower()
   if   camCmd.startswith("oscam") : VVDRno = "oscam"
   elif camCmd.startswith("ncam") : VVDRno = "ncam"
  if VVDRno:
   tStr = os.path.basename(camCommand).lower()
   for path in iGlob("/etc/init.d/softcam.*"):
    _, _, camName = os.path.basename(path).lower().partition(".")
    if camName == tStr:
     fTxt = FFmx8y(path)
     span = iSearch(r"-config-dir\s(\/etc\/tuxbox.*?)\s", fTxt, IGNORECASE)
     if span:
      VVb9Ap = FF9Uvy(span.group(1))
      var = "$CAMNAME"
      if var in VVb9Ap:
       span = iSearch(r'CAMNAME="(.+)"', fTxt, IGNORECASE)
       if span:
        VVb9Ap = VVb9Ap.replace(var, span.group(1))
      break
   else:
    path = FF2ndj(camCommand + " -V 2> /dev/null | grep -i configdir | awk '{print $2}'")
    path = FF9Uvy(path)
    if VVkY7E(path):
     VVb9Ap = path
   tFile = FF9Uvy(VVb9Ap) + VVDRno + ".conf"
   tFile = FF2ndj("FILE='%s'; [ -f $FILE ] && cat $FILE | grep -i LOGFILE | awk '{print $3}'" % tFile)
   if FFKbVo(tFile):
    VVBK9v = tFile
  return VVb9Ap, VVDRno, VVBK9v, camCommand
 @staticmethod
 def VVxpnT(SELF=None):
  VVb9Ap, VVDRno, VVBK9v, camCommand = CCCusX.VVp200()
  VV3jVw = confFile = ""
  if VVDRno:
   VV3jVw = "os" if "oscam" in VVDRno else "n"
   confFile = "%s%scam.conf" % (VVb9Ap, VV3jVw)
  elif SELF:
   FFbBGq(SELF, message="No active OSCam/NCam")
  return VVb9Ap, VVDRno, VVBK9v, camCommand, VV3jVw, confFile
 @staticmethod
 def VVfAwd(SELF, part, act, typ="html"):
  VVb9Ap, VVDRno, VVBK9v, camCommand, VV3jVw, confFile = CCCusX.VVxpnT(SELF)
  return CCCusX.VVV2aW(SELF, VV3jVw, confFile, part, act, typ=typ) if VVDRno else None
 @staticmethod
 def VVv1uy():
  VVb9Ap, VVDRno, VVBK9v, camCommand, VV3jVw, confFile = CCCusX.VVxpnT()
  return "%s%scam.server" % (VVb9Ap, VV3jVw) if VVDRno else ""
 @staticmethod
 def VVnapK():
  VVb9Ap, VVDRno, VVBK9v, camCommand, VV3jVw, confFile = CCCusX.VVxpnT()
  return ("%sCCcam.cfg" % VVb9Ap) if VVb9Ap else ""
 @staticmethod
 def VVVyvP():
  return "/etc/CCcam.cfg"
 @staticmethod
 def VVd0py():
  return (CCCusX.VVVyvP(), CCCusX.VVnapK())
 @staticmethod
 def VVPcyP(rFile):
  lst  = []
  tag  = "[reader]"
  lines = FF2kXa(rFile)
  tagFound= False
  enable = label = description = url = port = protocol = User = password = ""
  onStr = "#f#1100ff00#" + "ON"
  offStr = "OFF"
  for ndx, line in enumerate(lines):
   if tag in line.lower() or ndx >= len(lines) - 1:
    if enable or label or description or url or port or protocol or User or password:
     if enable == "": enable = onStr
     lst.append((str(len(lst) + 1), enable, label, description, url, port, protocol, User, password))
    enable = label = description = url = port = protocol = User = password = ""
   elif "=" in line:
    key, _, val = line.partition("=")
    key, val = key.strip().lower(), val.strip()
    if   key == "label"   : label   = val
    elif key == "description" : description = val
    elif key == "protocol"  : protocol  = val
    elif key == "user"   : User   = val
    elif key == "password"  : password  = val
    elif key == "enable"  : enable = offStr if val == "0" else onStr
    elif key == "device"  :
     url, _, port = val.partition(",")
     url, port = url.strip(), port.strip()
  return lst
 @staticmethod
 @FFJRPn("Deleting ...")
 def VVln8I(SELF, lbl, delCC=True, cbFnc=None):
  if delCC: CCCusX.VVNpVS(lbl)
  uReq = CCCusX.VVfAwd(SELF, "readerlist", "&label=%s&action=delete" % FFTnsB(lbl), typ="json")
  if uReq:
   try:
    res = iUrlopen(uReq, timeout=4)
    if cbFnc: cbFnc()
   except:
    FF8bV6(SELF, "Cannot access SoftCam", 2000)
 @staticmethod
 def VVNpVS(dLbl):
  relatedReaders = []
  rFile = CCCusX.VVv1uy()
  rLst = [(hst, prt, usr, pas) for num, stt, lbl, dscr, hst, prt, prot, usr, pas in CCCusX.VVPcyP(rFile) if lbl==dLbl]
  for f in CCCusX.VVd0py():
   c, lines = 0, []
   for ln in FF2kXa(f):
    span = iSearch(r"^(?:C|N):\s+(\S+)\s+(\d+)\s+(\S+)\s+(\S+)", ln.strip())
    if span and span.groups() in rLst:
     ln = "#" + ln
     c += 1
    lines.append(ln)
   if c > 0:
    with open(f, "w") as f:
     f.write("%s\n" % "\n".join(lines))
 @staticmethod
 def VV28ou(session):
  cmd, name = CCCusX.VVWVnh()
  if cmd:
   def VVxN3u(*args): CC2Ekb.VVIMKA(session)
   CCDRFn().VV70Ea("%s restart" % cmd, VVxN3u)
 @staticmethod
 def VVWVnh():
  try:
   c = os.path.realpath("/etc/init.d/softcam")
   if not c.endswith(".None"): return c, os.path.split(c)[1].partition(".")[2]
  except:
   pass
  return "", ""
 @staticmethod
 def VVD2oD(session, VVPDsT):
  VVb9Ap, VVDRno, VVBK9v, camCommand = CCCusX.VVp200()
  if VVDRno: session.open(BF(CCVHM5, VVb9Ap=VVb9Ap, VVDRno=VVDRno, VVBK9v=VVBK9v, VVPDsT=VVPDsT))
  else  : FFvOl9(session, message="No active OSCam/NCam", title="Live Log")
 @staticmethod
 def VVbBWp(SELF):
  if iElem:
   return True
  else:
   FFbBGq(SELF, "Module not found:\n\nxml.etree")
   return False
 @staticmethod
 def VVpILg(lst, i):
  t = CCM6jS.VVy3nL(900)
  if t and VVSm4H: lst.insert(i, (VVk4x7 + t, "VV3koW"))
  return lst
class CCSy7n(Screen):
 def __init__(self, VVTp1W, session, args=0):
  self.skin, self.VVmNvK = FFQaOH(VVNkG2, 700, 650, 50, 40, 30, "#22003300", "#22001100", 30)
  self.session  = session
  self.VVb9Ap, VVDRno, VVBK9v, camCommand = CCCusX.VVp200()
  if   VVTp1W == "ncam" : self.prefix = "n"
  elif VVTp1W == "oscam" : self.prefix = "os"
  else     : self.prefix = ""
  VV9cxb = []
  if self.prefix == "":
   VV9cxb.append(("CCcam.cfg"         , "c_CCcam_cfg"  ))
   VV9cxb.append(("ecm.info"          , "c_ecm_info"  ))
  else:
   VV9cxb.append(("AutoRoll.Key"         , "x_AutoRoll_Key" ))
   VV9cxb.append(("constant.cw"         , "x_constant_cw" ))
   VV9cxb.append((self.prefix + "cam.ccache"      , "x_cam_ccache" ))
   VV9cxb.append((self.prefix + "cam.conf"      , "x_cam_conf"  ))
   VV9cxb.append((self.prefix + "cam.dvbapi"      , "x_cam_dvbapi" ))
   VV9cxb.append((self.prefix + "cam.provid"      , "x_cam_provid" ))
   VV9cxb.append((self.prefix + "cam.server"      , "x_cam_server" ))
   VV9cxb.append((self.prefix + "cam.services"     , "x_cam_services" ))
   VV9cxb.append((self.prefix + "cam.srvid2"      , "x_cam_srvid2" ))
   VV9cxb.append((self.prefix + "cam.user"      , "x_cam_user"  ))
   VV9cxb.append(VVbM5H)
   VV9cxb.append(("SoftCam.Key / SoftCam.key"     , "x_SoftCam_Key" ))
   VV9cxb.append(("CCcam.cfg"         , "x_CCcam_cfg"  ))
   VV9cxb.append(VVbM5H)
   VV9cxb.append((self.prefix + "cam.log (last 100 lines)"  , "x_cam_log"  ))
   VV9cxb.append((self.prefix + "cam.log-prev (last 100 lines)" , "x_cam_log_prev" ))
   VV9cxb.append((self.prefix + "cam.pid"      , "x_cam_pid"  ))
  FFNhKZ(self, VV9cxb=VV9cxb)
  self.onShown.append(self.VVf1Ra)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  FFvJ8o(self["myMenu"])
  FFNUiO(self)
 def VVyuDa(self):
  item = FFgo5c(self)
  pathTmp = "/tmp/"
  if item is not None:
   if   item == "c_CCcam_cfg"  : FFjTOc(self, "/var/etc/CCcam.cfg")
   elif item == "c_ecm_info"  : FFjTOc(self, "/tmp/ecm.info")
   elif item == "x_AutoRoll_Key" : FFjTOc(self, self.VVb9Ap + "AutoRoll.Key")
   elif item == "x_constant_cw" : FFjTOc(self, self.VVb9Ap + "constant.cw")
   elif item == "x_cam_ccache"  : self.VVIWHD("cam.ccache")
   elif item == "x_cam_conf"  : self.VVIWHD("cam.conf")
   elif item == "x_cam_dvbapi"  : self.VVIWHD("cam.dvbapi")
   elif item == "x_cam_provid"  : self.VVIWHD("cam.provid")
   elif item == "x_cam_server"  : self.VVIWHD("cam.server")
   elif item == "x_cam_services" : self.VVIWHD("cam.services")
   elif item == "x_cam_srvid2"  : self.VVIWHD("cam.srvid2")
   elif item == "x_cam_user"  : self.VVIWHD("cam.user")
   elif item == "x_SEP"   : pass
   elif item == "x_SoftCam_Key" : self.VVItSw()
   elif item == "x_CCcam_cfg"  : FFjTOc(self, self.VVb9Ap + "CCcam.cfg")
   elif item == "x_SEP"   : pass
   elif item == "x_cam_log"  : FFjTOc(self, pathTmp + self.prefix + "cam.log")
   elif item == "x_cam_log_prev" : FFjTOc(self, pathTmp + self.prefix + "cam.log-prev")
   elif item == "x_cam_pid"  : FFjTOc(self, pathTmp + self.prefix + "cam.pid")
   else       : self.close()
 def VVIWHD(self, fileName):
  FFjTOc(self, self.VVb9Ap + self.prefix + fileName)
 def VVItSw(self):
  path = self.VVb9Ap + "SoftCam.Key"
  if FFKbVo(path) : FFjTOc(self, path)
  else    : FFjTOc(self, path.replace(".Key", ".key"))
class CCVHM5(Screen):
 def __init__(self, session, VVb9Ap="", VVDRno="", VVBK9v="", VVPDsT=False):
  self.skin, self.VVmNvK = FFQaOH(VV0v8m, 1700, 950, 50, 30, 20, "#22002030", "#33000011", 25, VVSwLg=40)
  self.session   = session
  self.VVBK9v   = VVBK9v
  self.VVPDsT   = VVPDsT
  self.timer    = eTimer()
  self.VV52Uj  = False
  self.Title    = "Live Log"
  self.elementTree  = None
  self.VVt44Z   = None
  self.VVdvX7  = False
  self.user    = "root"
  self.pwd    = ""
  self.port    = ""
  self.VVAIxO  = None
  self.period    = 3000
  if "oscam" in VVDRno : titleTxt, self.VV3jVw = "OSCam", "os"
  else     : titleTxt, self.VV3jVw = "NCam" , "n"
  self.confFile   = "%s%scam.conf" % (VVb9Ap, self.VV3jVw)
  if self.VVPDsT: self.Title = "  %s Status" % titleTxt
  else   : self.Title = "  %s Live Log" % titleTxt
  FFNhKZ(self, self.Title, addScrollLabel=True)
  FFi79B(self["keyRed"], "Stop")
  FFmpyO(self, {"red": self.VVlULu})
  self.onShown.append(self.VVf1Ra)
  self.onClose.append(self.onExit)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  self["myLabel"].VVesH9(isResizable=False)
  FFuwGk(self)
  self["myBar"].instance.setHAlign(1)
  self.VVlULu()
 def onExit(self):
  self.timer.stop()
 def VV6Qfy(self):
  try: self.timer_conn = self.timer.timeout.connect(self.VVhV0x)
  except: self.timer.callback.append(self.VVhV0x)
  self.timer.start(self.period, False)
  self.VV52Uj = True
  self.VVMjKn(True)
 def VVVhUs(self):
  self.timer.stop()
  self.VV52Uj = False
  try:
   self.timer.callback.remove(self.VVhV0x)
  except:
   pass
  self.VVMjKn(False)
 def VVMjKn(self, isOn):
  if isOn : title, redTxt, barTxt, txt = " (Running)" , "Stop" , "Waiting for update ..." , "Started"
  else : title, redTxt, barTxt, txt = ""   , "Start", ""      , "Stopped"
  if self.VVAIxO:
   self.VVAIxO.VVuSAP(self.Title + title)
   self.VVAIxO["keyRed"].setText(redTxt)
   FFoTZI(self.VVAIxO, txt, 800)
  else:
   self["myTitle"].setText(self.Title + title)
   self["keyRed"].setText(redTxt)
   FFoTZI(self, txt, 1000)
 def VVlULu(self):
  if self.VV52Uj:
   self.VVVhUs()
  else:
   self.VV6Qfy()
   uReq = CCCusX.VVV2aW(self, self.VV3jVw, self.confFile, "status", "")
   if uReq and CCCusX.VVbBWp(self):
    self.VVt44Z, self.elementTree = uReq, iElem
    if self.VVdvX7:
     self.VVdvX7 = False
     self["myLabel"].setText("Reading from SoftCAM Interface ...")
    FFvfpL(self.VVrdDZ)
   else:
    self.close()
 def VVhV0x(self):
  if self.VV52Uj:
   self.VVXLnf()
 def VVrdDZ(self):
  self.VVXLnf()
 def VVXLnf(self):
  try:
   page = iUrlopen(self.VVt44Z, timeout=1).read()
   err = ""
  except iURLError as e:
   err = FFxcy7(e)
  except Exception as e:
   err = str(e)
  if err:
   self["myLabel"].setText(FFKrMM("Cannot read from SoftCAM Interface !\n\nError = %s\n\nPlease activate Softcam." % err, VVdLWL))
   self.VVdvX7 = True
   self.VVVhUs()
   return
  camTxt = page.decode("UTF-8")
  lines = list(map(str, camTxt.splitlines()))
  if self.VVPDsT: ok = self.VVt01V(lines)
  else   : ok = self.VVxniI(lines)
  txt = "Last Update : %s" % FFENz0()
  if self.VVAIxO: self.VVAIxO["myBar"].setText(txt)
  else     : self["myBar"].setText(txt)
  if not ok:
   FFbBGq(self, "No date from SoftCam.")
   self.VVVhUs()
   if self.VVAIxO: self.VVAIxO.cancel()
   self.close()
 def VVt01V(self, lines):
  xmlTxt = '<?xml version="1.0" encoding="UTF-8"?>\n'
  tags = ("<status", "<client", "<request", "<times", "<connection", "</client", "</status")
  for line in lines:
   line = line.strip()
   if line.startswith(tags):
    xmlTxt += line
  parseError = False
  try:
   root = self.elementTree.fromstring(xmlTxt)
  except Exception as e:
   parseError = FFKrMM("Error while parsing data elements !\n\nError = %s" % str(e), VVPI2q)
   self.VVdvX7 = True
   self.VVVhUs()
  txt = ""
  if not parseError is False:
   txt = parseError
   self["myLabel"].setText(txt, VV5wgt=VVoR3b)
  else:
   VVuGUx = []
   for client in root.findall("client"):
    name  = client.get("name", "-")
    desc  = client.get("desc", "-")
    protocol = client.get("protocol", "-")
    conn  = client.find("connection")
    if not conn is None:
     ip  = conn.get("ip", "-")
     port = conn.get("port", "-")
     status = conn.text
    else:
     ip = port = status = "-"
    stCode, fg = self.VVQZlS(status)
    VVuGUx.append((name, ip, port, protocol, desc, "%s%s" % (fg, status)))
   if VVuGUx:
    VVuGUx.sort(key=lambda x: x[0].lower())
    if self.VVAIxO:
     self.VVAIxO.VVEEBV(VVuGUx, VVWBXTMsg=False)
    else:
     bg = "#22000011"
     title = self.Title.strip() + " (Running)" if self.VV52Uj else ""
     VVpW7I = self.VVFyJv
     VVDPcX = (""  , self.VVPqLS , [])
     VVjW3s  = ("Stop"  , self.VVDiSM , [])
     VViMvb = ("Options" , self.VV1Wxs, [])
     header = ("Label" , "Host", "Port", "Protocol", "Description" , "State" )
     widths = (32  ,  15 , 8  , 17  , 16   , 12  )
     align = (LEFT  ,  LEFT , CENTER, CENTER , LEFT   , CENTER )
     self.VVAIxO = FFCXsL(self, None, title=title, header=header, VVXpNQ=VVuGUx, VV4Uoc=align, VV8boH=widths, VVPYL1=24, width=1700, height=950, VVpW7I=VVpW7I, VVDPcX=VVDPcX, VVjW3s=VVjW3s, VViMvb=VViMvb
            , VVfWsQ="#22002030", VVB5I5=bg, VVYCun=bg, VVmErq="#00664411", VVK8UQ="#00444444", VVgSJJ="#08442211")
    return True
   else:
    return False
 def VVFyJv(self, VVAIxO):
  VVAIxO.cancel()
  self.close()
 def VVPqLS(self, VVAIxO, title, txt, colList):
  VVAIxO["myBar"].instance.setHAlign(1)
 def VVDiSM(self, VVAIxO, title, txt, colList):
  self.VVlULu()
 def VVQZlS(self, st):
  st = st.upper()
  if   st in ["OK", "CONNECTED", "CARDOK"] or st.startswith(("ON")) : c = 0
  elif any(x in st for x in ("ERROR", "UNDEF", "UNKNOWN", "OFFLINE")) : c = 1
  elif st == "OFF"             : c = 2
  else                : c = 3
  return c, {0:"#f#0055ff55#", 1:"#f#00ff8000#", 2:"#f#00aa88ff#"}.get(c, "")
 def VV1Wxs(self, VVAIxO, title, txt, colList):
  delLst, lblLst = [], []
  for lbl, hst, prt, Prot, Dsc, stt in VVAIxO.VVGpBN():
   if not Prot in ("http", "server", "dvbapi"): lblLst.append(lbl)
   stCode, fg = self.VVQZlS(stt)
   if stCode == 1: delLst.append(lbl)
  tmp = {x: lblLst.count(x) for x in lblLst}
  duplLst = []
  for lbl, cnt in tmp.items():
   if cnt > 1: duplLst.extend([lbl] * (cnt - 1))
  curLbl, hst, prt, curProt, Dsc, stt = colList
  c1, c2 = VVU4M8 , VVv8b8
  VV9cxb = []
  VV9cxb.append(("Delete Selected Reader", "delCur"))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(FFH04v("Delete Inactive Readers" , "badRdr", delLst))
  VV9cxb.append(FFH04v("Delete Duplicate Readers" , "dupRdr", duplLst))
  if VVSm4H:
   VV9cxb.append(VVbM5H)
   VV9cxb.append(FFH04v("Delete Inactive Lines (from CCcam.cfg Files)" , "badCc", delLst))
  FFO9kU(self, BF(self.VVCEmH, VVAIxO, duplLst, delLst, curLbl, curProt), VV9cxb=VV9cxb, width=1000, title="Options", VVDkqE=True)
 def VVCEmH(self, VVAIxO, duplLst, delLst, curLbl, curProt, item):
  if item:
   title, ref, ndx = item
   if   ref == "delCur": self.VVnuaO(VVAIxO, delLst, curLbl, curProt)
   elif ref == "badRdr": self.VVvVaD(VVAIxO, title, delLst, True)
   elif ref == "dupRdr": self.VVvVaD(VVAIxO, title, duplLst, False)
   elif ref == "badCc" : self.VVyxH8(delLst, title)
 def VVyxH8(self, delLst, title=""):
  def VVxN3u(fil):
   lines = []
   c = 0
   for ln in FF2kXa(fil):
    span = iSearch(r"^(?:C|N):\s+(\S+)\s+(\d+)\s+(\S+)", ln)
    if span and "_".join(span.groups()) in delLst:
     c += 1
     continue
    else:
     lines.append(ln)
   if c > 0:
    with open(fil, "w") as f:
     f.write("%s\n" % "\n".join(lines))
   return c
  txt = ""
  for f in CCCusX.VVd0py():
   if FFKbVo(f):
    tot = VVxN3u(f)
    if tot: txt += "File\t: %s\nDeleted\t: %s\n\n" % (f, tot)
  if title:
   if txt:
    FFSMJz(self, txt, title)
    CCCusX.VV28ou(self.session)
   else:
    FF0onH(self, "No related lines in CCcam.cfg files.", title)
 def VVvVaD(self, VVAIxO, title, delLst, delC):
  if delC: self.VVyxH8(delLst)
  CCV3Gw.VVgWD3(self, VVuSHu=BF(self.VV2jq6, delLst), VVhK3C=BF(self.VV8phH, title))
 def VV2jq6(self, delLst, VVqeT6):
  totDel = totErr = 0
  VVqeT6.VVfT17(len(delLst))
  VVqeT6.VVL8uX = (totDel, totErr)
  for lbl in delLst:
   if not VVqeT6 or VVqeT6.isCancelled: return
   VVqeT6.VVX5nT(lbl)
   VVqeT6.VVqE9L(1)
   page = None
   uReq = CCCusX.VVV2aW(self, self.VV3jVw, self.confFile, "readerlist", "&label=%s&action=delete" % FFTnsB(lbl), typ="json")
   if uReq:
    try: page = iUrlopen(uReq, timeout=4)
    except: pass
   if page : totDel += 1
   else : totErr += 1
   if not VVqeT6 or VVqeT6.isCancelled: return
   VVqeT6.VVL8uX = (totDel, totErr)
 def VV8phH(self, title, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  totDel, totErr = VVL8uX
  txt = "Deleted : %s" % totDel
  if totErr: txt += "\n\nFailed : %s" % totErr
  if totDel: self.VVXLnf()
  FF0onH(self, txt, title)
 def VVnuaO(self, VVAIxO, delLst, curLbl, curProt):
  fnc = BF(CCCusX.VVln8I, VVAIxO, curLbl, cbFnc=self.VVXLnf)
  if curProt in ("http", "server", "dvbapi") : FFoTZI(VVAIxO, "Cannot delete protocol=%s" % curProt, 2000)
  elif curLbl in delLst      : fnc()
  else          : FF6pUe(self, fnc, "%s\n\nDelete ?" % curLbl, title="Delete Active Reader")
 def VVxniI(self, lines):
  txt = ""
  for line in lines:
   line = line.strip()
   span = iSearch(r"^[0-9]{4}[-\/][0-9]{2}[-\/][0-9]{2}\s+", line, IGNORECASE)
   if span:
    line = "\n" + VVWJEN + line[:19] + VV0p9P + line[19:]
    for preTxt in (" connecting to ", " from server ", " by ", "reader ", "server ", "(reader) "):
     if preTxt in line:
      if preTxt == " by " and " by WebIf" in line:
       line = line.replace("WebIf", VV0MNp + "WebIf" + VV0p9P)
      else:
       t1, t2, t3 = line.partition(preTxt)
       if t2:
        h1, h2, h3 = t3.partition(" ")
        line = t1 + t2 + VV1l75 + h1 + h2 + VV0p9P + h3
    span = iSearch(r"(.+:\s*)(found\s*)(\(\d+\s*ms\))(.+)", line, IGNORECASE)
    if span:
     line = "\n" + span.group(1) + VVOQkl + span.group(2) + VVk4x7 + span.group(3) + VV0p9P + span.group(4)
    line = self.VV2Fvo(line, VVk4x7, ("(webif)", ))
    line = self.VV2Fvo(line, VVk4x7, ("(anticasc)", "(anticasc)", "(cache)", "(cccam)", "(chk)", "(client)", "(config)", "(dvbapi)", "(ecm)", "(emm)", "(emmcache)", "(emu)", "(main)", "(net)", "(newcamd)", "(reader)", "(stat)"))
    line = self.VV2Fvo(line, VVOQkl, ("OSCam", "NCam", "log switched"))
    line = self.VV2Fvo(line, VVU4M8, (": not found", "failed", "rejected group", "usr/pwd invalid", "timeout", "no matching reader", "disconnected"))
    ndx = line.find(") - ")
    if ndx > -1:
     line = line[:ndx + 3] + VVjojy + line[ndx + 3:] + VV0p9P
    txt += line + "\n"
  self["myLabel"].setText(txt, VV5wgt=VVoR3b)
  return bool(txt.strip())
 def VV2Fvo(self, line, color, lst):
  for txt in lst:
   if txt in line:
    t1, t2, t3 = line.partition(txt)
    if t2:
     return t1 + color + t2 + VV0p9P + t3
  return line
class CCmWdL(Screen):
 def __init__(self, session, args=0):
  self.skin, self.VVmNvK = FFQaOH(VVNkG2, 750, 1000, 50, 60, 30, "#10104060", "#10001A1F", 30)
  self.session  = session
  VV9cxb = []
  VV9cxb.append(("Backup Channels"    , "VVxqTR"   ))
  VV9cxb.append(("Restore Channels"    , "VV51RM"  ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Backup SoftCAM Files"   , "VVn6Zq" ))
  VV9cxb.append(("Restore SoftCAM Files"  , "VVuZBK" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Backup Tuner Settings"  , "bkupTuner"    ))
  VV9cxb.append(("Restore Tuner Settings"  , "restTuner"    ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Backup HotKeys Settings"  , "bkupHKeys"    ))
  VV9cxb.append(("Restore HotKeys Settings"  , "restHKeys"    ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Backup Enigma2 Settings File" , "VVv8Zh"   ))
  VV9cxb.append(("Restore Enigma2 Settings File", "VVlg3v"  ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Backup Network Settings"  , "VVdhG8"   ))
  VV9cxb.append(("Restore Network Settings"  , "VVLkdA"   ))
  if VVSm4H:
   VV9cxb.append(VVbM5H)
   VV9cxb.append(("Backup FHD-Glass17 Skin" , "bkupFhdg17"    ))
   VV9cxb.append(("Restore FHD-Glass17 Skin" , "restFhdg17"    ))
  for i in range(0, len(VV9cxb), 3):
   VV9cxb[i] = (VVWH8U + VV9cxb[i][0], VV9cxb[i][1])
  if VVSm4H:
   c1, c2, c3, c4, c5 =VVdLWL, VVOQkl, VVWH8U , VV1l75, VVk4x7
   VV9cxb.append(VVbM5H)
   VV9cxb.append((c1 + "Fix Data (%s)" % VVxjol , "VVSuyZ"   ))
   VV9cxb.append((c2 + "1- Create IPK"    , "VVhIa51"  ))
   VV9cxb.append((c2 + "2- Create DEB"    , "VVhIa52"  ))
   VV9cxb.append((c3 + "3- Create IPK (No Restart)" , "VVhIa53"  ))
   VV9cxb.append((c3 + "4- Create DEB (No Restart)" , "VVhIa54"  ))
   VV9cxb.append((c3 + "5- Create IPK (No Depend)" , "VVhIa55"  ))
   VV9cxb.append((c3 + "6- Create DEB (No Depend)" , "VVhIa56"  ))
   VV9cxb.append(VVbM5H)
   VV9cxb.append((c4 + "Decode Crash Report"   , "VV6xoF" ))
   VV9cxb.append((c4 + "Show Windows Stats"   , "VV2K9a" ))
   VV9cxb.append((c5 + "%s Simple Portal" % ("Disable" if CFG.simplePortal.getValue() else "Enable") , "VV9Km7" ))
  FFNhKZ(self, title="Backup & Restore", VV9cxb=VV9cxb)
  self.onShown.append(self.VVf1Ra)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  FFvJ8o(self["myMenu"])
  FFNUiO(self)
 def VVyuDa(self):
  item = FFgo5c(self)
  if item is not None:
   if   item == "VVxqTR"  : self.VVxqTR()
   elif item == "VV51RM"  : self.VVEYSq("channels_backup*.tar.gz", self.VV51RM, isChan=True)
   elif item == "VVn6Zq" : self.VVn6Zq()
   elif item == "VVuZBK": self.VVEYSq("softcam_backup*.tar.gz", self.VVuZBK)
   elif item == "bkupTuner"   : self.VVM1wq("tuner_backup", ["config.Nims."])
   elif item == "restTuner"   : self.VVEYSq("tuner_backup*.backup", BF(self.VVBgle, "tuner"), isTuner=True)
   elif item == "bkupHKeys"   : self.VVM1wq("hotkey_backup", ["config.misc.hotkey.", "config.misc.ButtonSetup."])
   elif item == "restHKeys"   : self.VVEYSq("hotkey_backup*.backup", BF(self.VVBgle, "hotk"))
   elif item == "VVv8Zh"  : self.VVv8Zh()
   elif item == "VVlg3v"  : self.VVEYSq("settings_backup*.tar.gz", self.VVlg3v)
   elif item == "VVdhG8"  : self.VVdhG8()
   elif item == "VVLkdA"  : self.VVEYSq("network_backup*.tar.gz", self.VVLkdA)
   elif item == "bkupFhdg17"   : self.VVM1wq("fhdg17_skin_backup", ["config.plugins.setupGlass17."])
   elif item == "restFhdg17"   : self.VVEYSq("fhdg17_skin_backup*.backup", BF(self.VVBgle, "fhdg17"))
   elif item == "VVSuyZ"   : FF6pUe(self, BF(FF8385, self.session, BF(CCmWdL.VVSuyZ, self)), "Erase previous obf ?")
   elif item.startswith("VVhIa5") : self.VVhIa5(int(item[-1]))
   elif item == "VV6xoF" : self.VV6xoF()
   elif item == "VV2K9a"  : CCmWdL.VV2K9a(self)
   elif item == "VV9Km7" : self.VV9Km7()
 def VV9Km7(self):
  FFBWtx(CFG.simplePortal, not CFG.simplePortal.getValue())
  self.close()
 @staticmethod
 def VVqMg2(SELF):
  OBF_Path = VVoFUo + "OBF/"
  if FFKbVo(OBF_Path + "obf.py"):
   from sys import path as iPath
   iPath.append(OBF_Path)
   try: from imp import reload
   except: from importlib import reload
   try: from .OBF import obf
   except: import obf
   reload(obf)
   return obf
  else:
   FFWfGZ(SELF, OBF_Path)
   return None
 @staticmethod
 def VV2K9a(SELF):
  obf = CCmWdL.VVqMg2(SELF)
  if obf:
   txt, title = obf.windowsStats()
   FFSMJz(SELF, txt, title=title, outputFileToSave="WinStat")
 @staticmethod
 def VVSuyZ(SELF):
  obf = CCmWdL.VVqMg2(SELF)
  if obf:
   txt, err = obf.fixCode(VVoFUo, VV8h7S, VVxjol)
   if err : FFbBGq(SELF, err)
   else : FFSMJz(SELF, txt, height=1050)
 def VVhIa5(self, mode):
  OBF_Path = VVoFUo + "OBF/"
  files = iGlob("%s*main_final.py" % OBF_Path)
  if not files:
   FFbBGq(self, "Final File .py not found in:\n\n%s" % OBF_Path)
   return
  FFlonU("rm -f %s__pycache__/" % VVoFUo)
  self.session.open(CC63Xr, path=VVoFUo, VV8uHX=mode in (2, 4, 6), VV5lsI=mode in (3, 4), VVcLek=mode not in (5, 6))
 def VV6xoF(self):
  path = "/tmp/OBF/"
  if not VVkY7E(path):
   FFbBGq(self, "Path not found:\n%s" % path)
   return
  files = iGlob("%s*.log" % path)
  if not files:
   FFbBGq(self, "No log files in:\n\n%s" % path)
   return
  codF, err = self.VVde1z("%s*.list" % path)
  if err:
   FFWfGZ(self, path + "*.list")
   return
  srcF, err = self.VVde1z("%s*main_final.py" % path)
  if err:
   FFWfGZ(self, path + "*.final.py")
   return
  VVXpNQ = []
  for f in files:
   f = os.path.basename(f)
   VVXpNQ.append((f, f))
  FFO9kU(self, BF(self.VVLrov, path, codF, srcF), VV9cxb=VVXpNQ)
 def VVLrov(self, path, codF, srcF, item=None):
  if item:
   logF = path + item
   if not FFKbVo(logF) : FFWfGZ(self, logF)
   else     : self.VVTHlW(logF, codF, srcF)
 @FFJRPn()
 def VVTHlW(self, logF, codF, srcF):
  lst  = []
  lines = FF2kXa(codF)
  for line in lines:
   line = line.split(":")[1]
   parts = line.split("->")
   lst.append((parts[1].strip(), parts[0].strip()))
  if not lst:
   FFbBGq(self, "No codes in : %s" % codF)
   return
  newLogF = logF.replace(".log", ".NEW.log")
  totLog  = self.VVeEew(lst, logF, newLogF)
  if totLog == 0:
   FFbBGq(self, "No match found in this version for:\n\n%s" % os.path.basename(logF))
   return
  newSrcF = srcF.replace(".py" , ".DBG.py")
  totSrc  = self.VVeEew(lst, srcF, newSrcF)
  txt = "Found\t: %s\nIn\t: %s\n\nFound\t: %s\nIn\t: %s\n\nNew Files\t:\n" % (totLog, logF, totSrc, srcF)
  if not totLog and not totSrc:
   txt += "None"
  else:
   if totLog: txt += "    %s\n" % newLogF
   if totSrc: txt += "    %s\n" % newSrcF
  FFSMJz(self, txt)
 def VVde1z(self, patt):
  tFiles = iGlob(patt)
  if not tFiles:
   return "", "*.list"
  f = tFiles[0]
  if not FFKbVo(f):
   return "", "Not found:\n\n"
  return f, ""
 def VVeEew(self, lst, f1, f2):
  txt = FFmx8y(f1)
  tot = 0
  for item in lst:
   if item[0] in txt:
    tot += 1
   txt = txt.replace(item[0], item[1])
  if tot > 0:
   with open(f2, "w") as f:
    f.write(txt)
  return tot
 def VVxqTR(self):
  path1 = VVgVTn
  path2 = "/etc/tuxbox/"
  VVXpNQ = []
  VVXpNQ.append("%s%s" % (path1, "*.tv"))
  VVXpNQ.append("%s%s" % (path1, "*.radio"))
  VVXpNQ.append("%s%s" % (path1, "*list"))
  VVXpNQ.append("%s%s" % (path1, "*list_*"))
  VVXpNQ.append("%s%s" % (path1, "lamedb*"))
  VVXpNQ.append("%s%s" % (path2, "*.xml"))
  CCmWdL.VV0FuB(self, VVXpNQ, self.VVjOCO("channels_backup"), addTimeStamp=True)
 def VVn6Zq(self):
  VVXpNQ = []
  VVXpNQ.append("/etc/tuxbox/config/")
  VVXpNQ.append("/etc/tuxbox/scce/")
  VVXpNQ.append("/etc/CCcam.*")
  VVXpNQ.append("/usr/keys/")
  VVXpNQ.append("/usr/scam/")
  VVXpNQ.append("/etc/tuxbox/*cam*")
  VVXpNQ.append("/etc/tuxbox/*Cam*")
  VVXpNQ.append("/usr/local/etc/oscam*.*")
  VVXpNQ.append("/usr/local/etc/ncam*.*")
  VVXpNQ.append("/etc/oscam*.*")
  VVXpNQ.append("/etc/ncam*.*")
  VVXpNQ.append("/etc/uniqid")
  CCmWdL.VV0FuB(self, VVXpNQ, self.VVjOCO("softcam_backup"), addTimeStamp=True)
 def VVdhG8(self):
  VVXpNQ = []
  VVXpNQ.append("/etc/hostname")
  VVXpNQ.append("/etc/default_gw")
  VVXpNQ.append("/etc/resolv.conf")
  VVXpNQ.append("/etc/wpa_supplicant*.conf")
  VVXpNQ.append("/etc/network/interfaces")
  VVXpNQ.append("%snameserversdns.conf" % VVgVTn)
  CCmWdL.VV0FuB(self, VVXpNQ, self.VVjOCO("network_backup"), addTimeStamp=True)
 def VVv8Zh(self):
  CCmWdL.VV0FuB(self, [VVlLfA], self.VVjOCO("settings_backup"), addTimeStamp=True)
 def VVlg3v(self, path=None):
  if path:
   ques = "Overwrite %s File (and restart) ?" % VVlLfA
   img = CCg47Y.VVvjvY()
   if img:
    if not img.lower() in path.lower():
     ques = "This file is not labeled with your image name (%s)\n\n%s" % (FFKrMM(img, VVjojy), ques)
   FF6pUe(self, BF(self.VVIKV7, path), ques)
 def VVIKV7(self, path):
  path = FFJv8S() + path
  pathInTar = VVlLfA.lstrip("/")
  res = FF2ndj("tar -tf '%s' '%s'" % (path, pathInTar))
  if not res == pathInTar:
   FFbBGq(self, "Cannot read settings file from:\n\n%s" % path)
   return
  if not FFlonU("cp -rf '%s' '%s.bak'" % (VVlLfA, VVlLfA)):
   FFbBGq(self, "Cannot backup the file:\n\n%s" % VVlLfA)
   return
  if not FFlonU("tar -C / -xf '%s' '%s'" % (path, pathInTar)):
   FFbBGq(self, "Cannot read settings file from:\n\n%s" % path)
   return
  if FFlonU("tar -C / -xzf '%s%s'" % (FFJv8S(), path)):
   FFbBGq(self, "Cannot restore the file:\n\n%s" % VVlLfA)
   return
  FF9CWb(self, "echo 'Applying new settings ...'")
 def VVjOCO(self, fName):
  img = CCg47Y.VVvjvY()
  if img: fName = "%s_%s" % (fName, img)
  return fName
 def VV51RM(self, fileName=None):
  if fileName:
   FF6pUe(self, BF(self.VVgOJq, fileName), "Overwrite current channels ?")
 @FFJRPn("Restoring ...")
 def VVgOJq(self, fileName):
  path = FFJv8S() + fileName
  if FFKbVo(path):
   if CC17eA.VVcnM6(path):
    VVO4q6 , VVdRDV = CC2Ekb.VV2yDM()
    VVVKXl, VVGgJ3 = CC2Ekb.VVnOwm()
    cmd  = FFQWwc("cd %s" % VVgVTn)
    cmd += FFQWwc("rm -f *.tv *.radio *.del lamedb* whitelist blacklist satellites.xml %s %s" % (VVdRDV, VVGgJ3))
    cmd += "tar -C / -xzf '%s'" % path
    ok = FFlonU(cmd)
    FFANYL()
    if ok: FF0onH(self, "Channels Restored.")
    else : FFbBGq(self, "Error while restoring:\n\n%s" % fileName)
   else:
    FFbBGq(self, "Invalid tar file:\n\n%s" % path)
  else:
   FFWfGZ(self, path)
 def VVuZBK(self, fileName=None):
  if fileName:
   FF6pUe(self, BF(self.VVsF36, fileName), "Overwrite SoftCAM files ?")
 def VVsF36(self, fileName):
  fileName = FFJv8S() + fileName
  txt = FF4aqG("tar -C / -xzf '%s'" % fileName)
  if txt : FFSMJz(self, "Error while restoring SoftCam files from:\n\n%s\n\n%s\n\nError:\n\n%s" % (fileName, SEP, txt), isErr=True)
  else : FF0onH(self, "SoftCam Files Restored.\n\n( You may need to restart your SoftCAM )")
 def VVLkdA(self, fileName=None):
  if fileName:
   FF6pUe(self, BF(self.VVWsgx, fileName), "Overwrite Network Settings (and REBOOT) ?")
 def VVWsgx(self, fileName):
  fileName = FFJv8S() + fileName
  if FFKbVo(fileName):
   cmd = "tar -C / -xzvf '%s';" % fileName
   cmd += "echo ''; echo 'REBOOTING ...';"
   cmd += "sleep 3; reboot"
   FF6NKJ(self,  cmd)
  else:
   FFWfGZ(self, fileName)
 def VVEYSq(self, pattern, callBackFunction, isTuner=False, isChan=False):
  title = FFJ4QU()
  if VVkY7E(FFJv8S()):
   myFiles = FFYvtE(FFJv8S(), pattern)
   if len(myFiles) > 0:
    myFiles.sort(key=os.path.getmtime, reverse=True)
    VVXpNQ = []
    for myFile in myFiles:
     fileName = os.path.basename(myFile)
     VVXpNQ.append((fileName, fileName))
    if len(myFiles) > 1:
     title = title + " (Sorted by time)"
    if   isTuner  : VVWt1H = ("Sat. List", self.VVaiFN)
    elif isChan and iTar: VVWt1H = ("Bouquets Importer", CCUyKl.VVSLMY)
    else    : VVWt1H = None
    VVGbyT = ("Rename ", self.VVyrUY)
    VVF79M = self.VVaGMh
    FFO9kU(self, callBackFunction, title=title, width=1200, VV9cxb=VVXpNQ, VVF79M=VVF79M, VVWt1H=VVWt1H, VVGbyT=VVGbyT, VV1NnQ=FFJv8S())
   else:
    FFbBGq(self, "No files found in:\n\n%s" % FFJv8S(), title)
  else:
   FFbBGq(self, "Path not found:\n\n%s" % FFJv8S(), title)
 def VVaGMh(self, VVhzhr, txt, ref, ndx):
  ttl = lambda x, y: "%s:\n%s\n\n" % (FFKrMM(x, VVk4x7), y)
  txt  = ttl("File", txt)
  txt += ttl("Path", FFJv8S())
  txt += ttl("Note", FFKrMM("%s can restore this file on any image." % PLUGIN_NAME, VVWH8U))
  FFSMJz(self, txt)
 def VVyrUY(self, VVhzhr, fName):
  left = name = right = ""
  for prefix in ("channels_backup_", "softcam_backup_", "settings_backup_", "network_backup_"):
   ext = ".tar.gz"
   if fName.startswith(prefix) and fName.endswith(ext):
    left, name, right, = prefix, fName[len(prefix):-len(ext)], ext
    break
  if not name:
   for prefix in ("tuner_backup_", "hotkey_backup_", "fhdg17_skin_backup_"):
    ext = ".backup"
    if fName.startswith(prefix) and fName.endswith(ext):
     left, name, right, = prefix, fName[len(prefix):-len(ext)], ext
     break
  if not name:
   name = fName
  FFANcN(self, BF(self.VVTi2D, VVhzhr, fName, left, name, right), defaultText=name, title="Rename: %s .. %s" % (left, right), message="New name:")
 def VVTi2D(self, VVhzhr, fName, left, name, right, nName):
  if nName is not None:
   if not nName: left = left.rstrip("_")
   nName = left + nName + right
   bPath = FFJv8S()
   if   fName == nName    : FFoTZI(VVhzhr, "No change", 800)
   elif FFKbVo(bPath + nName) : FFbBGq(self, "Name already exists:\n\n%s" % nName)
   else       : FF6pUe(self, BF(self.VVKTMa, VVhzhr, bPath, fName, nName), "Rename to:\n\n%s" % nName, title=fName)
 def VVKTMa(self, VVhzhr, bPath, fName, nName):
  fPath = bPath + fName
  nPath = bPath + nName
  try:
   stat = os.stat(fPath)
   os.rename(fPath, nPath)
   os.utime(nPath, (stat.st_atime, stat.st_mtime))
   VVhzhr.VVVN5V((nName, nName))
   FFxHED(VVhzhr, "Renamed", 800)
  except Exception as e:
   FFbBGq(self, str(e), title="Rename")
 def VVM1wq(self, filePrefix, grepLst):
  if not FFKbVo(VVlLfA):
   FFbBGq(self, "Cannot read settings file")
   return
  grep = r"\|".join(grepLst)
  lines = FFQ1wB("cat '%s' | grep '%s'" % (VVlLfA, grep))
  if not lines:
   FFbBGq(self, "No settings found")
  for line in lines:
   if not any(x in line for x in grepLst):
    FFbBGq(self, "\n".join(lines))
    return
  else:
   path = "%s%s%s_%s.backup" % (FFJv8S(), filePrefix, self.VVjOCO(""), FFRIlf())
   try:
    with open(path, "w") as f:
     f.write("%s\n" % "\n".join(lines))
    FF0onH(self, "Result File:\n\n%s" % path)
   except Exception as e:
    FFbBGq(self, str(e))
 def VVBgle(self, mode, path=None):
  if not path:
   return
  path = FFJv8S() + path
  if not FFKbVo(path):
   FFWfGZ(self, path)
   return
  elif not FFKbVo(VVlLfA):
   FFWfGZ(self, VVlLfA)
   return
  if   mode == "tuner" : subj, grepLst = "Tuner"  , [".Nims."]
  elif mode == "hotk"  : subj, grepLst = "Hotkeys" , [".hotkey.", ".ButtonSetup."]
  elif mode == "fhdg17": subj, grepLst = "FHDG17-Skin", [".setupGlass17."]
  lines = FF2kXa(path)
  lst1 = []
  for line in lines:
   if line.strip() and not line in lst1 and any(x in line for x in grepLst):
    lst1.append(line)
  if not lst1:
   FFbBGq(self, "Nothing to restore from:\n\n%s" % path)
   return
  lst2 = []
  if mode == "tuner":
   for line in lines:
    span = iSearch(r"(.+\..+\.\d+\.)(.+)", line)
    if span:
     if span.group(2).startswith("dvbs."): line = span.group(1) + span.group(2)[5:]
     else        : line = span.group(1) + "dvbs." + span.group(2)
     if not line in lst1:
      lst2.append(line)
   lst = lst1 + lst2
   if nimmanager.nim_slots:
    if "dvbs" in config.Nims[0].dict() : lst = [x for x in lst if ".dvbs." in x]
    else        : lst = [x for x in lst if ".dvbs." not in x]
  elif mode == "hotk":
   pli, atv = ".hotkey.", ".ButtonSetup."
   for line in lines:
    if   atv in line: line = line.replace(atv, pli)
    elif pli in line: line = line.replace(pli, atv)
    if not line in lst1:
     lst2.append(line)
   lst = lst1 + lst2
   if CCmWdL.VV1oHD() : lst = [x for x in lst if atv in x]
   else          : lst = [x for x in lst if atv not in x]
  FF6pUe(self, BF(self.VV05u0, lst, grepLst), "Overwrite %s settings (and restart) ?" % subj)
 def VV05u0(self, lines, grepLst):
  tFile = "/tmp/ajp_tmp"
  try:
   with open(tFile, "w") as f:
    for line in FF2kXa(VVlLfA):
     if line.strip() and not any(x in line for x in grepLst):
      f.write("%s\n" % line)
    for ndx, line in enumerate(lines):
     f.write("%s%s" % (line, "" if ndx == len(lines) - 1 else "\n"))
  except Exception as e:
   FFbBGq(self, str(e))
   return
  cmd  = "echo 'Applying new settings ...';"
  cmd += "mv -f '%s' '%s'" % (tFile, VVlLfA)
  FF9CWb(self, cmd)
 @staticmethod
 def VV1oHD():
  from sys import modules
  return "Screens.ButtonSetup" in modules
 def VVaiFN(self, selectionObj, path):
  if not path:
   return
  path = FFJv8S() + path
  if not FFKbVo(path):
   FFWfGZ(self, path)
   return
  txt = FFmx8y(path)
  satList = []
  lst = iFindall(r".+[.](diseqc.?)[=](\d+)", txt, IGNORECASE)
  for sat in lst:
   diseqc = sat[0].upper()
   satNum = sat[1]
   satList.append((diseqc.replace("DISEQC", "DiSEqC-"), satNum))
  lst = iFindall(r".+[.]sat[.](\d+)[.](lnb[=].+)", txt, IGNORECASE)
  for sat in lst:
   satNum = sat[0]
   lnb  = sat[1].upper()
   satList.append((lnb.replace("LNB=", "LNB-"), satNum))
  if satList:
   satList = list(set(satList))
   satList.sort(key=lambda x: x[0])
   txt = ""
   for item in satList:
    txt += "%s\t%s\n" % (item[0], FFUti6(item[1]))
   FFSMJz(self, txt, title="Satellites List")
  else:
   FFbBGq(self, "Incorrect Tuner Backup file !\n\n(or missing info.)", title="  Satellites List")
 @staticmethod
 def VV0FuB(SELF, pathList, tarFileName, addTimeStamp=True):
  VVXpNQ = []
  t = ""
  for path in pathList:
   if os.path.isfile(path):
    if FFKbVo(path):
     VVXpNQ.append(path)
   elif os.path.isdir(path):
    if os.listdir(path):
     VVXpNQ.append(path)
   else:
    VVGKHT  = os.path.dirname(path)
    fileName = os.path.basename(path)
    fileName = fileName.replace("*", ".*")
    if CCmWdL.VVxwVS(VVGKHT, fileName):
     VVXpNQ.append(path)
  if not VVXpNQ:
   FFbBGq(SELF, "Files not found!")
  elif not VVkY7E(FFJv8S()):
   FFbBGq(SELF, "Path not found!\n\n%s" % FFJv8S())
  else:
   VVlZdM = FFJv8S()
   tarFileName = "%s%s" % (VVlZdM, tarFileName)
   if addTimeStamp:
    tarFileName = "%s_%s" % (tarFileName, FFRIlf())
   tarFileName += ".tar.gz"
   filesLine = ""
   for f in VVXpNQ:
    filesLine += "%s " % f
   failed = "Process failed !"
   cmd  = "echo 'Collecting files ...';"
   cmd += "tar -czf '%s' %s 2> /dev/null;" % (tarFileName, filesLine)
   cmd += "if [ -f '%s' ]; then "   % tarFileName
   cmd += " chmod 644 '%s';"    % tarFileName
   cmd += " echo -e '\nDONE\n';"
   cmd += " echo -e '\nResult File:\n%s\n' %s;" % (tarFileName, FFuLAo(tarFileName, VVOQkl))
   cmd += " echo '';"
   cmd += "else"
   cmd += " echo -e '\n%s\n' %s;"   % (failed, FFuLAo(failed, VVOQkl))
   cmd += "fi;"
   FFg05d(SELF, cmd, VVWRZK=True)
 @staticmethod
 def VVxwVS(Dir, patt):
  lst = []
  if Dir:
   exp = iCompile(patt)
   for root, dirs, files in os.walk(Dir):
    for f in files:
     if exp.match(f) is not None:
      lst.append((root, f))
  return lst
class CCUyKl():
 def __init__(self, SELF):
  self.SELF   = SELF
  self.Title   = "Bouquets Importer"
  self.fileName  = ""
  self.filePath  = ""
  self.instance  = None
  self.isZip   = False
  self.cbFnc   = None
 @staticmethod
 def VVSLMY(SELF, fName):
  bi = CCUyKl(SELF)
  bi.instance = bi
  bi.VVpBWz(fName)
 @staticmethod
 def VVeuTk(SELF, cbFnc=None):
  bi = CCUyKl(SELF)
  bi.instance = bi
  bi.cbFnc = cbFnc
  bi.VVUH4s()
 def VVpBWz(self, fName):
  self.fileName = fName
  self.filePath = FFJv8S() + fName
  self.isZip   = fName.endswith(".zip")
  if FFKbVo(self.filePath): self.VVAWUP()
  else      : self.VV69I1(self.filePath)
 def VVJf3H(self, txt) : FFbBGq(self.SELF, txt, title=self.Title)
 def VVAdNn(self, txt)  : FFoTZI(self, txt, 1500)
 def VV69I1(self, path) : FFWfGZ(self.SELF, path, title=self.Title)
 def VVUH4s(self):
  if VVkY7E(FFJv8S()):
   lst = FFYvtE(FFJv8S(), "channels_backup*.tar.gz")
   if iZip: lst.extend(self.VVS2b1())
   if len(lst) > 0:
    VV9cxb = []
    for item in lst:
     item = os.path.basename(item)
     txt = FFKrMM(item, VVk4x7) if item.endswith(".zip") else item
     VV9cxb.append((txt, item))
    VV9cxb.sort(key=lambda x: x[1].lower())
    FFO9kU(self.SELF, self.VVPdyZ, VV3an7=3, title=self.Title, width=1200, VV9cxb=VV9cxb, VV1NnQ=FFJv8S(), VVfWsQ="#22111111", VVB5I5="#22111111")
   else:
    self.VVJf3H("No valid backup files found in:\n\n%s" % FFJv8S())
  else:
   self.VVJf3H("Backup Directory not found:\n\n%s" % FFJv8S())
 def VVPdyZ(self, fName=None):
  if fName:
   self.VVpBWz(fName)
  else:
   if self.instance: del self.instance
 def VVS2b1(self):
  files = FFYvtE(FFJv8S(), "*.zip")
  lst = []
  try:
   for path in files:
    bakFile = os.path.basename(path)
    with iZip.ZipFile(path) as zipF:
     dbFound = bFound = False
     for zipInfo in zipF.infolist():
      fName = os.path.basename(zipInfo.filename)
      if fName == "lamedb" : dbFound = True
      if fName.endswith(".tv"): bFound = True
      if dbFound and bFound:
       lst.append(bakFile)
       break
  except:
   pass
  return lst
 def VV5EKf(self, lines):
  lst = []
  for line in lines:
   span = iSearch(r".+(userbouquet\..+\.(tv|radio))", line, IGNORECASE)
   if span:
    lst.append(span.group(1))
  return lst
 def VVAWUP(self):
  CCV3Gw.VVgWD3(self.SELF, VVN6I4="Reading Bouquets ...", titleBg="#22003344", bodyBg="#22001122"
      , VVuSHu  = self.VVHNAS
      , VVhK3C = self.VVL61X)
 def VVHNAS(self, VVqeT6):
  lines, err = CCUyKl.VVenXe(self.filePath, "bouquets.tv")
  if err:
   self.VVJf3H(err)
   return
  bTvSortLst  = self.VV5EKf(lines)
  lines, err = CCUyKl.VVenXe(self.filePath, "bouquets.radio")
  if err:
   self.VVJf3H(err)
   return
  bRadSortLst = self.VV5EKf(lines)
  if not VVqeT6 or VVqeT6.isCancelled:
   return
  self.VVuGUx = []
  self.subBouquets = {}
  if self.filePath.endswith(".zip"):
   with iZip.ZipFile(self.filePath) as zipF:
    zInfLst = zipF.infolist()
    VVqeT6.VVfT17(len(zInfLst))
    for zipInfo in zInfLst:
     fName = os.path.basename(zipInfo.filename)
     if not VVqeT6 or VVqeT6.isCancelled: return
     VVqeT6.VVX5nT(fName)
     VVqeT6.VVqE9L(1)
     span = iSearch(r"userbouquet\..+\.(tv|radio)$", fName, IGNORECASE)
     if span:
      mode = span.group(1)
      with zipF.open(zipInfo.filename) as f:
       row, bnbLst, err = self.VVN27A(f, mode, len(self.VVuGUx), zipInfo.filename, "-", False)
       if err:
        return
       tName = os.path.basename(row[11])
       parenB = row[1]
       if   tName in bTvSortLst : row[0] = str(bTvSortLst.index(tName))
       elif tName in bRadSortLst: row[0] = str(1000000 + bRadSortLst.index(tName))
       self.VVuGUx.append(row)
       lst = []
       for fPath in bnbLst:
        for zipInfo in zipF.infolist():
         if fPath == os.path.basename(zipInfo.filename):
          with zipF.open(zipInfo.filename) as f:
           row, bnbLst, err = self.VVN27A(f, mode, len(self.VVuGUx), zipInfo.filename, parenB, True)
           if err:
            return
           lst.append(row)
       if lst:
        self.subBouquets[tName] = lst
  else:
   with iTar.open(self.filePath) as tar:
    members = tar.getmembers()
    VVqeT6.VVfT17(len(members))
    for mem in members:
     fName = os.path.basename(mem.name)
     if not VVqeT6 or VVqeT6.isCancelled: return
     VVqeT6.VVX5nT(fName)
     VVqeT6.VVqE9L(1)
     span = iSearch(r"userbouquet\..+\.(tv|radio)$", fName, IGNORECASE)
     if span:
      mode = span.group(1)
      f = tar.extractfile(mem)
      row, bnbLst, err = self.VVN27A(f, mode, len(self.VVuGUx), mem.name, "-", False)
      if err:
       return
      tName = os.path.basename(row[11])
      parenB = row[1]
      if   tName in bTvSortLst : row[0] = str(bTvSortLst.index(tName))
      elif tName in bRadSortLst: row[0] = str(1000000 + bRadSortLst.index(tName))
      self.VVuGUx.append(row)
      lst = []
      for fPath in bnbLst:
       for mem in tar.getmembers():
        if fPath == os.path.basename(mem.name):
         f = tar.extractfile(mem.name)
         row, bnbLst, err = self.VVN27A(f, mode, len(self.VVuGUx), mem.name, parenB, True)
         if err:
          return
         lst.append(row)
      if lst:
       self.subBouquets[tName] = lst
 def VVL61X(self, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  if self.VVuGUx:
   self.VVuGUx.sort(key=lambda x: int(x[0]))
   for ndx, item in enumerate(self.VVuGUx): self.VVuGUx[ndx][0] = str(ndx + 1)
   for key, lst in self.subBouquets.items():
    for ndx, row in enumerate(self.VVuGUx):
     if key == os.path.basename(row[11]):
      self.VVuGUx = self.VVuGUx[:ndx+1] + lst + self.VVuGUx[ndx+1:]
      break
   for ndx, item in enumerate(self.VVuGUx): self.VVuGUx[ndx][0] = str(ndx + 1)
   VVYCun = "#11000600"
   VVUZ91 = self.VVzzuH
   VVj7lw  = ("Show Services"  , self.VVFxtM  , [])
   VVmolf = (""     , self.VVVTIB, [])
   VVwqVu = ("Import to System" , self.VV60Ic  , [])
   VV46TD = ("Multi-Select"  , self.VV0iBS, [])
   header   = ("Num" , "Bouquet Name", "Parent Bouquet" , "Mode", "Items" , "DVB" , "IPTV", "S.Relay" , "Local" , "Marker" , "Bouquet" , "File")
   widths   = (7  ,  36   , 0.01    , 7  , 7   , 7  , 7  , 7   , 7   , 7   , 8   ,  0.01 )
   VV4Uoc  = (CENTER ,  LEFT   , LEFT    , CENTER, CENTER , CENTER, CENTER, CENTER , CENTER , CENTER , CENTER ,  LEFT )
   tbl = FFCXsL(self.SELF, None, title=self.Title, header=header, VVXpNQ=self.VVuGUx, VV4Uoc=VV4Uoc, VV8boH=widths, VVPYL1=24, height=1000, VVj7lw=VVj7lw, VVmolf=VVmolf, VVUZ91=VVUZ91, VVwqVu=VVwqVu, VV46TD=VV46TD, VVMBr1=1, VVAGe1=CFG.lastFindServers, VVfWsQ=VVYCun, VVB5I5=VVYCun, VVYCun=VVYCun, VVmErq="#00004455", VVK8UQ="#0a282828")
   tbl.VVQ4nk(BF(self.VVzzuH, tbl))
  else:
   self.VVJf3H("No valid bouquets in:\n\n%s" % os.path.basename(self.filePath))
 def VV60Ic(self, VVAIxO, title, txt, colList):
  if VVAIxO["keyGreen"].getVisible():
   cnt = 0
   if VVAIxO.VVGZGK:
    rows = VVAIxO.VVdxfP()
    for ndx, totBnb in enumerate(VVAIxO.VVKa9C(10)):
     if VVAIxO.VVDjAB(ndx) and totBnb.isdigit() and int(totBnb) > 0:
      VVAIxO.VVSDiu(ndx, mode=0, movDn=False)
      cnt += 1
   if cnt == 0:
    if VVAIxO.VVGZGK:
     tot = VVAIxO.VVAGI8()
     ques = "Import %s Bouquet%s" % (FFKrMM(tot, VVOQkl), FFaRsj(tot))
    else:
     bName = VVAIxO.VVQDwi()[1]
     ques = "Import Bouquet ?\n\n%s" % bName
    FF6pUe(self.SELF, BF(self.VVksJc, VVAIxO, self.filePath), ques, title=self.Title)
   else:
    FF8bV6(VVAIxO, "Fixed Selections : %s" % cnt, 2000)
 def VVzzuH(self, VVAIxO):
  VVAIxO["keyGreen"].hide()
  if VVAIxO.VVGZGK:
   if VVAIxO.VVAGI8() > 0:
    VVAIxO["keyGreen"].show()
  else:
   totBnb = VVAIxO.VVQDwi()[10]
   if not (totBnb.isdigit() and int(totBnb) > 0):
    VVAIxO["keyGreen"].show()
 def VVVTIB(self, VVAIxO, title, txt, colList):
  totBnb = VVAIxO.VVQDwi()[10]
  if totBnb.isdigit() and int(totBnb) > 0:
   c1, c2 = VVdLWL, VVk4x7
   txt += "\n%sNote:\n" % c1
   txt += "%s- This bouquet includes %s%s%s Sub-Bouquet%s.\n" % (c2, c1, totBnb, c2, FFaRsj(int(totBnb)))
   txt += "- Its-Sub-Bouquets will follow it in the list (in yellow) if exist in the backup file."
  FFSMJz(self.SELF, txt, title=title)
 def VV0iBS(self, VVAIxO, title, txt, colList):
  CC17aQ(self.SELF, VVAIxO, addSep=False, setsOk=True).VV4sFy(None, None, width=700)
 def VVFxtM(self, VVAIxO, title, txt, colList):
  if FFKbVo(self.filePath):
   num, bName, parentB, bMode, totItem, totDVB, totIptv, totSRelay, totLoc, totMrk, totBnb, fName = VVAIxO.VVQDwi()
   CCV3Gw.VVgWD3(self.SELF, VVN6I4= "Reading Services ...", titleBg="#22003344", bodyBg="#22001122"
       , VVuSHu  = BF(self.VVc9m3, bName, fName)
       , VVhK3C = BF(self.VVOWNB, VVAIxO, bName))
  else:
   FFoTZI(VVAIxO, "Cannot open file !", 1500)
 def VVc9m3(self, bName, fName, VVqeT6):
  lines, err = CCUyKl.VVenXe(self.filePath, "lamedb")
  if err:
   self.VVJf3H(err)
   return
  dbServLst = CC2Ekb.VVLSxp(lines, mode=10)
  lines, err = CCUyKl.VVenXe(self.filePath, os.path.basename(fName))
  if err:
   self.VVJf3H(err)
   return
  if not VVqeT6 or VVqeT6.isCancelled: return
  patt = iCompile(r"1:64:(?:[a-f0-9]+:){8}:(.+)"
      r'|.+1:7:.+FROM BOUQUET\s+"(.+)"'
      r"|(?:[a-f0-9]+:){10}http.+:(.+)"
      r"|(?:[a-f0-9]+:){10}(\/.+)"
      r'|.+1:7:.+FROM BOUQUET\s+"(.+)"'
      r"|((?:[a-f0-9]+:){10})(?:$|:.+)"
      , IGNORECASE)
  VVqeT6.VVfT17(len(lines))
  VVuGUx = []
  bnbFound = False
  for line in lines:
   if not VVqeT6 or VVqeT6.isCancelled: return
   VVqeT6.VVqE9L(1)
   iSleep(0.0005)
   if line.startswith("#SERVICE "):
    span = patt.search(line)
    if span:
     g1, g2, g3, g4, g5, g6 = span.groups()
     if   g1: VVuGUx.append((g1.strip(), "Marker"))
     elif g2: VVuGUx.append((g2 or "-", "Sub-Bouquet"))
     elif g3: VVuGUx.append((g3.strip() or "-", "Stream Relay" if FFKeSw(line) else "IPTV"))
     elif g4: VVuGUx.append((os.path.basename(g4.strip() or "-"), "Local Media"))
     elif g5: VVuGUx.append((g5 or "-", "Sub-Bouquet"))
     elif g6:
      dbCode = CC2Ekb.VVpvrS(g6)
      for dbCode1, name, prov in dbServLst:
       if dbCode1.upper() in dbCode:
        VVuGUx.append((name.strip() or "-", FFgAAw(g6, False)))
        break
     if any((g2, g5)):
      bnbFound = True
     if not VVqeT6 or VVqeT6.isCancelled: return
     if VVuGUx:
      VVqeT6.VVX5nT(VVuGUx[len(VVuGUx) - 1][0])
  if bnbFound:
   if not VVqeT6 or VVqeT6.isCancelled: return
   VVqeT6.VVfT17(len(VVuGUx))
   VVqeT6.VVOwDF(0)
   for ndx, item in enumerate(VVuGUx):
    name, descr = item
    if not VVqeT6 or VVqeT6.isCancelled: return
    VVqeT6.VVX5nT(name)
    VVqeT6.VVqE9L(1)
    if iMatch(r".+\.tv", name, IGNORECASE):
     lines, err = CCUyKl.VVenXe(self.filePath, os.path.basename(name))
     if lines and not err:
      span = iSearch(r"#NAME\s+(.+)", lines[0], IGNORECASE)
      if span:
       bName = span.group(1).strip()
       if bName:
        VVuGUx[ndx] = (bName, descr)
  if not VVqeT6 or VVqeT6.isCancelled:
   return
  VVqeT6.VVL8uX = VVuGUx
 def VVOWNB(self, VVAIxO, bName, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  if VVL8uX:
   VVYCun = "#11001122"
   bName = iSub(r"\s{4,}" ," .. " , bName)
   header  = ("Service", "Type")
   widths  = (80  , 20 )
   VV4Uoc = (LEFT  , CENTER)
   FFCXsL(self.SELF, None, title="Services in : %s" % bName, header=header, VVXpNQ=VVL8uX, VV4Uoc=VV4Uoc, VV8boH=widths, VVPYL1=26, VVfWsQ=VVYCun, VVB5I5=VVYCun, VVYCun=VVYCun, VVmErq="#11550033", VVAGe1=CFG.lastFindServers)
  elif not VV6ZvL:
   pass
  else:
   FFoTZI(VVAIxO, "No valid services !", 1500)
 def VVN27A(self, f, mode, sequence, fPath, parentB, isSubB):
  bName = ""
  totItem = totDVB = totMrk = totBnb = totIptv = totSRelay = totLoc = 0
  bnbLst = []
  for line in f:
   try:
    line = str(line.decode()).strip()
   except:
    self.VVJf3H("Encoding Error in the archived file:\n\n%s" % fPath)
    return [], [], "File Encoding Error"
   if line.startswith("#SERVICE "):
    totItem +=1
    if   iMatch(r".+1:64:(?:[A-Fa-f0-9]+:){8}:.+", line)    : totMrk += 1
    elif FFKeSw(line)           : totSRelay += 1
    elif iMatch(r".+(?:[A-Fa-f0-9]+:){10}http.+:.+", line, IGNORECASE) : totIptv += 1
    elif iMatch(r".+(?:[A-Fa-f0-9]+:){10}\/.+", line)     : totLoc += 1
    elif iMatch(r".+(?:[A-Fa-f0-9]+:){10}(?:$|:.+)", line)    : totDVB += 1
    else:
     span = iSearch(r'.+1:7:.+FROM BOUQUET\s+"(.+)".+', line, IGNORECASE)
     if span:
      totBnb += 1
      bnbLst.append(span.group(1))
   elif line.startswith("#NAME "):
    bName = line[6:]
  chColor = lambda x: str(x) if x else "#f#00666666#" + str(x)
  bMode = "TV" if mode == "tv" else "Radio"
  if   totBnb : fg, totBnb  = "#f#00ff5522#" , str(totBnb)
  elif isSubB : fg, totBnb  = "#f#00ffffbb#" , "Sub-B."
  else  : fg, totBnb = ""    , chColor(totBnb)
  row = [str(2000001 + sequence), fg + bName, parentB, fg + bMode, "#f#00ff88ff#" + str(totItem), chColor(totDVB), chColor(totIptv), chColor(totSRelay), chColor(totLoc), chColor(totMrk), fg + totBnb, fPath]
  return row, bnbLst, ""
 def VVksJc(self, VVAIxO, archPath):
  title = "Import Bouquets"
  tvBouquetFile  = VVgVTn + "bouquets.tv"
  radBouquetFile = VVgVTn + "bouquets.radio"
  for f in (tvBouquetFile, radBouquetFile):
   if not FFKbVo(f):
    FFWfGZ(self.SELF, f, title=title)
    return
  isMulti = VVAIxO.VVGZGK
  if isMulti : rows = VVAIxO.VVdxfP()
  else  : rows = [VVAIxO.VVQDwi()]
  CCV3Gw.VVgWD3(self.SELF, VVN6I4=title, titleBg="#22003344", bodyBg="#22001122", totBars=2
      , VVuSHu  = BF(self.VVMMSe, VVAIxO, rows, archPath, tvBouquetFile, radBouquetFile, title)
      , VVhK3C = BF(self.VVel6P, title) )
 def VVMMSe(self, VVAIxO, rows, archPath, tvBouquetFile, radBouquetFile, title, VVqeT6):
  totTP = totServ = totTv = totRad = totMissTP = totMissServ = totMissSRelay = totAllServ = 0
  totBouq = len(rows)
  VVqeT6.VVfT17(totBouq)
  VVqeT6.VVH2AI(totBouq)
  VVqeT6.VVL8uX = (totBouq, totAllServ, totTP, totServ, totTv, totRad, totMissTP, totMissServ, totMissSRelay)
  bList = []
  totAllServ = 0
  if FFKbVo(archPath):
   for num, bName, parentB, bMode, totItem, totDVB, totIptv, totSRelay, totLoc, totMrk, totBnb, fName in rows:
    if not VVqeT6 or VVqeT6.isCancelled:
     return
    VVqeT6.VVX5nT(bName)
    VVqeT6.VVqE9L(1)
    totAllServ += int(totItem)
    newFile = os.path.basename(fName)
    span = iSearch(r".+\.(.+)\.(tv|radio)", newFile, IGNORECASE)
    if span : fNamePart, fNameExt = span.group(1), span.group(2)
    else : fNamePart, fNameExt = "bouquet", "tv"
    newFile = "userbouquet.%s.%s" % (fNamePart, fNameExt)
    bPath = VVgVTn + newFile
    num  = 0
    while FFKbVo(bPath):
     num += 1
     newFile = "userbouquet.%s_%d.%s" % (fNamePart, num, fNameExt)
     bPath = VVgVTn + newFile
    CCUyKl.VVBiW9(archPath, fName, VVgVTn, newFile)
    if FFKbVo(bPath):
     bList.append(newFile)
  if not VVqeT6 or VVqeT6.isCancelled:
   return
  if bList:
   FF03ch(tvBouquetFile)
   FF03ch(radBouquetFile)
   for bFile in bList:
    if bFile.endswith("tv") : mainBFile, totTv = tvBouquetFile , totTv  + 1
    else     : mainBFile, totRad = radBouquetFile, totRad + 1
    with open(mainBFile, "a") as f:
     f.write('#SERVICE 1:7:1:0:0:0:0:0:0:0:FROM BOUQUET "%s" ORDER BY bouquet\n' % bFile)
   if not VVqeT6 or VVqeT6.isCancelled:
    return
   VVqeT6.VVL8uX = (totBouq, totAllServ, totTP, totServ, totTv, totRad, totMissTP, totMissServ, totMissSRelay)
   totTP, totServ, totMissTP, totMissServ, totMissSRelay = self.VVAngJ(archPath, bList, VVqeT6)
   VVqeT6.VVL8uX = (totBouq, totAllServ, totTP, totServ, totTv, totRad, totMissTP, totMissServ, totMissSRelay)
 def VVel6P(self, title, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  FFANYL()
  totBouq, totAllServ, totTP, totServ, totTv, totRad, totMissTP, totMissServ, totMissSRelay = VVL8uX
  c1, c2 = VVk4x7, VVdLWL
  txt  = FFKrMM("Added:\n", VVk4x7)
  txt += "Bouquets\t: %d     (%d TV , %d Radio)\n" % (totBouq, totTv, totRad)
  txt += "Services\t: %d\n" % totAllServ
  if totTP or totServ:
   txt += "\n"
   txt += FFKrMM("Imported to lamedab:\n", VVk4x7)
   if totTP : txt += "Transponders\t: %d\n" % totTP
   if totServ : txt += "Services\t: %d\n"  % totServ
  if any((totMissTP, totMissServ, totMissSRelay)):
   txt += "\n"
   txt += FFKrMM("Missing from archived lamedb:\n", VVdLWL)
   if totMissTP : txt += "Transponders\t: %d\n" % totMissTP
   if totMissServ : txt += "Services\t: %d"  % totMissServ
   if totMissSRelay : txt += "Stream Relay\t: %d" % totMissSRelay
  FFSMJz(self.SELF, txt, title=title, width=1000)
  if self.cbFnc:
   self.cbFnc()
 def VVAngJ(self, archPath, bList, VVqeT6):
  VVO4q6, err = CC2Ekb.VV2g3w(self.SELF, VVFiGB=False)
  if err:
   return 0, 0, 0, 0
  dbServIDs = CC2Ekb.VVXiSy(VVO4q6, mode=11)
  if not dbServIDs:
   return 0, 0, 0, 0
  newDbServIDs = set()
  newDbTpIDs  = set()
  newStreamRelayChNames = set()
  for bFile in bList:
   if not VVqeT6 or VVqeT6.isCancelled:
    return
   VVqeT6.VVX5nT(bFile)
   VVqeT6.VVpqYW(1)
   lines = FF2kXa(VVgVTn + bFile)
   for line in lines:
    span = iSearch(r"((?:[A-Fa-f0-9]+:){10}$)", line, IGNORECASE)
    if span:
     VVq9SN = span.group(1)
     dbCode = CC2Ekb.VVpvrS(VVq9SN)
     if not dbCode in dbServIDs:
      newDbServIDs.add(dbCode)
      newDbTpIDs.add(CC2Ekb.VVov2P(VVq9SN))
    else:
     span = iSearch(r"(?:[A-Fa-f0-9]+:){10}https?(?::|%3a)\/\/(?:(?:127|0)\.\d+\.\d+\.\d+|localhost)(?::|%3a)\d+\/(.+)\/pid(\d+):", line, IGNORECASE)
     if span:
      newStreamRelayChNames.add(" PID ".join(span.groups()))
  dbServIDs = None
  if not VVqeT6 or VVqeT6.isCancelled:
   return
  VVqeT6.VVX5nT("Updating lamedb (Stage-1) ...")
  tFile = ""
  if any((newDbServIDs, newDbTpIDs, newStreamRelayChNames)) and FFKbVo(archPath):
   dbName = "lamedb"
   tFile = "/tmp/%s.tmp" % dbName
   fName = CCUyKl.VVRW3I(archPath, dbName)
   CCUyKl.VVBiW9(archPath, fName, "/tmp/", dbName + ".tmp")
  newTPLines = set()
  newServLines= set()
  dbTpData = CC2Ekb.VVXiSy(VVO4q6, mode=0)
  dbServData = CC2Ekb.VVXiSy(VVO4q6, mode=10)
  if newDbTpIDs:
   for item in CC2Ekb.VVXiSy(tFile, mode=0):
    if item[0].upper() in newDbTpIDs and not item in dbTpData:
     newTPLines.add(item)
  if newDbServIDs:
   for item in CC2Ekb.VVXiSy(tFile, mode=10):
    if item[0].upper() in newDbServIDs and not item in dbServData:
     newServLines.add(item)
  totMissSRelay = len(newStreamRelayChNames)
  if newStreamRelayChNames:
   for item in CC2Ekb.VVXiSy(tFile, mode=14):
    for VVUwmk in newStreamRelayChNames:
     if VVUwmk.lower() == item[1].lower():
      totMissSRelay = 0
      if not item in dbServData:
       newServLines.add(item)
       tp = CC2Ekb.VVRKzP(item[0])
       if not tp in dbTpData:
        newTPLines.add(tp)
  if not VVqeT6 or VVqeT6.isCancelled:
   return
  VVqeT6.VVX5nT("Updating lamedb (Stage-2) ...")
  totMissTP = 0
  totMissServ = 0
  lst = CC2Ekb.VVXiSy(tFile, mode=1)
  for dbCode in newDbTpIDs:
   if not lst or not dbCode in lst:
    totMissTP += 1
  lst = CC2Ekb.VVXiSy(tFile, mode=11)
  for dbCode in newDbServIDs:
   if not lst or not dbCode in lst:
    totMissServ += 1
  if not VVqeT6 or VVqeT6.isCancelled:
   return
  VVqeT6.VVX5nT("Updating lamedb (Stage-3) ...")
  FFnE7j(tFile)
  totServ = totTP = 0
  if newTPLines or newServLines:
   isServ = isTP = False
   tmpDbFile = VVO4q6 + ".tmp"
   lines   = FF2kXa(VVO4q6)
   with open(tmpDbFile, "w") as f:
    for line in lines:
     sLine = line.strip()
     if   sLine == "transponders": isTP, isServ = True, False
     elif sLine == "services" : isTP, isServ = False, True
     elif sLine == "end":
      if isTP:
       for item in (newTPLines):
        totTP += 1
        for L in item:
         f.write(L + "\n")
      elif isServ:
       for item in (newServLines):
        totServ += 1
        for L in item:
         f.write(L + "\n")
     f.write(line + "\n")
   FFlonU("mv -f '%s' '%s'" % (tmpDbFile, VVO4q6))
  return totTP, totServ, totMissTP, totMissServ, totMissSRelay
 @staticmethod
 def VVRW3I(path, fName):
  if path.endswith(".zip"):
   with iZip.ZipFile(path) as zipF:
    for zipInfo in zipF.infolist():
     if os.path.basename(zipInfo.filename) == fName:
      return zipInfo.filename
  else:
   with iTar.open(path) as tar:
    for mem in tar.getmembers():
     if os.path.basename(mem.name) == fName:
      return mem.name
  return ""
 @staticmethod
 def VVBiW9(path, fName, newPath, newFile):
  if path.endswith(".zip"):
   with iZip.ZipFile(path) as zipF:
    zipInfo = zipF.getinfo(fName)
    zipInfo.filename = newFile
    zipF.extract(zipInfo, newPath)
  else:
   with iTar.open(path) as tar:
    mem = tar.getmember(fName)
    mem.name = newFile
    tar.extract(mem, path=newPath)
 @staticmethod
 def VVenXe(path, subFile):
  lines = []
  try:
   if path.endswith(".zip"):
    with iZip.ZipFile(path) as zipF:
     for zipInfo in zipF.infolist():
      fName = os.path.basename(zipInfo.filename)
      if fName == subFile:
       with zipF.open(zipInfo.filename) as f:
        lines = f.read().decode().splitlines()
       break
     else:
      return [], "Archived file not found:\n\n%s" % subFile
   else:
    with iTar.open(path) as tar:
     for mem in tar.getmembers():
      fName = os.path.basename(mem.name)
      if fName == subFile:
       f = tar.extractfile(mem)
       lines = f.read().decode().splitlines()
       break
     else:
      return [], "Archived file not found:\n\n%s" % subFile
   return [str(x.strip()) for x in lines], ""
  except:
   return [], "Error while reading the archived file:\n\n%s" % subFile
class CCBqST():
 def __init__(self):
  self.VVt4x0   = "Package Creator"
  self.VVTRnV   = "ajpanel_package_"
  self.VVbNM8  = FFJv8S()
  self.VVsq3b   = ""
  self.VVPRaR   = ""
  self.VVqdGz   = ""
  self.VVbnpT   = None
  self.VVZtOM   = None
  self.VVJNGQ = ""
  self.VVFWRi  = ""
  self.VVS8WH = ""
  self.VVKMoH = ""
  self.VV6H8N = ""
  self.VVeItb = ""
  self.VV2Ebt()
 def VV2Ebt(self):
  self.projPkg   = ""
  self.projVer   = ""
  self.projArch   = ""
  self.VVqdGzsSize  = 0
  self.projTotalDirs  = 0
  self.projTotalFiles  = 0
  self.projAct_postInst = 0
  self.projAct_postRm  = 0
 @FFJRPn()
 def VVVWHX(self):
  FFb7uh()
  self.VVbNM8 = FFl55O()
  lst = FF4gEM(self.VVbNM8)
  VV9cxb = []
  if lst:
   for path in lst:
    if path.startswith(self.VVTRnV):
     prName = os.path.basename(path)
     VV9cxb.append((prName, prName))
  if VV9cxb:
   VV9cxb.sort(key=lambda x: x[1].lower())
   VVQ4hk = self.VVVf4M
   VVWt1H = ("Add new project", self.VV45W7)
   VVqj6y= ("Delete Project" , self.VV1Doa)
   self.VVbnpT = FFO9kU(self, None, VV9cxb=VV9cxb, width=1100, VVQ4hk=VVQ4hk, VVWt1H=VVWt1H, VVqj6y=VVqj6y, VV3an7=5, VVfWsQ="#22111133", VVB5I5="#22111133")
  else:
   FF6pUe(self, self.VVChZC, "No projects found !\n\n Create new project ?", title=self.VVt4x0)
 def VVChZC(self)    : FF7iMz(self, BF(self.VV4aKU))
 def VV45W7(self, VVhzhr, item) : FF7iMz(self.VVbnpT, BF(self.VV4aKU))
 def VV4aKU(self):
  err, _ = self.VVm5qw(0)
  if err:
   self.VVZjd1(err)
  else:
   c = 0
   while True:
    c += 1
    name = "project_%d" % (c)
    if not VVkY7E("%s%s%s" % (self.VVbNM8, self.VVTRnV, name)):
     break
   self.VVz3H4(name)
 def VVz3H4(self, name, cbFnc=None):
  FFANcN(self, cbFnc or self.VVJMWt, defaultText=name, title="New Project Name", message="Enter project name")
 def VVJMWt(self, name):
  if name and name.strip():
   path = "%s%s%s" % (self.VVbNM8, self.VVTRnV, name)
   if VVkY7E(path):
    FF6pUe(self, BF(self.VVz3H4, name), "Project directory already exists !\n\n Change name ?", title=self.VVt4x0)
   else:
    err = FFz4NZ(path)
    if err:
     self.VVZjd1("Cannot create project directory !\n\n %s" % err)
    else:
     item = os.path.basename(path)
     if self.VVbnpT: self.VVbnpT.VVisOz((item, item), isSort=True)
     else   : self.VVVWHX()
 def VV1Doa(self, VVhzhr, path):
  if path:
   path = self.VVbNM8 + path
   if VVkY7E(path):
    totDir, totFile, totLink = FFrfrn(path)
    FF6pUe(self, BF(self.VVaqCP, path), "Project directory contains %d items.\n\n%s\n\nDelete ?" %(totDir + totFile + totLink, path), title=self.VVt4x0)
 def VVaqCP(self, path):
  if FFlonU("rm -rf '%s'" % path):
   self.VVbnpT.VVg78V()
 def VVVf4M(self, item=None):
  if item:
   VVhzhr, txt, Dir, ndx = item
   self.VV2Ebt()
   self.VVsq3b = os.path.basename(Dir)[len(self.VVTRnV):]
   self.VVPRaR = "%s%s/" % (self.VVbNM8, Dir)
   self.VVqdGz = "%s%s.cfg"  % (self.VVPRaR, self.VVsq3b)
   self.VVJNGQ = self.VVPRaR + "control"
   self.VVFWRi  = self.VVPRaR + "prerm"
   self.VVS8WH = self.VVPRaR + "postrm"
   self.VVKMoH = self.VVPRaR + "preinst"
   self.VV6H8N = self.VVPRaR + "postinst"
   if not FFKbVo(self.VVJNGQ):
    err, lst = self.VVm5qw(2)
    if err:
     self.VVZjd1(err)
     return
    pkg = FFvKOW(self.VVsq3b, r"_").lower()
    with open(self.VVJNGQ, "w") as f:
     for line in lst:
      f.write("%s\n" % (line[1].replace("xx1", pkg).replace("xx2", self.VVsq3b)))
   if not FFKbVo(self.VVqdGz):
    with open(self.VVqdGz, "w") as f:
     sep = "#" * 80
     f.write("%s\n" % sep)
     f.write("%s Project\t: %s\n" % ("#", self.VVsq3b))
     f.write("%s Started\t: %s\n" % ("#", FFENz0()))
     f.write("%s\n" % sep)
   if FFKbVo(self.VVqdGz): self.VVeGq3(VVhzhr)
   else      : self.VVZjd1("Cannot create project file:\n\n%s" % self.VVqdGz)
 def VVeGq3(self, VVhzhr=None, jmpDict=None):
  FF7iMz(VVhzhr or self.VVZtOM or self, BF(self.VVlHnG, jmpDict))
 def VVlHnG(self, jmpDict):
  self.VV2Ebt()
  pkgRows, ctrlRows, actnRows, fileRows, unknRows = [], [], [], [], []
  tLst = []
  if FFKbVo(self.VVJNGQ):
   for lineNdx, line in enumerate(FF2kXa(self.VVJNGQ)):
    line = line.strip()
    if ":" in line:
     subj, val, rem = self.VV5gQs(line)
     if   subj in tLst: rem = FFKrMM("Duplicate Field", VVdLWL)
     elif val == ""  : rem = FFKrMM("No Value", VVdLWL)
     tLst.append(subj)
     pkgRows.append((str(lineNdx), "Control", subj, val, "", rem, ""))
  if not pkgRows:
   self.VVZjd1('Invalid "control" file:\n\n%s' % self.VVJNGQ)
   return
  for path in (self.VVKMoH, self.VV6H8N, self.VVFWRi, self.VVS8WH):
   size = val = ""
   if FFKbVo(path):
    val = path
    sz = FFLjtI(path)
    if sz > -1: size = CC17eA.VVxNgx(sz, mode=4)
    else   : size = FFKrMM("Size error", VVdLWL)
   ctrlRows.append(("", "Script", os.path.basename(path), val, size, "", ""))
  lines = list(map(str.strip, FF2kXa(self.VVqdGz)))
  pathsLst = []
  for line in lines:
   if line.startswith("/"):
    pathsLst.append(line)
  pathsAnalysis = CC0Aie.VVU9Q0(pathsLst)
  for lineNdx, line in enumerate(lines):
   lineNdx = str(lineNdx)
   if line and not line.startswith("#"):
    validF = size = rem = ""
    if line.startswith("/"):
     path, fName, typ, size, rem, validF = self.VVnIKS(line, fileRows, pathsAnalysis)
     fileRows.append((lineNdx, "Resource", typ or "Unknown", path, size, rem, validF))
    else:
     Title, val = self.VVwG14(line)
     if Title: actnRows.append((lineNdx, "Action", Title, val, size, rem, validF))
     else : unknRows.append((lineNdx, "?", "-", line, size, FFKrMM("Unknown value", VVdLWL), validF))
  for ndx, row in enumerate(actnRows):
   lineNdx, Section, Title, Value, Size, Remarks, ValidF = row
   rem = ""
   if   FFKbVo(self.VV6H8N) and Title == "postinst" : rem = "Ignored (if custom postinst)"
   elif FFKbVo(self.VVS8WH  ) and Title == "postrm" : rem = "Ignored (if custom postrm)"
   if rem:
    actnRows[ndx] = (lineNdx, Section, Title, Value, Size, FFKrMM(rem, VVdLWL), ValidF)
  actnRows.sort(key=lambda x: x[2].lower())
  fileRows.sort(key=lambda x: (x[2].lower(), x[3].lower()))
  unknRows.sort(key=lambda x: x[3].lower())
  VVuGUx = pkgRows
  VVuGUx.extend(actnRows)
  VVuGUx.extend(ctrlRows)
  VVuGUx.extend(fileRows)
  VVuGUx.extend(unknRows)
  cDict = {"Control":"", "Action":"0c302636", "Script":"0a28281a", "Resource":"1100385a", "?":"11550000"}
  for ndx, row in enumerate(VVuGUx):
   lineNdx, Section, Title, Value, Size, Remarks, ValidF = row
   color = cDict.get(Section, "")
   if color:
    if ValidF: Remarks = "%s%s" % (FFKrMM("Valid", VVOQkl), " ... " + Remarks if Remarks else "")
    VVuGUx[ndx] = (lineNdx, "#b#%s#" % color + Section, Title, Value, Size, "#b#0a0b0b1b#" + Remarks, ValidF)
  if self.VVZtOM:
   self.VVZtOM.VVEEBV(VVuGUx, VVyoYa=BF(self.VVBS33, jmpDict) if jmpDict else None, isSort=False)
  else:
   bg = "#15000000"
   title = "%s : %s" % (self.VVt4x0, self.VVsq3b)
   VVmolf = (""     , self.VVtFJy   , [])
   VV8OKD = (""     , self.VVzpr4   , [])
   VVjW3s = ("Create Package"  , self.VV6N8e , [])
   VV46TD = ("Post Install Action", self.VVZtSK, [])
   VViMvb = ("Edit File"   , self.VVreTX  , [])
   header  = ("lineNdx", "Section" , "Title" , "Value / Path", "Size", "Remarks" , "ValidF")
   widths  = (0  , 9   , 11  , 48   , 10 , 22  , 0   )
   VV4Uoc = (CENTER , CENTER , LEFT  , LEFT   , CENTER, LEFT  , CENTER )
   self.VVZtOM = FFCXsL(self, None, title=title, header=header, VVXpNQ=VVuGUx, VV4Uoc=VV4Uoc, VV8boH=widths, width=1850, height=1040, VVPYL1=26, VVmolf=VVmolf, VV8OKD=VV8OKD, VVjW3s=VVjW3s, VV46TD=VV46TD, VViMvb=VViMvb, VVMBr1=2
         , VVfWsQ=bg, VVB5I5=bg, VVYCun=bg, VVmErq="#00664411", VVK8UQ="#00444444", VVgSJJ="#08442211")
   self.VVZtOM.VVQ4nk(self.VVrTog)
 def VVBS33(self, jmpDict, VVAIxO, title, txt, colList):
  self.VVZtOM.VV5rHa(jmpDict)
 def VVrTog(self):
  lineNdx, Section, Title, Value, Size, Remarks, ValidF = self.VVZtOM.VVQDwi()
  if Section == "Control":
   txt = '"control" File'
  elif Section == "Script" :
   txt = "Script File"
   if Value.startswith("/") and FFKbVo(Value):
    txt = "Script File"
   else:
    self.VVZtOM["keyBlue"].hide()
    return
  else:
   txt = "Project File"
  self.VVZtOM["keyBlue"].show()
  self.VVZtOM["keyBlue"].setText("Edit %s" % txt)
 def VV5gQs(self, line):
  def VVxN3u(patt, val, Len):
   if len(val) < Len   : return FFKrMM("Length error" , VVdLWL)
   elif not iMatch(patt, val) : return FFKrMM("Invalid format" , VVdLWL)
   else      : return ""
  subj, _, val = line.partition(":")
  val, rem = val.strip(), ""
  if   not self.projPkg  and subj == "Package"  : self.projPkg, rem = val, VVxN3u(r"^[a-z]+[a-z0-9+-_.]+$", val, 2)
  elif not self.projVer  and subj == "Version"  : self.projVer, rem = val, VVxN3u(r"^[a-zA-Z0-9_+-.~]*$" , val, 1)
  elif not self.projArch and subj == "Architecture": self.projArch = val
  return subj, val, rem
 def VVnIKS(self, path, fileRows, pathsAnalysis):
  cleanLst, dirLst, filLst, errLst, mntLst, rmDirLst, totDuplDir, totDuplFil = pathsAnalysis
  rem = note = validF = targetType = ""
  size = "-"
  isCtrl = False
  fName = os.path.basename(path)
  typ = FF1cqE(path)
  path = FFsxFo(path)
  c1 = VVdLWL
  if   typ == "Mount"     : rem = "Not allowed"
  elif not typ      : rem = "Cannot be accessed"
  elif FF9Uvy(path) in rmDirLst: rem = "Ignored (child exists)"
  else:
   for item in fileRows:
    if item[3].strip() == path:
     rem = "Duplicate"
     break
  if rem:
   rem = FFKrMM(rem, c1)
   return path, fName, typ, size, rem, validF
  sz = -1
  skipSz = False
  if typ == "Directory":
   sz = FFxsAV(path)
  elif typ == "SymLink":
   targetPath = os.path.realpath(path)
   targetType = FF1cqE(targetPath)
   if  targetType == "Mount"  : skipSz, rem = True, FFKrMM("Not allowed", c1)
   elif targetType == "Directory" : sz = FFxsAV(targetPath)
   elif targetType == "File"  : sz = FFLjtI(targetPath)
   else       : sz, rem = FFLjtI(path), FFKrMM("Invalid", c1)
   note = "%s%s%s" % (note, " ... " if note else "", "Linked to : %s" % targetPath)
  elif typ == "File":
   sz = FFLjtI(path)
  if not skipSz:
   if sz > -1:
    validF = "" if rem else "1"
    if validF:
     if "Directory" in (typ, targetType) : self.projTotalDirs  += 1
     if "File" in (typ, targetType)  : self.projTotalFiles += 1
     self.VVqdGzsSize += sz
    size = CC17eA.VVxNgx(sz, mode=4)
   else:
    size = FFKrMM("Size error", c1)
  rem = "%s%s%s" % (rem, " ... " if rem else "", note)
  return path, fName, typ, size, rem, validF
 def VVwG14(self, line):
  Title = val = ""
  actDict = {"restart":1, "reboot":2 }
  span = iSearch(r"postinst\s*=\s*(.+)", line, IGNORECASE)
  if span:
   act = span.group(1).lower()
   self.projAct_postInst = actDict.get(act, 0)
   Title, val = "postinst", "%s after the package is installed" % act.capitalize()
  else:
   span = iSearch(r"postrm\s*=\s*(.+)", line, IGNORECASE)
   if span:
    act = span.group(1).lower()
    self.projAct_postRm = actDict.get(act, 0)
    Title, val = "postrm", "%s after the package is removed" % act.capitalize()
  return Title, val
 def VVreTX(self, VVAIxO, title, txt, colList):
  lineNdx, Section, Title, Value, Size, Remarks, ValidF = colList
  if   Section == "Control": path, lineNdx = self.VVJNGQ, int(lineNdx)
  elif Section == "Script" : path, lineNdx = Value, 0
  else      : path, lineNdx = self.VVqdGz, int(lineNdx)
  if FFKbVo(path) : CCNb3y(self, path, VVhK3C=self.VV7u84, VVmB4A=lineNdx)
  else    : FFWfGZ(self, path)
 def VV7u84(self, fileChanged):
  if fileChanged:
   self.VVeGq3()
 def VVZjd1(self, txt):
  FFbBGq(self, txt, title=self.VVt4x0)
 def VVtFJy(self, VVAIxO, title, txt, colList):
  tab = lambda x, y: "%s\t: %s\n" % (x, y)
  c = VVk4x7
  s  = FFFGRS("Current Row", c)
  s += title + "\n"
  s += txt + "\n"
  s += FFFGRS("Project", c)
  s += tab("File Name", self.VVqdGz)
  s += tab("Valid Dirs", self.projTotalDirs)
  s += tab("Valid Files", self.projTotalFiles)
  s += tab("Total Size", CC17eA.VVxNgx(self.VVqdGzsSize))
  FFSMJz(self, s, title="Project Info", width=1600)
 def VVzpr4(self, VVAIxO, title, txt, colList):
  c1, c2, c3, c4, c5 = VVWH8U, VVv8b8, VVk4x7, VVdLWL, VVOQkl
  allRes, invRes, unkRes = self.VVsFMG()
  totAll = len(allRes)
  totInv = len(invRes)
  totAllTxt = ("(Total=%d)" % totAll) if allRes else ""
  totInvTxt = ("(Total=%d)" % totInv) if invRes else ""
  lineNdx, Section, Title, Value, Size, Remarks, ValidF = colList
  canDel = False
  if Section != "Script" and Title not in ("Package", "Version", "Description", "Maintainer", "Architecture"):
   canDel = True
  canAddPkg, depTitle = False, ""
  if Section == "Control" and Title in ("Breaks", "Built-Using", "Conflicts", "Depends", "Enhances", "Pre-Depends", "Provides", "Recommends", "Replaces", "Suggests"):
   canAddPkg, depTitle = True , VV0p9P + '\tFor : "%s"' % Title
  VV9cxb = []
  VV9cxb.append((c1 + "Add Resource Files/Dirs"       , "addFiles"))
  VV9cxb.append((c1 + "Import Files/Dirs List from an Installed Package", "pkgFiles"))
  VV9cxb.append(VVbM5H)
  VV9cxb.append((c3 + "Import Control File (control/preinst/prerm/postinst/postrm)" , "ctrlFMan" ))
  VV9cxb.append((c3 + "Import Control Data from an Installed Package"    , "ctrlImprt" ))
  VV9cxb.append((c3 + "Add Control Field"           , "ctrlField" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(FFH04v("Add Binary Package%s"  % depTitle  , "addDep" , canAddPkg, c2 ))
  VV9cxb.append(FFH04v("Remove Binary Package%s" % depTitle  , "delDep" , canAddPkg, c2 ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Change Package Name"  , "pkgNam" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(FFH04v("Delete All Resources %s"  % totAllTxt , "delAllRes" , totAll > 0, c4))
  VV9cxb.append(FFH04v("Delete Invalid Resources %s" % totInvTxt , "delInval" , totInv > 0, c4))
  VV9cxb.append(FFH04v("Delete Current Row"      , "delRow"  , canDel , c4))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(FFH04v('Undo Last "control" File Changes'   , "ctrlUndo" , FFKbVo(self.VVJNGQ + ".bak"), c5))
  VV9cxb.append(FFH04v("Undo Last Project File Changes"   , "projUndo" , FFKbVo(self.VVqdGz + ".bak")  , c5))
  FFO9kU(self, BF(self.VVS7cP, Title), VV9cxb=VV9cxb, width=1050, height=1000, title="Options", VVfWsQ="#11001122", VVB5I5="#11001122", VVDkqE=True)
 def VVS7cP(self, fldTitle, item=None):
  if item:
   ques, item, ndx = item
   ques = FFkEjh(ques)
   if   item == "addFiles" : self.VVjvA5()
   elif item == "pkgFiles" : self.VVGLh2(self.VVZtOM, "Import Files/Dirs", self.VVlO3O)
   elif item == "ctrlFMan" : self.VVniam()
   elif item == "ctrlImprt": self.VVGLh2(self.VVZtOM, "Import 'control' data", self.VV72U1)
   elif item == "ctrlField": self.VVq94K()
   elif item == "addDep" : self.VV2JIJ(self.VVZtOM, fldTitle)
   elif item == "delDep" : self.VVibEK(fldTitle)
   elif item == "pkgNam" : self.VVzanf()
   elif item == "delAllRes": self.VVRQny(ques, 1)
   elif item == "delInval" : self.VVRQny(ques, 2)
   elif item == "delRow" : self.VV4n7s()
   elif item == "ctrlUndo" : self.VVBMJt(self.VVJNGQ)
   elif item == "projUndo" : self.VVBMJt(self.VVqdGz)
 def VVjvA5(self):
  Dir = CFG.lastPkgProjDir.getValue()
  self.session.openWithCallback(self.VVJsaL, BF(CC17eA, mode=CC17eA.VVdHom, VVqNQm=Dir, VVVh8u=True))
 def VVJsaL(self, path):
  if path:
   if isinstance(path, list):
    lines = "\n".join(path)
    path = path[0]
   else:
    lines = path
   FFBWtx(CFG.lastPkgProjDir, FFdwbd(path, True))
   self.VVDPeS(lines, 2)
 @FFJRPn(par=1)
 def VVlO3O(self, VVAIxO, title, txt, colList):
  pkg = colList[0]
  lst = FFQ1wB(r"%s | grep -E '^\/'" % (FF4zTV(VV6g4l, pkg)))
  if lst : FF6pUe(self, BF(self.VVW74Q, VVAIxO, lst), "Add %s Files/Dirs to project ?" % len(lst), title="Import Control Fields")
  else : self.VVZjd1("No files/dirs found in package:\n\n%s" % pkg)
 def VVW74Q(self, VVAIxO, lst):
  VVAIxO.cancel()
  self.VVDPeS("\n".join(lst), 2)
 def VVniam(self):
  Dir = FFdwbd(CFG.lastPkgProjDir.getValue(), False)
  self.session.openWithCallback(self.VVc3L4, BF(CC17eA, VV8JM3="pkgCtrl", VVqNQm=Dir))
 def VVc3L4(self, path):
  if path:
   FFBWtx(CFG.lastPkgProjDir, path)
   fName = os.path.basename(path)
   FFwvAe(self.VVJNGQ)
   if FFlonU("cp -f '%s' '%s'" % (path, self.VVPRaR + fName)):
    self.VVeGq3()
    self.VVZtOM.VV5rHa({1:"Script", 2:fName})
 def VVBMJt(self, File):
  if FFlonU("mv -f '%s.bak' '%s'" % (File, File)):
   self.VVeGq3()
  else:
   self.VVZjd1("Process Failed !")
 @FFJRPn(par=1)
 def VV72U1(self, VVAIxO, title, txt, colList):
  pkg = colList[0]
  lines = []
  for line in FFQ1wB(FF4zTV(VV68Kk, pkg)):
   span = iSearch(r"^([A-Z].+):\s*.+", line)
   if span and span.group(1) in ("Package", "Version", "Depends", "Section", "Architecture", "Maintainer", "Source", "Description"):
    lines.append(line)
  if lines: FF6pUe(self, BF(self.VVtFNy, VVAIxO, lines), "Replace current fields ?", title="Import Control Fields")
  else : self.VVZjd1("Cannot import from this package:\n\n%s" % pkg)
 def VVtFNy(self, VVAIxO, lines):
  VVAIxO.cancel()
  FFwvAe(self.VVJNGQ)
  with open(self.VVJNGQ, "w") as f:
   for line in lines:
    f.write(line.strip() + "\n")
  self.VVeGq3(jmpDict={1:"Control", 2:"Package"})
 def VVsFMG(self):
  allRes, invRes, unkRes = [], [], []
  for ndx, row in enumerate(self.VVZtOM.VVGpBN()):
   lineNdx, Section, Title, Value, Size, Remarks, ValidF = row
   if lineNdx.isdigit():
    if Section == "Resource":
     allRes.append(int(lineNdx))
     if not ValidF: invRes.append(int(lineNdx))
    if Section == "?": unkRes.append(int(lineNdx))
  allRes.extend(unkRes)
  invRes.extend(unkRes)
  return sorted(allRes), sorted(invRes), sorted(unkRes)
 def VVRQny(self, ques, mode):
  allRes, invRes, unkRes = self.VVsFMG()
  if   mode == 1: lst = allRes
  elif mode == 2: lst = invRes
  if lst : FF6pUe(self, BF(self.VVqXLP, lst), "%s ?" % ques, title=self.VVt4x0)
  else : FFoTZI(self.VVZtOM, "Nothing to delete", 2000)
 def VVqXLP(self, ndxLst):
  if FFKbVo(self.VVqdGz):
   lines = FF2kXa(self.VVqdGz)
   FFwvAe(self.VVqdGz)
   with open(self.VVqdGz, "w") as f:
    for ndx, line in enumerate(lines):
     if not ndx in ndxLst:
      f.write("%s\n" % line)
   self.VVeGq3()
  else:
   FFWfGZ(self, self.VVqdGz, title=self.VVt4x0)
 def VV4n7s(self):
  lineNdx, Section, Title, Value, Size, Remarks, ValidF = self.VVZtOM.VVQDwi()
  if    Section == "Control" : file = self.VVJNGQ
  else      : file = self.VVqdGz
  if Section == "Control" : FFwvAe(self.VVJNGQ)
  else     : FFwvAe(self.VVqdGz)
  lineNum = int(self.VVZtOM.VVQDwi()[0]) + 1
  FFlonU("sed -i .bak -e '%dd' '%s'" % (lineNum, file))
  self.VVeGq3()
 def VVDPeS(self, line, jmp):
  if FFKbVo(self.VVqdGz):
   FFwvAe(self.VVqdGz)
   FF03ch(self.VVqdGz)
   with open(self.VVqdGz, "a") as f:
    f.write("%s\n" % line)
   if   jmp == 1: jmpDict = {1:"Action" , 2:line.split("=")[0]}
   elif jmp == 2: jmpDict = {1:"Resource" , 3:line.strip().rstrip("/")}
   else   : jmpDict = None
   self.VVeGq3(jmpDict=jmpDict)
  else:
   FFWfGZ(self, self.VVqdGz, title=self.VVt4x0)
 def VVZtSK(self, VVAIxO, title, txt, colList):
  VV9cxb = []
  VV9cxb.append(FFH04v("No-Action after installation" , "instNon", self.projAct_postInst != 0))
  VV9cxb.append(FFH04v("Restart after installation" , "instRes", self.projAct_postInst != 1))
  VV9cxb.append(FFH04v("Reboot after installation"  , "instReb", self.projAct_postInst != 2))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(FFH04v("No-Action after removal" , "rmNon", self.projAct_postRm != 0))
  VV9cxb.append(FFH04v("Restart after removal" , "rmRes", self.projAct_postRm != 1))
  VV9cxb.append(FFH04v("Reboot after removal"  , "rmReb", self.projAct_postRm != 2))
  FFO9kU(self, self.VV442S, VV9cxb=VV9cxb, title="Action (after the package is installed/removed)")
 def VV442S(self, item=None):
  if item:
   if   item == "instNon" : self.VVpo1d("postinst", 0)
   elif item == "instRes" : self.VVpo1d("postinst", 1)
   elif item == "instReb" : self.VVpo1d("postinst", 2)
   elif item == "rmNon" : self.VVpo1d("postrm", 0)
   elif item == "rmRes" : self.VVpo1d("postrm", 1)
   elif item == "rmReb" : self.VVpo1d("postrm", 2)
 def VVpo1d(self, subj, val):
  if FFKbVo(self.VVqdGz):
   lines = FF2kXa(self.VVqdGz)
   FFwvAe(self.VVqdGz)
  else:
   lines = []
  inFile = False
  with open(self.VVqdGz, "w") as f:
   for ndx, line in enumerate(lines):
    line = line.strip()
    if not iMatch(r"%s\s*=.+" % subj, line, IGNORECASE) : f.write(line + "\n")
    else            : inFile = True
  if val > 0: self.VVDPeS("%s=%s" % (subj, {1:"restart", 2:"reboot"}.get(val, "")), 1)
  elif inFile: self.VVeGq3()
 def VVzanf(self):
  pkg = FFvKOW(self.VVsq3b, r"_").lower()
  VV9cxb = []
  VV9cxb.append((pkg, pkg))
  VV9cxb.append(VVbM5H)
  for s in ("extensions", "systemplugins", "", "skins", "picons", "softcams", "", "drivers", "security", "settings"):
   if s:
    name = "enigma2-plugin-%s-%s" % (s, pkg)
    c = VVk4x7 if name == self.projPkg else ""
    VV9cxb.append((c + name, name))
   else:
    VV9cxb.append(VVbM5H)
  FFO9kU(self, self.VV9rUg, VV9cxb=VV9cxb, title="Package Name")
 def VV9rUg(self, item=None):
  if item:
   self.VVU65Q("Package", item)
 @FFJRPn(par=1)
 def VV2JIJ(self, VVZtOM, fldTitle):
  lst = set()
  for path in CCz0DD.VVZwPY():
   if FFKbVo(path):
    with open(path, "r") as f:
     for line in f:
      if line.startswith(("Package")):
       lst.add(line.split(":", 1)[1].strip())
  if lst:
   VV9cxb = []
   for item in lst: VV9cxb.append((item, item))
   VV9cxb.sort(key=lambda x: x[0].lower())
   VVhzhr = FFO9kU(self, BF(self.VVNIRb, fldTitle), VV9cxb=VV9cxb, width=1100, title="Add Binary Package")
   if self.VVeItb:
    VVhzhr.VVhrmd(self.VVeItb)
  else:
   self.VVZjd1("Cannot read dependencies list !")
 def VVNIRb(self, fldTitle, item=None):
  if item:
   lst = []
   self.VVeItb = item
   if FFKbVo(self.VVJNGQ):
    for line in FF2kXa(self.VVJNGQ):
     line = line.strip()
     if line.startswith("%s:" % fldTitle):
      pkgs = line[len(fldTitle) + 1:].strip()
      if pkgs:
       lst = list(map(str.strip, pkgs.split(",")))
      break
   if not item in lst:
    lst.append(item)
    self.VVU65Q("%s" % fldTitle, ", ".join(lst))
   else:
    FFoTZI(self.VVZtOM, "Already added", 1500)
 def VVibEK(self, fldTitle):
  lst = []
  lineNdx, Section, Title, Value, Size, Remarks, ValidF = self.VVZtOM.VVQDwi()
  lst = list(map(str.strip, Value.split(",")))
  if lst:
   VV9cxb = []
   for item in lst: VV9cxb.append((item, item))
   FFO9kU(self, BF(self.VVqiea, fldTitle, lst), VV9cxb=VV9cxb, title="Remove Dependency")
  else:
   self.VVZjd1("No dependencies to remove !")
 def VVqiea(self, fldTitle, lst, item=None):
  if item:
   for ndx, dep in enumerate(lst):
    if dep == item:
     del lst[ndx]
     break
   if lst:
    self.VVU65Q(fldTitle, ", ".join(lst))
   else:
    FFwvAe(self.VVJNGQ)
    FFlonU("sed -i '/%s:*/d' '%s'" % (fldTitle, self.VVJNGQ))
    self.VVeGq3(jmpDict={1:"Control", 2:fldTitle})
 def VVU65Q(self, subj, val):
  lines = FF2kXa(self.VVJNGQ) if FFKbVo(self.VVJNGQ) else []
  inFile = False
  FFwvAe(self.VVJNGQ)
  with open(self.VVJNGQ, "w") as f:
   for ndx, line in enumerate(lines):
    line = line.strip()
    if line.startswith(subj + ":"):
     line = "%s: %s" % (subj, val)
     inFile = True
    f.write(line + "\n")
   if not inFile:
    f.write("%s: %s\n" % (subj, val))
  self.VVeGq3(jmpDict={1:"Control", 2:subj})
 def VVq94K(self):
  err, lst = self.VVm5qw(3, onlyName=True)
  if err:
   self.VVZjd1(err)
  else:
   curFields = []
   for ndx, row in enumerate(self.VVZtOM.VVGpBN()):
    lineNdx, Section, Title, Value, Size, Remarks, ValidF = row
    if Section == "Control":
     curFields.append(Title)
   lst.sort(key=lambda x: x[0].lower())
   VV9cxb = []
   for item in lst:
    if not item[0] in curFields:
     VV9cxb.append((item[0], item[1]))
   if VV9cxb : FFO9kU(self, self.VVB4mv, VV9cxb=VV9cxb, title="Control Fields", VVDkqE=True)
   else  : self.VVZjd1("All fields are added.")
 def VVB4mv(self, item=None):
  if item:
   if FFKbVo(self.VVJNGQ):
    txt, line, ndx = item
    FFwvAe(self.VVJNGQ)
    FF03ch(self.VVJNGQ)
    with open(self.VVJNGQ, "a") as f:
     f.write("%s\n" % line)
    self.VVeGq3(jmpDict={1:"Control", 2:txt})
   else:
    FFWfGZ(self, self.VVJNGQ, title=self.VVt4x0)
 def VVm5qw(self, mode, excl="", onlyName=False):
  path = "%sajpanel_pkg" % VVK8DT
  if not FFKbVo(path) : return "Missing 'control' Template File !", []
  elif mode == 0   : return "", []
  reqLst1, optLst1 , optLst2 = [], [], []
  for line in FF2kXa(path):
   line = line.strip()
   if line and not line.startswith("#"):
    span = iSearch(r"(.{3})(\d):(.+):\s*(.*)", line)
    if span:
     typ, seq, name, val = span.group(1), span.group(2), span.group(3), span.group(4)
     if not excl or excl.startswith("%s:", fld):
      item = ((name, "%s: %s" %(name, val)))
      if   typ == "REQ" and seq == "1": reqLst1.append(item)
      elif typ == "OPT" and seq == "1": optLst1.append(item)
      elif typ == "OPT" and seq == "2": optLst2.append(item)
  if   mode == 1: lst = reqLst1
  elif mode == 2: lst = reqLst1 + optLst1
  else    : lst = reqLst1 + optLst1 + optLst2
  return "", lst
 def VV6N8e(self, VVAIxO, title, txt, colList):
  for ndx, row in enumerate(self.VVZtOM.VVGpBN()):
   lineNdx, Section, Title, Value, Size, Remarks, ValidF = row
   if Section == "Control" and Remarks:
    self.VVZtOM.VVt5t9(ndx)
    FFoTZI(self.VVZtOM, "Check %s\n( %s )" % (Title, FFkEjh(Remarks)), 1500)
    return
  VV9cxb = []
  VV9cxb.append(("Create .ipk", "ipk"))
  VV9cxb.append(("Create .deb", "deb"))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Create .tar.gz  (ignore control files)", "tar"))
  FFO9kU(self, self.VVs3H5, VV9cxb=VV9cxb, width=700, title=self.VVt4x0)
 def VVs3H5(self, typ=None):
  if typ:
   fnc = BF(self.VVOgBU, self.VVZtOM, typ)
   if self.projTotalDirs + self.projTotalFiles > 0:
    fnc()
   elif typ == "tar":
    self.VVZjd1("No Dirs/Files found !\n\nYou need to add at least 1 directory or 1 file to the project !")
    return
   else:
    FF6pUe(self, fnc, "No directories/files included in this package.\n\nContinue ?", title=self.VVt4x0)
 @FFJRPn(par=1)
 def VVOgBU(self, VVZtOM, typ):
  if   not self.projPkg : err = "Package"
  elif not self.projVer : err = "Version"
  elif not self.projArch : err = "Architecture"
  else     : err = ""
  if err:
   self.VVZjd1('Parameter "%s" not found !' % err)
   return
  pyTxt = ""
  if typ == "tar":
   tName, ext, arch = self.VVsq3b, "tar.gz" , ""
  else:
   tName, ext, arch = self.projPkg , typ  , "_" + self.projArch
   if   "py2" in self.VVsq3b.lower() : pyTxt = "_py2"
   elif "py3" in self.VVsq3b.lower() : pyTxt = "_py3"
  outFile = "%s%s_%s%s%s.%s" % (FFl55O(), tName, self.projVer, arch, pyTxt, ext)
  projDir = "/tmp/__%s/" % PLUGIN_NAME
  FFlonU("rm -rf '%s'"  % projDir)
  if not typ == "tar":
   if not FFlonU("mkdir -p '%s'" % projDir):
    self.VVZjd1("Cannot create tmp files:\n\n%s" % projDir)
    return
  ctrlLst = []
  resFiles = []
  for ndx, row in enumerate(self.VVZtOM.VVGpBN()):
   lineNdx, Section, Title, Value, Size, Remarks, ValidF = row
   if   Section == "Control": ctrlLst.append("%s: %s" % (Title, Value))
   elif ValidF     : resFiles.append(Value)
  if typ == "tar":
   CC0Aie.VVVyb4(self, pType=typ, pName=self.VVsq3b, outFile=outFile, resFiles=resFiles)
   return
  cFile = "%scontrol" % projDir
  try:
   with open(cFile, "w") as f:
    for line in ctrlLst:
     f.write("%s\n" % line)
  except:
   self.VVZjd1("Cannot create 'control' file:\n\n%s" % cFile)
   return
  fName = ("prerm"     ,"preinst"      ,"postrm"     , "postinst"     )
  srcF  = (self.VVFWRi  , self.VVKMoH   , self.VVS8WH  , self.VV6H8N  )
  line  = ("Removing package : xx ...", "Installing Package : xx ..." , "Package removed (xx)." , "Installation completed (xx)" )
  act   = (0       , 0        , self.projAct_postRm  , self.projAct_postInst   )
  def VVxN3u(act):
   if   act == 1: return "echo 'RESTARTING GUI ...'\n%s\n" % CCYInC.VVTwB4()
   elif act == 2: return "echo 'REBOOTING DEVICE ...'\nsleep 3; reboot\n"
   else   : return "echo 'You may need to Restart GUI.'\n"
  cntrlFiles = [cFile]
  for fName, srcF, line, act in zip(fName, srcF, line, act):
   dstF = os.path.join(projDir, fName)
   cntrlFiles.append(dstF)
   if FFKbVo(srcF):
    FFlonU("cp -f '%s' '%s'" % (srcF, dstF))
   else:
    with open(dstF, "w") as f:
     f.write("#!/bin/bash\n")
     f.write("echo '%s'\n" % line.replace("xx", self.projPkg))
     f.write(VVxN3u(act) if srcF in (self.VV6H8N, self.VVS8WH) else "")
     f.write("exit 0\n")
  CC0Aie.VVVyb4(self, pType=typ, pName=self.VVsq3b, outFile=outFile, cntrlFiles=cntrlFiles, resFiles=resFiles, cbFnc=BF(self.VV3RQF, projDir))
 def VV3RQF(self, projDir):
  FFlonU("rm -rf '%s'"  % projDir)
class CC63Xr(Screen):
 def __init__(self, session, path, VV8uHX, VV5lsI=False, VVcLek=False):
  self.skin, self.VVmNvK = FFQaOH(VV7rcW, 510, 510, 30, 0, 0, "#ff000000", "#ff000000", 30, VVNLQc=False)
  self.session    = session
  self.Path     = FF9Uvy(path)
  self.VVUGcq   = path
  self.VVrf9o   = ""
  self.VVYwsB   = ""
  self.VV8uHX    = VV8uHX
  self.VV5lsI   = VV5lsI
  self.VVcLek   = VVcLek
  self.VVgpbH    = ""
  self.VVaGC4  = ""
  self.VV207I    = False
  self.VV80fr  = False
  self.origPackageName  = ""
  self.VV4f5K   = 0
  self.VVPBHm  = "enigma2-plugin-extensions-"
  self.VVJ6Ev  = "enigma2-plugin-systemplugins-"
  self.VV2yMM = "enigma2-"
  self.VVoyjC  = 0
  self.VVqVoY  = 1
  self.VV2OO6  = 2
  self.tbl     = None
  self.allOk     = False
  self.grnBtn     = True
  if VVkY7E(self.Path + "DEBIAN") or VV8uHX : self.VVihW2 = "DEBIAN"
  else           : self.VVihW2 = "CONTROL"
  self.controlPath = self.Path + self.VVihW2
  self.controlFile = self.controlPath + "/control"
  self.preinstFile = self.controlPath + "/preinst"
  self.postinstFile = self.controlPath + "/postinst"
  self.prermFile  = self.controlPath + "/prerm"
  self.postrmFile  = self.controlPath + "/postrm"
  self.newControlPath = ""
  if VV8uHX : self.packageExt = ".deb"
  else  : self.packageExt = ".ipk"
  self.Title = "Create Package (%s)" % self.packageExt
  FFNhKZ(self)
  self.onShown.append(self.VVf1Ra)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  self.VVNBv4()
 @FFJRPn()
 def VVNBv4(self):
  self.VVenPz(True)
  self.VVDToX(True)
 def VVZo7u(self, state):
  if self.tbl:
   if self.grnBtn : self.tbl["keyGreen"].show()
   else   : self.tbl["keyGreen"].hide()
 def VVDToX(self, VV0wMr=False):
  cLst, pkgName, ok = self.VVYp5H(self.controlFile)
  self.allOk = ok
  if not cLst:
   FFbBGq(self, "Cannot read control file:\n\n%s" % self.controlFile, title=self.Title)
   self.cancel()
   return
  if pkgName:
   txt = ""
   if self.VV207I:
    if   self.VV5lsI  : txt = "_no_restart"
    elif not self.VVcLek : txt = "_no_depends"
   pkgName = "%s%s%s" % (pkgName, txt, self.packageExt)
   self.VVYwsB = self.VVrf9o + pkgName
   self.VV80fr = True
   errTxt = ""
  else:
   self.VVYwsB  = ""
   self.VV80fr = False
  if VV0wMr:
   if   pkgName.startswith(self.VVPBHm) : self.VVUGcq = VVxQ5s + self.VVgpbH + "/"
   elif pkgName.startswith(self.VVJ6Ev) : self.VVUGcq = VVISpi + self.VVgpbH + "/"
   else            : self.VVUGcq = self.Path
  lst = []
  if self.VV207I : fg = "#f#00ff80ff#"
  else    : fg = ""
  bg = "#b#00000000#"
  lst.append((bg + "Source Path" , fg + self.Path      , ""))
  lst.append((bg + "Installation" , fg + "#f#00ffff88#" + self.VVUGcq, ""))
  lst.append((bg + "Package File" , "#f#0000ff00#" + self.VVYwsB  , ""))
  lst.append((bg + "Control File" , "#f#00777777#" + self.controlFile  , ""))
  if self.grnBtn:
   if   self.VV4f5K == 1: act = "Add commands to %s after installation." % FFKrMM("Restart GUI" , VVdLWL)
   elif self.VV4f5K == 2: act = "Add commands to %s after installation." % FFKrMM("Reboot Device", VVdLWL)
   else      : act = "No action."
   lst.append((bg + "Post Install" , bg + act, ""))
  lst.extend(cLst)
  if self.tbl:
   self.tbl.VVEEBV(lst, isSort=False)
  elif lst:
   if self.VV8uHX: bg, typ = "#0a002a3a", "DEB"
   else   : bg, typ = "#0a002a2a", "IPK"
   VVpW7I = self.VV8PEY
   VVjW3s = ("Create %s" % typ , self.VV2Jft , [])
   VVwqVu = ("Post Install"  , self.VVUjWR , [])
   VV46TD = ("Installation Path" , self.VV3aOB  , [])
   VViMvb = ("Change Version"  , self.VVmWXn  , [])
   header  = ("Field" , "Value" , "Remarks" )
   widths  = (15  , 67  , 18  )
   self.tbl = FFCXsL(self, None, title=self.Title, header=header, VVXpNQ=lst, width=1800, height=1000, VV8boH=widths, VVPYL1=30, VVpW7I=VVpW7I, VVjW3s=VVjW3s, VVwqVu=VVwqVu, VV46TD=VV46TD, VViMvb=VViMvb, VVRtfk=2
        , VVfWsQ=bg, VVB5I5=bg, VVYCun=bg
        , VVK8UQ="#00333333", VVmErq="#06443333", VVgSJJ="#0a332244")
   self.VV7pEO()
 def VV7pEO(self):
  for ndx, (field, val, rem) in enumerate(self.tbl.VVGpBN()):
   if rem:
    self.tbl.VVt5t9(ndx)
    break
 def cancel(self):
  if self.tbl: self.tbl.cancel()
  self.close()
 def VV8PEY(self, VVAIxO):
  if self.newControlPath:
   if self.VV207I:
    self.VVawrs()
   else:
    txt  = "Control Files were created in:\n%s\n\n" % FFKrMM(self.newControlPath, VV0p9P)
    txt += FFKrMM("Keep these files ?", VVjojy)
    FF6pUe(self, self.cancel, txt, callBack_No=self.VVawrs, title="Create Package", VVv5tA=True)
  else:
   self.cancel()
 def VVawrs(self):
  FFlonU("rm -rf '%s'" % self.newControlPath)
  self.cancel()
 def VVYp5H(self, cPath):
  pkg, ver, dsc, arc = "Package", "Version", "Description", "Architecture"
  dic = {}
  for line in FF2kXa(cPath):
   if ":" in line:
    subj, _, val = line.partition(":")
    subj, val = subj.strip(), val.strip()
    if subj: dic[subj] = val
   elif iMatch(r"^\s+\S", line):
    line = line.strip()
    if line and dsc in dic:
     dic[dsc] = " - ".join((dic[dsc], line))
  pkgPatt = r"^[a-z]+[a-z0-9+-_.]+$"
  verPatt = r"^[a-zA-Z0-9_+-.~]*$"
  lenErr = "Must be > 1 char"
  frmErr = "Format error"
  lst = []
  pName =  pVer = pArc = ""
  ok = True
  for subj in (pkg, ver, dsc, arc):
   val = dic.get(subj, "")
   err = ""
   if val:
    if subj == pkg:
     pName = val
     if   len(val) < 2    : err = lenErr
     elif not iMatch(pkgPatt, val): err = frmErr
    elif subj == ver:
     pVer = val
     if   len(val) < 2    : err = lenErr
     elif not iMatch(verPatt, val): err = frmErr
    elif subj == arc:
     pArc = val
   else:
    err = "Missing value"
   lst.append((subj, val, ("#f#00ff8000#" if err else "") + err))
   if ok and err:
    ok = False
  for k, v in dic.items():
   if not k in (pkg, ver, dsc, arc):
    lst.append((k, v, ""))
  pkgName = ""
  if all((pName, pVer, pArc)):
   pkgName = "%s_%s_%s" % (pName, pVer, pArc)
   pkgName = pkgName.replace(" ", "")
  return lst, pkgName, ok
 def VVenPz(self, VV0wMr):
  self.VVgpbH   = FFiZj6(self.Path)
  self.VVgpbH   = "_".join(self.VVgpbH.split())
  self.VVaGC4 = self.VVgpbH.lower()
  self.VV207I = FFns14(self.VVgpbH, self.Path)
  if self.VV207I and self.VVaGC4.endswith(VVXAzM.lower()):
   self.VVaGC4 += "el"
  if self.VV207I : self.VVrf9o = FFJv8S()
  else    : self.VVrf9o = FFl55O()
  self.VVrf9o = FF9Uvy(self.VVrf9o)
  if not VVkY7E(self.controlPath):
   FFlonU("mkdir '%s'" % self.controlPath)
   self.newControlPath = self.controlPath
  else:
   self.newControlPath = ""
  mode = self.VVu0BX()
  if FFKbVo(self.controlFile):
   lines = FF2kXa(self.controlFile)
   for line in lines:
    if line.strip().startswith("Package") and line.count(":") == 1:
     self.origPackageName = line.split(":")[1].strip()
     break
  else:
   if self.VV207I : version, description, maintainer = VV8h7S , PLUGIN_DESCRIPTION, "AMAJamry - " + CCLbil.VVSHHu()
   else    : version, description, maintainer = "v1.0"   , self.VVgpbH , self.VVgpbH
   txt = ""
   txt += "Package: %s\n"  % self.VVmDPM(mode)
   txt += "Version: %s\n"  % version
   txt += "Description: %s\n" % description
   txt += "Maintainer: %s\n" % maintainer
   txt += "Architecture: all\n"
   txt += "Priority: optional\n"
   txt += "Section: base\n"
   txt += ("Homepage: %s\n" % CCLbil.VVSHHu()) if self.VV207I else ""
   if self.VV207I and self.VVcLek:
    txt += "Recommends: xz (>= 5), zip, p7zip, unrar, bzip2, ffmpeg, python-requests | python3-requests, python-imaging | python3-pillow, ar (>= 2) | enigma2-plugin-extensions-opkg-tools | binutils\n"
   with open(self.controlFile, "w") as f:
    f.write(txt)
  if self.VV207I : t = PLUGIN_NAME
  else    : t = self.VVgpbH
  self.VVoXPT(self.prermFile, "echo 'Removing package : %s ...'\n" % t)
  if self.VV207I : txt = (r'find %s \( -name "*.pyo" -o -name "*.pyc" \) -type f -delete' % self.Path) + "\n"
  else    : txt = ""
  self.VVoXPT(self.postrmFile, txt + "echo 'Package removed.'\n")
  if self.VV207I : self.VVoXPT(self.preinstFile, "echo 'Installing %s (%s) ...'\n" % (PLUGIN_NAME, VV8h7S))
  else    : self.VVoXPT(self.preinstFile, "echo 'Installing Package : %s ...'\n" % self.VVgpbH)
  if VV0wMr and not mode == self.VVoyjC:
   self.VV4f5K = 1
  txt = self.VVza7g(0 if self.VV5lsI else self.VV4f5K)
  canChange = True
  self.grnBtn = True
  if FFKbVo(self.postinstFile):
   fText = FFmx8y(self.postinstFile).strip()
   if txt.strip() == fText:
    canChange = False
   else:
    for action in range(3):
     if fText.strip() == self.VVza7g(action).strip():
      break
    else:
     canChange = False
     self.grnBtn = False
  if canChange:
   with open(self.postinstFile, "w") as f:
    f.write(txt)
  FFlonU("chmod 755 '%s' '%s' '%s' '%s' " % (self.preinstFile, self.postinstFile, self.prermFile, self.postrmFile))
 def VVoXPT(self, path, lines):
  if not FFKbVo(path):
   with open(path, "w") as f:
    f.write("#!/bin/bash\n")
    f.write(lines)
    f.write("exit 0\n")
 def VVza7g(self, action):
  sep  = "echo '%s'\n" % SEP
  txt = "#!/bin/bash\n" + sep
  if action == 0:
   txt += "echo '--- FINISHED ---'\n"
   txt += sep
   txt += "echo 'You may need to Restart GUI.'\n"
  elif action == 1:
   txt += "echo 'RESTARTING GUI ...'\n"
   txt += sep
   txt += "%s\n" % CCYInC.VVTwB4()
  elif action == 2:
   txt += "echo 'REBOOTING DEVICE ...'\n"
   txt += sep
   txt += "sleep 3; reboot\n"
  else:
   return ""
  txt += "exit 0\n"
  return txt
 def VVUjWR(self, VVAIxO, title, txt, colList):
  if self.tbl["keyGreen"].getVisible():
   VV9cxb = []
   VV9cxb.append(("No Action" , "noAction" ))
   VV9cxb.append(("Restart GUI" , "VVoPrg" ))
   VV9cxb.append(("Reboot Device", "rebootDev" ))
   FFO9kU(self, self.VVAQrL, title="Package Installation Option (after completing installation)", VV9cxb=VV9cxb)
 def VVAQrL(self, item=None):
  if item is not None:
   if   item == "noAction"  : self.VV4f5K = 0
   elif item == "VVoPrg" : self.VV4f5K = 1
   elif item == "rebootDev" : self.VV4f5K = 2
   self.VVenPz(False)
   self.VVDToX()
 def VV3aOB(self, VVAIxO, title, txt, colList):
  rootPath = FFKrMM("/%s/" % self.VVgpbH, VVk4x7)
  VV9cxb = []
  VV9cxb.append(("Current Path"       , "toCurrent"  ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(FFH04v("Extension Path"   , "toExtensions" , not self.VVUGcq.startswith(VVxQ5s)))
  VV9cxb.append(FFH04v("System Plugins Path"  , "toSystemPlugins" , not self.VVUGcq.startswith(VVISpi)))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Package Name in Root : %s" % rootPath , "toRootPath"  ))
  VV9cxb.append(('Root "/"'        , "toRoot"   ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Pick Path with File Manager ..."  , "toOthers"  ))
  FFO9kU(self, self.VVwtCJ, title="Installation Path", VV9cxb=VV9cxb)
 def VVwtCJ(self, item=None):
  if item is not None:
   if   item == "toCurrent"  : self.VVoZtq(FFdwbd(self.Path, True))
   elif item == "toExtensions"  : self.VVoZtq(VVxQ5s)
   elif item == "toSystemPlugins" : self.VVoZtq(VVISpi)
   elif item == "toRootPath"  : self.VVoZtq("/")
   elif item == "toRoot"   : self.VVoZtq("/", False)
   elif item == "toOthers"   : self.session.openWithCallback(self.VVkzX6, BF(CC17eA, mode=CC17eA.VVAcq8, VVqNQm=FFJv8S()))
 def VVkzX6(self, path):
  if len(path) > 0:
   self.VVoZtq(path)
 def VVoZtq(self, parent, withPackageName=True):
  if withPackageName : self.VVUGcq = parent + self.VVgpbH + "/"
  else    : self.VVUGcq = "/"
  mode = self.VVu0BX()
  FFlonU(r"sed -i '/Package/c\Package: %s' %s" % (self.VVmDPM(mode), self.controlFile))
  self.VVDToX()
 def VVmWXn(self, VVAIxO, title, txt, colList):
  if FFKbVo(self.controlFile):
   lines = FF2kXa(self.controlFile)
   version = ""
   for line in lines:
    if ":" in line:
     parts = line.split(":")
     key  = parts[0].strip()
     val  = parts[1].strip()
     if key == "Version":
      version = val
      break
   if version : FFANcN(self, self.VVyTdu, title="Change Package Version", defaultText=version, message="Enter Version:")
   else  : FFbBGq(self, "Version not found or incorrectly set !")
  else:
   FFWfGZ(self, self.controlFile)
 def VVyTdu(self, VVV9Cp):
  if VVV9Cp:
   version, color = self.VVeVFH(VVV9Cp, False)
   if color == VV1l75:
    FFlonU(r"sed -i '/Version:/c\Version: %s' %s" % (VVV9Cp, self.controlFile))
    self.VVDToX()
   else:
    FFbBGq(self, "Incorrect Version Syntax !\n\nAllowed characters : letter, digits and _+-.~")
 def VVmDPM(self, mode):
  prefix, name = "", ""
  package = self.origPackageName or self.VVaGC4
  if package.startswith(self.VV2yMM):
   span = iSearch(r"(.+-)(.+)", package)
   if span:
    prefix, name = span.group(1).strip(), span.group(2)
  if not name:
   prefix, name = self.VV2yMM, package
  prefix = iSub(r"([^a-z0-9+-.]+)", r"-", prefix)
  name = iSub(r"([^a-z0-9+-.]+)", r"-", name)
  if   mode == self.VVqVoY : prefix = self.VVPBHm
  elif mode == self.VV2OO6 : prefix = self.VVJ6Ev
  return (prefix + name).lower()
 def VVu0BX(self):
  if   self.VVUGcq.startswith(VVxQ5s) : return self.VVqVoY
  elif self.VVUGcq.startswith(VVISpi) : return self.VV2OO6
  else            : return self.VVoyjC
 def VVeVFH(self, val, isPackage):
  if   isPackage : pattern = r"^[a-z]+[a-z0-9+-_.]+$"
  else   : pattern = r"^[a-zA-Z0-9_+-.~]*$"
  if iMatch(pattern, val) and len(val) >= 2 : return val, VV1l75
  else          : return val, VVPI2q
 def VV2Jft(self, VVAIxO, title, txt, colList):
  if not self.VV80fr:
   FFbBGq(self, "Please fix Control File errors first.")
   return
  obfVars = obfErr = None
  if self.VV207I:
   obfVars, obfErr = self.VV0MKf()
  parent  = FFdwbd(self.VVUGcq, True)
  newPath  = parent[1:]
  symlink  = parent[1:] + self.VVgpbH
  symlinkTo = FFsxFo(self.Path)
  instPathInfo=  (self.VVUGcq, parent, newPath, symlink, symlinkTo)
  pType  = "deb" if self.VV8uHX else "ipk"
  pName  = self.VVgpbH
  outFile  = self.VVYwsB
  resFiles = [self.Path]
  cntrlFiles = [self.controlFile]
  for f in (self.preinstFile, self.postinstFile, self.prermFile, self.postrmFile):
   if FFKbVo(f):
    cntrlFiles.append(f)
  CC0Aie.VVVyb4(self, pType=pType, pName=pName, outFile=outFile, cntrlFiles=cntrlFiles, resFiles=resFiles, instPathInfo=instPathInfo, cbFnc=BF(self.VVuqsj, obfVars, obfErr))
 def VVuqsj(self, obfVars, obfErr):
  if obfVars:
   err = obfErr
   if not err:
    myP, obfP = obfVars
    if not FFlonU("mv -f '%splugin.py' '%s'" % (obfP, myP)): err = "Cannot restore plug"
    if not FFlonU("mv -f '%smain.py' '%s'" % (obfP, myP)): err = "Cannot restore main"
   if err:
    FFbBGq(self, err, title="OBF Error")
 def VV0MKf(self):
  myP  = VVoFUo
  obfP = "%sOBF/" % VVoFUo
  plug = "%splugin.py" % myP
  main = "%smain.py" % myP
  lst  = iGlob("%s*main_final.py" % obfP)
  obfVars = (myP, obfP)
  if not VVkY7E(obfP) : return obfVars, "No OBF Dir"
  if not len(lst) == 1 : return obfVars, "No OBF File"
  if not FFKbVo(plug) : return obfVars, "No plug File"
  if not FFKbVo(main) : return obfVars, "No main File"
  if not FFlonU("cp -f '%s' '%s' '%s'" % (plug, main, obfP)) : return obfVars, "Cannot copy to OBF"
  if not FFlonU("cp -f %s*main_final.py '%s'" % (obfP, plug)): return obfVars, "Cannot OBF to main"
  if not FFlonU("rm -f '%s'" % main)       : return obfVars, "Cannot del main"
  return obfVars, ""
class CC0Aie(Screen):
 def __init__(self, session, title="", pType="", pName="", outFile="", cntrlFiles="", resFiles=None, instPathInfo="", cbFnc=None):
  self.skin, self.VVmNvK = FFQaOH(VV0v8m, 1400, 900, 50, 30, 20, "#11302020", "#0a001010", 30)
  self.session   = session
  self.Title    = title or "Package Maker (%s)" % pName
  self.pType    = pType
  self.pName    = pName
  self.outFile   = outFile
  self.cntrlFiles   = cntrlFiles
  self.resFiles   = resFiles
  self.instPathInfo  = instPathInfo
  self.cbFnc    = cbFnc
  if pType == "deb": self.tarParam, self.tarExt = "-cJf", ".tar.xz"
  else    : self.tarParam, self.tarExt = "-czf", ".tar.gz"
  self.isTar    = pType == "tar"
  self.totalObj   = len(resFiles)
  self.outputFileToSave = "packaging_result"
  self.tmpDir    = "/tmp/_%s/" % PLUGIN_NAME
  self.dataDir   = self.tmpDir + "DATA/"
  self.controlDir   = self.tmpDir + "CONTROL/"
  self.debBinFile   = self.tmpDir + "debian-binary"
  self.controlFile  = self.tmpDir + "control" + self.tarExt
  self.resLstFile   = self.tmpDir + "resLst"
  self.allInRoot   = False
  self.VVUGcq  = ""
  FFNhKZ(self, self.Title, addScrollLabel=True)
  FFmpyO(self, { "ok": self.VV89S0 })
  self.onShown.append(self.VVf1Ra)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  self["myLabel"].VVesH9(outputFileToSave=self.outputFileToSave)
  self["myLabel"].appendText("Process started ...")
  FFvfpL(self.VVY8UU)
 def VV89S0(self):
  pass
 def VVOhJD(self, txt):
  self["myLabel"].appendText(txt + "\n")
 def VVcexi(self, txt="FAILED"):
  self.VVOhJD(FFKrMM("\n%s\n\nProcess Stopped !" % txt, VVdLWL))
  self.VVxN5L()
 def VVxN5L(self):
  self.VVKr2e()
  if self.cbFnc:
   self.cbFnc()
 def VVKr2e(self, txt="FAILED"):
  FFlonU("rm -rf '%s'"  % self.tmpDir)
 def VVY8UU(self):
  self.VVOhJD("Checking Resources ...")
  if self.totalObj > 1:
   self.resFiles, dirLst, filLst, errLst, mntLst, rmDirLst, totDuplDir, totDuplFil = CC0Aie.VVU9Q0(self.resFiles)
   txt = ".. Valid Resources List\t: %s\n" % len(self.resFiles)
   if errLst  : txt += ".. Invalid Files/Dirs\t: %s\n... %s\n" % (len(errLst), FFKrMM("\n... ".join(errLst), VV3Hcc, VV0p9P))
   if totDuplDir : txt += ".. Removed Duplicate Dirs\t: %s\n"  % totDuplDir
   if totDuplFil : txt += ".. Removed Duplicate File\t: %s\n"  % totDuplFil
   if mntLst  : txt += ".. Removed Mount Paths\t: %s\n"   % len(mntLst)
   if rmDirLst  : txt += ".. Ignored dirs (child listed)\t: %s" % len(rmDirLst)
   self.VVOhJD(FFKrMM(txt.rstrip("\n"), VV0p9P))
   if not self.resFiles:
    self.VVcexi("No valid resources")
    return
  elif self.totalObj == 1 and not FFKbVo(self.resFiles[0]):
   self.VVcexi("Invalid or unreachable file/dir:\n%s" % self.resFiles[0])
   return
  self.VVKr2e()
  FFnE7j(self.outFile)
  self.VVOhJD("Creating working dirs ...")
  if not FFlonU("mkdir -p '%s'"  % self.tmpDir):
   self.VVcexi("Cannot create working dir.")
   return
  if not self.isTar:
   if not FFlonU("mkdir -p '%s'" % self.controlDir):
    self.VVcexi("Cannot create /tmp/ dir.")
    return
   if self.instPathInfo:
    VVUGcq, parent, newPath, symlink, symlinkTo = self.instPathInfo
    newPath  = self.dataDir + newPath
    symlink  = self.dataDir + symlink
    symlinkTo = symlinkTo
    self.allInRoot = VVUGcq == "/"
    self.VVUGcq = VVUGcq.rstrip("/")
    if not FFlonU("mkdir -p '%s'" % newPath):
     self.VVcexi("Cannot create full path.")
     return
    if not FFlonU("ln -sf '%s' '%s';" % (symlinkTo, symlink)):
     self.VVcexi("Cannot create resources link.")
     return
   self.VVOhJD("Creating debian-binary file ...")
   if not FFZZgw("echo '2.0' > '%s'" % self.debBinFile):
    self.VVcexi("Cannot create bin file.")
    return
   lst = self.cntrlFiles
   for f in lst:
    if not FFlonU("cp -f '%s' '%s'" % (f, self.controlDir)):
     self.VVcexi("Cannot read file:\n%s" % f)
     return
    newF = os.path.join(self.controlDir, os.path.basename(f))
    FF03ch(newF)
    if not FFlonU("chmod 755 '%s'" % newF):
     self.VVcexi("Cannot chmod file:\n%s" % newF)
     return
   self.VVOhJD("Archiving control files ...")
   cmd  = "cd '%s';" % self.controlDir
   cmd += "tar %s '%s' ./*;" % (self.tarParam, self.controlFile)
   if not FFlonU(cmd):
    self.VVcexi("Cannot archive control files.")
    return
  self.VVOhJD("Archiving data files ...")
  if self.totalObj > 1:
   self.resFiles.sort(key=lambda x: x[0].lower())
   with open(self.resLstFile, "w") as resF:
    for item in self.resFiles:
     item = item.lstrip("/")
     if item:
      resF.write("%s\n" % item)
  FFvfpL(self.VV8Dbe)
 def VV8Dbe(self):
  if self.isTar: dataFile = self.outFile
  else   : dataFile = self.tmpDir + "data" + self.tarExt
  tarExclude = "--exclude CONTROL --exclude DEBIAN --exclude __pycache__"
  if FFns14(self.pName, self.outFile):
   tarExclude += " --exclude OBF --exclude *.pyo --exclude *.pyc"
  if self.instPathInfo:
   self.tarParam = self.tarParam.replace("-c", "-ch")
   cmd = "cd '%s';" % self.dataDir
   if self.allInRoot:
    cmd += "tar -C '%s' %s %s '%s' ./" % (self.resFiles[0], tarExclude, self.tarParam, dataFile)
   else:
    cmd += "tar %s %s '%s' '.%s'" % (tarExclude, self.tarParam, dataFile, self.VVUGcq)
  else:
   if self.totalObj > 1:
    cmd = "tar -C / %s %s '%s' -T '%s'" % (tarExclude, self.tarParam, dataFile, self.resLstFile)
   elif self.totalObj == 1:
    cmd = "tar -C / %s %s '%s' '%s'" % (tarExclude, self.tarParam, dataFile, self.resFiles[0].lstrip("/"))
   else:
    cmd = ""
  if cmd:
   resp = FFQ1wB(cmd)
   if resp:
    self.VVcexi(FFKrMM("\n".join(resp), VVU4M8, VVdLWL))
    return
  else:
   if not FFlonU("cp -f '%sdata%s' '%s'" % (VVK8DT, self.tarExt, self.tmpDir)):
    self.VVcexi("Cannot copy temporary data.%s" % self.tarExt)
    return
  if not self.isTar:
   self.VVOhJD("Creating %s ..." % self.pType.upper())
   arResp = FFQ1wB("ar -r '%s' '%s' '%s' '%s';" % (self.outFile, self.debBinFile, self.controlFile, dataFile))
   if len(arResp) > 1 or not FFKbVo(self.outFile):
    self.VVcexi(FFKrMM("\n".join(arResp), VVU4M8, VVdLWL))
    return
  self.VVxN5L()
  self.VVOhJD("Done.\n\nResult:\n%s\n" % FFKrMM(self.outFile, VVOQkl))
 @staticmethod
 def VVU9Q0(lst):
  lines = list(map(str.strip, lst))
  cleanLst, dirLst, filLst, errLst, mntLst, rmDirLst = [], [], [], [], [], []
  for item in lst:
   item = item.strip()
   if   os.path.ismount(item) : mntLst.append(item)
   elif os.path.isdir(item) : dirLst.append(FF9Uvy(item))
   elif os.path.isfile(item) : filLst.append(item)
   else       : errLst.append(item)
  totDir = len(dirLst)
  dirLst = list(set(dirLst))
  totDuplDir = totDir - len(dirLst)
  totFil = len(filLst)
  filLst = list(set(filLst))
  totDuplFil = totFil - len(filLst)
  cleanLst.extend(list(set(filLst)))
  for tDir in dirLst:
   for fil in cleanLst:
    if fil.startswith(tDir):
     rmDirLst.append(tDir)
     break
   else:
    cleanLst.append(tDir)
  cleanLst.sort(key=lambda x: x.lower())
  return cleanLst, dirLst, filLst, errLst, mntLst, rmDirLst, totDuplDir, totDuplFil
 @staticmethod
 def VVVyb4(SELF, **kwargs):
  if CCz0DD.VVLDCy(SELF):
   SELF.session.open(CC0Aie, **kwargs)
class CCz0DD(Screen, CCBqST):
 def __init__(self, session, args=0):
  self.skin, self.VVmNvK = FFQaOH(VVNkG2, 850, 900, 50, 40, 30, "#221a001a", "#22110011", 30)
  self.session   = session
  self.lastListAllRow  = -1
  self.lastRemoveAllRow = -1
  self.lastRemoveExtRow = -1
  self.lastPickedRow  = -1
  self.holdPkgColor  = "#f#00ff8800#"
  self.instPkgColor  = "#f#0000ff00#"
  CCBqST.__init__(self)
  c1, c2, c3, c4 = VVWH8U, VVv8b8, VVWJEN, VVk4x7
  VV9cxb = []
  VV9cxb.append((c1 + "Plugins Browser"        , "pluginsBrowser"   ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append((c2 + "Download/Install Packages (from feeds)"  , "downloadInstallPackages" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append((c3 + "Remove Packages (show all)"     , "VVkNO0sAll"  ))
  VV9cxb.append((c3 + "Remove Packages (Plugins/SoftCams/Skins)" , "removePluginSkinSoftCAM" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append((c2 + "Update Packages List from Feeds"    , "VVd7pK"  ))
  VV9cxb.append((c2 + "Upgradable Packages"       , "VVJmxk" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append((c4 + "Package Creator (ipk/deb/tar)"    , "packageCreator"   ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append((c4 + "Generate Packages.gz (from ipk/deb directory)", "VVYAuE"  ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Packaging Tool"         , "VVpxfH"   ))
  VV9cxb.append(("Active Feeds"          , "VVzFo9"   ))
  FFNhKZ(self, title="Plugins Tools", VV9cxb=VV9cxb)
  self.onShown.append(self.VVf1Ra)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  FFvJ8o(self["myMenu"])
  FFNUiO(self)
 def VVyuDa(self):
  item = FFgo5c(self)
  if item is not None:
   if   item == "pluginsBrowser"    : CCBj8K.VVhtKh(self.session)
   elif item == "downloadInstallPackages"  : FF7iMz(self, BF(self.VVYA1E, 0))
   elif item == "VVkNO0sAll"   : FF7iMz(self, BF(self.VVYA1E, 1))
   elif item == "removePluginSkinSoftCAM"    : FF7iMz(self, BF(self.VVYA1E, 2))
   elif item == "VVd7pK"   : CCz0DD.VVd7pK(self)
   elif item == "VVJmxk"  : self.VVJmxk()
   elif item == "packageCreator"    : self.VVVWHX()
   elif item == "VVYAuE"   : self.VVYAuE()
   elif item == "VVpxfH"    : self.VVpxfH()
   elif item == "VVzFo9"    : self.VVzFo9()
   else          : self.close()
 @FFJRPn()
 def VVzFo9(self):
  VVuGUx = []
  totAll = 0
  for path in CCz0DD.VVZwPY():
   tot = 0
   with open(path, "r") as f:
    for line in f:
     if line.startswith("Package"):
      tot += 1
      totAll += 1
   if tot:
    VVuGUx.append((os.path.basename(path), str(tot)))
  if VVuGUx:
   VVHRm1 = "Total Packages = %s" % totAll
   VVuGUx.sort(key=lambda x: x[0].lower())
   header  = ("Feed","Packages")
   widths  = (82  , 18  )
   VV4Uoc = (LEFT  , CENTER )
   FFCXsL(self, None, header=header, VVXpNQ=VVuGUx, VV4Uoc=VV4Uoc, VV8boH=widths, width=1000, VVPYL1=26, VVHRm1=VVHRm1, VVRtfk=2)
  else:
   self.VVZjd1("Cannot read packages list !")
 def VVJmxk(self, VVAIxO=None):
  FF7iMz(VVAIxO or self, BF(self.VV5Fpb, VVAIxO))
 def VV5Fpb(self, VVAIxO):
  fLst, feedDic, instDic = self.VVYk9V()
  lst = set()
  for pkg, (ver, dsc, inst, hold) in instDic.items():
   if pkg in feedDic:
    ver1, dsc1, inst1, hold1 = feedDic[pkg]
    if CCz0DD.VVA5OB(ver, ver1) < 0:
     if hold : hold, c1 = "Yes", self.holdPkgColor
     else : hold = c1 = ""
     lst.add((c1 + pkg, c1 + ver, c1 + ver1, c1 + hold))
  if lst:
   VVuGUx = list(lst)
   VVuGUx.sort(key=lambda x: FFT7Bj(x[0]).lower())
   if VVAIxO:
    VVAIxO.VVEEBV(VVuGUx, isSort=False)
   else:
    bg = "#20110011"
    VVwqVu = ("Upgrade"  , self.VV6s7b   , [])
    VV46TD = ("Package Info." , self.VV2QQY    , [])
    VViMvb = ("Hold Update" , self.VVynQw , [])
    header  = ("Package", "Current Version" , "New Version" , "Hold Upd." )
    widths  = ( 40  , 25    , 25   , 10   )
    VV4Uoc = ( LEFT , LEFT    , LEFT   , CENTER  )
    tbl = FFCXsL(self, None, header=header, VVXpNQ=VVuGUx, VV4Uoc=VV4Uoc, VV8boH=widths, width=1700, VVPYL1=26, VVwqVu=VVwqVu, VV46TD=VV46TD, VViMvb=VViMvb, VVAGe1=CFG.lastFindPackages, VVfWsQ=bg, VVB5I5=bg, VVYCun=bg, VVmErq="#00114455")
    tbl.VVQ4nk(BF(self.VVm8lU, tbl))
  else:
   FF8bV6(self, "Nothing to upgrade", 1500)
   if VVAIxO: VVAIxO.cancel()
 def VV6s7b(self, VVAIxO, title, txt, colList):
  pkg, curV, newVer, holdState = VVAIxO.VVQDwi()
  if holdState:
   FFoTZI(VVAIxO, "Change Hold State first", 1000)
  else:
   cmd = FF4zTV(VVw2da, pkg)
   FF6NKJ(self, cmd, title="Installing : %s" % pkg, VVu7vM=BF(self.VVJmxk, VVAIxO))
 @FFJRPn(par=1)
 def VVynQw(self, VVAIxO, title, txt, colList):
  pkg, curV, newVer, holdState = VVAIxO.VVQDwi()
  cmd = FF4zTV(VVgNsi if holdState else VVu89s, pkg)
  FFlonU(cmd)
  holdLst = self.VVoRab(pkg)
  holdState = c1 = ""
  if len(holdLst) == 1 and holdLst[0][0] == pkg:
   holdState, c1 = "Yes", self.holdPkgColor
  VVAIxO.VVsu0I((c1 + pkg, c1 + curV, c1 + newVer, c1 + holdState))
  self.VVm8lU(VVAIxO)
 def VVm8lU(self, VVAIxO):
  pkg, curV, newVer, holdState = VVAIxO.VVQDwi()
  VVAIxO["keyBlue"].setText("%s Update" % ("Allow" if holdState else "Hold"))
 def VVYAuE(self):
  if CCz0DD.VVLDCy(self):
   self.session.openWithCallback(self.VV5DY3, BF(CC17eA, mode=CC17eA.VVAcq8, VVqNQm=CFG.lastFeedPkgsDir.getValue()))
 @FFJRPn()
 def VV5DY3(self, path):
  title = "Feed Packages.gz Creator"
  if len(path) > 0:
   FFBWtx(CFG.lastFeedPkgsDir, path)
   files = []
   lst = iGlob(path + "*.ipk")
   totIpk = len(lst)
   for f in lst:
    files.append(os.path.basename(f))
   lst = iGlob(path + "*.deb")
   totDeb = len(lst)
   for f in lst:
    files.append(os.path.basename(f))
   lst = None
   if len(files) > 0:
    files.sort(key=lambda x: x[0].lower())
   else:
    FFbBGq(self, "No ipk/deb files found in:\n\n%s" % path)
    return
   pFile = os.path.join(path, "Packages")
   gFile = "%s.gz" % pFile
   tFile = os.path.join(path, "Packages.stamps")
   with open(pFile, "w") as pF:
    with open(tFile, "w") as tF:
     for fName in files:
      fPath = os.path.join(path, fName)
      txt, mTime = CCz0DD.VVsFbw(fPath)
      pF.write("%s\n" % txt)
      tF.write("%s\n" % mTime)
   FFnE7j(gFile)
   os.system("gzip -k '%s'" % pFile)
   c = VVWH8U
   txt  = "%s: %s\n" % (FFKrMM("Processed Files:", c), len(files))
   txt += "  ipk   : %s\n" % totIpk
   txt += "  deb  : %s\n" % totDeb
   txt += "\n%s\n" % FFKrMM("Output Files:", c)
   txt += "  %s\n" % pFile
   txt += "  %s\n" % gFile
   txt += "  %s" % tFile
   FFSMJz(self, txt)
 def VVpxfH(self):
  pkg = FFJMbF()
  aptT = "apt - Advanced Package Tool" if FFW91j("apt") else ""
  txt = {"ipkg": "Itsy", "opkg": "Open", "dpkg": "Debian"}.get(pkg, "")
  txt = "%s - %s Package Management System" % (pkg, txt) if txt else ""
  txt += "%s%s" % ("\n\nand\n\n" if txt and aptT else "", aptT)
  FF0onH(self, txt or "No packaging tools found!")
 def VVYA1E(self, mode, Filter="", VVAIxO=None):
  fdPath = Filter[5:] if Filter.startswith("feed=") else ""
  fLst, feedDic, instDic = self.VVYk9V(fdPath)
  if fdPath and not feedDic:
   FF8bV6(VVAIxO, "No packages !", 1200)
   return
  if mode == 0: dic = feedDic.copy()
  else  : dic = instDic.copy()
  feedDic = instDic = None
  if mode == 2:
   words = ("extensions", "systemplugins", "softcams", "skin")
   for pkg in list(dic):
    if not pkg.startswith("enigma2-plugin-") and not any(x in pkg for x in words):
     del dic[pkg]
  if mode == 0 and Filter and not fdPath:
   word = Filter.lower()
   if word.endswith("s"): word = word[:-1]
   for pkg in list(dic):
    if not word in pkg:
     del dic[pkg]
   if not dic:
    FF8bV6(VVAIxO, "Not found", 1500)
    return
  VVXpNQ = []
  for pkg, (ver, dsc, inst, hold) in dic.items():
   holdT = instT = c1 = ""
   if   hold    : c1, holdT = self.holdPkgColor, "Yes"
   elif inst and mode == 0 : c1, instT = self.instPkgColor, "Yes"
   VVXpNQ.append((c1+ pkg, c1 + ver, c1 + dsc, c1 + instT, c1 + holdT))
  if VVXpNQ:
   VVXpNQ.sort(key=lambda x: FFT7Bj(x[0]).lower())
  else:
   FFbBGq(self, "No packages found!")
   return
  if mode == 0:
   c1 = VVv8b8
   if Filter and not Filter == "All":
    if fdPath: title = "Feed = %s" % os.path.basename(fdPath)
    else  : title = "Filter = %s" % Filter
    title = "Download/Install ... %s" % FFKrMM(title, c1)
   else:
    title = FFKrMM("Download/Install Packages (from feeds)", c1)
  if VVAIxO:
   VVAIxO.VVEEBV(VVXpNQ, title, VVWBXTMsg=False, isSort=False)
   self.VVnJ5o(mode, VVAIxO)
  else:
   if mode == 0:
    VVMVUB = self.lastListAllRow
    VVpW7I = self.VVH9dN
    VVjW3s = ("Install" , self.VVuGN1     , [])
    VVwqVu = ("Download" , self.VVlhOP     , [])
    VViMvb = ("Filter"  , BF(self.VVOnG1, fLst) , [])
    width = 1800
    widths = (43, 18, 32, 7, 0)
   else:
    if mode == 1:
     VVMVUB  = self.lastRemoveAllRow
     VVpW7I = self.VVdIVv
    else:
     VVMVUB  = self.lastRemoveExtRow
     VVpW7I = self.VVu3kx
    VVjW3s = ("Uninstall" , self.VVkNO0        , [])
    VVwqVu = None
    VViMvb = ("Hold Update", BF(self.VVK5wo, mode), [])
    width = 1550
    widths = (55, 35, 0, 0, 10)
   bg = "#11191111"
   VV46TD = ("Package Info." , self.VV2QQY  , [])
   header   = ("Package", "Version" , "Description" , "Inst." , "Hold Upd." )
   VV4Uoc  = (LEFT  , LEFT  , LEFT   , CENTER , CENTER  )
   tbl = FFCXsL(self, None, header=header, VVXpNQ=VVXpNQ, VV8boH=widths, VV4Uoc=VV4Uoc, width=width, height=1000, VVPYL1=26, VVpW7I=VVpW7I, VVjW3s=VVjW3s, VVwqVu=VVwqVu, VV46TD=VV46TD, VViMvb=VViMvb, VVMVUB=VVMVUB, VVAGe1=CFG.lastFindPackages
      , VVfWsQ="#22110011", VVB5I5=bg, VVYCun=bg, VVmErq="#00004444", VVK8UQ="#00333333")
   if mode != 0:
    tbl.VVQ4nk(BF(self.VVnJ5o, mode, tbl))
 def VVOnG1(self, fLst, VVAIxO, title, txt, colList):
  VV9cxb = []
  VV9cxb.append(("All Packages", "All"))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Feed ...", "fdPath"))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("enigma2-plugin-extensions" , "enigma2-plugin-extensions" ))
  VV9cxb.append(("enigma2-plugin-systemplugins" , "enigma2-plugin-systemplugins"))
  VV9cxb.append(VVbM5H)
  for word in ("Alsa", "Dream", "Drivers", "Enigma", "Extensions", "Feeds", "Firmware", "Fonts", "GLibc", "GStreamer", "Kernel", "Lib", "Linux", "Locale", "Modules", "Network", "Octagon", "PIcons", "Perl", "Pkg", "Plugin", "Python", "Samba", "Settings", "Skin", "SoftCam", "SystemPlugins", "Tools", "Util", "Zip"):
   VV9cxb.append((word, word))
  FFO9kU(self, BF(self.VVOzz3, fLst, VVAIxO), VV9cxb=VV9cxb, title="Select Filter")
 def VVOzz3(self, fLst, VVAIxO, item=None):
  if item:
   def VVxN3u(txt):
    if txt: FF7iMz(VVAIxO, BF(self.VVYA1E, 0, Filter=txt, VVAIxO=VVAIxO), title="Filtering ...")
   if item == "fdPath":
    lst = [(os.path.basename(f), "feed=%s" % f) for f in fLst]
    if lst : FFO9kU(self, VVxN3u, VV9cxb=lst, title="Select Feed")
    else : FFoTZI(VVAIxO, "Not feed list", 2000)
   else:
    VVxN3u(item)
 def VVYk9V(self, fdPath=""):
  fLst, feedDic = CCz0DD.VVS9Qz(fdPath)
  instDic = CCz0DD.VVvHGB()
  for pkg, (ver, dsc, inst, hold) in instDic.items():
   if not dsc:
    if pkg in feedDic: newDsc = feedDic[pkg][1]
    else    : newDsc = self.VVLNkg(pkg)
    if newDsc:
     instDic[pkg] = (ver, newDsc, inst, hold)
  for pkg, (ver, dsc, inst, hold) in instDic.items():
   if pkg in feedDic:
    ver1, dsc1, inst1, hold1 = feedDic[pkg]
    if ver == ver1:
     feedDic[pkg] = (ver1, dsc1, inst, hold)
  return fLst, feedDic, instDic
 @staticmethod
 def VVS9Qz(fdPath):
  if fdPath: fLst = [fdPath]
  else  : fLst = CCz0DD.VVZwPY()
  return fLst, CCz0DD.VVFM9d(fLst)
 @staticmethod
 def VVvHGB():
  fLst = [CCz0DD.VV6tgN()]
  return CCz0DD.VVFM9d(fLst)
 def VVoRab(self, toFind=""):
  dic = CCz0DD.VVvHGB()
  lst = set()
  for pkg, (ver, dsc, inst, hold) in dic.items():
   if hold:
    if toFind:
     if pkg == toFind:
      return [(pkg, ver)]
    else:
     lst.add((pkg, ver))
  return lst
 @staticmethod
 def VVFM9d(fLst):
  dic = {}
  tab = lambda line: line.partition(":")[2].strip()
  for path in fLst:
   try:
    with open(path, "r") as f:
     pkg = ver = dsc = sta = ""
     for line in f:
      if ":" in line:
       line = line.strip()
       if   line.startswith("Package")  : pkg = tab(line)
       elif line.startswith("Version")  : ver = tab(line)
       elif line.startswith("Status")   : sta = tab(line)
       elif line.startswith("Description") : dsc = tab(line)
      elif iMatch(r"^\s+\S", line):
       dsc = " - ".join((dsc, line.strip()))
      elif not line.strip():
       staL = sta.lower()
       hold = "hold" in staL
       inst = "installed" in staL and not "not-installed" in staL
       if pkg: dic[pkg] = (ver, dsc, inst, hold)
       pkg = ver = dsc = sta = ""
   except:
    pass
  return dic
 @staticmethod
 def VVZwPY():
  dirs = set()
  span = iSearch(r"option\s+lists_dir\s+(\/.+\/.+)", FFmx8y("/etc/opkg/opkg.conf"))
  if span and VVkY7E(span.group(1)): dirs.add(span.group(1))
  for s in ("apt", "opkg", "ipkg"):
   path = "/var/lib/%s/lists" % s
   if VVkY7E(path): dirs.add(path)
  files = []
  for d in dirs: files.extend(iGlob(FF9Uvy(d) + "*"))
  files = [f for f in files if os.path.isfile(f) and not f.endswith("/status")]
  files.sort()
  return files
 @staticmethod
 def VV6tgN():
  for p in ("lib", "lib64"):
   p = "/var/%s/dpkg/status" % p
   if FFKbVo(p):
    return p
  span = iSearch(r"option\s+status_file\s+(\/.+\/.+)", FFmx8y("/etc/opkg/opkg.conf"))
  if span and VVkY7E(span.group(1)):
   return span.group(1)
  else:
   for s in ("opkg", "ipkg"):
    path = "/var/lib/%s/status" % s
    if FFKbVo(path):
     return path
  return ""
 def VVLNkg(self, pkg):
  dsc = ""
  for s in ("opkg", "ipkg"):
   fil = "/var/lib/%s/info/%s.control" % (s, pkg)
   if FFKbVo(fil):
    for line in FF2kXa(fil):
     if ":" in line:
      line = line.strip()
      if   line.startswith("Description") : dsc = line.partition(":")[2].strip()
      elif line and line.startswith(" ") : dsc += " - " + line.strip()
  return dsc
 def VVH9dN(self, VVAIxO):
  self.lastListAllRow = VVAIxO.VVoxea()
  VVAIxO.cancel()
 def VVdIVv(self, VVAIxO):
  self.lastRemoveAllRow = VVAIxO.VVoxea()
  VVAIxO.cancel()
 def VVu3kx(self, VVAIxO):
  self.lastRemoveExtRow = VVAIxO.VVoxea()
  VVAIxO.cancel()
 def VVbKGk(self, VVAIxO):
  self.lastPickedRow  = VVAIxO.VVoxea()
  VVAIxO.cancel()
 @FFJRPn(par=2)
 def VVK5wo(self, mode, VVAIxO, title, txt, colList):
  pkg, ver, desc, inst, holdState = VVAIxO.VVQDwi()
  cmd = FF4zTV(VVgNsi if holdState else VVu89s, pkg)
  FFlonU(cmd)
  holdLst = self.VVoRab(pkg)
  holdState = c1 = ""
  if len(holdLst) == 1 and holdLst[0][0] == pkg:
   holdState, c1 = "Yes", self.holdPkgColor
  VVAIxO.VVsu0I((c1 + pkg, c1 + ver, c1 + desc, c1 + inst, c1 + holdState))
  self.VVnJ5o(mode, VVAIxO)
 def VVnJ5o(self, mode, VVAIxO):
  if mode in (1, 2):
   pkg, ver, desc, inst, holdState = VVAIxO.VVQDwi()
   VVAIxO["keyBlue"].setText("%s Update" % ("Allow" if holdState else "Hold"))
 @FFJRPn(par=1)
 def VVGLh2(self, VVZtOM, grnTxt, grnFnc):
  instDic = CCz0DD.VVvHGB()
  VVXpNQ = [(pkg, ver) for pkg, (ver, dsc, inst, hold) in instDic.items()]
  if not VVXpNQ:
   self.VVZjd1("Cannot read installed packages !")
   return
  VVXpNQ.sort(key=lambda x: x[0].lower())
  VVpW7I = self.VVbKGk
  VVwqVu = (grnTxt   , grnFnc     , [])
  VV46TD = ("Package Info." , self.VV2QQY , [])
  header = ("Package", "Version" )
  widths = (65  , 35  )
  FFCXsL(self, None, title=grnTxt, header=header, VVXpNQ=VVXpNQ, VV8boH=widths, VVPYL1=30, VVpW7I=VVpW7I, VVwqVu=VVwqVu, VV46TD=VV46TD, VVMVUB=self.lastPickedRow, VVAGe1=CFG.lastFindPackages
    , VVfWsQ="#22110011", VVB5I5="#22191111", VVYCun="#22191111", VVmErq="#00003030", VVK8UQ="#00333333")
 def VV2QQY(self, VVAIxO, title, txt, colList):
  FF7iMz(VVAIxO, BF(CCz0DD.VVHbAQ, self, colList[0]))
 def VVkNO0(self, VVAIxO, title, txt, colList):
  pkg, ver, desc, inst, holdState = VVAIxO.VVQDwi()
  if holdState: FFoTZI(VVAIxO, "Change Hold State first", 1000)
  else  : self.VVICxd(VVAIxO)
 def VVICxd(self, VVAIxO):
  VV9cxb = []
  VV9cxb.append(("Remove Package"        , "remove_ExistingPackage" ))
  VV9cxb.append(("Remove Package (force remove)"    , "remove_ForceRemove"  ))
  VV9cxb.append(("Remove Package (ignore failed dependencies)" , "remove_IgnoreDepends" ))
  FFO9kU(self, BF(self.VVoTl3, VVAIxO)  , VV9cxb=VV9cxb)
 def VVoTl3(self, VVAIxO, item):
  if item:
   pkg, ver, desc, inst, holdState = VVAIxO.VVQDwi()
   if   item == "remove_ExistingPackage" : cmdOpt = VVBjy1
   elif item == "remove_ForceRemove"  : cmdOpt = VVeNPM
   elif item == "remove_IgnoreDepends"  : cmdOpt = VVbseS
   FF6pUe(self, BF(self.VVvA9t, VVAIxO, cmdOpt, pkg), "Remove Package ?\n\n%s" % pkg)
 def VVvA9t(self, VVAIxO, cmdOpt, pkg):
  cmd = FF4zTV(cmdOpt, pkg)
  if cmd : FF6NKJ(self, cmd, VVu7vM=BF(self.VVBCzE, VVAIxO, pkg))
  else : FFWaiD(self)
 def VVBCzE(self, VVAIxO, pkg):
  if not CCz0DD.VVsyhp(pkg):
   VVAIxO.VVIB2X()
   if VVAIxO.VVM62I() == 0:
    VVAIxO.cancel()
  FFLgRo()
 def VVuGN1(self, VVAIxO, title, txt, colList):
  VV9cxb = []
  VV9cxb.append(("Install Package"        , "install_CheckVersion" ))
  VV9cxb.append(("Install Package (force reinstall)"   , "install_ForceReinstall" ))
  VV9cxb.append(("Install Package (force overwrite)"   , "install_ForceOverwrite" ))
  VV9cxb.append(("Install Package (force downgrade)"   , "install_ForceDowngrade" ))
  VV9cxb.append(("Install Package (ignore failed dependencies)" , "install_IgnoreDepends" ))
  FFO9kU(self, BF(self.VVjhUF, VVAIxO), VV9cxb=VV9cxb)
 def VVjhUF(self, VVAIxO, item):
  if item:
   pkg, ver, desc, inst, holdState = VVAIxO.VVQDwi()
   if   item == "install_CheckVersion"  : cmdOpt = VVw2da
   elif item == "install_ForceReinstall" : cmdOpt = VVNtuq
   elif item == "install_ForceOverwrite" : cmdOpt = VVT1hn
   elif item == "install_ForceDowngrade" : cmdOpt = VVhy5N
   elif item == "install_IgnoreDepends" : cmdOpt = VVV9EQ
   FF6pUe(self, BF(self.VVD0op, pkg, VVAIxO, cmdOpt), "Install Package ?\n\n%s" % pkg)
 def VVD0op(self, pkg, VVAIxO, cmdOpt):
  cmd = FF4zTV(cmdOpt, pkg)
  if cmd : FF6NKJ(self, cmd, VVu7vM=BF(self.VVUPDD, pkg, VVAIxO), VVAH4n=True)
  else : FFWaiD(self)
 def VVUPDD(self, pkg, VVAIxO):
  FFLgRo()
  if CCz0DD.VVsyhp(pkg):
   c1 = self.instPkgColor
   pkg, ver, desc, inst, holdState = VVAIxO.VVQDwi()
   row = (c1 + pkg.strip(), c1 + ver.strip(), c1 + desc.strip(), c1 + "Yes", c1 + holdState)
   VVAIxO.VVsu0I(row)
 def VVlhOP(self, VVAIxO, title, txt, colList):
  pkg = colList[0]
  FF6pUe(self, BF(self.VVkldF, pkg), "Download Package ?\n\n%s" % pkg)
 def VVkldF(self, pkg):
  if CC9qM0.VVQ0uB():
   iCmd = FF4zTV(VV68Kk, pkg)
   dCmd = FF4zTV(VVSqiD, pkg)
   dest = FF18rY()
   if iCmd and dCmd:
    cTxt = lambda x, fg: " echo -e '\n%s' %s;" % (x, FFuLAo(x, fg))
    cmd  = "echo -e 'Downloading : %s';" % pkg
    cmd += "FILE1=$(%s '%s' | grep Filename | awk '{print $2}');" % (iCmd, pkg)
    cmd += 'if [ -z "$FILE1" ]; then'
    cmd += " echo -e '\nPackage : %s\n';" % pkg
    cmd += " echo -e $FILE1"
    cmd +=    cTxt("Not available on feed (update packages list and try again.)", VVPI2q)
    cmd += "else"
    cmd += " cd '%s';" % dest
    cmd +=   FFQWwc(' rm -f "$FILE1"')
    cmd += " %s;" % dCmd
    cmd += ' if [ -f "%s$FILE1" ]; then' % dest
    cmd +=    cTxt("Downloaded to:", VVOQkl)
    cmd += '  echo "%s$FILE1";' % dest
    cmd += ' fi;'
    cmd += 'fi;'
    FFClck(self, cmd, VVELy4=[VVPI2q, "error:", "collected errors:", "failed", "not found"], VVAH4n=True)
   else:
    FFWaiD(self)
  else:
   FFbBGq(self, "No internet connection !")
 @staticmethod
 def VVd7pK(SELF):
  cmd = FFMXCy(VVEuxp)
  if cmd : FF6NKJ(SELF, cmd, VVAH4n=True, title="Available Packages List Upadate")
  else : FFWaiD(SELF)
 @staticmethod
 def VVRgRC(path):
  pkg = err = ""
  if VVkY7E(path):
   for line in FFQ1wB(FF4zTV(VVuPdC, "*%s*" % path)):
    span = iSearch(r"(.+) - |(.+):", line)
    if span:
     pkg = span.group(1) or span.group(2)
     break
   if not pkg:
    err = "No package info !"
  else:
   err = "Path not found !"
  return pkg, err
 @staticmethod
 def VVHbAQ(SELF, package, title=""):
  title = title or package
  fileExt = ""
  txt = instTime = ""
  c1 = VV2jvK
  info1 = []
  info2 = []
  infoCmd = FF4zTV(VV68Kk, package)
  if not infoCmd:
   FFWaiD(SELF, title=title)
   return
  info0 = FFQ1wB(infoCmd, trim=False)
  if package.startswith("/") and info0:
   title = os.path.basename(package)
   info1 = info0
   for line in info0:
    line = line.strip()
    fld, _, val = line.partition(":")
    if fld == "Package" and val:
     fileExt = os.path.splitext(package)[1].strip(".").upper()
     package = val.strip()
     if CCz0DD.VVsyhp(package):
      info2 = FFQ1wB(FF4zTV(VV68Kk, package), trim=False)
     break
  else:
   info2 = info0
  if info1:
   txt += FFFGRS("%s File Info" % (fileExt or "Package"), c1)
   txt += CCz0DD.VVrJZo(info1)[2] + "\n"
  if info2:
   txt1, txt2, txt3, instTime = CCz0DD.VVrJZo(info2)
   if txt1 and txt2:
    txt += FFFGRS("Package Version", c1)
    txt += txt1 + "\n"
    txt += FFFGRS("Installed Version", c1) + "\n"
    txt += txt2 + "\n"
   else:
    txt += FFFGRS("System Info", c1)
    txt += txt3 + "\n"
  if not info1 and not info2:
   txt += FFFGRS("Package Info", c1)
   txt += "No package information !\n\n"
  isInst = CCz0DD.VVsyhp(package)
  txt += FFFGRS("Package State", c1)
  txt += "  %s" % (FFKrMM("Installed", VVWH8U) if isInst else FFKrMM("Not Installed", VVdLWL))
  txt += "\t%s\n\n" % instTime
  if isInst:
   files = FFQ1wB(FF4zTV(VV6g4l, package) + " | grep -e '^/'")
   files.sort()
   txt += FFFGRS("Resources", c1)
   if files: txt += "\n".join(files)
   else : txt += "  None"
  FFSMJz(SELF, txt, title=title, width=1700, height=1000, VVPYL1=28, VVAQi3=30, titleBg="#11000022", VVYCun="#11000a11", outputFileToSave=package)
 @staticmethod
 def VVrJZo(info):
  instTime = lastFld  = ""
  pkgCount = 0
  lines1 = []
  lines2 = []
  lines = lines1
  color = VVk4x7
  for line in info:
   fld, sep, val = line.partition(":")
   if sep:
    fld, val = fld.strip(), val.strip()
    if fld == "Package":
     pkgCount += 1
     if pkgCount > 1:
      lines = lines2
      color = VVWH8U
    elif fld == "Installed-Time":
     tm = val.strip()
     if tm.isdigit():
      instTime = FFG6of(float(tm), wDay=True)
    lastFld = fld
   else:
    if lastFld == "Conffiles":
     val = fld.strip()
     Len = len(lines)
     last = Len - 1
     if Len > 0 and lines[last] == (lines[last][0], ""):
      lines[last] = (lines[last][0], val)
      continue
    else:
     val = fld
    fld = ""
   fld = fld.strip()
   if fld or val.strip():
    if fld: fld = FFKrMM(fld, color)
    lines.append((fld, val))
  txt1 = ""
  for fld, val in lines1:
   txt1 += "%s\t: %s\n" % (fld, val)
  txt2 = ""
  for fld, val in lines2:
   txt2 += "%s\t: %s\n" % (fld, val)
  txt3 = txt1
  if txt2:
   txt3 += "\n%s\n" % SEP + txt2
  return txt1, txt2, txt3, instTime
 @staticmethod
 def VVY56J():
  return FFlonU("if [[ \"$(ar -V 2> /dev/null | grep 'GNU ar')\" ]]; then exit 0; else exit 1; fi")
 @staticmethod
 def VVsyhp(pkg):
  instDic = CCz0DD.VVvHGB()
  return pkg in instDic
 @staticmethod
 def VVLDCy(SELF):
  if not CCz0DD.VVY56J():
   FF6pUe(SELF, BF(FF6NKJ, SELF, FF6SON(), title="Installing 'ar'"), "'ar' package is required.\n\nInstall ?")
   return False
  else:
   pFound, pBBox = FF3mxO("xz")
   if not pFound   : title, ques = "Install 'xz'", "'xz' package is required.\n\nInstall ?"
   elif pFound and pBBox : title, ques = "Upgrade 'xz'", "Found BusyBox xz. A higher version is required.\n\nUpgrade ?"
   else     : return True
   FF6pUe(SELF, BF(FF6NKJ, SELF, FF4AtW(), title=title), ques, title=title)
   return False
 @staticmethod
 def VVsFbw(path):
  txt = mTime = ""
  if FFKbVo(path):
   fName = os.path.basename(path)
   isDeb = os.path.splitext(fName)[1] == ".deb"
   if isDeb: ext, tarP = "xz", "J"
   else : ext, tarP = "gz", "z"
   txt += FF4aqG("ar -p '%s' control.tar.%s | tar %sxO ./control" % (path, ext, tarP))
   txt += "\n"
   txt += "Size: %s\n" % FFLjtI(path)
   txt += "Filename: %s\n" % fName
   txt += "MD5sum: %s\n" % FF2ndj("md5sum '%s' | cut -b-32" % path)
   txt += "SHA256sum: %s\n" % FF2ndj("sha256sum '%s' | cut -b-64"  % path)
   mTime = "%s %s" % (FF2ndj("stat -c%%Y '%s'" % path), fName)
  return txt, mTime
 @staticmethod
 def VVA5OB(ver1, ver2):
  def VVxN3u(x):
   if   x == '~' : return -1
   elif x.isdigit(): return 0
   elif not x  : return 0
   elif x.isalpha(): return ord(x)
   else   : return ord(x) + 256
  def VVIY8t(val, ref):
   while val or ref:
    first_diff = 0
    while (val and not val[0].isdigit()) or (ref and not ref[0].isdigit()):
     vc = VVxN3u(val[0]) if val else 0
     rc = VVxN3u(ref[0]) if ref else 0
     if vc != rc:
      return vc - rc
     val = val[1:]
     ref = ref[1:]
    val = val.lstrip('0')
    ref = ref.lstrip('0')
    while val and ref and val[0].isdigit() and ref[0].isdigit():
     if not first_diff:
      first_diff = ord(val[0]) - ord(ref[0])
     val = val[1:]
     ref = ref[1:]
    if val and val[0].isdigit() : return 1
    if ref and ref[0].isdigit() : return -1
    if first_diff    : return first_diff
   return 0
  return VVIY8t(ver1, ver2)
 @staticmethod
 def VVQmy3(curVer, webVer):
  webVer = webVer.strip().replace("version=", "")
  tab = lambda x: iSub(r"[^\d\.]", "", x.replace("_", "."))
  cur, web = tab(curVer), tab(webVer)
  upd = CCz0DD.VVA5OB(cur, web) < 0
  return curVer.replace("v", ""), webVer, upd
class CCQyUl():
 def VVWvup(self, isRef, onlyEpg=False):
  self.shareIsRef   = isRef
  self.onlyEpg   = onlyEpg
  self.shareFilePrefix = "ajpanel_share_%s_" % ("ref" if self.shareIsRef else "data")
  self.shareFilePath  = ""
  FFaA3e()
  self.VV4bj9()
 def VV4bj9(self):
  files = FFYvtE(FF4FYM(), self.shareFilePrefix + "*.xml")
  if files:
   files.sort()
   VV9cxb = []
   for fil in files:
    VV9cxb.append((os.path.basename(fil), fil))
   if self.shareIsRef : VVfWsQ, VVB5I5 = "#22221133", "#22221133"
   else    : VVfWsQ, VVB5I5 = "#22003344", "#22002233"
   VVWt1H  = ("Add new File", self.VVfjAD)
   FFO9kU(self, self.VVQAHd, VV9cxb=VV9cxb, width=1100, VVWt1H=VVWt1H, VV1NnQ="", VV3an7=4, VVfWsQ=VVfWsQ, VVB5I5=VVB5I5)
  else:
   FF6pUe(self, self.VVI22Q, "No files found.\n\nCreate a new file ?")
 def VVI22Q(self):
  path = self.VVQ65P()
  if FFKbVo(path) : self.VV4bj9()
  else    : FFoTZI(self, "Cannot create file", 1500)
 def VVfjAD(self, VVhzhr, path):
  path = self.VVQ65P()
  VVhzhr.VVisOz((os.path.basename(path), path), isSort=True)
 def VVQ65P(self):
  path = "%s%s%s.xml" % (FF4FYM(), self.shareFilePrefix, FFRIlf())
  with open(path, "w") as f:
   f.write('<?xml version="1.0" encoding="utf-8"?>\n<share>\n\n\t<ch>\n\t\t<name1>Channel-1</name1>  <ref1>5001:0:1:22:22:22:22:0:0:0</ref1>\n\t\t<name2>Channel-2</name2>  <ref2>4097:0:1:22:22:22:22:0:0:0</ref2>\n\t</ch>\n\n</share>')
  return path
 @FFJRPn()
 def VVQAHd(self, path=None):
  if not path: return
  if not FFKbVo(path):
   FFWfGZ(self, path)
   return
  elif not CC17eA.VV9kj1(self, path, FFJ4QU()):
   return
  else:
   self.shareFilePath = path
  if not CCCusX.VVbBWp(self):
   return
  tree = CC2Ekb.VVF6XZ(self, self.shareFilePath)
  if not tree:
   return
  refLst = CC8i1k.VV0t8D()
  def VVqz4B(VVq9SN):
   if   FFaKr0(VVq9SN): return FFKrMM("DVB", VVWH8U)
   elif VVq9SN in refLst     : return FFKrMM("IPTV", VVWH8U)
   else         : return ""
  VVuGUx= []
  errColor= "#f#00ffaa55#"
  num  = 1
  dupl = 0
  for ch in tree.getroot():
   ok, srcName, srcRef, dstName, dstRef = self.VVZjSV(ch)
   if ok:
    srcTxt = VVqz4B(srcRef)
    dstTxt = VVqz4B(dstRef)
    srcName, dstName = srcName.strip(), dstName.strip()
    skip = False
    for num1, srcName1, srcRef1, srcTxt1, dstName1, dstRef1, dstTxt1, remark1 in VVuGUx:
     if (srcRef, dstRef) == (srcRef1, dstRef1):
      dupl += 1
      break
    else:
     if  srcRef == dstRef : remark, c1, c2 = "4", errColor, errColor
     elif srcTxt and dstTxt : remark, c1, c2 = "0", ""  , ""
     elif dstTxt    : remark, c1, c2 = "1", errColor, ""
     elif srcTxt    : remark, c1, c2 = "2", ""  , errColor
     else     : remark, c1, c2 = "3", errColor, errColor
     c3 = "#f#0000ff00#" if remark == "0" else errColor
     VVuGUx.append((c3 + str(num), c1 + srcName, c1 + srcRef, c1 + srcTxt, c2 + dstName, c2 + dstRef, c2 + dstTxt, remark))
     num += 1
  refLst = None
  if VVuGUx:
   if self.shareIsRef : VVfWsQ, VVB5I5, optTxt = "#1a221133", "#1a221133", "Share Reference"
   else    : VVfWsQ, VVB5I5, optTxt = "#1a003344", "#1a002233", "Copy EPG" if self.onlyEpg else "Copy EPG/PIcons"
   VVDPcX = (""    , BF(self.VVz4dO, dupl) , [])
   VVmolf = (""    , self.VVibBg    , [])
   VVjW3s = ("Delete Entry" , self.VVAYF1   , [])
   VVwqVu = ("Add Entry"  , self.VVpfj8 , [])
   VV46TD = (optTxt   , self.VVsLKk  , [])
   header  = ("Num" , "Source" , "Source Ref." ,"Type" , "Destination" , "Dest. Ref." , "Type", "Remark" )
   widths  = (8  , 25  , 15   , 6  , 25   , 15   , 6  , 0   )
   VV4Uoc = (CENTER , LEFT  , LEFT   ,CENTER , LEFT   , LEFT   , CENTER, CENTER )
   VVAIxO = FFCXsL(self, None, header=header, VVXpNQ=VVuGUx, VV4Uoc=VV4Uoc, VV8boH=widths, VVPYL1=24, VVDPcX=VVDPcX, VVmolf=VVmolf, VVjW3s=VVjW3s, VVwqVu=VVwqVu, VV46TD=VV46TD, VVoNmU=True, VVMBr1=1, VVAGe1=CFG.lastFindServices
         , VVfWsQ=VVfWsQ, VVB5I5=VVB5I5, VVYCun=VVB5I5, VVmErq="#0a000000")
  else:
   FFbBGq(self, "No valid sharing data found in:\n\n%s" % self.shareFilePath)
 def VVz4dO(self, dupl, VVAIxO, title, txt, colList):
  if dupl:
   VVAIxO.VV2t5o("Skipped %d duplicate%s" % (dupl, FFaRsj(dupl)), 2000)
 def VVibBg(self, VVAIxO, title, txt, colList):
  def VVqz4B(key, val): return "%s\t: %s\n" % (key, val or FFKrMM("?", VVU4M8))
  Keys = VVAIxO.VVjp8T()
  Vals = VVAIxO.VVQDwi()
  txt = ""
  for i in range(len(Keys) - 1):
   txt += VVqz4B(Keys[i], Vals[i])
   if i in (0, 3, 6):
    txt += "\n"
  remark = colList[7]
  txt1 = "Remarks\t: "
  c1, c2 = VVOQkl, VVU4M8
  if   remark == "0": txt1 += c1 + "Valid"
  elif remark == "1": txt1 += c2 + "Source channel is not in system"
  elif remark == "2": txt1 += c2 + "Destination channel is not in system"
  elif remark == "3": txt1 += c2 + "Both channels are not in system"
  elif remark == "4": txt1 += c2 + "Both channels have same Reference"
  FFSMJz(self, txt + txt1, title=title)
 def VVZjSV(self, chElem):
  srcName = chElem.find("name1")
  srcRef  = chElem.find("ref1")
  dstName = chElem.find("name2")
  dstRef  = chElem.find("ref2")
  patt = r"((?:[A-Fa-f0-9]+:){9}(?:[A-Fa-f0-9]+))"
  if srcName is not None and srcRef is not None and dstName is not None and dstRef is not None:
   lst = [srcName.text or "", srcRef.text or "", dstName.text or "", dstRef.text or ""]
   for i, text in enumerate(lst):
    lst[i] = str(text.encode("UTF-8").decode())
   srcName, srcRef, dstName, dstRef = lst
   span = iSearch(patt, srcRef)
   if span:
    srcRef = span.group(1).upper()
    span = iSearch(patt, dstRef)
    if span:
     dstRef = span.group(1).upper()
     return True, srcName.strip(), srcRef.strip(":"), dstName.strip(), dstRef.strip(":")
  return False, "", "", "", ""
 def VVAYF1(self, VVAIxO, title, txt, colList):
  if VVAIxO.VVoxea() == 0 and VVAIxO.VVM62I() == 1:
   isLast, ques = True, "This is the last entry.\n\nDelete File ?"
  else:
   isLast, ques = False, "Delete current row ?"
  FF6pUe(self, BF(self.VV8v01, isLast, VVAIxO), ques)
 def VV8v01(self, isLast, VVAIxO):
  if isLast:
   FFnE7j(self.shareFilePath)
   VVAIxO.cancel()
  else:
   num, srcName, srcRef, srcType, dstName, dstRef, dstType, remark = VVAIxO.VVQDwi()
   if self.VVpMUd(srcName, srcRef, dstName, dstRef):
    VVAIxO.VVIB2X()
    VVAIxO.VVdVkN()
    FFxHED(VVAIxO, "Deleted", 500)
   else:
    FFoTZI(VVAIxO, "Cannot delete from file", 2000)
 def VVpfj8(self, VVAIxO, title, txt, colList):
  if self.shareIsRef : self.VVRWdF(VVAIxO)
  else    : FFO9kU(self, BF(self.VVqjX7, VVAIxO), VV9cxb=[("DVB to IPTV", "iptv"), ("DVB to DVB", "dvb")], width=600, title="Source and Destination")
 def VVqjX7(self, VVAIxO, item):
  if item:
   if   item == "iptv" : fnc = self.VVRWdF(VVAIxO)
   elif item == "dvb" : fnc = self.VVzQle(VVAIxO)
 @FFJRPn("Loading Services ...", par=1)
 def VVzQle(self, VVAIxO):
  lst, err = CC2Ekb.VVTefV(self, CC2Ekb.VV6xi4)
  if not lst:
   FFbBGq(self, "No DVB Services !")
   return
  lst = [(VVUwmk, VVq9SN + ":", sat) for VVUwmk, chProv, sat, VVq9SN in lst]
  lst.sort(key=lambda x: x[0].lower())
  chkLst = [(dstRef + ":", srcRef + ":") for num, srcName, srcRef, srcTxt, dstName, dstRef, dstTxt, remark in VVAIxO.VVGpBN()]
  VVVmGQLst = []
  try:
   bg = "#11001100"
   self.session.open(CCVdvJ, lst, chkLst=chkLst, srcPath=self.shareFilePath, dstPath=self.shareFilePath
       , title="Chain DVB to DVB Channel", mnuTitle2="Destination Channel", mnuTitle3="Source", blueTitle="Add Entry"
       , blueFnc=BF(self.VVTNq0, VVAIxO, VVVmGQLst), delFnc=None
       , widths2=(70, 0, 30), aligns2=(LEFT, LEFT, CENTER), tBg=bg, bBg=bg, bg1=bg, bg2=bg)
  except:
   pass
 @FFJRPn("Loading Services ...", par=1)
 def VVRWdF(self, VVAIxO):
  lst = CCQyUl.VVkCJM()
  if not lst:
   FFbBGq(self, "No IPTV Services !")
   return
  lst = [(name, ref + ":") for name, bouquet, url, ref in lst]
  chkLst = [(dstRef + ":", srcRef + ":") for num, srcName, srcRef, srcTxt, dstName, dstRef, dstTxt, remark in VVAIxO.VVGpBN()]
  VVVmGQLst = [r + ":" for r in CC8i1k.VV0t8D()]
  try:
   self.session.open(CCVdvJ, lst, chkLst=chkLst, srcPath=self.shareFilePath, dstPath=self.shareFilePath
       , title="Chain DVB to IPTV Channel", mnuTitle2="IPTV Chan Name", mnuTitle3="IPTV Reference", blueTitle="Add Entry"
       , blueFnc=BF(self.VVTNq0, VVAIxO, VVVmGQLst), delFnc=None
       , widths2=(60, 40), fonts2=(0, 1))
  except:
   pass
 @FFJRPn(par=3)
 def VVTNq0(self, VVAIxO, VVVmGQLst, bindCls):
  c1  = VVWH8U
  title= bindCls.Title
  outF = bindCls.dstPath
  d  = bindCls.VVRlr4()
  srcName, srcRef, srcTxt = d["name"]  , d["VVq9SN10"].rstrip(":"), ""
  dstName, dstRef, dstTxt = d["mnuTxt"], d["mnuRef"].rstrip(":")  , ""
  if   FFaKr0(srcRef)  : srcTxt = FFKrMM("DVB", c1)
  elif srcRef.rstrip(":") + ":" in VVVmGQLst : srcTxt = FFKrMM("IPTV", c1)
  if   FFaKr0(dstRef)  : dstTxt = FFKrMM("DVB", c1)
  elif dstRef.rstrip(":") + ":" in VVVmGQLst : dstTxt = FFKrMM("IPTV", c1)
  if srcRef == dstRef:
   FF8bV6(bindCls, "Cannot add (same Reference)", 2000)
  else:
   for ndx, (num1, srcName1, srcRef1, srcTxt1, dstName1, dstRef1, dstTxt1, remark1) in enumerate(VVAIxO.VVGpBN()):
    if (srcRef, dstRef) == (srcRef1, dstRef1):
     FFbBGq(self, "Already added in row Num-%d" % (ndx + 1))
     break
   else:
    if self.VVgciM(srcName, srcRef, dstName, dstRef):
     VVAIxO.VV4hgQ((str(VVAIxO.VVM62I() + 1), srcName, srcRef, srcTxt, dstName, dstRef, dstTxt, "0"))
     FFtn0P(bindCls, "Saved", 800)
     bindCls.VV4DM0((d["mnuRef"], d["VVq9SN10"]))
    else:
     FF8bV6(bindCls, "Cannot edit XML File", 2000)
 @staticmethod
 def VVkCJM():
  VVuGUx = []
  files  = CCTe4w.VVcN0J()
  patt  = r"#SERVICE\s+([A-Fa-f0-9]+:0:(?:[A-Fa-f0-9]+[:]){8})(http.+)\n#DESCRIPTION\s+(.+)"
  if files:
   for path in files:
    txt = FFmx8y(path)
    span = iSearch(r"#NAME\s(.+)", txt, IGNORECASE)
    if span : VVsvsL = span.group(1)
    else : VVsvsL = ""
    VVsvsL_lCase = VVsvsL.lower()
    for match in iFinditer(patt, txt, IGNORECASE):
     VVq9SN = match.group(1).upper().strip(":")
     url  = match.group(2).strip()
     VVUwmk = match.group(3).strip()
     VVuGUx.append((VVUwmk, VVsvsL, url, VVq9SN))
  return VVuGUx
 def VVgciM(self, srcName, srcRef, dstName, dstRef):
  tree = CC2Ekb.VVF6XZ(self, self.shareFilePath)
  if not tree:
   return False
  root = tree.getroot()
  ch = iElem.Element("ch")
  root.append(ch)
  name  = iElem.SubElement(ch, "name1")
  ref   = iElem.SubElement(ch, "ref1")
  name.text = srcName
  ref.text = srcRef
  name  = iElem.SubElement(ch, "name2")
  ref   = iElem.SubElement(ch, "ref2")
  name.text = dstName
  ref.text = dstRef
  self.VVgxgg(tree, root)
  return True
 def VVpMUd(self, srcName1, srcRef1, dstName1, dstRef1):
  tree = CC2Ekb.VVF6XZ(self, self.shareFilePath)
  if not tree:
   return False
  tableLst = [srcName1, srcRef1, dstName1, dstRef1]
  found = False
  root = tree.getroot()
  for ch in root:
   ok, srcName, srcRef, dstName, dstRef = self.VVZjSV(ch)
   if ok and [srcName, srcRef, dstName, dstRef] == tableLst:
    root.remove(ch)
    found = True
  if found:
   self.VVgxgg(tree, root)
  return found
 def VVgxgg(self, tree, root, withComments=True):
  xmlTxt = iElem.tostring(root)
  txt  = CC2Ekb.VVfQte(xmlTxt)
  parser = CC2Ekb.CClM2A()
  if withComments : parser = iElem.XMLParser(target=parser)
  else   : parser = None
  root = iElem.fromstring(txt, parser=parser)
  tree._setroot(root)
  tree.write(self.shareFilePath, encoding="UTF-8")
 def VVsLKk(self, VVAIxO, title, txt, colList):
  if self.onlyEpg:
   self.VVKHVE(VVAIxO, "epg")
  else:
   if self.shareIsRef:
    FF6pUe(self, BF(self.VV4i8U, VVAIxO), "Copy all References from Source to Destination ?")
   else:
    VV9cxb = []
    VV9cxb.append(("Copy EPG\t (All List)" , "epg"  ))
    VV9cxb.append(("Copy Picons\t (All List)" , "picon" ))
    FFO9kU(self, BF(self.VVKHVE, VVAIxO), VV9cxb=VV9cxb, width=1000)
 def VVKHVE(self, VVAIxO, item=None):
  if item:
   if   item == "epg" : fnc, txt = self.VVyN9y  , "EPG"
   elif item == "picon": fnc, txt = self.VVkly0 , "PIcons"
   title = "Copy %s" % txt
   tot   = VVAIxO.VVM62I()
   FF6pUe(self, BF(fnc, VVAIxO, title), "Overwrite %s for %d Service%s ?" % (FFKrMM(txt, VVjojy), tot, FFaRsj(tot)), title=title)
 @FFJRPn(par=1)
 def VV4i8U(self, VVAIxO):
  files = CCTe4w.VVcN0J()
  totChange = 0
  if files:
   for path in files:
    txt = FFmx8y(path)
    toSave = False
    for num, srcName, srcRef, srcTxt, dstName, dstRef, dstTxt, remark in VVAIxO.VVGpBN():
     if remark == "0":
      srcPart = ":".join(srcRef.split(":")[1:]) + ":"
      dstPart = ":".join(dstRef.split(":")[1:]) + ":"
      txt, tot = iSubn(r"(#SERVICE\s+(?:[A-Fa-f0-9]+[:]))%s(.+\/\/.+)" % dstPart, r"\g<1>%s\2" % srcPart, txt, IGNORECASE)
      if tot:
       toSave = True
       totChange += tot
    if toSave:
     with open(path, "w") as f:
      f.write(txt)
  if totChange > 0:
   FFANYL()
  tot = VVAIxO.VVM62I()
  txt  = "Services\t: %d\n" % tot
  txt += "Changed\t: %d\n"  % totChange
  txt += "Skipped\t: %d\n"  % (tot- totChange)
  FFSMJz(self, txt)
 @FFJRPn(par=1)
 def VVkly0(self, VVAIxO, title):
  if not iCopyfile:
   FFbBGq(self, "Module not found:\n\nshutil", title=title)
   return
  pPath = CCRGqC.VV5G3P()
  totFound = totDone = totSame = totErr = 0
  for num, srcName, srcRef, srcTxt, dstName, dstRef, dstTxt, remark in VVAIxO.VVGpBN():
   srcPng = pPath + srcRef.replace(":", "_") + ".png"
   dstPng = pPath + dstRef.replace(":", "_") + ".png"
   if FFKbVo(srcPng):
    totFound += 1
    if srcPng == dstPng:
     totSame += 1
    else:
     try:
      iCopyfile(srcPng, dstPng)
      totDone += 1
     except:
      totErr += 1
  txt  = "Services\t: %d\n" % VVAIxO.VVM62I()
  txt += "Found\t: %d\n" % totFound
  txt += "Copied\t: %d"  % totDone
  if totSame: txt += "\nSame Ref.\t: %d" % totSame
  if totErr : txt += "\nErrors\t: %d"  % totErr
  FFSMJz(self, txt, title=title)
 @FFJRPn(par=1)
 def VVyN9y(self, VVAIxO, title):
  txt, err = CCtAi7.VVjXeX(VVAIxO, title)
  if err : FFbBGq(self, err, title=title)
  else : FFSMJz(self, txt, title=title)
 class CClM2A(iElem.TreeBuilder):
  def comment(self, data):
   self.start(iElem.Comment, {})
   self.data(data)
   self.end(iElem.Comment)
 @staticmethod
 def VVF6XZ(SELF, path, withComments=True, title=""):
  try:
   if withComments:
    try:
     return iElem.parse(path, parser=iElem.XMLParser(target=CC2Ekb.CClM2A()))
    except:
     return iElem.parse(path)
  except Exception as e:
   CCQyUl.VVXqCi(SELF, path, str(e), title)
   return None
 @staticmethod
 def VVXqCi(SELF, path, err, title=None):
  txt  = "%s\n%s\n\n" % (FFKrMM("XML Parse Error in:", VVU4M8), path)
  txt += "%s\n%s\n\n" % (FFKrMM("Error:", VVU4M8), str(err))
  FFSMJz(SELF, txt, VVYCun="#11220000", titleBg="#11330000", title=title or FFJ4QU().strip())
 @staticmethod
 def VVfQte(xmlTxt):
  txt = iSub(r">[\n\s]*", ">" , xmlTxt.decode("UTF-8"))
  txt = iSub(r"([^12])>\s*<" , r"\1>\n<", txt)
  txt = iSub(r"ref1>\s*<name2", r"ref1>\n<name2", txt)
  txt = iSub(r"</ref2></ch>" , r"</ref2>\n</ch>\n", txt)
  txt = iSub(r"<ch>"   , r"\t<ch>", txt)
  txt = iSub(r"</ch>"   , r"\t</ch>", txt)
  txt = iSub(r"<name1>"  , r"\t\t<name1>", txt)
  txt = iSub(r"<name2>"  , r"\t\t<name2>", txt)
  txt = iSub(r"(<!-- .+ -->)" , r"\t\1\n", txt)
  txt = iSub(r"<share>"  , r"<share>\n", txt)
  return txt
class CCUdhV(Screen):
 def __init__(self, session, title):
  self.skin, self.VVmNvK = FFQaOH(VVwsZy, 600, 300, 30, 0, 0, "#22112211", "#0a223322", 35, VVSwLg=40)
  self.session  = session
  self.index   = 1
  self.totSec   = 0
  FFNhKZ(self, title=title)
  FFi79B(self["keyYellow"], "Reset")
  self["signTitle"] = Label("+/-")
  self["hourTitle"] = Label("Hour")
  self["minTitle"] = Label("Min")
  self["sign"]  = Label("+")
  self["hour"]  = Label("00")
  self["min"]   = Label("00")
  self.list   = [self["sign"], self["hour"], self["min"]]
  FFrM8n(self,
  {
   "ok" : self.VVtDnC ,
   "green" : self.VVtDnC ,
   "yellow": self.VVMkJV ,
   "up" : self.VVCdU6  ,
   "down" : self.VV41MG ,
   "left" : self.VVDDr1 ,
   "right" : self.VVksC6 ,
   "cancel": self.close
  })
  self.onShown.append(self.VVf1Ra)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  FFuwGk(self)
  self.VVbkxF()
 def VVtDnC(self):
  sign = self["sign"].getText()
  hour = self["hour"].getText()
  min  = self["min"].getText()
  seconds = int(hour) * 3600 + int(min) * 60
  seconds *= 1 if sign == "+" else -1
  self.close(seconds)
 def VVMkJV(self):
  self["sign"].setText("+")
  self["hour"].setText("00")
  self["min"].setText("00")
 def VVCdU6(self)  : self.VVWedW(1)
 def VV41MG(self) : self.VVWedW(-1)
 def VVDDr1(self) : self.VVbkxF(-1)
 def VVksC6(self) : self.VVbkxF(1)
 def VVbkxF(self, box=0):
  self.index += box
  if   self.index < 0     : self.index = len(self.list) - 1
  elif self.index > len(self.list) - 1: self.index = 0
  for obj in self.list: FFgLA9(obj, "#06405040")
  FFgLA9(self.list[self.index], "#0a225577")
 def VVWedW(self, increment):
  if self.index == 0:
   sign = self.list[0].getText()
   if   sign == "+": sign = "-"
   elif sign == "-": sign = "+"
   self.list[0].setText(sign)
  else:
   if self.index == 1 : min, max, step = 0, 23, 1
   else    : min, max, step = 0, 45, 15
   val = int(self.list[self.index].getText()) + increment * step
   if val < min: val = max
   if val > max: val = min
   self.list[self.index].setText("%02d" % val)
class CCJi7o():
 def __init__(self, SELF, mode=0):
  self.SELF   = SELF
  self.Title   = "XML-TV Tools"
  self.xmltv_path  = FFJv8S() + "epg/"
  self.VVtGUP  = ""
  self.curChName  = ""
  self.curChTitle  = ""
  self.curPath  = ""
  self.curTotTags  = 0
  self.displayName = ""
  self.adjustedTime = 0
  self.curChanRefFile = self.xmltv_path + CFG.xmlTvChannelRefFile.getValue()
  self.skipLst  = ("hd+", "hd", "fhd+", "fhd", "4k", "tv", "hd_en", "beinsports.com", "elcienma", "elifeon", "jawwy", "ooredoo", "shahid", "sattv", "switch", "tod", "whatson")
  self.blackStar  = b"\xe2\x9c\xa6".decode("UTF-8")
  if mode == 0:
   CCJi7o.VV8ofQ()
   self.VV2Zvo(self.SELF)
  else:
   self.tbl = SELF
   if   mode == 1: CCJi7o.VVtDuI(SELF, cbf=self.VVdKcN, toTable=True)
   elif mode == 2: CCJi7o.VVtDuI(SELF)
   elif mode == 3: CCJi7o.VV6fsU(SELF)
 @FFJRPn("Collecting Files ...", par=1)
 def VV2Zvo(self, SELF, goToFile=None):
  lst = self.VVO8K2()
  if lst:
   wTxt = "Reading names ..."
   bg = "#11001020"
   VVmolf = (""      , self.VVhUcP    , [])
   VVjW3s = ("Delete File"   , self.VVRrwP   , [])
   VVwqVu = ("XML File Channels"  , BF(self.VVUFlI, False), [], wTxt)
   VV46TD = ("More Options"   , self.VVRBHO   , [])
   VViMvb = ("EPG for Current Chan" , BF(self.VVUFlI, True) , [], wTxt)
   header  = ("File" , "Size", "Type")
   widths  = (64  , 14 , 22 )
   VV4Uoc = (LEFT  , CENTER, LEFT )
   self.tbl = FFCXsL(self.SELF, None, title=self.Title, header=header, VVXpNQ=lst, VV4Uoc=VV4Uoc, VV8boH=widths, width=1600, VVPYL1=28, VVmolf=VVmolf, VVjW3s=VVjW3s, VVwqVu=VVwqVu, VV46TD=VV46TD, VViMvb=VViMvb
        , VVfWsQ=bg, VVB5I5=bg, VVYCun=bg, VVmErq="#06554455", VVK8UQ="#00333333")
  else:
   FF6pUe(self.SELF, BF(CC7uqI, self.SELF, BF(self.VV2Zvo, self.SELF)), "No xml Files in:\n\n%s\n\nDownload ?" % self.xmltv_path, title=self.Title)
 def VVHh73(self, newPath=None):
  if newPath:
   lst = self.VVO8K2()
   if lst:
    self.tbl.VVEEBV(lst, VVyoYa=BF(self.VVAYMi, newPath), VVWBXTMsg=True)
 def VVAYMi(self, newPath, VVAIxO, title, txt, colList):
  if newPath:
   self.tbl.VVSepa(0, os.path.basename(newPath))
 def VVO8K2(self):
  lst = []
  for f in iGlob("%s*.xml" % self.xmltv_path):
   sz, typ = self.VVa7Sy(f)
   if sz > -1:
    if   sz > 200000000 : c1 = "#f#00ff4000#"
    elif sz > 10000000 : c1 = "#f#00ff8033#"
    else    : c1 = "#f#00aaffaa#"
    lst.append((os.path.basename(f), c1 + CC17eA.VVxNgx(sz, mode=4), typ))
  if lst : return sorted(lst, key=lambda x: x[0].lower())
  else : return []
 def VVa7Sy(self, path):
  sz = FFLjtI(path)
  orng =   "#f#00ff8033#"
  if sz == -1:
   return sz, orng + "Not found"
  else:
   defF = CFG.xmlTvChannelRefFile.getValue()
   c1 = "#f#0055ff55#" if defF == os.path.basename(path) else "#f#00cccccc#"
   try:
    for ndx, (event, elem) in enumerate(iElem.iterparse(path, events=("start", ))):
     if ndx == 0:
      if   elem.tag == "tv"  : return sz, "#f#00888888#" + "Events"
      elif elem.tag == "channels" : return sz, c1 + "Reference"
      else      : return sz, orng + 'Unknown tag "%s"' % elem.tag
   except Exception as e:
    return sz, orng + str(e)[:50]
 def VVhUcP(self, VVAIxO, title, txt, colList):
  fName, szTxt, Type = VVAIxO.VVQDwi()
  ttl = lambda x, y: "%s:\n%s\n\n" % (FFKrMM(x, VVv8b8), y)
  txt  = ttl("File", fName)
  txt += ttl("Size", szTxt)
  txt += ttl("Type", Type)
  path = self.xmltv_path + fName
  if 1 < FFLjtI(path) < 500:
   txt += ttl("File Contents", FFmx8y(path).strip())
  FFSMJz(self.tbl, txt, title=title)
 def VVRBHO(self, VVAIxO, title, txt, colList):
  fName, szTxt, Type = VVAIxO.VVQDwi()
  defF = CFG.xmlTvChannelRefFile.getValue()
  canView = defF and FFKbVo(self.xmltv_path + defF)
  self.curPath = self.xmltv_path + colList[0].strip()
  c1, c2, c3, c4 = VVWH8U, VVk4x7, VVv8b8, VVjojy
  VV9cxb = []
  VV9cxb.append((c1 + "Change Current Channel"   , "zap"  ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append((c2 + "Read Current Channel EPG"  , "curEv" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append((c2 + "Save Current Channel EPG"  , "saveCur" ))
  VV9cxb.append((c2 + "Save Current Channel-Group EPG" , "saveGrp" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append((c3 + "Download XML-TV File"   , "dlnd" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append((c1 + "Analyze Selected XML File Tags" , "chk" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(FFH04v("View Channel-Reference Table" , "refTable", canView, c4))
  VV9cxb.append((    "Set Channel-Reference File" , "refPick" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(FFH04v("Chain References to File Channels", "bind" , "Events" in Type , c1))
  FFO9kU(self.tbl, self.VVwCwG, VV9cxb=VV9cxb, width=950, VV3an7=3, title="XML File Options", VVfWsQ="#11110022", VVB5I5="#11110022", VVfINZ="#08663300")
 def VVwCwG(self, item):
  if   item == "zap"  : CC2Ekb.VV7p8T()
  elif item == "curEv" : CCJi7o.VVtDuI(self.tbl, cbf=self.VVdKcN, toTable=True)
  elif item == "saveCur" : CCJi7o.VVtDuI(self.tbl, cbf=self.VVHh73)
  elif item == "saveGrp" : CCJi7o.VV6fsU(self.tbl, cbf=self.VVHh73)
  elif item == "dlnd"  : CC7uqI(self.tbl, self.VVHh73)
  elif item == "chk"  : self.VVmty7(self.curPath)
  elif item == "refTable" : self.VVQEyl(self.tbl)
  elif item == "refPick" : self.VVAe4o()
  elif item == "bind"  : CCJi7o.VVIdvX(self.tbl, self.curPath)
 @FFJRPn(par=1)
 def VVQEyl(self, tbl):
  title = "Channel-Reference File (Error)"
  refLst, err = self.VVw53T(self.xmltv_path + CFG.xmlTvChannelRefFile.getValue())
  if err:
   FF6pUe(self.tbl, self.VVAe4o, "%s\n\nOpen a new file ?" % (err), title=title)
   return
  elif not refLst:
   FF6pUe(self.tbl, self.VVAe4o, "No records in:\n%s\n\nOpen a new file ?" % (os.path.basename(self.curChanRefFile)), title=title)
   return
  refLst = [(nm, rf, CC2Ekb.VVZeVo(rf, unknown="")) for nm, rf in refLst]
  bg = "#0a202020"
  refLst.sort(key=lambda x: x[0].lower())
  header   = ("Channel Name", "Reference" , "Source" )
  widths   = (46    , 42   , 12  )
  VV4Uoc  = (LEFT    , LEFT   , CENTER )
  FFCXsL(self.tbl, None, title=CFG.xmlTvChannelRefFile.getValue(), header=header, VVXpNQ=refLst, VV4Uoc=VV4Uoc, VV8boH=widths, width=1600, VVPYL1=28, VVfWsQ=bg, VVB5I5=bg, VVYCun=bg, VVmErq="#0a805000", VVK8UQ="#00333333")
 def VVAe4o(self):
  title = "Channel-Reference File"
  defF = CFG.xmlTvChannelRefFile.getValue()
  lst = []
  for fName, szTxt, Type in self.tbl.VVGpBN():
   if "Reference" in Type:
    lst.append((FFKrMM(fName, VVOQkl) if fName == defF else fName, fName))
  if lst : FFO9kU(self.tbl, self.VVPGpO, VV9cxb=sorted(lst, key=lambda x: x[1].lower()), title=title, width=1400)
  else : self.VVJf3H("No Channel-Reference files in:\n\n%s" % self.xmltv_path, title=title)
 def VVPGpO(self, fName):
  if fName:
   if self.xmltv_path + fName == self.xmltv_path + CFG.xmlTvChannelRefFile.getValue():
    FF8bV6(self.tbl, "No change", 1000)
   else:
    FFBWtx(CFG.xmlTvChannelRefFile, fName)
    FF8bV6(self.tbl, "Saved", 800, isGrn=True)
    defF = CFG.xmlTvChannelRefFile.getValue()
    for ndx, (fName, szTxt, Type) in enumerate(self.tbl.VVGpBN()):
     if "Reference" in Type:
      if fName == defF: color = "#0055ff55"
      else   : color = "#00cccccc"
      self.tbl.VVvqdM(ndx, 2, 8, FFcUfR(color))
      self.tbl.VVvqdM(ndx, 2, 9, FFcUfR(color))
 def VVjQdp(self):
  VVq9SN, VVadS0, VVjgtq, VVVmGQ, VVUwmk = FFLlAM(self.tbl)
  if VVUwmk and VVq9SN:
   self.VVtGUP = VVq9SN
   self.curChName = VVUwmk
   self.curChTitle = "Current Ch. : %s" % FFKrMM(self.curChName, VV1l75)
   return True
  else:
   self.VVJf3H("Cannot get current channel data.")
   return False
 def VVRrwP(self, VVAIxO, title, txt, colList):
  fName = colList[0].strip()
  FF6pUe(self.tbl, BF(self.VVfm9B, VVAIxO, self.xmltv_path + fName), "Delete:\n\n%s" % fName, title=self.Title)
 def VVfm9B(self, VVAIxO, path):
  FFnE7j(path)
  if FFKbVo(path):
   FFoTZI(self.tbl, "Not deleted", 1000)
  else:
   VVAIxO.VVIB2X()
   if VVAIxO.VVM62I() == 0:
    VVAIxO.cancel()
 def VVUFlI(self, isCurChan, VVAIxO, title, txt, colList):
  self.curPath = self.xmltv_path + colList[0].strip()
  if isCurChan and not self.VVjQdp():
   return
  self.VVhyUO(self.curPath)
  if self.curTotTags == -1:
   return
  chLst, err = self.VVhBkB(self.curPath)
  if not err:
   if isCurChan: self.VVwqWm(chLst)
   else  : self.VVgOXh(chLst)
  VVAIxO.VVEL2E()
 def VVwqWm(self, chLst):
  if self.VVjQdp():
   CCLbil.VVZvbO(self.tbl, CFG.xmlTvNameCompRatio, "Name Similarity Ratio (%)", cbFnc=BF(self.VVorFW, self.tbl, chLst), isSave=True)
 @FFJRPn("Filtering names ...", par=1)
 def VVorFW(self, tbl, chLst):
  mRatio  = CFG.xmlTvNameCompRatio.getValue()
  VVtGUP = self.VVtGUP.rstrip(":").upper()
  curName  = self.curChName.lower()
  lst   = []
  for name, chId, VVq9SN, iconUrl, isIcon, isRef in chLst:
   if VVq9SN == VVtGUP:
    lst.append((name, chId, "100", iconUrl, isIcon))
   else:
    tName = name.lower().replace(self.blackStar, "")
    span = iSearch(r".+[|:]\s*(.+)", tName)
    if span:
     tName = span.group(1) or name
    tName = " ".join([x for x in tName.split() if x not in self.skipLst])
    ratio = CCRGqC.VV0v8f(curName, tName)
    if ratio > mRatio:
     lst.append((name, chId, str(ratio), iconUrl, isIcon))
  if lst:
   bg = "#0a102020"
   tName = "Closest Name ( > %s%% )" % mRatio
   lst.sort(key=lambda x: int(x[2]), reverse=True)
   VVmolf = ("", self.VVt6jp  , [])
   VVj7lw  = ("", self.VVUdYW , [], "Checking file ...")
   VVHRm1   = "OK = Filter New Events"
   header  = (tName, "ID" , "Ratio" , "iconUrl" , "PIcon" )
   widths  = (88 , 0  , 0   , 0   , 12  )
   VV4Uoc = (LEFT , LEFT , CENTER , CENTER , CENTER )
   FFCXsL(self.tbl, None, title=self.curChTitle, header=header, VVXpNQ=lst, VV4Uoc=VV4Uoc, VV8boH=widths, width=1200, VVPYL1=30, VVmolf=VVmolf, VVj7lw=VVj7lw, VVHRm1=VVHRm1, VVRtfk=2
     , VVfWsQ=bg, VVB5I5=bg, VVYCun=bg, VVmErq="#0a805000", VVK8UQ="#00333333")
  else:
   self.VVJf3H("No %s%% similar name in:\n\n%s" % (mRatio, os.path.basename(self.curPath)), title=self.curChName)
  self.tbl.VVEL2E()
 def VVt6jp(self, VVAIxO, title, txt, colList):
  name, chId, ratio, iconUrl, isIcon = VVAIxO.VVQDwi()
  CCpebE.VV1v7b(self.tbl, VV6tGM=CCpebE.VVsy7G, title=title, params=(txt, iconUrl))
 def VVgOXh(self, chLst):
  refLst, err = self.VVw53T(self.xmltv_path + CFG.xmlTvChannelRefFile.getValue())
  if err:
   FF6pUe(self.tbl, self.VVAe4o, "%s\n\nOpen a new file ?" % (err), title="Channel-Reference File (error)")
   return
  refDict = dict(refLst)
  lst = []
  for name, chId, VVq9SN, iconUrl, isIcon, isRef in chLst:
   if not VVq9SN and chId in refDict:
    VVq9SN, isRef = refDict[chId], "Yes"
   lst.append((name, chId, VVq9SN, iconUrl, isIcon, isRef))
  bg = "#0a302a20"
  lst.sort(key=lambda x: x[0].lower())
  VVUZ91 = self.VVMruk
  VVmolf = (""      , self.VVISCN    , [])
  VVwqVu = ("Import EPG (Auto)"  , self.VVelcr , [])
  VV46TD = ("Multi-Select"   , self.VVFqaf   , [])
  VViMvb = ("Filter EPG to File"  , self.VV0lQh  , [])
  header   = ("Channel", "ID" , "VVq9SN" , "iconUrl" , "PIcon" , "Ref.")
  widths   = (80  , 0  , 0   , 0   , 10  , 10 )
  VV4Uoc  = (LEFT  , CENTER, CENTER , CENTER , CENTER , CENTER)
  FFCXsL(self.tbl, None, title=os.path.basename(self.curPath), header=header, VVXpNQ=lst, VV4Uoc=VV4Uoc, VV8boH=widths, width=1300, VVPYL1=30, VVmolf=VVmolf, VVwqVu=VVwqVu, VV46TD=VV46TD, VViMvb=VViMvb, VVUZ91=VVUZ91
    , VVfWsQ=bg, VVB5I5=bg, VVYCun=bg, VVmErq="#00005566", VVK8UQ="#00333333")
 def VVISCN(self, VVAIxO, title, txt, colList):
  name, chId, VVq9SN, iconUrl, isIcon, isRef = VVAIxO.VVQDwi()
  sat = CC2Ekb.VVZeVo(VVq9SN, unknown="")
  txt  = "Channel\t: %s\n" % name
  if VVq9SN : txt += "Reference\t: %s\n" % VVq9SN
  if sat  : txt += "Source\t: %s\n" % sat
  if iconUrl : txt += "\n%s:\n%s" % (FFKrMM("Icon URL", VVk4x7), iconUrl)
  CCpebE.VV1v7b(self.tbl, VV6tGM=CCpebE.VVsy7G, title=title, params=(txt, iconUrl))
 def VVFqaf(self, VVAIxO, title, txt, colList):
  CC17aQ(self.SELF, VVAIxO, addSep=False).VV4sFy(None, None, width=700)
 def VVMruk(self, VVAIxO):
  VVAIxO.VVQBxV()
  VVAIxO.VVFKrx()
  if VVAIxO.VVGZGK:
   VVAIxO.VV0rXd("OK = Select")
   if VVAIxO.VVAGI8():
    VVAIxO.VVdqRF()
    VVAIxO.VVRl3T()
  else:
   VVAIxO.VV0rXd("")
   VVAIxO.VVdqRF()
   VVAIxO.VVRl3T()
 def VV0lQh(self, VVAIxO, title, txt, colList):
  if VVAIxO["keyBlue"].getVisible():
   if VVAIxO.VVGZGK : tot = VVAIxO.VVAGI8()
   else        : tot = 1
   FF6pUe(self.tbl, BF(self.VV8JsP, VVAIxO), "Save data for %s selected channel%s to file ?" % (FFKrMM(tot, VVOQkl), FFaRsj(tot)), title=self.curChTitle)
 def VV8JsP(self, VVAIxO):
  CCV3Gw.VVgWD3(self.tbl, VVN6I4="Reading events ...", VV32kU=CCV3Gw.VVQFxC
      , VVuSHu  = BF(self.VVlwvS, VVAIxO)
      , VVhK3C = self.VVW1hR )
 def VVlwvS(self, VVAIxO, VVqeT6):
  self.tmpPath = ""
  totTags = self.VV9h49(self.curPath, VVqeT6)
  if totTags == -1:
   return
  if not VVqeT6 or VVqeT6.isCancelled:
   return
  VVqeT6.VVfT17(totTags)
  self.tmpTitle = "Filter EPG to File"
  self.tmpTotCh = self.tmpTotEv = self.tmpTotValid = self.tmpTotRep = 0
  if VVAIxO.VVGZGK : rows = VVAIxO.VVdxfP()
  else        : rows = [VVAIxO.VVQDwi()]
  idLst = [x[1] for x in rows]
  if not CCJi7o.VVN48H(self.tbl, self.Title):
   return
  tName = FFgYic(rows[0][0], r"-").replace(" ", "_")
  totCh = len(rows)
  if totCh > 1:
   tName += "_(+%s_other%s)" % (totCh - 1, FFaRsj(totCh - 1))
  self.tmpPath = "%s_%s_%s.xml" % (self.curPath[:-4], tName, FFRIlf())
  self.tmpFileFooter = "</tv>\n"
  progLst = set()
  with open(self.tmpPath, "w") as f:
   f.write('<?xml version="1.0" encoding="UTF-8"?>\n')
   f.write('<tv generator-info-name="%s-%s-EPG-Filter">\n' % (PLUGIN_NAME, VV8h7S))
   try:
    for event, elem in iElem.iterparse(self.curPath, events=("end", )):
     if not VVqeT6 or VVqeT6.isCancelled:
      return
     VVqeT6.VVqE9L(1)
     if elem.tag == "programme":
      prId = FFfkDl(elem, "channel")
      if prId in idLst:
       self.tmpTotEv += 1
       start = FFfkDl(elem, "start")
       stop  = FFfkDl(elem, "stop")
       if start and stop:
        tmpId = (start, stop, prId)
        if tmpId in progLst:
         self.tmpTotRep +=1
        else:
         self.tmpTotValid += 1
         progLst.add(tmpId)
         f.write(FFPwu2(elem)+ "\n")
      elem.clear()
     elif elem.tag == "channel":
      if FFfkDl(elem, "id") in idLst:
       self.tmpTotCh += 1
       f.write(FFPwu2(elem) + "\n")
      elem.clear()
     if self.tmpTotCh:
      totValid = FFKrMM(self.tmpTotValid, VVOQkl if self.tmpTotValid else VVPI2q)
      if not VVqeT6 or VVqeT6.isCancelled:
       return
      VVqeT6.VVX5nT("Channels: %s        Events: %s     Valid: %s" % (self.tmpTotCh, self.tmpTotEv, totValid))
   except Exception as e:
    self.VVgOre(str(e), title=self.tmpTitle)
    VVqeT6.VVY97Z()
    return
   f.write(self.tmpFileFooter)
   self.tmpFileFooter = ""
 def VVW1hR(self, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  if threadErr or self.tmpTotEv == 0:
   FFnE7j(self.tmpPath)
   if self.tmpTotEv == 0:
    FFbBGq(self.tbl, "No valid events.", title=self.tmpTitle)
  else:
   note = ""
   if self.tmpFileFooter:
    note = FFKrMM("\n\n  ... Cancelled at %s %%" % int(threadCounter * 100 / threadTotal), VVdLWL)
    with open(self.tmpPath, "a") as f:
     f.write(self.tmpFileFooter)
   repTxt = FFKrMM("   ( Repeated Event Time : %s )" % self.tmpTotRep, VVdLWL) if self.tmpTotRep else ""
   txt  = "Channels\t: %s\n" % self.tmpTotCh
   txt += "Found Events\t: %s%s\n" % (self.tmpTotEv, repTxt)
   txt += "Filtered Events\t: %s\n\n" % self.tmpTotValid
   txt += "%s\n%s" % (FFKrMM("Output File:", VVOQkl), self.tmpPath)
   txt += note
   FFSMJz(self.tbl, txt, title=self.tmpTitle)
   self.VVHh73(self.tmpPath)
 def VVmty7(self, path):
  CCV3Gw.VVgWD3(self.tbl, VV32kU=CCV3Gw.VVQFxC
      , VVuSHu  = self.VVoeVj
      , VVhK3C = self.VV96aa)
 def VVoeVj(self, VVqeT6):
  VVqeT6.VVL8uX = {}
  totTags = self.VV9h49(self.curPath, VVqeT6)
  if totTags == -1:
   return
  if not VVqeT6 or VVqeT6.isCancelled:
   return
  VVqeT6.VVX5nT("Validating XML Tags ...")
  VVqeT6.VVfT17(totTags)
  tDict = {}
  try:
   for event, elem in iElem.iterparse(self.curPath, events=("end", )):
    if not VVqeT6 or VVqeT6.isCancelled:
     return
    VVqeT6.VVqE9L(1)
    tDict[elem.tag] = tDict.get(elem.tag, 0) + 1
    elem.clear()
  except Exception as e:
   VVqeT6.VVL8uX["xErr"] = str(e)
   return
  if tDict:
   lst = [(key, val) for key, val in tDict.items()]
   lst.sort(key=lambda x: x[0].lower())
   c1 = VVk4x7
   txt  = FFKrMM("File:\n", c1)
   txt += "%s\n\n" % self.curPath
   txt += FFKrMM("XML Tags (total = %s):\n" % totTags, c1)
   for key, val in lst:
    txt += "%s\t: %s\n" % (key, val)
   if not VVqeT6 or VVqeT6.isCancelled: return
   VVqeT6.VVL8uX["txt"] = txt
   VVqeT6.VVL8uX["ttl"] = "XML Tags Validation : %sOK" % VVOQkl
  else:
   VVqeT6.VVL8uX["err"] = "No xml tags in:\n\n%s" % self.curPath
 def VV96aa(self, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  if   "err"  in VVL8uX : self.VVJf3H(VVL8uX["err"])
  elif "xErr" in VVL8uX : self.VVgOre(VVL8uX["xErr"])
  elif "txt"  in VVL8uX : FFSMJz(self.tbl, VVL8uX["txt"], height=1050, title=VVL8uX["ttl"])
 def VVhyUO(self, path):
  fName = os.path.basename(path)
  sz = FFLjtI(path)
  if sz > -1:
   return True
  else:
   FFWfGZ(self.tbl, path, title=self.Title)
   return False
 def VV9h49(self, path, VVqeT6):
  infPath = path + ".tot_tags"
  try: sz, mTm = FFLjtI(path), os.path.getmtime(path)
  except: sz, mTm = -1, 0
  if not self.VVhyUO(path):
   FFnE7j(infPath)
   return -1
  try:
   tot = self.VVUxzZ(path, infPath, sz, mTm)
   if tot:
    return tot
   else:
    tot = 0
    with ioOpen(path, "r", encoding="UTF-8") as f:
     for line in f:
      tot += line.count("</") + line.count("/>")
      if not VVqeT6 or VVqeT6.isCancelled:
       return -1
      VVqeT6.VVX5nT("Counting Tags : %s" % tot)
     self.VVARsZ(path, infPath, tot, sz, mTm)
     return tot
  except Exception as e:
   self.VVgOre(str(e))
   FFnE7j(infPath)
   return -1
 def VVARsZ(self, path, infPath, tot, sz, mTm):
  try:
   with open(infPath, "w") as f:
    f.write("%s,%s,%s" % (int(sz), mTm, tot))
  except:
   pass
 def VVUxzZ(self, path, infPath, sz, mTm):
  try:
   sz1, mTm1, tot = FFmx8y(infPath).strip().split(",")
   if (str(sz), str(mTm)) == (sz1, mTm1):
    return int(tot)
  except:
   pass
  FFnE7j(infPath)
  return 0
 @staticmethod
 def VVw53T(path):
  if not CFG.xmlTvChannelRefFile.getValue(): return [], "This requires Channel-Reference File."
  elif not FFKbVo(path)     : return [], ("File not found:\n%s" % path)
  else          : return CCJi7o.VVltHh(path)
 @staticmethod
 def VVltHh(path):
  lst = set()
  err = ""
  try:
   for ndx, (event, elem) in enumerate(iElem.iterparse(path, events=("start", ))):
    if ndx == 0 and elem.tag != "channels":
     err = "Invalid Channel-Reference File !"
     break
    elif elem.tag == "channel":
     chId = FFfkDl(elem, "id")
     if chId:
      VVq9SN = FF4jcy(elem)
      span = iSearch(r"^((?:[A-Fa-f0-9]+:){9}(?:[A-Fa-f0-9]+))", VVq9SN)
      if span:
       lst.add((chId, span.group(1).upper()))
    elem.clear()
  except Exception as e:
   err = str(e)
  return list(lst), err
 def VVhBkB(self, path, VVAdNn=True):
  lst = set()
  err = err1 = ""
  try:
   for ndx, (event, elem) in enumerate(iElem.iterparse(path, events=("start", ))):
    if ndx == 0 and elem.tag != "tv":
     err = "Not XML-TV Format:\n\n%s" % path
     break
    elif elem.tag == "channel":
     chId = FFfkDl(elem, "id")
     if chId:
      name = FFd3Fl(elem, "display-name")
      if name:
       VVq9SN = FFd3Fl(elem, "reference").rstrip(":").upper()
       iconUrl = FFFjxV(elem, "icon", "src")
       isIcon = "Yes" if iconUrl else ""
       isRef = "Yes" if VVq9SN else ""
       lst.add((name, chId, VVq9SN, iconUrl, isIcon, isRef))
     elem.clear()
    elif elem.tag == "programme":
     elem.clear()
     break
  except Exception as e:
   err1 = str(e)
  if not lst:
   err = "No channel names in:\n\n%s" % os.path.basename(self.curPath)
  if VVAdNn:
   if   err : self.VVJf3H(err)
   elif err1: self.VVgOre(err1)
  return lst, err or err1
 def VVOsFh(self, chIdSet, VVqeT6):
  tab = lambda x, y: "%s\t: %s\n" % (x, y)
  tabLst = lambda x, y: tab(x, " , ".join(y))
  now  = int(iTime())
  try:
   chan = ""
   for event, elem in iElem.iterparse(self.curPath, events=("start", )):
    if not VVqeT6 or VVqeT6.isCancelled:
     return
    VVqeT6.VVqE9L(1)
    if elem.tag == "programme":
     self.tmpTotEv += 1
     chan = FFfkDl(elem, "channel")
     if chan in chIdSet:
      startTS = self.VVwNP2(FFfkDl(elem, "start"))
      stopTS  = self.VVwNP2(FFfkDl(elem, "stop"))
      if startTS and stopTS and stopTS > startTS:
       dur = stopTS - startTS
       if startTS > now or now < startTS + dur:
        self.tmpTotNew += 1
        director = writer = producer = actor = rating = ""
        Title = FFd3Fl(elem, "title")
        descSh = FFd3Fl(elem, "sub-title")
        descLng = FFd3Fl(elem, "desc")
        Date = FFd3Fl(elem, "date")
        country = FFd3Fl(elem, "country")
        cat  = FFih6H(elem, "category")
        episode = FFih6H(elem, "episode-num")
        iconUrl = FFFjxV(elem, "icon", "src")
        cred = elem.find("credits")
        if not cred is None:
         director= FFih6H(cred, "director")
         writer = FFih6H(cred, "writer")
         producer= FFih6H(cred, "producer")
         actor = FFih6H(cred, "actor")
        rate = elem.find("rating")
        if not rate is None:
         rSys = FFFjxV(elem, "rating", "system")
         rating = FFd3Fl(rate, "value") + ((" (%s)" % rSys) if rSys else "")
        desc = ""
        if Date  : desc += tab("Date", Date)
        if country : desc += tab("Country", country)
        if rating : desc += tab("Rating", rating)
        if cat  : desc += tabLst("Category", cat)
        if episode : desc += tabLst("Episode", episode)
        if director : desc += tabLst("Director", director)
        if writer : desc += tabLst("Writer", writer)
        if producer : desc += tabLst("Producer", producer)
        if actor : desc += tabLst("Actors", actor)
        if desc  : descLng = "%s\n\n%s" % (desc.rstrip(), descLng)
        startTxt= FFG6of(startTS).replace(" ", "   ")
        startTS = str(int(startTS))
        durTxt = FFrTEd(dur)
        dur  = str(int(dur))
        isDesc = "Yes" if desc else ""
        isIcon = "Yes" if iconUrl else ""
        yield chan, (startTxt, startTS, durTxt, dur, Title, descSh, descLng, iconUrl, isDesc, isIcon)
       else:
        self.tmpTotOld += 1
        yield None, None
    elif elem.tag == "channel":
     pass
    if elem.tag != "tv":
     elem.clear()
  except Exception as e:
   self.tmpTotErr = str(e)
   yield chan, None
 def VVUdYW(self, VVAIxO, title, txt, colList):
  name, chId, ratio, iconUrl, isIcon = VVAIxO.VVQDwi()
  self.displayName = name
  CCV3Gw.VVgWD3(self.tbl, VV32kU=CCV3Gw.VVQFxC
      , VVuSHu  = BF(self.VVta5H, {chId})
      , VVhK3C = self.VVhXbp )
  VVAIxO.VVEL2E()
 def VVta5H(self, chIdSet, VVqeT6):
  self.curTotTags = self.VV9h49(self.curPath, VVqeT6)
  if self.curTotTags == -1:
   return
  if not VVqeT6 or VVqeT6.isCancelled:
   return
  VVqeT6.VVX5nT("Reading Events ...")
  VVqeT6.VVfT17(self.curTotTags)
  VVqeT6.VVL8uX = set()
  self.tmpTotEv = self.tmpTotNew = self.tmpTotOld = 0
  self.tmpTotErr = ""
  for retChId, row in self.VVOsFh(chIdSet, VVqeT6):
   if not VVqeT6 or VVqeT6.isCancelled:
    return
   if self.tmpTotErr:
    self.VVgOre(self.tmpTotErr)
    VVqeT6.VVY97Z()
    return
   elif row:
    VVqeT6.VVL8uX.add(row)
   txt = "Events: %d   (%s new)" % (self.tmpTotEv, FFKrMM(self.tmpTotNew, VVOQkl if self.tmpTotNew else VVPI2q))
   VVqeT6.VVX5nT(txt)
 def VVhXbp(self, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  if threadErr:
   pass
  elif VVL8uX:
   self.VVdKcN(FFKrMM(self.displayName, VVjojy), VVL8uX)
  elif VV6ZvL:
   if self.tmpTotOld: txt = "No new event.\n\nFound %s expired event%s." % (self.tmpTotOld, FFaRsj(self.tmpTotOld))
   else     : txt = "No valid events data !"
   self.VVJf3H(txt, title=self.curChName)
 def VVdKcN(self, VVUwmk, evLst):
  if not self.VVjQdp():
   return
  title = "EPG for : %s" % VVUwmk
  evLst = sorted(list(evLst), key=lambda x: int(x[1]))
  VVmolf = (""      , self.VVXU2e    , [])
  VVwqVu = ("Import All Events"  , self.VV9M6p , [])
  VV46TD = ("Reset Times"   , self.VVob94   , [])
  VViMvb = ("Adjust All Start Time" , self.VVxkgX  , [])
  header  = ("Start Time" , "start" ,"Duration" , "dur" , "Title" , "Summary" , "desc", "iconUrl" , "Descr." , "Poster" )
  widths  = (20   , 0   , 10  , 0  , 30  , 26  , 0  , 0   , 7   , 7   )
  VV4Uoc = (CENTER  , CENTER ,CENTER  , CENTER, LEFT  , LEFT  , LEFT , LEFT  , CENTER , CENTER )
  tbl = FFCXsL(self.tbl, None, title=title, header=header, VVXpNQ=evLst, VV4Uoc=VV4Uoc, VV8boH=widths, width=1800, VVPYL1=24, VVmolf=VVmolf, VVwqVu=VVwqVu, VV46TD=VV46TD, VViMvb=VViMvb)
  tbl.VVKxwu()
 def VVXU2e(self, VVAIxO, title, txt, colList):
  startTxt, startTS, durTxt, dur, Title, descSh, descLng, iconUrl, isDesc, isIcon = VVAIxO.VVQDwi()
  ttl = lambda x, y: "%s:\n%s\n\n" % (FFKrMM(x, VVk4x7), y)
  txt  = "Start Time\t: %s\n" % startTxt
  txt += "Duration\t: %s\n\n" % durTxt
  txt += ttl("Title", Title)
  if descSh : txt += ttl("Summary", descSh)
  if descLng: txt += ttl("Description", descLng)
  CCpebE.VV1v7b(self.tbl, VV6tGM=CCpebE.VVsy7G, title=title, params=(txt, iconUrl))
 def VV9M6p(self, VVAIxO, title, txt, colList):
  tot  = VVAIxO.VVM62I()
  ques = "Add %s event%s to current channel from:\n\n%s" % (tot, FFaRsj(tot), FFKrMM(self.displayName, VVjojy))
  FF6pUe(self.tbl, BF(self.VVXYCQ, VVAIxO), ques, title=self.curChTitle)
 @FFJRPn(par=1)
 def VVXYCQ(self, VVAIxO):
  lst = []
  for startTxt, startTS, durTxt, dur, Title, descSh, descLng, iconUrl, isDesc, isIcon in VVAIxO.VVGpBN():
   lst.append((int(startTS), int(dur), Title, descSh, descLng, 1))
  totEv, totOK = CCtAi7.VVRFU9(self.VVtGUP, lst)
  if totOK > 0:
   CCtAi7.VVFxed()
   CC2Ekb.VVIMKA(self.tbl.session)
  txt = "Total Events\t: %s\n" % totEv
  txt += "Total Added\t: %s\n" % totOK
  FFSMJz(self.tbl, txt, title=self.curChName)
 def VVelcr(self, VVAIxO, title, txt, colList):
  title = "Import EPG (Auto)"
  if VVAIxO.VVGZGK : rows = VVAIxO.VVdxfP()
  else        : rows = [VVAIxO.VVQDwi()]
  totRef = 0
  for name, chId, VVq9SN, iconUrl, isIcon, isRef in rows:
   if VVq9SN: totRef += 1
  totSel = len(rows)
  if totRef:
   ques = "Selected channels = %s ( %s with Reference )\n\nImport events for %s channel%s ?" % (totSel, totRef, totRef, FFaRsj(totRef))
   FF6pUe(self.tbl, BF(self.VVVqiB, title, rows), ques, title=title)
  else:
   s = FFaRsj(totSel)
   self.VVJf3H("No Reference%s for the selected channel%s in:\n\n%s" % (s, s, CFG.xmlTvChannelRefFile.getValue()), title=title)
 def VVVqiB(self, title, rows):
  CCV3Gw.VVgWD3(self.tbl, VVN6I4="Reading events ...", VV32kU=CCV3Gw.VVQFxC
      , VVuSHu  = BF(self.VVuzAg, title, rows)
      , VVhK3C = BF(self.VVZtXq, title) )
 def VVuzAg(self, title, rows, VVqeT6):
  totTags = self.VV9h49(self.curPath, VVqeT6)
  if totTags == -1:
   return
  if not VVqeT6 or VVqeT6.isCancelled:
   return
  VVqeT6.VVfT17(totTags)
  self.tmpTotEv = self.tmpTotNew = self.tmpTotOld = self.tmpTotAdd = self.tmpTotNoRef = self.tmpTotCh = self.tmpTotChDone = 0
  self.tmpTotErr = ""
  chIdSet = set()
  refDict = {}
  for name, chId, VVq9SN, iconUrl, isIcon, isRef in rows:
   if iMatch(r"^([A-Fa-f0-9]+:){9}(?:[A-Fa-f0-9]+)", VVq9SN):
    chIdSet.add(chId)
    refDict[chId] = VVq9SN
    self.tmpTotCh += 1
   else:
    self.tmpTotNoRef += 1
  if not chIdSet:
   self.VVJf3H("Channel Reference not found in file.", title=title)
   return
  lst = []
  doneCh = set()
  oldChId = newChId = ""
  for retChId, row in self.VVOsFh(chIdSet, VVqeT6):
   if not VVqeT6 or VVqeT6.isCancelled:
    return
   if self.tmpTotErr:
    self.VVgOre(self.tmpTotErr)
    VVqeT6.VVY97Z()
    return
   elif row:
    if not VVqeT6 or VVqeT6.isCancelled:
     return
    doneCh.add(retChId)
    self.tmpTotChDone = len(doneCh)
    VVq9SN = refDict.get(retChId, "")
    startTxt, startTS, durTxt, dur, Title, descSh, descLng, iconUrl, isDesc, isIcon = row
    lst = [(int(startTS), int(dur), Title, descSh, descLng, 1)]
    totEv, totOK = CCtAi7.VVRFU9(VVq9SN, lst)
    self.tmpTotAdd += totOK
   txt = "Events: %d   (%s new)" % (self.tmpTotEv, FFKrMM(self.tmpTotNew, VVOQkl if self.tmpTotNew else VVPI2q))
   VVqeT6.VVX5nT(txt)
 def VVZtXq(self, title, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  if threadCounter > 0:
   tab = lambda x, y: "%s\t: %s\n" % (x, y)
   txt  = ""
   txt += tab("Channels", self.tmpTotCh)
   txt += tab("Processed", self.tmpTotChDone)
   txt += "\n"
   if self.tmpTotNoRef: txt += tab("No Reference", self.tmpTotNoRef)
   txt += tab("Total Events", self.tmpTotNew + self.tmpTotOld)
   txt += tab("Added Events", self.tmpTotAdd)
   if self.tmpTotOld: txt += tab("Old Events", self.tmpTotOld)
   if not threadCounter == threadTotal:
    txt += FFKrMM("\n  ... Cancelled at %s %%" % int(threadCounter * 100 / threadTotal), VVdLWL)
   FFSMJz(self.tbl, txt, title=title, width=1500)
   if self.tmpTotAdd > 0:
    CCtAi7.VVFxed()
    CC2Ekb.VVIMKA(self.tbl.session)
 def VVxkgX(self, VVAIxO, title, txt, colList):
  self.tbl.session.openWithCallback(BF(self.VVTQ84, VVAIxO), CCUdhV, "Adjust Event Start Time")
 @FFJRPn(par=1)
 def VVTQ84(self, VVAIxO, sec=None):
  if sec is not None:
   if sec == 0:
    newSec = -self.adjustedTime
    self.adjustedTime = 0
   else:
    newSec = sec
    self.adjustedTime += sec
   lst = []
   for ndx, (startTxt, startTS, durTxt, dur, Title, descSh, descLng, iconUrl, isDesc, isIcon) in enumerate(VVAIxO.VVGpBN()):
    startTS = int(startTS) + newSec
    startTxt =  FFG6of(startTS).replace(" ", "   ")
    lst.append((startTxt, str(startTS), durTxt, dur, Title, descSh, descLng, iconUrl, isDesc, isIcon))
   VVAIxO.VVEEBV(lst)
   if self.adjustedTime:
    VVAIxO.VVExV5()
    VVAIxO["keyYellow"].setText("Reset Times ( %s %s )" % ("-" if self.adjustedTime < 0 else "+", FFrTEd(abs(self.adjustedTime))))
   else:
    VVAIxO.VVKxwu()
 def VVob94(self, VVAIxO, title, txt, colList):
  self.VVTQ84(VVAIxO, 0)
 def VVwNP2(self, tm):
  try:
   span = iSearch(r"(\d{14})(?:\s+([+-])(\d\d)(\d\d))*", tm)
   if span:
    dateTime, sign, hh,mm = span.groups()
    tStamp = mktime(datetime.strptime(dateTime, "%Y%m%d%H%M%S").timetuple())
    if sign and hh and mm:
     gmt = (int(hh) * 3600 + int(mm) * 60)
     if sign == "-":
      gmt *= -1
     tStamp -= gmt
    return tStamp - iTimezone
  except:
   pass
  return 0
 def VVJf3H(self, err, title=""):
  FFbBGq(self.tbl, err, title=title or self.Title)
 def VVgOre(self, err, title=""):
  CCQyUl.VVXqCi(self.tbl, os.path.basename(self.curPath), str(err), title=title or self.Title)
 @staticmethod
 def VVfw20(timeStamp):
  return datetime.fromtimestamp(timeStamp + iTimezone).strftime("%Y%m%d%H%M%S +0000")
 @staticmethod
 def VVIy8L(txt):
  return txt.replace("&", "&#38;")
 @staticmethod
 def VVN48H(SELF, title=""):
  path = FFJv8S() + "epg/"
  if FFlonU("mkdir -p '%s'" % path):
   return path
  else:
   FFbBGq(SELF, "Cannot create EPG directory:\n\n%s" % path, title=title or FFJ4QU().strip())
   return ""
 @staticmethod
 def VV8ofQ():
  path = FFJv8S() + "epg/"
  fName = "ajpanel_channels.xml"
  refF = path + fName
  if not FFKbVo(refF) and FFlonU("mkdir -p '%s'" % path):
   with open(refF, "w") as f:
    f.write('<?xml version="1.0" encoding="utf-8"?>\n<channels>\n</channels>\n')
 @staticmethod
 @FFJRPn()
 def VVtDuI(SELF, cbf=None, toTable=False):
  title = "Read Current Channel EPG" if toTable else "Seve Current Channel Events"
  VVAdNn = lambda x: FFbBGq(SELF, x, title=title)
  VVq9SN, VVadS0, VVjgtq, VVVmGQ, VVUwmk = FFLlAM(SELF)
  if not VVUwmk or not VVq9SN:
   VVAdNn("Cannot get current channel data.")
   return
  ec, inst = CCtAi7.VVtqyE()
  if not inst:
   VVAdNn("Cannot access EPG Cache !")
   return
  try:
   evList = inst.lookupEvent([CCtAi7.VVxlz3, (VVq9SN.rstrip(":"), 0, -1, -1)])
  except:
   evList = []
  if not evList:
   FFbBGq(SELF, "No EPG.", title=VVUwmk)
   return
  lst = []
  for start, dur, Title, descrS, descrL, pc, genre in evList:
   startTxt= FFG6of(start).replace(" ", "   ")
   startTS = str(int(start))
   durTxt = FFrTEd(dur)
   if descrS == "Not Applicable":
    descrS = ""
   more = ""
   if pc:
    for Sys, val in pc: more += "Parental Control (%s) : %s\n" % (Sys.strip(), val)
   if genre:
    for g in genre: more += "Genre : %s\n" % str(g)
   if more:
    descrL = more.rstrip() + ("\n" + descrL if descrL else "")
   lst.append((startTxt, startTS, FFrTEd(dur), str(int(dur)), Title, descrS, descrL, "", "Yes" if descrL else "", ""))
  if toTable:
   cbf(FFKrMM(VVUwmk, VVOQkl), lst)
   return
  epgDir = CCJi7o.VVN48H(SELF, title)
  if not epgDir:
   return
  tName = FFgYic(VVUwmk, r"-").replace(" ", "_")
  path = "%sajpanel_xmltv_%s_%s.xml" % (epgDir, tName, FFRIlf())
  with open(path, "w") as f:
   if not VVq9SN.endswith(":"): VVq9SN += ":"
   f.write('<?xml version="1.0" encoding="UTF-8"?>\n')
   f.write('<tv generator-info-name="%s-%s-EPG-Export">\n' % (PLUGIN_NAME, VV8h7S))
   f.write('<channel id="%s"><display-name lang="en">%s</display-name></channel>\n' % (VVUwmk, VVUwmk))
   f.write('<channel id="%s"><display-name lang="en">%s</display-name><reference>%s</reference></channel>\n' % (VVUwmk, VVUwmk, VVq9SN))
   for startTxt, startTS, durTxt, dur, Title, descSh, descLng, iconUrl, isDesc, isIcon in lst:
    end = int(startTS) + int(dur)
    start = CCJi7o.VVfw20(int(startTS))
    stop  = CCJi7o.VVfw20(end)
    f.write('<programme start="%s" stop="%s" channel="%s">\n'   % (start, stop, VVUwmk))
    f.write('\t<title lang="en">%s</title>\n'      % CCJi7o.VVIy8L(Title))
    if descSh: f.write('\t<sub-title lang="en">%s</sub-title>\n' % CCJi7o.VVIy8L(descSh))
    f.write('\t<desc lang="en">%s</desc>\n'       % CCJi7o.VVIy8L(descLng))
    f.write('</programme>\n')
   f.write("</tv>\n")
  tot = len(evList)
  FF0onH(SELF, "Saved %d event%s to:\n\n%s\n%s" % (tot, FFaRsj(tot), epgDir, os.path.basename(path)), title=VVUwmk)
  if cbf: cbf(path)
 @staticmethod
 @FFJRPn()
 def VV6fsU(SELF, cbf=None):
  title = "Save EPG to File"
  VVAdNn = lambda x: FFbBGq(SELF, x, title=title)
  ec, inst = CCtAi7.VVtqyE()
  if not inst:
   VVAdNn("Cannot access EPG Cache !")
   return
  srvLst = CC8i1k.VV2lFz()
  if not srvLst:
   VVAdNn("No services found in:\n\n%s" % rootSrc)
   return
  srvLst.sort(key=lambda x: x[1].lower())
  srvLst = [[VVUwmk, VVq9SN.rstrip(":"), 0] for x, (VVq9SN, VVUwmk) in enumerate(srvLst)]
  epgDir = CCJi7o.VVN48H(SELF, title)
  if not epgDir:
   return
  VVq9SN, refName, rootRef, rootName, inBouquet, rootSrc = CC9c0P.VVqz5S()
  path  = "%sajpanel_xmltv_%s_%s.xml" % (epgDir, FFgYic(rootName or rootSrc, r"_"), FFRIlf())
  tPath = "/tmp/ajp_xmltv"
  totChk = totCh = totEv = totPc = totGenre = 0
  with open(tPath, "w") as f:
   for ndx, (VVUwmk, VVq9SN, flag) in enumerate(srvLst):
    totChk += 1
    try:
     evList = inst.lookupEvent([CCtAi7.VVxlz3, (VVq9SN.rstrip(":"), 0, -1, -1)])
    except:
     evList = []
    if evList:
     srvLst[ndx][2] = 1
     totCh += 1
     totEv += len(evList)
     for start, dur, Title, descrS, descrL, pc, genre in evList:
      end = start + dur
      start = CCJi7o.VVfw20(start)
      stop  = CCJi7o.VVfw20(end)
      f.write('<programme start="%s" stop="%s" channel="%s">\n' % (start, stop, VVUwmk))
      f.write('\t<title lang="en">%s</title>\n'    % CCJi7o.VVIy8L(Title))
      if descrS and not "Not Applicable" in descrS:
       f.write('\t<sub-title lang="en">%s</sub-title>\n' % CCJi7o.VVIy8L(descrS))
      f.write('\t<desc lang="en">%s</desc>\n'     % CCJi7o.VVIy8L(descrL))
      if pc:
       for Sys, val in pc:
        totPc += 1
        f.write('\t<rating system="%s"><value>%s</value></rating>\n' % (Sys.strip(), val))
      if genre:
       for item in genre:
        totGenre += 1
        f.write('\t<category lang="en">%s</category>\n' % str(item))
      f.write('</programme>\n')
  if totEv:
   err = ""
   try:
    with open(path, "w") as f:
     f.write('<?xml version="1.0" encoding="UTF-8"?>\n')
     f.write('<tv generator-info-name="%s-%s-EPG-Export">\n' % (PLUGIN_NAME, VV8h7S))
     for VVUwmk, VVq9SN, flag in srvLst:
      if flag:
       if not VVq9SN.endswith(":"): VVq9SN += ":"
       f.write('<channel id="%s"><display-name lang="en">%s</display-name><reference>%s</reference></channel>\n' % (VVUwmk, VVUwmk, VVq9SN))
     with open(tPath, "r") as tmpf:
      for line in tmpf.readlines():
       f.write(line)
     f.write("</tv>\n")
    tab = lambda x, y: "%s\t: %s\n" % (x, y)
    txt  = ""
    txt += tab("Group", rootSrc)
    txt += tab("Name", rootName or rootSrc)
    txt += "\n"
    txt += tab("Channels", totCh)
    txt += tab("Events", totEv)
    if totGenre : txt += tab("Category", totGenre)
    if totPc : txt += tab("P. Control", totPc)
    txt += "\n%s\n%s" % (FFKrMM("Output File:", VVOQkl), path)
    FFSMJz(SELF, txt, title=title, width=1500)
    if cbf: cbf(path)
   except Exception as e:
    FFnE7j(path)
    VVAdNn("Error during data export:\n\n%s" % str(e))
  else:
   FFbBGq(SELF, "No EPG from %s channel%s in:\n\n%s" % (totChk, FFaRsj(totChk), rootName or rootSrc), title=VVUwmk)
  FFnE7j(tPath)
 @staticmethod
 def VVJPaH(path):
  lst = set()
  try:
   for ndx, (event, elem) in enumerate(iElem.iterparse(path, events=("start", ))):
    if ndx == 0 and elem.tag != "tv":
     return [], "File is not XML-TV Format:\n%s" % FFKrMM(path, VVPI2q)
     break
    elif elem.tag == "channel":
     chId = FFfkDl(elem, "id")
     name = FFd3Fl(elem, "display-name")
     if chId and name:
      lst.add((name, chId))
     elem.clear()
    elif elem.tag == "programme":
     elem.clear()
     break
  except Exception as e:
   return [], str(e)
  return sorted(list(lst)), ""
 @staticmethod
 @FFJRPn("Validating Files ...")
 def VVIdvX(SELF, epgF):
  title = "Chain Channel Reference to XML-TV Channel Name"
  epgDir = CCJi7o.VVN48H(SELF, title)
  if epgDir: outF = epgDir + "ajpanel_channels.xml"
  else  : return
  if FFKbVo(outF):
   chkLst, err = CCJi7o.VVltHh(outF)
   if err:
    CCQyUl.VVXqCi(SELF, outF, err, title=title)
    return
   else:
    chkLst = [(id, (ref + ":")) for id, ref in chkLst]
  else:
   chkLst = []
  lst, err = CCJi7o.VVJPaH(epgF)
  if err:
   CCQyUl.VVXqCi(SELF, outF, err, title=title)
  else:
   try:
    SELF.session.open(CCVdvJ, lst, chkLst=chkLst, srcPath=epgF, dstPath=outF
        , title=title, mnuTitle2="XMLTV Display Name", mnuTitle3="XMLTV Channel ID", blueTitle="Add Entry"
        , blueFnc=CCJi7o.VVorVm, delFnc=CCJi7o.VVOTYT)
   except:
    pass
 @staticmethod
 @FFJRPn()
 def VVorVm(bindCls):
  title= bindCls.Title
  outF = bindCls.dstPath
  d  = bindCls.VVRlr4()
  if not d["VVq9SN10"]:
   FF8bV6(bindCls, "Invalid Reference !", 800)
   return
  line = '\t<!-- %s --><channel id="%s">%s</channel><!-- %s -->\n' % (d["source"], d["mnuRef"], d["VVq9SN10"], d["name"])
  try:
   if FFKbVo(outF):
    txt = FFmx8y(outF)
    with open(outF, "w") as f:
     f.write(txt.replace("</channels>", "").strip() + "\n%s\n</channels>\n" % line)
   else:
    with open(outF, "w") as f:
     f.write('<?xml version="1.0" encoding="utf-8"?>\n')
     f.write('<channels>\n\n')
     f.write(line)
     f.write('\n</channels>\n')
   FFtn0P(bindCls, "Saved", 800)
   bindCls.VV4DM0((d["mnuRef"], d["VVq9SN10"]))
  except Exception as e:
   CCQyUl.VVXqCi(bindCls, outF, e, title=title)
 @staticmethod
 @FFJRPn()
 def VVOTYT(bindCls):
  title= bindCls.Title
  outF = bindCls.dstPath
  d  = bindCls.VVRlr4()
  try:
   lines = FF2kXa(outF, keepends=True)
   with open(outF, "w") as f:
    for line in lines:
     if not d["mnuRef"] in line and not d["VVq9SN10"] in line:
      f.write(line)
   FFtn0P(bindCls, "Deleted", 800)
   bindCls.VV32KC((d["mnuRef"], d["VVq9SN10"]))
  except Exception as e:
   CCQyUl.VVXqCi(bindCls, outF, e, title=title)
class CCVdvJ(ChannelSelectionBase):
 def __init__(self, session, VV9cxb, chkLst=None, srcPath="", dstPath="", pickMode=0, perc1=50, aligns2=None, widths2=None, fonts2=None, title="", mnuTitle1="", mnuTitle2="", mnuTitle3="", blueTitle="", blueFnc=None, delFnc=None, tBg="#11001122", bBg="#11001122", tBg1="#11220000", tBg2="#11220000", bg1="#11001122", bg2="#11001122"):
  self.skin, self.VVmNvK = FFQaOH(VV1UOW, 1800, 1000, 30, 10, 10, tBg, bBg, 30, VVSwLg=40, VVcmdl=2, VVIZ5t={"perc1": perc1, "perc2": widths2[0] if widths2 else 50, "tbg1": tBg1, "tbg2": tBg2, "bg1": bg1, "bg2": bg2})
  self.session  = session
  self.VV9cxb  = VV9cxb
  self.chkLst   = chkLst or []
  self.srcPath  = srcPath
  self.dstPath  = dstPath
  self.pickMode  = pickMode
  self.aligns2  = aligns2
  self.widths2  = widths2
  self.fonts2   = fonts2
  self.Title   = title or "Chain Channel Reference"
  self.mnuTitle1  = mnuTitle1 or "Source Channels"
  self.mnuTitle2  = mnuTitle2
  self.mnuTitle3  = mnuTitle3
  self.blueTitle  = blueTitle or "Add Selection to file"
  self.blueFnc  = blueFnc
  self.delFnc   = delFnc
  self.bg2   = bg2
  self.totRows  = 18
  self.VVCW3G  = 40
  self.curMenu  = 1
  self.VVPYL1  = int(self.VVCW3G * 0.82)
  self.cursCur  = "#08885500"
  self.cursNorm  = "#08223333"
  self.curRef   = ""
  self.cancelTime  = 0
  self.added   = False
  self.lastChannel = self.VV5YeZ()
  self.tpData   = CCrDr0()
  self.isVti   = CCg47Y.VVKvUI()
  FFNhKZ(self, title=self.Title)
  self["myMenu"]  = MenuList([], True, eListboxPythonMultiContent)
  self["myTitle1"] = Label(self.mnuTitle1)
  self["myTitle2"] = Label(self.mnuTitle2)
  self["myTitle3"] = Label(self.mnuTitle3)
  self["myFrm1"]  = Label()
  self["myFrm2"]  = Label()
  FFi79B(self["keyRed"] , "Group = Favourite")
  FFi79B(self["keyGreen"] , "Show Chains")
  FFi79B(self["keyYellow"], "Find Close Name")
  FFi79B(self["keyBlue"] , self.blueTitle)
  if self.pickMode == 0: self["keyBlue"].hide()
  self["keyGreen"].hide()
  try:
   from difflib import get_close_matches as iClosest
   self.iClosest = iClosest
  except:
   self.iClosest = None
  ChannelSelectionBase.__init__(self, session)
  self.bouquet_mark_edit = 0
  FFrM8n(self,
  {
   "ok"  : self.VVyuDa  ,
   "cancel" : self.cancel  ,
   "info"  : self.VVecqG ,
   "menu"  : self.VVKeTE ,
   "tv"  : self.VV4fRJ,
   "red"  : self.VVVVz6 ,
   "green"  : self.VVEYOv,
   "yellow" : self.VVbUMn,
   "blue"  : self.VViFLH ,
   "down"  : self.VV41MG  ,
   "up"  : self.VVCdU6   ,
   "left"  : self.VVDDr1  ,
   "right"  : self.VVksC6  ,
   "pageUp" : self.VVRlRL  ,
   "chanUp" : self.VVRlRL  ,
   "pageDown" : self.VV4SSV ,
   "chanDown" : self.VV4SSV ,
   "next"  : self.VVlOwU  ,
   "last"  : self.VVqo47
  }, name="ChannelSelectBaseActions", prio=-2)
  FFrM8n(self, {})
  self.onShown.append(self.VVf1Ra)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  FFeo1z(self)
  FFuwGk(self)
  obj  = self["myMenu"]
  objL = obj.l
  self.VV3JFg()
  FFvJ8o(obj, bg=self.cursNorm)
  objL.setFont(0, gFont(VV3IRX, self.VVPYL1))
  objL.setFont(1, gFont(VV3IRX, int(self.VVPYL1 * 0.7)))
  objL.setItemHeight(self.VVCW3G)
  obj.setList(self.VVgYUv())
  obj.setList(obj.list)
  obj  = self["list"]
  objL = obj.l
  self.setTvMode()
  self.showFavourites()
  obj.setMode(1)
  self.VVsyfJ()
  FFvJ8o(obj, bg=self.cursCur)
  obj.onSelectionChanged.append(self.VVHVrU)
  objL.setItemHeight(self.VVCW3G)
  try:
   objL.setColor(objL.eventForeground, parseColor("#00ffffaa"))
   objL.setItemsDistances(15)
  except:
   pass
  objL.setColor(objL.serviceEventProgressbarColor, parseColor("#0000ff00"))
  objL.setColor(objL.serviceEventProgressbarColorSelected, parseColor("#0000ff00"))
  objL.setColor(objL.serviceEventProgressbarBorderColor, parseColor("#00ffffff"))
  self.VVvxsk()
 def VVKeTE(self):
  VV9cxb = []
  VV9cxb.append(("Go to Current Playing Channel" , "cur" ))
  VV9cxb.append(("Go to Original Playing Channel" , "orig"))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(FFH04v("Delete Selected Chain", "del" , self.delFnc and self.VV76qn(), VVdLWL))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Exit  (or double-Cancel)"   , "exit"))
  FFO9kU(self, self.VV5QnJ, title="Options", VV9cxb=VV9cxb)
 def VV5QnJ(self, item):
  if item:
   if   item == "cur"  : self.VVJXKF(False)
   elif item == "orig"  : self.VVJXKF(True)
   elif item == "del"  : self.delFnc(self)
   elif item == "exit"  : self.close()
 def VVyuDa(self):
  if self.curMenu == 1:
   serv = self.getCurrentSelection()
   if serv.flags & 7 == 7:
    self.enterPath(serv)
    self.VVsyfJ()
    serv = self.session.nav.getCurrentlyPlayingServiceReference()
    if serv:
     try: self.setCurrentSelectionAlternative(serv)
     except: self.setCurrentSelection(serv)
   elif serv.flags == 0:
    FF9SoI(self.session, self.curRef)
    FFd2In(self, "Cancel to go back to table")
  self.VVvxsk()
 def cancel(self):
  if iTime() - self.cancelTime < 0.6:
   self.close()
  elif self.curMenu == 2:
   self.VVDDr1()
  else:
   self.keyGoUp()
   self.VVsyfJ()
   self.VVvxsk()
   self.cancelTime = iTime()
 def VVecqG(self):
  lst= []
  d  = self.VVRlr4()
  def VVxN3u(x, y):
   if y: lst.append((c + x, y))
  c, s = "#b#11440044#", "Source Channel - "
  VVxN3u(s + "Name"  , d["name"])
  VVxN3u(s + "Reference" , "" if "ORDER BY" in d["noPhpRef"] else d["noPhpRef"])
  VVxN3u(s + "Source" , d["source"] + (" (%s)" % d["satLong"]) if d["satLong"] else "")
  VVxN3u(s + "Path"  , d["path"])
  VVxN3u(s + "Parent" , d["rootName"])
  VVxN3u(s + "ParentPath", d["rootPath"])
  c, s = "#b#11001122#", "Destination Channel - "
  VVxN3u(s + "Row Number", "%d of %d" % (d["mnuRowNum"], len(self.VV9cxb)))
  VVxN3u(s + self.mnuTitle2, d["mnuTxt"])
  VVxN3u(s + self.mnuTitle3, d["mnuRef"])
  VVxN3u(s + "Source File", self.srcPath)
  VVxN3u(s + "Output File", self.dstPath)
  FFCXsL(self, None, title=self.Title, VVXpNQ=lst, VV8boH=(40, 60), width=1700, VVPYL1=28, VVmErq="#0a333333", VVK8UQ="#00333333", VVRtfk=1)
 def VVEYOv(self):
  if self["keyGreen"].getVisible():
   self.VVxXRX()
 def VViFLH(self):
  if self["keyBlue"].getVisible():
   if self.added: FF8bV6(self, "Already Added.", 1000)
   else   : self.blueFnc(self)
 def VVCdU6(self):
  if self.curMenu == 1: self.moveUp()
  else    : self["myMenu"].up()
  self.VVvxsk()
 def VV41MG(self):
  if self.curMenu == 1: self.moveDown()
  else    : self["myMenu"].down()
  self.VVvxsk()
 def VVRlRL(self):
  if self.curMenu == 1: self.servicelist.instance.moveSelection(self.servicelist.instance.pageUp)
  else    : self["myMenu"].pageUp()
  self.VVvxsk()
 def VV4SSV(self):
  if self.curMenu == 1: self.servicelist.instance.moveSelection(self.servicelist.instance.pageDown)
  else    : self["myMenu"].pageDown()
  self.VVvxsk()
 def VVqo47(self):
  if self.curMenu == 1: self["list"].moveToPrevMarker()
  else    : self["myMenu"].moveToIndex(0)
 def VVlOwU(self):
  if self.curMenu == 1: self["list"].moveToNextMarker()
  else    : self["myMenu"].moveToIndex(len(self["myMenu"].list) - 1)
 def VVDDr1(self):
  if self.curMenu == 2:
   self.curMenu = 1
   self.VVvxsk()
 def VVksC6(self):
  if self.curMenu == 1:
   self.curMenu = 2
   self.VVvxsk()
 def VVhINX(self, ndx):
  self["myMenu"].moveToIndex(ndx)
 def VV5YeZ(self):
  root = None
  serv = self.session.nav.getCurrentlyPlayingServiceReference()
  if serv:
   root = InfoBar.instance.servicelist.getRoot()
  return serv, root
 def VVJXKF(self, isOrig):
  serv = root = None
  if isOrig: serv, root = self.lastChannel
  else  : serv, root = self.VV5YeZ()
  if serv and root:
   self.enterPath(root)
   self.servicelist.setCurrent(serv)
   self.VVsyfJ()
   self.VVDDr1()
   d = self.VVRlr4()
   self["keyRed"].setText("Group = %s" % d["gName"])
 @FFJRPn()
 def VVbUMn(self):
  d = self.VVRlr4()
  lst = [item[0] for item in self.VV9cxb]
  lst.extend([item[1] for item in self.VV9cxb])
  bestLst = self.iClosest(d["name"], lst, 1, 0.6)
  if bestLst : self.VVmTCA(bestLst[0])
  else  : FF8bV6(self, "Not found.", 500)
 def VVmTCA(self, id):
  for ndx, item in enumerate(self.VV9cxb):
   txt = item[0]
   ref = item[1]
   if txt == id or ref == id:
    self["myMenu"].moveToIndex(ndx)
    self.VVvxsk()
    break
 def VVM9V6(self):
  d = self.VVRlr4()
  lst = []
  for txt, ref in self.chkLst:
   if d["VVq9SN10"] == ref:
    return True
  return False
 def VVxXRX(self):
  d = self.VVRlr4()
  lst = []
  lst2 = []
  for txt, ref in self.chkLst:
   if d["VVq9SN10"] == ref:
    txt1 = FFKrMM(txt, VV0p9P)
    for item in self.VV9cxb:
     if txt in item:
      txt1 = FFKrMM(item[0], VVWH8U) + FFKrMM("  (%s)" % item[1], VV3Hcc)
      lst.append((txt1, txt))
      break
    else:
     lst2.append((txt1, txt))
  if lst or lst2:
   lst.sort(key=lambda x: x[0].lower())
   lst2.sort(key=lambda x: x[0].lower())
   if lst and lst2 : lst.append(VVbM5H)
   if lst2   : lst.extend(lst2)
   FFO9kU(self, self.VV0mqT, VV9cxb=lst, width=1200, title="Item%s Linked to : %s" % (FFaRsj(len(lst)), FFKrMM(d["name"], VVWH8U)), VVfWsQ="#11001122", VVB5I5="#11001122", VVfINZ="#11330000")
  else:
   FFoTZI(self, "Not found", 800)
 def VV0mqT(self, toFind):
  if toFind:
   for ndx, item in enumerate(self.VV9cxb):
    txt = item[0]
    ref = item[1]
    if ref == toFind:
     self.VVhINX(ndx)
     self.VVvxsk()
     break
   else:
    FFbBGq(self, "Not found in current list.\n\nProbably added from another list.", toFind)
 def VVvxsk(self):
  if self.VV76qn() : tBg, cBg, self.added = "#00ff8000", "#00ff0000", True
  else        : tBg, cBg, self.added = "#00ffffff", self.cursCur, False
  FFMhbx(self["myTitle1"], tBg)
  FFMhbx(self["myTitle2"], tBg)
  FFMhbx(self["myTitle3"], tBg)
  if self.curMenu == 1:
   CCwyMT(self, self["list"])
   FFvJ8o(self["list"], bg=cBg)
   FFvJ8o(self["myMenu"], bg=self.cursNorm)
  else:
   CCwyMT(self, self["myMenu"])
   FFvJ8o(self["list"], bg=self.cursNorm)
   FFvJ8o(self["myMenu"], bg=cBg)
  for obj in ("list", "myMenu"):
   inst = self[obj].instance
   inst.setSelectionEnable(0)
   inst.setSelectionEnable(1)
 def VV4DM0(self, item):
  self.chkLst.append(item)
  self.VVvxsk()
 def VV32KC(self, item):
  self.chkLst.remove(item)
  self.VVvxsk()
 def VV76qn(self):
  d = self.VVRlr4()
  newEntry = (d["mnuRef"], d["VVq9SN10"])
  return newEntry in self.chkLst
 def VVRlr4(self):
  serv = self.getCurrentSelection()
  d = {"name": "", "rootName": "", "VVq9SN": "", "VVq9SN10": "", "noPhpRef": "", "rootRef": "", "gName": "", "source": "", "satLong": "", "path": "", "rootPath": ""}
  ndx, txt, ref = self.VVhEjT()
  d["mnuRowNum"], d["mnuTxt"], d["mnuRef"] = ndx + 1, txt, ref
  if serv:
   VVq9SN   = serv.toString()
   path   = CCM4Rv.VVFC75(VVq9SN, mode=1)
   if "ORDER BY" in path: path = ""
   span = iSearch(r"((?:[A-Fa-f0-9]+[:]){10})", VVq9SN)
   if span  : d["VVq9SN10"] = span.group(1)
   if not path : d["satLong"]   = FFgAAw(VVq9SN, True)
   d["VVq9SN"] = VVq9SN
   d["name"]  = FFEnx2(VVq9SN)
   d["source"]  = CC2Ekb.VVZeVo(VVq9SN, unknown="")
   d["noPhpRef"]= iSub(r"[&?]mode=.+end=", r"", VVq9SN, flags=IGNORECASE)
   d["path"]  = path
   rootRef   = self.getRoot().toString()
   rootPath  = CCM4Rv.VVFC75(rootRef, mode=1)
   if "ORDER BY" in rootPath: rootPath = ""
   gNum, gName  = self.VVYrMj(rootRef)
   d["rootRef"] = rootRef
   d["rootName"]= FFEnx2(rootRef)
   d["gName"]  = gName
   d["rootPath"]= rootPath
  return d
 def VVhEjT(self):
  ndx = self["myMenu"].l.getCurrentSelectionIndex()
  txt = self.VV9cxb[ndx][0]
  ref = self.VV9cxb[ndx][1]
  return ndx, txt, ref
 def VV4fRJ(self):
  try:
   if   self.mode == 0: self.setRadioMode()
   elif self.mode == 1: self.setTvMode()
   serv = self.getCurrentSelection()
   if serv.flags & 7 == 7:
    self.enterPath(serv)
   rootRef = self["list"].getRoot().toString()
   gNum, gName = self.VVYrMj(rootRef)
   self.VV6QOq(gNum)
  except:
   pass
 def VVYrMj(self, VVq9SN):
  if   "(satellitePosition == " in VVq9SN: return 2, "Satellite"
  elif "Current transponder" in VVq9SN : return 2, "Transponder"
  elif "(provider == " in VVq9SN   : return 3, "Provider"
  elif "FROM BOUQUET" in VVq9SN   : return 4, "Favourite"
  else         : return 1, "ALL"
 def VVVVz6(self):
  FFO9kU(self, self.VV6QOq, width=500, VV9cxb=[("All", 1), ("Satellites", 2), ("Provider", 3), ("Favourites", 4)], title="Channels Group")
 def VV6QOq(self, g):
  if g:
   if   g == 1: self.showAllServices()
   elif g == 2: self.showSatellites()
   elif g == 3: self.showProviders()
   elif g == 4: self.showFavourites()
   self.VVsyfJ()
   self.VVvxsk()
   self["keyRed"].setText("Group = " + {1:"All", 2:"Satellites", 3:"Provider", 4:"Favourites", }.get(g, "?"))
 def VVgYUv(self):
  totCol = len(self.VV9cxb[0])
  align = self.aligns2 or [LEFT] * totCol
  font = self.fonts2 or [0] * totCol
  fg  = [FFcUfR("#00ffffff")] * totCol
  fg[1] = FFcUfR("#00666666")
  bg  = FFcUfR(self.bg2)
  sFg  = [FFcUfR("#00ffffff")] * totCol
  sFg[1] = FFcUfR("#00888888")
  w  = self["myMenu"].instance.size().width()
  if self.widths2 : widths = [w * r / 100 for r in self.widths2]
  else   : widths = [w  // totCol] * totCol
  rows  = []
  for rNdx, row in enumerate(self.VV9cxb):
   cols = [rNdx]
   posX = 0
   for cNdx, txt in enumerate(row):
    gap = (0 if align[cNdx] == CENTER else 8)
    cols.append(CC4ngo.VVI3ci( posX + gap, 0
              , widths[cNdx] - gap, self.VVCW3G
              , font[cNdx]
              , align[cNdx] | RT_VALIGN_CENTER
              , txt
              , fg[cNdx]
              , bg
              , sFg[cNdx]
              , None
              , 0
              , None
              ))
    posX += widths[cNdx]
   rows.append(cols)
  return rows
 def VV3JFg(self):
  inst = self["myMenu"].instance
  sz = inst.size()
  w, h = sz.width(), sz.height()
  self.VVCW3G = h // self.totRows
  diff = h % self.totRows
  if diff:
   for obj in ("list", "myMenu", "myFrm1", "myFrm2"):
    inst = self[obj].instance
    w, h = inst.size().width(), inst.size().height()
    inst.resize(eSize(*(w, h - diff)))
   inst = self.instance
   w, h = inst.size().width(), inst.size().height()
   inst.resize(eSize(*(w, h - diff)))
   screenSize = getDesktop(0).size()
   inst.move(ePoint((screenSize.width() - w) // 2, (screenSize.height() - h) // 2))
   for name in ("keyRed", "keyGreen", "keyYellow", "keyBlue", "myBar", "myLine"):
    obj = self[name]
    inst = obj.instance
    pos = obj.getPosition()
    obj.instance.move(ePoint(pos[0], pos[1] - diff))
 def VVsyfJ(self):
  obj = self["list"]
  objL= obj.l
  objL.setItemHeight(self.VVCW3G)
  numFontSz = int(self.VVCW3G * 0.45)
  objL.setElementFont(objL.celServiceNumber, gFont(VV3IRX, numFontSz))
  objL.setElementFont(objL.celServiceName, gFont(VV3IRX, self.VVPYL1))
  objL.setElementFont(objL.celServiceInfo, gFont(VV3IRX, int(self.VVCW3G * 0.60)))
  if self.isVti:
   return
  try:
   inst = obj.instance
   numW = self.VVHlXT(inst, gFont(VV3IRX, numFontSz), inst.size(), "0000").width()
   rowW = inst.size().width() - 30
   nameW = rowW - (numW + obj.fieldMargins + obj.progressBarWidth + obj.fieldMargins)
   serv = self.getCurrentSelection()
   objL.setElementPosition(objL.celServiceNumber, eRect(0, 0, numW, self.VVCW3G))
   if serv and serv.flags == 0 : left = numW + obj.fieldMargins
   else      : left = 10
   objL.setElementPosition(objL.celServiceName, eRect(left, 0, nameW, self.VVCW3G))
   objL.setElementPosition(objL.celServiceEventProgressbar, eRect(rowW - obj.progressBarWidth, 0, obj.progressBarWidth, self.VVCW3G))
  except:
   pass
 def VVHlXT(self, instance, font, targetSize, txt):
  from enigma import eLabel
  return eLabel.calculateTextSize(font, txt, targetSize)
 def VVHVrU(self):
  self["keyBlue"].hide()
  serv = self.getCurrentSelection()
  if serv and serv.flags == 0:
   self.curRef = serv.toString()
   txt = CC2Ekb.VVZeVo(self.curRef, unknown="")
   tpTxt = self.tpData.VVAv0x(self.curRef)
   if tpTxt: txt += " (%s)" % tpTxt
   if txt : txt += " - "
   txt = (txt + self.curRef).strip()
   if len(txt) > 61: txt = txt[:61] + ".."
   if self.pickMode in (0, 2): self["keyBlue"].show()
  else:
   self.curRef = ""
   txt = self.mnuTitle1
   if self.pickMode in (1, 2): self["keyBlue"].show()
  if self.VVM9V6() : self["keyGreen"].show()
  else     : self["keyGreen"].hide()
  self["myTitle1"].setText(txt)
class CC7uqI():
 def __init__(self, SELF, cbf=None):
  self.SELF  = SELF
  self.cbf  = cbf
  self.Title  = "Download XML-TV File"
  self.urlsPath = FFJv8S() + "ajpanel_epg_source"
  self.dstPath = FFJv8S() + "epg/"
  self.tbl  = None
  self.lastPath = ""
  if not FFKbVo(self.urlsPath):
   FFWfGZ(self.SELF, self.urlsPath, title=self.Title)
   return
  self.epgDir = CCJi7o.VVN48H(SELF, self.Title)
  if not self.epgDir:
   return
  lst = self.VVYy13()
  if lst:
   if self.tbl:
    self.tbl.VVEEBV(lst)
   else:
    lst.sort(key=lambda x: x[0].lower())
    bg = "#11112233"
    VVpW7I = self.VVn6eG
    VVwqVu = ("Download", self.VVQYnW, [])
    header  = ("File", "URL", "Exists" )
    widths  = (28  , 64 , 8   )
    VV4Uoc = (LEFT  , LEFT , CENTER )
    self.tbl = FFCXsL(self.SELF, None, title=self.Title, header=header, VVXpNQ=lst, VV8boH=widths, VV4Uoc=VV4Uoc, width=1700, VVPYL1=26, VVpW7I=VVpW7I, VVwqVu=VVwqVu, VVfWsQ="#00004455", VVB5I5=bg, VVYCun=bg, VVmErq="#0a665533", VVK8UQ="#00333333", VVgSJJ="#00552222")
  else:
   FFbBGq(self.SELF, "No valid URLs in:\n\n%s" % path, title=self.Title + " (xml/gz/xz)" )
 def VVn6eG(self, VVAIxO):
  if self.lastPath and self.cbf:
   self.cbf(self.lastPath)
  VVAIxO.cancel()
 def VVYy13(self):
  lst = []
  for url in FF2kXa(self.urlsPath):
   url = url.strip()
   if not url.startswith("#") and url.endswith((".gz", ".xz", ".xml")) and not url.endswith((".tar.gz", ".tar.xz")):
    fName = os.path.basename(url)
    if fName.endswith((".gz", ".xz")) : fName = fName[:-3]
    if not fName.endswith(".xml")  : fName += ".xml"
    lst.append((fName, url, "Yes" if FFKbVo(self.dstPath + fName) else ""))
  return lst
 def VVQYnW(self, VVAIxO, title, txt, colList):
  fName, url, exist = VVAIxO.VVQDwi()
  for ext, tool in {".gz": "gzip", ".xz":"xz"}.items():
   if url.endswith(ext) and not FFW91j(tool):
    FFbBGq(self.tbl, 'Please install "%s" to handle the "%s" files.' % (tool, ext), title=self.Title)
    return
  ques = "Download%s:\n\n%s" % (" (%s)" % FFKrMM("and overwrite", VVdLWL) if FFKbVo(self.epgDir + fName) else "", fName)
  FF6pUe(self.tbl, BF(self.VVIHtZ, self.tbl, url, fName), ques, title=self.Title)
 @FFJRPn("Downloading ...", par=1, clearMsg=False)
 def VVIHtZ(self, tbl, url, fName):
  path, err = FFUzwU(url, os.path.basename(url), timeout=3, tmpPath=self.epgDir)
  if path:
   self.VVQr6L(self.tbl, path)
  else:
   FFbBGq(self.tbl, "Download Error:\n\n%s" % err, title=self.Title)
   FFoTZI(self.tbl)
 @FFJRPn("Extracting ...", par=1)
 def VVQr6L(self, tbl, path):
  if path.endswith((".gz", ".xz")):
   txt = FF4aqG("%s -fd '%s'" % ("gzip" if path.endswith("gz") else "xz", path))
   if not txt:
    src = path[:-3]
    path = src
    if not path.endswith(".xml"):
     path = src + ".xml"
    if not FFlonU("mv -f '%s' '%s'" % (src, path)):
     FFbBGq(self.tbl, "Cannot rename the downloaded file:\n\n%s" % src, title=self.Title)
     return
   else:
    FFbBGq(self.tbl, "Cannot extract:\n%s\n\n( %s )" % (path, txt), title=self.Title)
    return
  self.lastPath = path
  FFxHED(self.tbl, "Downloaded")
  try:
   fName, url, exist = self.tbl.VVQDwi()
   self.tbl.VVsu0I((fName, url, FFKrMM("New", VVOQkl)))
  except:
   pass
class CCtAi7(Screen, CCQyUl):
 VVXWB1  = "BDTSE"
 VVxlz3  = "BDTSEPW"
 VV68H4   = "save"
 VV8vsl   = "load"
 VVBOGM  = "flushEPG"
 def __init__(self, session):
  self.skin, self.VVmNvK = FFQaOH(VVNkG2, 1000, 1000, 50, 40, 30, "#22110011", "#22110022", 30)
  self.session  = session
  c1, c2, c3, c4, c5 = VVWH8U, VVk4x7, VVWH8U, VV1l75, VVdLWL
  valid, path, sz, szTxt, modTm = CCtAi7.VVZae3()
  qUrl, VVadS0, VVVmGQ = CCTe4w.VVKjeQ(self)
  VV9cxb = []
  VV9cxb.append((c1 + "XML-TV Tools", "xmltvTools"))
  VV9cxb.append(VVbM5H)
  VV9cxb.append((c2 + "Read Current Channel EPG"  , "curEv" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append((c2 + "Save Current Channel EPG"  , "saveCur" ))
  VV9cxb.append((c2 + "Save Current Channel-Group EPG" , "saveGrp" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append((c3 + "EPG Events Counter"    , "evCount" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append((c4 + "Cache File Info.", "inf"))
  VV9cxb.append(VVbM5H)
  fTxt = " (%s)" % os.path.basename(path) if valid else ""
  VV9cxb.append(FFH04v("Save EPG to File%s" % fTxt , self.VV68H4, valid))
  VV9cxb.append(FFH04v("Load EPG from File%s" % fTxt , self.VV8vsl, valid))
  VV9cxb.append(VVbM5H)
  VV9cxb.append((c5 + "Delete EPG (from RAM only)", self.VVBOGM))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(FFH04v("Update Current Bouquet EPG/PIcons (from IPTV Server)", "VVmmMb", qUrl or "chCode" in VVVmGQ))
  VV9cxb.append(("Copy EPG between Channels (from xml file)", "copyEpg" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Translate Current Channel EPG", "VV78zU"))
  FFNhKZ(self, title="EPG Tools", VV9cxb=VV9cxb)
  self.onShown.append(self.VVf1Ra)
 def VVyuDa(self):
  item = FFgo5c(self)
  if item is not None:
   if   item == "xmltvTools"   : CCJi7o(self)
   elif item == "curEv"    : CCJi7o(self, mode=1)
   elif item == "saveCur"    : CCJi7o(self, mode=2)
   elif item == "saveGrp"    : CCJi7o(self, mode=3)
   elif item == "evCount"    : self.VVmZUQ()
   elif item == "inf"     : self.VVQF90()
   elif item in (self.VV68H4, self.VV8vsl, self.VVBOGM):
    reset = item == self.VV8vsl
    FF6pUe(self, BF(self.VVc8uF, item, reset), VVqg4G="Continue ?")
   elif item == "VVmmMb": CCTe4w.VVmmMb(self)
   elif item == "copyEpg"    : self.VVWvup(False, onlyEpg=True)
   elif item == "VV78zU" : self.VV78zU()
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  FFvJ8o(self["myMenu"])
  FFNUiO(self)
 @FFJRPn()
 def VVc8uF(self, act, reset=False):
  ok = CCtAi7.VVhoAj(act)
  if ok:
   if reset:
    CC2Ekb.VVIMKA(self.session)
   FF0onH(self, "Done")
  else:
   FF0onH(self, "Failed!")
 def VVQF90(self):
  title = "EPG Cache File"
  valid, path, sz, szTxt, modTm = CCtAi7.VVZae3()
  if path:
   if valid: txt = "File Path\t: %s\n\nFile Size\t: %s\n\nModified\t: %s\n" % (path, szTxt or "?", modTm)
   else : txt = "System Settings: %s\n\n%s" % (path, FFKrMM("File not found (check System EPG settings).", VVdLWL))
   FFSMJz(self, txt, title=title)
  else:
   FFbBGq(self, "Cannot read Path Settings !", title=title)
 @FFJRPn()
 def VVmZUQ(self):
  title = "EPG Events Counter"
  ec, inst = CCtAi7.VVtqyE()
  if not inst:
   FFbBGq(self, "Cannot access EPG Cache !", title=title)
   return
  lst = CC2Ekb.VVwkaL("1:7:")
  lst = [(n, r.rstrip(":"), FFgAAw(r, False)) for r, n in lst]
  lst2 = CC8i1k.VVjNDz()
  lst.extend([(n, r.rstrip(":"), "IPTV") for r, n in lst2])
  lst2 = None
  VVuGUx = []
  totEv = 0
  for n, r, t in lst:
   evList = inst.lookupEvent([CCtAi7.VVXWB1, (r.rstrip(":"), 0, -1, -1)])
   tot = len(evList)
   if tot:
    totEv += tot
    VVuGUx.append((n, r, t, str(tot)))
  if VVuGUx:
   title += FFKrMM("  ( Total Events = %s )" % totEv, VV0p9P)
   bg = "#0a112525"
   VVuGUx.sort(key=lambda x: x[0].lower())
   header  = ("Name" , "Reference" , "Source" , "EPG Events" )
   widths  = (40  , 40   , 8   , 12   )
   VV4Uoc = (LEFT  , LEFT   , CENTER , CENTER )
   VVAIxO = FFCXsL(self, None, title=title, header=header, VVXpNQ=VVuGUx, VV4Uoc=VV4Uoc, VVdZd9=True, width=1800, height=950, VV8boH=widths, VVPYL1=28
         , VVfWsQ=bg, VVB5I5=bg, VVYCun=bg)
  else:
   FFbBGq(self, "No channels with cached EPG !", title=title)
 def VV78zU(self):
  title = "Translate Current Channel EPG"
  bg = "#11101010"
  VVj7lw  = (""   , BF(self.VVTiQ8, title, True) , [])
  VVwqVu = ("Start"  , BF(self.VVTiQ8, title, False), [])
  VViMvb = ("Language" , self.VV1Mid         , [])
  widths  = (50 , 50 )
  VV4Uoc = (LEFT , CENTER)
  FFCXsL(self, None, title=title, VVXpNQ=self.VVNciL(), VV4Uoc=VV4Uoc, VV8boH=widths, width=900, VVoqL2=20, VVPYL1=30, VVj7lw=VVj7lw, VVwqVu=VVwqVu, VViMvb=VViMvb, VVRtfk=2
    , VVfWsQ="#11201010", VVB5I5=bg, VVYCun=bg, VVmErq="#00004455", VVK8UQ=bg)
 def VVNciL(self):
  ch = dict(self.VVv1w6())
  VVuGUx = []
  VVuGUx.append(("Event Name Language" , ch.get(CFG.epgLangTitle.getValue(), "")))
  VVuGUx.append(("Description Language", ch.get(CFG.epgLangDescr.getValue(), "")))
  return VVuGUx
 def VV1Mid(self, VVAIxO, title, txt, colList):
  ndx = VVAIxO.VVoxea()
  title = colList[0]
  confItem = CFG.epgLangTitle if ndx == 0 else CFG.epgLangDescr
  CCLbil.VVZvbO(self, confItem, title, lst=self.VVv1w6(), cbFnc=BF(self.VV4CPx, VVAIxO), isSave=True)
 def VV4CPx(self, VVAIxO):
  for ndx, row in enumerate(self.VVNciL()):
   VVAIxO.VVUvuG(ndx, row)
  FFxHED(VVAIxO, "Saved", 600)
 def VVv1w6(self):
  lst = [("", "DISABLED")]
  for line in FF2kXa("%sajpanel_lang" % VVK8DT):
   span = iSearch(r"\s*(.+)\s*,\s*(.+)\s*", line)
   if span:
    lst.append((span.group(1), span.group(2)))
  return lst
 def VVTiQ8(self, Title, isAsk, VVAIxO, title, txt, colList):
  tVal, dVal = CFG.epgLangTitle.getValue(), CFG.epgLangDescr.getValue()
  if not (tVal or dVal):
   FFoTZI(VVAIxO, "Change Language", 700)
  else:
   VVq9SN, VVadS0, VVjgtq, VVVmGQ, VVUwmk = FFLlAM(self)
   VVq9SN, evList, err = CCtAi7.VVQsbF(VVq9SN)
   fnc = BF(self.VVbpPi, Title, VVq9SN, evList, VVAIxO)
   if   err : FFbBGq(self, err, title=Title)
   elif isAsk : FF6pUe(self, fnc, "Start ?", title=Title)
   else  : fnc()
 def VVbpPi(self, title, VVq9SN, evList, VVAIxO):
  CCV3Gw.VVgWD3(self, VVN6I4=title, titleBg="#22003344", bodyBg="#22001122"
      , VVuSHu  = BF(self.VVQKF5, evList)
      , VVhK3C = BF(self.VVClPz, VVAIxO, title, VVq9SN))
 def VVQKF5(self, evList, VVqeT6):
  totEv = len(evList)
  newLst = []
  totErrName = totErrShort = totErrLong = totSkip = 0
  VVqeT6.VVfT17(totEv)
  VVqeT6.VVL8uX = (newLst, totEv, totErrName, totErrShort, totErrLong, totSkip)
  lang = CFG.epgLangDescr.getValue()
  for ev in evList:
   trName, trShort, trLong, errName, errShort, errLong = CCtAi7.VVhjTq(*ev[2:5])
   totErrName  += errName
   totErrShort += errShort
   totErrLong  += errLong
   if not VVqeT6 or VVqeT6.isCancelled:
    return
   VVqeT6.VVqE9L(1)
   VVqeT6.VVN88H(len(newLst), ev[2] if len(ev[2]) < 22 else ev[2][:22] + " ...")
   name1, short1, long1 = ev[2:5]
   if (name1, short1, long1) != (trName, trShort, trLong):
    item = list(ev)
    item[2], item[3], item[4] = trName, trShort, trLong
    item.append(1)
    newLst.append(tuple(item))
   else:
    totSkip += 1
   VVqeT6.VVL8uX = (newLst, totEv, totErrName, totErrShort, totErrLong, totSkip)
 def VVClPz(self, VVAIxO, title, VVq9SN, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  newLst, totEv, totErrName, totErrShort, totErrLong, totSkip = VVL8uX
  if newLst: totEv, totOK = CCtAi7.VVRFU9(VVq9SN, newLst)
  else  : totOK = 0
  if totOK:
   CCtAi7.VVFxed()
   CC2Ekb.VVIMKA(self.session)
  txt  = "Events\t: %d\n"  % totEv
  txt += "Processed\t: %d\n" % len(newLst)
  txt += "Changed\t: %d\n" % totOK
  if totSkip : txt += "Skipped\t: %d \t... Same language\n" % totSkip
  if any((totErrName, totErrShort, totErrLong)):
   txt += "\nErrors:\n"
   if totErrName : txt += "  Event Name\t: %d\n" % totErrName
   if totErrShort: txt += "  Description\t: %d\n" % totErrShort
   if totErrLong : txt += "  Description\t: %d\n" % totErrLong
  FFSMJz(self, txt, title=title)
  VVAIxO.cancel()
 @staticmethod
 def VVhjTq(eName, eShort, eLong):
  eName, eShort, eLong = eName.strip(), eShort.strip(), eLong.strip()
  tVal, dVal = CFG.epgLangTitle.getValue(), CFG.epgLangDescr.getValue()
  lang, lst, resLst, errLst = (tVal, dVal, dVal), (eName, eShort, eLong), ["", "", ""], [0, 0, 0]
  def VVqz4B(ndx):
   if lst[ndx] and lang[ndx]:
    txt, err = CCtAi7.VVpz2a(lst[ndx], lang[ndx])
    resLst[ndx], errLst[ndx] = txt, 1 if err else 0
  thLst = []
  for ndx in range(3):
   th = iThread(name="ajp_%d" % ndx, target=BF(VVqz4B, ndx))
   th.start()
   thLst.append(th)
  for th in thLst: th.join()
  trName, trShort, trLong = resLst[0] or eName, resLst[1] or eShort, resLst[2] or eLong
  errName, errShort, errLong = errLst
  return trName, trShort, trLong, errName, errShort, errLong
 @staticmethod
 def VVpz2a(txt, toLang):
  txt = txt.strip()
  if txt:
   qUrl = "%s%s&q=%s" % ("=lt&otua=ls&?m/moc.elgoog.etalsnart//:sptth"[::-1], toLang, FFTnsB(txt))
   txt, err = CCTe4w.VVwngR(qUrl, timeout=1, allowDocType=True)
   if err:
    return "", err
   else:
    txt = FF5ov5(txt)
    ndx  = txt.find('<div class="result-container">')
    if ndx > -1:
     txt = txt[ndx + 30:]
     ndx  = txt.find("</div>")
     if ndx > -1:
      return str(CCtAi7.VVjp9l(txt[:ndx])).strip(), ""
   return "", "Could not translate"
  else:
   return "", "Nothing to translate"
 @staticmethod
 def VVZae3():
  path = szTxt = modTm = ""
  valid = sz = 0
  try: path = config.misc.epgcache_filename.getValue()
  except: pass
  if FFKbVo(path):
   valid = 1
   sz = FFLjtI(path)
   szTxt = CC17eA.VVxNgx(sz) if sz > -1 else ""
   modTm = FFG6of(os.path.getmtime(path))
  return valid, path, sz, szTxt, modTm
 @staticmethod
 def VVtqyE():
  try:
   from enigma import eEPGCache
   return eEPGCache, eEPGCache.getInstance()
  except:
   return None, None
 @staticmethod
 def VVFxed():
  CCtAi7.VVhoAj(CCtAi7.VV68H4)
 @staticmethod
 def VVhoAj(act):
  ec, inst = CCtAi7.VVtqyE()
  if inst and hasattr(ec, act):
   try:
    exec("inst.%s()" % act)
    return True
   except:
    pass
  return False
 @staticmethod
 def VVQsbF(VVq9SN):
  ec, inst = CCtAi7.VVtqyE()
  if inst:
   try:
    evList = inst.lookupEvent([CCtAi7.VVXWB1, (VVq9SN.rstrip(":"), 0, -1, 20160)])
    if evList: return VVq9SN, evList, ""
    else  : return VVq9SN, [], "No System EPG"
   except:
    return VVq9SN, [], "EPG Read-Error !"
  else:
   return VVq9SN, [], "Cannot read EPG Cache !"
 @staticmethod
 def VVRFU9(VVq9SN, events, longDescDays=0):
  ec, inst = CCtAi7.VVtqyE()
  totEv, totOK, fnc = 0, 0, None
  if inst:
   if   hasattr(ec, "importEvents"): fnc = inst.importEvents
   elif hasattr(ec, "importEvent") : fnc = inst.importEvent
  if fnc:
   for data in events:
    totEv += 1
    try:
     if longDescDays and data[0] > iTime() + 86400 * longDescDays:
      data = data[:4] + ("",) + data[5:]
     fnc(VVq9SN, (data,))
     totOK += 1
    except:
     pass
  return totEv, totOK
 @staticmethod
 def VVoo5Y(SELF):
  serv = SELF.session.nav.getCurrentlyPlayingServiceReference()
  if serv:
   ec, inst = CCtAi7.VVtqyE()
   if ec:
    event = inst.lookupEventTime(serv, -1, 0)
    if event:
     return CCtAi7.VVvwAu(event)
   try:
    info = eServiceCenter.getInstance().info(serv)
    event = info and info.getEvent(serv)
    if event:
     return CCpebE.CCtAi7(event)
   except:
    pass
   VVUwmk = serv.getName()
   if VVUwmk:
    return [VVUwmk] + [""] * 6
  return [CCZv30(SELF.session).VVUwmk] + [""] * 6
 @staticmethod
 def VVwEcY(SELF):
  fPath, fDir, fName = CC17eA.VVNGSU(SELF)
  if fName:
   return os.path.splitext(fName)[0]
  evName, evTime, evDur, evShort, evDesc, genre, PR = CCtAi7.VVoo5Y(SELF)
  return evName
 @staticmethod
 def VVvwAu(event):
  evName = event.getEventName().strip()    or ""
  evTime = event.getBeginTime()      or ""
  evDur = event.getDuration()      or ""
  evShort = event.getShortDescription().strip()  or ""
  evDesc = event.getExtendedDescription().strip() or ""
  genre, PR = CCtAi7.VVCA7u(event)
  return evName, evTime, evDur, evShort, evDesc, genre, PR
 @staticmethod
 def VVvcx2(VVq9SN):
  service = eServiceReference(VVq9SN)
  evLst = []
  if service:
   ec, inst = CCtAi7.VVtqyE()
   try:
    if inst:
     for evNum in range(2):
      event = inst.lookupEventTime(service, -1, evNum)
      evName, evTime, evDur, evShort, evDesc, genre, PR = CCtAi7.VVvwAu(event)
      evEnd = evPos = evRem = evCom = 0
      evTimeTxt = evPosTxt = evDurTxt = evEndTxt = evRemTxt = evComTxt = ""
      if evTime and evDur:
       evEnd = evTime + evDur
       evTimeTxt = FFG6of(evTime)
       evEndTxt  = FFG6of(evEnd)
       evDurTxt  = FFrTEd(evDur)
       now = int(iTime())
       if now > evTime and now < evEnd:
        evPos = now - evTime
        evPosTxt = FFrTEd(evPos)
        evRem = evEnd - now
        evRemTxt = FFrTEd(evRem)
       elif now < evTime:
        evCom = evTime - now
        evComTxt = FFrTEd(evCom)
      evLst.append((evName, evShort, evDesc, genre, PR, evTime, evTimeTxt, evDur, evDurTxt, evEnd, evEndTxt, evPos, evPosTxt, evRem, evRemTxt, evCom, evComTxt))
   except:
    pass
  return evLst
 @staticmethod
 def VVCA7u(event):
  genre = PR = ""
  try:
   genre  = CCtAi7.VVHhPP(event.getGenreData().getLevel1(), event.getGenreData().getLevel2())
   age = event.getParentalData().getRating()
   PR  = CCtAi7.VVp72U(age)
  except:
   pass
  return genre, PR
 @staticmethod
 def VVp72U(age):
  if   age == 0 : return "Undefinded (all ages)"
  elif age > 15 : return "Rated by broadcaster (%d)" % age
  else   : return "Minimum Age = %d years" % (age + 3)
 @staticmethod
 def VVHhPP(L1, L2):
  if   L1 <= 0  : return "Undefined Content"
  elif L1 >= 15  : return "User Defined Genre"
  elif L1 > 12  : return "Unlisted Genre"
  else:
   MG, SG = CCtAi7.VVbDTL()
   if MG and SG:
    key = "%d,%d" % (L1, L2)
    if key in SG   : return SG[key].title()
    elif L1 - 1 < len(MG) : return MG[L1 - 1] .title()
    else     : return "Unknown Genre"
   else:
    return ""
 @staticmethod
 def VVbDTL():
  path = VVK8DT + "_sup_genre"
  MG = SG = ""
  if FFKbVo(path):
   MG = iFindall(r"\d,0;(\w+\s?\w+)", FFmx8y(path), IGNORECASE)
   SG = iFindall(r"(\d+,\d+);(.+)", FFmx8y(path), IGNORECASE)
   if SG: SG = dict(SG)
  return MG, SG
 @staticmethod
 def VVjXeX(VVAIxO, title):
  ec, inst = CCtAi7.VVtqyE()
  if not inst:
   return "", "Cannot access EPG Cache !"
  totFound = totEvents = totSuccess = totInvalid = totEvErr = 0
  for num, srcName, srcRef, srcTxt, dstName, dstRef, dstTxt, remark in VVAIxO.VVGpBN():
   if remark == "0":
    try:
     evList = inst.lookupEvent([CCtAi7.VVXWB1, (srcRef.rstrip(":"), 0, -1, 20160)])
    except:
     totEvErr += 1
     evList = []
    if evList:
     totFound += 1
     lst = []
     for item in evList:
      lst.append((item[0], item[1], item[2], item[3], item[4], 1))
     totEv, totOK = CCtAi7.VVRFU9(dstRef, lst)
     totEvents += totEv
     totSuccess += totOK
   else:
    totInvalid += 1
  if totSuccess > 0:
   CCtAi7.VVFxed()
  txt  = "Services\t: %d\n"  % VVAIxO.VVM62I()
  txt += "Invalid Ref.\t: %s\n" % totInvalid
  txt += "With Events\t: %d\n\n" % totFound
  txt += "Found Events\t: %d\n" % totEvents
  txt += "Copied Events\t: %d\n" % totSuccess
  if totEvErr:
   txt += "EPG Errors\t: %d" % totEvErr
  return txt, ""
 @staticmethod
 def VVt9oe(VVq9SN):
  ec, inst = CCtAi7.VVtqyE()
  if inst and VVq9SN:
   try:
    return inst.lookupEvent([CCtAi7.VVxlz3, (VVq9SN.rstrip(":"), 0, -1, -1)])
   except:
    pass
  return []
 @staticmethod
 def VVvPPk(info, VVq9SN):
  evLst = []
  if info:
   for evNum in range(2):
    try:
     ev = info.getEvent(evNum)
     evLst.append(CCtAi7.VVvwAu(ev))
    except:
     pass
  if not evLst and VVq9SN:
   serv = eServiceReference(VVq9SN)
   ec, inst = CCtAi7.VVtqyE()
   if serv and inst:
    for evNum in range(2):
     try:
      ev = inst.lookupEventTime(serv, -1, evNum)
      evLst.append(CCtAi7.VVvwAu(ev))
     except:
      pass
  if not evLst and VVq9SN:
   try:
    serv = eServiceReference(VVq9SN)
    info = serv and eServiceCenter.getInstance().info(serv)
    if info:
     ev = info.getEvent(serv)
     evLst.append(CCtAi7.VVvwAu(ev))
   except:
    pass
  return evLst
 @staticmethod
 def VVZnm6(evList, totTr=0):
  tab = lambda x, y: "%s\t: %s\n" % (x, y) if y else ""
  tab2= lambda x, y: "%s\t:\n%s\n" % (x, y) if y else ""
  sep = FFKrMM("_" * 33 + "\n", VV3Hcc)
  now = iTime()
  epg = ""
  for evNum, (start, dur, Title, descrS, descrL, pc, genre)in enumerate(evList, start=1):
   startTxt = endTxt = durTxt = ""
   isCurEv = False
   try:
    startTxt= FFG6of(start).replace(" ", "   ")
    endTxt = FFG6of(start + dur).replace(" ", "   ")
    durTxt = FFrTEd(dur)
    isCurEv = start < now and (start + dur) > now
   except:
    pass
   descrS = str(descrS).strip()
   if descrS == "Not Applicable":
    descrS = ""
   descrL = str(descrL).strip()
   more = ""
   if pc:
    for Sys, val in pc: more += "Parental Control (%s) : %s\n" % (Sys.strip(), val)
   if genre:
    for g in genre: more += "Genre : %s\n" % str(g)
   if more:
    descrL = more.rstrip() + ("\n" + descrL if descrL else "")
   Title2 = lang = ""
   if totTr > 0 and evNum <= totTr:
    trName, trShort, trLong, errName, errShort, errLong = CCtAi7.VVhjTq(Title, descrS, descrL)
    descrS, descrL = trShort, trLong
    if Title and trName and Title != trName:
     Title2 = FFKrMM(trName, VVk4x7)
     lang = " (%s)" % CFG.epgLangDescr.getValue().upper()
   if isCurEv : evFg, descrFg, txt = VVdLWL , VVv8b8, "     (CURRENT EVENT)"
   else  : evFg, descrFg, txt = VVCQUS , VV0p9P  , ""
   epg += sep
   epg += tab("Event"   , FFKrMM(str(evNum) + txt, evFg))
   epg += tab("Start"   , startTxt)
   epg += tab("Title"   , FFKrMM(Title, VVk4x7) if Title else "")
   epg += tab("Title" + lang , FFKrMM(Title2, VVk4x7) if Title2 else "")
   epg += tab("Start"   , startTxt)
   epg += tab("End"   , endTxt)
   epg += tab("Duration"  , durTxt)
   epg += tab2("Summary"  , FFKrMM(descrS, VV0p9P) if descrS else "")
   epg += tab2("Description" , FFKrMM(descrL, descrFg) if descrL else "")
  return epg
 @staticmethod
 def VVjp9l(txt):
  try:
   from HTMLParser import HTMLParser
   return HTMLParser().unescape(txt)
  except:
   pass
  try:
   import html.parser
   return html.parser.HTMLParser().unescape(txt)
  except:
   pass
  try:
   import html
   return html.unescape(txt)
  except:
   pass
  return txt
class CC2Ekb(Screen, CCQyUl):
 VV70TO  = 0
 VVKtoE = 1
 VVvFUZ  = 2
 VVJ8bI  = 3
 VV6xi4 = 4
 VVdKU3 = 5
 VVPiun = 6
 def __init__(self, session):
  self.skin, self.VVmNvK = FFQaOH(VVNkG2, 1000, 1040, 50, 40, 30, "#22000033", "#22000011", 30)
  self.session   = session
  self.filterObj    = None
  self.VVzHof = None
  self.lastfilterUsed  = None
  self.servFilterInFilter = False
  VV9cxb = self.VVBcmE()
  FFNhKZ(self, VV9cxb=VV9cxb, title="Services/Channels")
  self.onShown.append(self.VVf1Ra)
 def VVf1Ra(self):
  self["myMenu"].setList(self.VVBcmE())
  FFvJ8o(self["myMenu"])
  FFNUiO(self)
 def VVBcmE(self):
  VV9cxb = []
  c = VVWH8U
  VV9cxb.append((c + "Open Player Bar"         , "openPlayer"   ))
  VV9cxb.append((c + "Open Signal Monitor"        , "openSignal"   ))
  VV9cxb.append((c + "Current Service Information"      , "currentServiceInfo" ))
  VV9cxb.append(VVbM5H)
  c = VVk4x7
  VV9cxb.append((c + "Services (Parental-Control + Hidden)"    , "VVck0o" ))
  VV9cxb.append((c + "Services (Transponders)"       , "VVzNzB"))
  VV9cxb.append((VVU4M8 + "More tables ..."     , "VVizzD"  ))
  c = VVv8b8
  VV9cxb.append(VVbM5H)
  VV9cxb.append(FFH04v("Import Bouquets from Backup Files"  , "VVeuTk", iTar, c ))
  VV9cxb.append((c + 'Export Services to "channels.xml"'    , "VVeHqK"       ))
  VV9cxb.append((c + "Copy EPG/PIcons between Channels (from xml file)" , "copyEpgPicons"       ))
  c = VVWJEN
  VV9cxb.append(VVbM5H)
  VV9cxb.append((c + "Satellites Services Cleaner"      , "VVidN2"  ))
  VV9cxb.append((c + "Invalid Services Cleaner"       , "VV2P6B" ))
  c = VVWJEN
  VV9cxb.append(VVbM5H)
  VV9cxb.append((c + "Delete Channels with no names"     , "VVNJXm" ))
  VV9cxb.append((c + "Delete Empty Bouquets"       , "VVktJH"  ))
  VV9cxb.append(VVbM5H)
  VVO4q6, VVdRDV = CC2Ekb.VV2yDM()
  if FFKbVo(VVO4q6):
   enab = FFKbVo(VVdRDV)
   if enab: VV9cxb.append(("Enable Hidden Services List"    , "enableHiddenChannels" ))
   else   : VV9cxb.append(("Disable Hidden Services List"   , "disableHiddenChannels" ))
  VV9cxb.append(("Reset Parental Control Settings"      , "VVi1b1" ))
  VV9cxb.append(("Reload Channels and Bouquets"       , "VV4Z9Q" ))
  return VV9cxb
 def VVyuDa(self):
  item = FFgo5c(self)
  if item is not None:
   if   item == "openPlayer"      : CCsmqb.VVlIAT(self.session)
   elif item == "openSignal"      : FFlUBp(self.session, reopen=True)
   elif item == "currentServiceInfo"    : CCpebE.VV1v7b(self, VV6tGM=CCpebE.VVbdzi)
   elif item == "VVck0o"   : self.VVck0o()
   elif item == "VVzNzB"  : self.VVzNzB()
   elif item == "VVizzD"    : self.VVizzD()
   elif item == "VVeuTk" : CCUyKl.VVeuTk(self)
   elif item == "VVeHqK"     : self.VVeHqK()
   elif item == "copyEpgPicons"     : self.VVWvup(False)
   elif item == "VVidN2"    : self.VVidN2()
   elif item == "VV2P6B"   : self.VV2P6B()
   elif item == "VVNJXm"   : self.VVNJXm()
   elif item == "VVktJH"    : self.VVktJH(self)
   elif item == "enableHiddenChannels"    : self.VVBekV(True)
   elif item == "disableHiddenChannels"   : self.VVBekV(False)
   elif item == "VVi1b1"   : FF6pUe(self, self.VVi1b1, "Reset and Restart ?")
   elif item == "VV4Z9Q"     : CC2Ekb.VV4Z9Q(self)
 def VVizzD(self):
  VV9cxb = []
  VV9cxb.append(("Services (IDs)"       , "VVvviN"))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Services (Parental-Control List)"   , "VVmFAO" ))
  VV9cxb.append(("Services (Hidden List)"     , "VVBZLz"  ))
  VV9cxb.append(("Services with PIcons for the System"  , "VVf9vk1"  ))
  VV9cxb.append(("Services without PIcons for the System" , "VVf9vk2"  ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Transponders (Statistics)"    , "TranspondersStats"  ))
  VV9cxb.append(("Satellites.xml (Statistics)"    , "VVkJ8P"  ))
  FFO9kU(self, None, VV9cxb=VV9cxb, title="Service Information", VVQ4hk=self.VV70Am)
 def VV70Am(self, item):
  if item:
   VVhzhr, txt, ref, ndx = item
   if   ref == "VVvviN" : self.VVvviN(VVhzhr, txt)
   elif ref == "VVmFAO" : self.VVmFAO(VVhzhr, txt)
   elif ref == "VVBZLz"  : self.VVBZLz(VVhzhr, txt)
   elif ref == "VVf9vk1"  : self.VVf9vk(VVhzhr, txt, True)
   elif ref == "VVf9vk2"  : self.VVf9vk(VVhzhr, txt, False)
   elif ref == "TranspondersStats"   : self.VVeVg6(VVhzhr, txt)
   elif ref == "VVkJ8P"  : self.VVkJ8P(VVhzhr, txt)
 def VVeHqK(self):
  VV9cxb = []
  VV9cxb.append(("All DVB-S/C/T Services", "all"))
  VV9cxb.extend(CC8i1k.VVtTm6())
  FFO9kU(self, self.VVTxj7, VV9cxb=VV9cxb, title="", VVDkqE=True)
 @FFJRPn()
 def VVTxj7(self, item=None):
  if item:
   txt, ref, ndx = item
   if ref == "all" : lst = CC2Ekb.VVwkaL("1:7:")
   else   : lst = FFM85b(eServiceReference(ref))
   if lst:
    tot = len(lst)
    if tot > 0:
     rows = []
     for r, n in lst:
      sat = CC2Ekb.VVZeVo(r)
      rows.append('<!-- %s --><channel id="%s">%s</channel><!-- %s -->\n' % (sat, n, r, n))
     if rows:
      rows.sort()
      fPath = "%schannels_%s.xml" % (FFeg8m(), FFRIlf())
      with open(fPath, "w") as f:
       f.write('<?xml version="1.0" encoding="utf-8"?>\n')
       f.write('<channels>\n\n')
       for row in rows: f.write(row)
       f.write('\n</channels>\n')
      FF0onH(self, "Saved %d service%s to:\n\n%s" % (tot, FFaRsj(tot), fPath))
      return
   FFoTZI(self, "No Services found !", 1500)
 @staticmethod
 @FFJRPn()
 def VV4Z9Q(SELF):
  FFANYL()
  FF0onH(SELF, "Finished\n\nReloaded Channels and Bouquets")
 @FFJRPn()
 def VVck0o(self):
  self.VVzHof = None
  self.lastfilterUsed  = None
  self.filterObj   = CCuHRT(self)
  VVuGUx, err = CC2Ekb.VVTefV(self, self.VV70TO)
  if VVuGUx:
   VVuGUx.sort(key=lambda x: x[0].lower())
   VVj7lw  = ("Zap"   , self.VVjhnq     , [])
   VVmolf = (""    , self.VV5Ozo   , [])
   VV46TD = ("Options"  , self.VV9QMN , [])
   VVwqVu = ("Current Service", self.VVasVx , [])
   VViMvb = ("Filter"   , self.VVXZ3W  , [], "Loading Filters ...")
   header   = ("Name" , "Provider", "Sat.", "Reference" , "PC"  , "Hidden" )
   widths   = (24  , 20  , 9  , 34   , 6   , 7   )
   VV4Uoc  = (LEFT  , LEFT  , CENTER, LEFT    , CENTER , CENTER )
   FFCXsL(self, None, header=header, VVXpNQ=VVuGUx, VV4Uoc=VV4Uoc, VV8boH=widths, VVPYL1=26, VVj7lw=VVj7lw, VVmolf=VVmolf, VVwqVu=VVwqVu, VV46TD=VV46TD, VViMvb=VViMvb, VVAGe1=CFG.lastFindServices)
 @FFJRPn()
 def VVzNzB(self):
  self.VVzHof = None
  self.lastfilterUsed  = None
  self.filterObj   = CCuHRT(self)
  VVuGUx, err = CC2Ekb.VVTefV(self, self.VVKtoE)
  if VVuGUx:
   VVuGUx.sort(key=lambda x: x[0].lower())
   VVj7lw  = ("Zap"   , self.VVjhnq      , [])
   VVmolf = (""    , self.VV5Ozo    , [])
   VVwqVu = ("Current Service", self.VVasVx  , [])
   VV46TD = ("Options"  , self.VVhMO9 , [])
   VViMvb = ("Filter"   , self.VVQJ5v  , [], "Loading Filters ...")
   header   = ("Name" , "Provider", "Type", "Ref.", "Sat.", "Transponder" , "Freq." , "Pol.", "FEC" , "SR" )
   widths   = (25  , 24  , 14 , 0.01 , 9  , 0.02   , 8   , 5  , 7  , 8  )
   VV4Uoc  = (LEFT  , LEFT  , CENTER, CENTER, CENTER, CENTER   , CENTER , CENTER, CENTER, CENTER)
   FFCXsL(self, None, header=header, VVXpNQ=VVuGUx, VV4Uoc=VV4Uoc, VV8boH=widths, VVPYL1=26, VVj7lw=VVj7lw, VVmolf=VVmolf, VVwqVu=VVwqVu, VV46TD=VV46TD, VViMvb=VViMvb, VVAGe1=CFG.lastFindServices)
 def VV9QMN(self, VVAIxO, title, txt, colList):
  servName = colList[0].strip()
  VVq9SN  = colList[3].strip()
  pcState  = colList[4].strip()
  hidState = colList[5].strip()
  mSel = CC17aQ(self, VVAIxO, setsOk=True, setsBlue=True)
  VV9cxb = []
  isMulti = VVAIxO.VVGZGK
  if isMulti:
   VVoSJs = VVAIxO.VVKa9C(3)
   if VVoSJs:
    VV9cxb.append(("Add Selection to Parental Control"  , "VVZwIU1" ))
    VV9cxb.append(("Remove Selection from Parental Control" , "VVZwIU2" ))
    VV9cxb.append(VVbM5H)
    VV9cxb.append(("Add Selection to Hidden Services"   , "VVB9La1" ))
    VV9cxb.append(("Remove Selection from Hidden Services" , "VVB9La2" ))
    VV9cxb.append(VVbM5H)
  else:
   pc = pcState == "No"
   hid = hidState == "No"
   VV9cxb.append(FFH04v("Add to Parental Control"  , "VVssqc1" , pc  ))
   VV9cxb.append(FFH04v("Remove from Parental Control" , "VVssqc2" , not pc ))
   VV9cxb.append(VVbM5H)
   VV9cxb.append(FFH04v("Add to Hidden Services"  , "VVvNUe1" , hid  ))
   VV9cxb.append(FFH04v("Remove from Hidden Services" , "VVvNUe2" , not hid ))
   VV9cxb.append(VVbM5H)
   VV9cxb.append(VVbM5H)
  cbFncDict = { "VVssqc1" : BF(self.VVssqc, VVAIxO, VVq9SN, True)
     , "VVssqc2" : BF(self.VVssqc, VVAIxO, VVq9SN, False)
     , "VVvNUe1" : BF(self.VVvNUe, VVAIxO, VVq9SN, True)
     , "VVvNUe2" : BF(self.VVvNUe, VVAIxO, VVq9SN, False)
     , "VVZwIU1" : BF(self.VVZwIU, VVAIxO, True)
     , "VVZwIU2" : BF(self.VVZwIU, VVAIxO, False)
     , "VVB9La1" : BF(self.VVB9La, VVAIxO, True)
     , "VVB9La2" : BF(self.VVB9La, VVAIxO, False)
     }
  VV9cxb1, cbFncDict1 = CC2Ekb.VVxMo5(self, VVAIxO, servName, 3)
  VV9cxb.extend(VV9cxb1)
  for key, val in cbFncDict1.items(): cbFncDict[key] = val
  mSel.VV4sFy(VV9cxb, cbFncDict)
 def VVhMO9(self, VVAIxO, title, txt, colList):
  servName = colList[0]
  mSel = CC17aQ(self, VVAIxO, setsOk=True, setsBlue=True)
  VV9cxb, cbFncDict = CC2Ekb.VVxMo5(self, VVAIxO, servName, 3)
  mSel.VV4sFy(VV9cxb, cbFncDict)
 @staticmethod
 def VVxMo5(SELF, VVAIxO, servName, VVyxB7):
  tot = VVAIxO.VVAGI8()
  if tot > 0:
   sTxt = FFKrMM("%d Service%s" % (tot, FFaRsj(tot)), VVk4x7)
   VV9cxb = [("Add %s to Bouquet ..." % sTxt   , "addToBouquet_multi" )]
  else:
   servName = FFkEjh(servName)
   if len(servName) > 20: servName = servName[:20] + ".."
   servName = FFKrMM(servName, VVk4x7)
   VV9cxb = [('Add "%s" to Bouquet ...' % servName , "addToBouquet_one" )]
  cbFncDict = { "addToBouquet_multi" : BF(CC2Ekb.VVCYzr, SELF, VVAIxO, VVyxB7, True)
     , "addToBouquet_one" : BF(CC2Ekb.VVCYzr, SELF, VVAIxO, VVyxB7, False)
     }
  return VV9cxb, cbFncDict
 @staticmethod
 def VVCYzr(SELF, VVAIxO, VVyxB7, isMulti):
  picker = CC8i1k(SELF, VVAIxO, "Add to Bouquet", BF(CC2Ekb.VVtyei, VVAIxO, VVyxB7, isMulti))
 @staticmethod
 def VVtyei(VVAIxO, VVyxB7, isMulti):
  if isMulti : VVoSJs = VVAIxO.VVKa9C(VVyxB7)
  else  : VVoSJs = [VVAIxO.VVQDwi()[VVyxB7]]
  chUrlLst = []
  for ref in VVoSJs:
   chUrlLst.append(ref)
  return chUrlLst
 def VVssqc(self, VVAIxO, VVq9SN, isAddToBlackList):
  self.VVcOeV(VVAIxO, [VVq9SN], isAddToBlackList)
 def VVZwIU(self, VVAIxO, isAddToBlackList):
  VVoSJs = VVAIxO.VVKa9C(3)
  if not VVoSJs:
   FFbBGq(self, "Nothing selected", title="Change Parental-Control State")
   return
  self.VVcOeV(VVAIxO, VVoSJs, isAddToBlackList)
 @FFJRPn(par=1, clearMsg=False)
 def VVcOeV(self, VVAIxO, VVoSJs, isAddToBlackList):
  for ndx, VVq9SN in enumerate(VVoSJs):
   VVq9SN = VVq9SN.strip()
   if not VVq9SN.endswith(":"):
    VVq9SN += ":"
    VVoSJs[ndx] = VVq9SN
  changed = False
  if isAddToBlackList:
   if isAddToBlackList:
    with open(VVnZCL, "a") as f:
     for VVq9SN in VVoSJs:
      f.write(VVq9SN + "\n")
      changed = True
  elif FFKbVo(VVnZCL):
   lines = FF2kXa(VVnZCL)
   if lines:
    for VVq9SN in VVoSJs:
     while VVq9SN in lines:
      ndx = lines.index(VVq9SN)
      lines[ndx] = ""
      changed = True
    if changed:
     with open(VVnZCL, "w") as f:
      for line in lines:
       if line:
        f.write(line + "\n")
  if changed:
   from Components.ParentalControl import parentalControl
   parentalControl.open()
   isMulti = VVAIxO.VVGZGK
   if isMulti:
    self.VVTk59(VVAIxO, len(VVoSJs))
   else:
    if VVq9SN.endswith(":"):
     VVq9SN = VVq9SN[:-1]
    self.VVPhLK(VVAIxO, VVq9SN)
    VVAIxO.VVEL2E()
  else:
   VVAIxO.VV2t5o("No changes")
 @FFJRPn(par=1)
 def VVvNUe(self, VVAIxO, VVq9SN, isHide):
  title = "Change Hidden State"
  if FFaKr0(VVq9SN):
   ret = FF97G8(VVq9SN, isHide)
   if ret : self.VVPhLK(VVAIxO, VVq9SN)
   else : FFbBGq(self, "Cannot Hide/Unhide this channel.", title=title)
  else:
   FFbBGq(self, "Cannot Hide/Unhide this channel.\n\n(Invalid transponder)", title=title)
 def VVPhLK(self, VVAIxO, VVq9SN):
  VVuGUx, err = CC2Ekb.VVTefV(self, self.VV70TO, VVZYNB=[3, [VVq9SN], False])
  done = False
  if VVuGUx:
   data = VVuGUx[0]
   if data[3] == VVq9SN:
    done = VVAIxO.VVsu0I(data)
  if not done:
   self.VVzdll(VVAIxO, VVAIxO.VVAjLb(), self.VV70TO)
 def VVTk59(self, VVAIxO, totRefCodes):
  VVuGUx, err = CC2Ekb.VVTefV(self, self.VV70TO, VVZYNB=self.VVzHof)
  VVAIxO.VVEEBV(VVuGUx, VVyoYa=BF(self.VVljs8, totRefCodes))
 def VVljs8(self, totRefCodes, VVAIxO, title, txt, colList):
  VVAIxO.VVurYr()
  FFtn0P(VVAIxO, "%d Processed" % totRefCodes, 1000)
 @FFJRPn(par=1, clearMsg=False)
 def VVB9La(self, VVAIxO, isHide):
  VVoSJs = VVAIxO.VVKa9C(3)
  if not VVoSJs:
   FFbBGq(self, "Nothing selected", title="Change Hidden State")
   return
  totChanges = 0
  for VVq9SN in VVoSJs:
   ret = FF97G8(VVq9SN, isHide, skipReload=True)
   if ret:
    totChanges += 1
  if totChanges > 0:
   FFANYL(True)
   self.VVTk59(VVAIxO, len(VVoSJs))
  else:
   VVAIxO.VV2t5o("No changes")
 def VVXZ3W(self, VVAIxO, title, txt, colList):
  inFilterFnc = BF(self.VVPnEA, VVAIxO) if self.VVzHof else None
  self.filterObj.VVtKPR(1, VVAIxO, 2, BF(self.VVQZaD, VVAIxO), inFilterFnc=inFilterFnc)
 def VVQZaD(self, VVAIxO, item):
  self.VVZE5k(VVAIxO, False, item, 2, self.VV70TO)
 def VVPnEA(self, VVAIxO, VVhzhr, item):
  self.VVZE5k(VVAIxO, True, item, 2, self.VV70TO)
 def VVQJ5v(self, VVAIxO, title, txt, colList):
  inFilterFnc = BF(self.VVoWWh, VVAIxO) if self.VVzHof else None
  self.filterObj.VVtKPR(2, VVAIxO, 4, BF(self.VViVIj, VVAIxO), inFilterFnc=inFilterFnc)
 def VViVIj(self, VVAIxO, item):
  self.VVZE5k(VVAIxO, False, item, 4, self.VVKtoE)
 def VVoWWh(self, VVAIxO, VVhzhr, item):
  self.VVZE5k(VVAIxO, True, item, 4, self.VVKtoE)
 def VVnK9u(self, VVAIxO, title, txt, colList):
  inFilterFnc = BF(self.VVEsYH, VVAIxO) if self.VVzHof else None
  self.filterObj.VVtKPR(0, VVAIxO, 4, BF(self.VV5Ooz, VVAIxO), inFilterFnc=inFilterFnc)
 def VV5Ooz(self, VVAIxO, item):
  self.VVZE5k(VVAIxO, False, item, 4, self.VVvFUZ)
 def VVEsYH(self, VVAIxO, VVhzhr, item):
  self.VVZE5k(VVAIxO, True, item, 4, self.VVvFUZ)
 def VVZE5k(self, VVAIxO, isInFilter, item, satCol, mode):
  self.servFilterInFilter = isInFilter
  if self.lastfilterUsed and self.lastfilterUsed == [item, satCol, mode]:
   return
  self.lastfilterUsed = [item, satCol, mode]
  if   item.startswith("__s__") : col, words, title = satCol, item[5:] , item[5:]
  elif item.startswith("__w__") : col, words, title = 0  , item[5:] , item[5:]
  elif item == "parentalControl" : col, words, title = 4  , "Yes"  , "Parental Control"
  elif item == "hiddenServices" : col, words, title = 5  , "Yes"  , "Hidden Services"
  elif item == "selectedTP"  :
   tp = VVAIxO.VVYmuZ(5)
   col, words, title = 5  , tp , tp
  elif item == "emptyTP"   : col, words, title = 6  , "-"  , "Channels with no Transponder"
  elif item == "streamRelay"  : col, words, title = 3  , ""  , "Stream Relay Services"
  else       : col, words, title = None , "All"  , "All"
  title = "Filter = %s" % title
  if len(title) > 55:
   title = title[:55] + ".."
  if col is None:
   self.VVzHof = None
  elif item == "streamRelay":
   words = CC2Ekb.VV0kGE()
   if not words:
    FFoTZI(VVAIxO, "Not found", 1000)
    return
   self.VVzHof = [col, words, False]
  else:
   words, asPrefix = CCuHRT.VVzdEZ(words)
   self.VVzHof = [col, words, asPrefix]
  if words: FF7iMz(VVAIxO, BF(self.VVzdll, VVAIxO, title, mode), clearMsg=False)
  else : FFoTZI(VVAIxO, "Incorrect filter", 2000)
 def VVzdll(self, VVAIxO, title, mode):
  VVuGUx, err = CC2Ekb.VVTefV(self, mode, VVZYNB=self.VVzHof, VVf6Ho=False)
  if self.servFilterInFilter:
   lst = []
   for row in VVAIxO.VVGpBN():
    try:
     ndx = VVuGUx.index(tuple(list(map(str.strip, row))))
     lst.append(VVuGUx[ndx])
    except:
     pass
   VVuGUx = lst
  if VVuGUx:
   VVuGUx.sort(key=lambda x: x[0].lower())
   VVAIxO.VVEEBV(VVuGUx, title)
  else:
   FFoTZI(VVAIxO, "Not found!", 1500)
 def VVhs97(self, title, VVXpNQ, VVj7lw=None, VVmolf=None, VVjW3s=None, VVwqVu=None, VV46TD=None, VViMvb=None):
  VVwqVu = ("Current Service", self.VVasVx, [], )
  header  = ("Name" , "Provider", "Sat.", "Reference" )
  widths  = (29  , 27  , 9  , 35   )
  VV4Uoc = (LEFT  , LEFT  , CENTER, LEFT    )
  FFCXsL(self, None, title=title, header=header, VVXpNQ=VVXpNQ, VV4Uoc=VV4Uoc, VV8boH=widths, VVPYL1=26, VVj7lw=VVj7lw, VVmolf=VVmolf, VVjW3s=VVjW3s, VVwqVu=VVwqVu, VV46TD=VV46TD, VViMvb=VViMvb, VVAGe1=CFG.lastFindServices)
 def VVasVx(self, VVAIxO, title, txt, colList):
  self.VVgasj(VVAIxO)
 def VVrY0B(self, VVAIxO, title, txt, colList):
  self.VVgasj(VVAIxO, True)
 def VVgasj(self, VVAIxO, isFromDetails=False):
  VVq9SN, VVadS0, VVjgtq, VVVmGQ, VVUwmk = FFLlAM(self)
  if VVq9SN:
   if isFromDetails:
    VVq9SN  = VVq9SN.upper()
    parts  = VVq9SN.split(":")
    Namespace = parts[6].zfill(8)
    SID   = parts[3].zfill(4)
    TSID  = parts[4].zfill(4)
    ONID  = parts[5].zfill(4)
    colDict  = { 0:VVUwmk, 5:Namespace, 6:SID, 7:TSID, 8:ONID }
    VVAIxO.VV5rHa(colDict, VVAdNn=True)
   else:
    VVAIxO.VVSepa(3, VVq9SN, True)
   return
  FFbBGq(self, "Cannot read current Reference Code !")
 @FFJRPn(par=1)
 def VVvviN(self, obj, title):
  self.VVzHof = None
  self.lastfilterUsed  = None
  self.filterObj   = CCuHRT(self)
  VVuGUx, err = CC2Ekb.VVTefV(self, self.VVvFUZ)
  if VVuGUx:
   VVuGUx.sort(key=lambda x: x[0].lower())
   VVmolf = (""    , self.VVr8ho , []      )
   VVwqVu = ("Current Service", self.VVrY0B  , []      )
   VViMvb = ("Filter"   , self.VVnK9u   , [], "Loading Filters ..." )
   VVj7lw  = ("Zap"   , self.VVYYJN      , []      )
   header   = ("Name" , "Provider", "Type-Val", "Type" , "Sat.", "Namespace" ,"SID" , "TSID", "ONID" )
   widths   = (24  , 22  , 0   , 16  , 9  , 11   , 6  , 6  , 6    )
   VV4Uoc  = (LEFT  , LEFT  , CENTER , CENTER , CENTER, CENTER  , CENTER, CENTER, CENTER )
   FFCXsL(self, None, title=title, header=header, VVXpNQ=VVuGUx, VV4Uoc=VV4Uoc, VV8boH=widths, VVPYL1=26, VVj7lw=VVj7lw, VVmolf=VVmolf, VVwqVu=VVwqVu, VViMvb=VViMvb, VVAGe1=CFG.lastFindServices)
 def VVr8ho(self, VVAIxO, title, txt, colList):
  VVq9SN, VVadS0, VVjgtq, VVVmGQ, VVUwmk = FFLlAM(self)
  VVq9SN1 = self.VV3eeQ(colList)
  if VVq9SN == VVq9SN1:
   txt = ""
  else:
   txt = "%s\n\n%s" % (title, txt)
   txt += "Reference\t: %s" % VVq9SN1
  CCpebE.VV1v7b(self, VV6tGM=CCpebE.VVZrW7, params=(VVq9SN1, colList[0], txt))
 def VVYYJN(self, VVAIxO, title, txt, colList):
  VVq9SN = self.VV3eeQ(colList)
  CCsmqb.VVlIAT(self.session, VVdxJv=VVq9SN)
 def VVjhnq(self, VVAIxO, title, txt, colList):
  CCsmqb.VVlIAT(self.session, VVdxJv=colList[3])
 def VV3eeQ(self, colList):
  VVUwmk, chProv, servTypeHex, STYPE, sat, NameSpace, SID, TSID, ONID = colList
  VVq9SN = "1:0:%s:%s:%s:%s:%s:0:0:0" % (servTypeHex, SID.lstrip("0"), TSID.lstrip("0"), ONID.lstrip("0"), NameSpace.lstrip("0") )
  VVq9SN = VVq9SN.replace("::", ":0:")
  return VVq9SN
 @staticmethod
 def VVXiSy(VVO4q6, mode=0):
  lines = FF2kXa(VVO4q6, encLst=["UTF-8"])
  return CC2Ekb.VVLSxp(lines, mode)
 @staticmethod
 def VVLSxp(lines, mode):
  lst = []
  header = "transponders" if mode < 10 else "services"
  if header in lines:
   lines = lines[lines.index(header) + 1:]
   if "end" in lines:
    lines = lines[:lines.index("end")]
    if len(lines) % 3 == 0:
     for i in range(0, len(lines), 3):
      if   mode in (0, 10): lst.append((lines[i], lines[i + 1], lines[i + 2]))
      elif mode in (1, 11): lst.append(lines[i].upper())
      elif mode in (2, 12): lst.append(lines[i + 1])
      elif mode in (3, 13): lst.append(lines[i + 2])
      elif mode == 14:
       span = iSearch(r"(\S+)\s+(PID)\s+(\d+)", lines[i + 1], IGNORECASE)
       if span:
        lst.append((lines[i], " ".join(span.groups()), lines[i + 2]))
  return lst
 @staticmethod
 def VVTefV(SELF, mode, VVZYNB=None, VVf6Ho=True, VVFiGB=True):
  VVO4q6, err = CC2Ekb.VV2g3w(SELF, VVFiGB)
  if err:
   return None, err
  asPrefix = False
  if VVZYNB:
   filterCol = VVZYNB[0]
   filterWords = VVZYNB[1]
   asPrefix = VVZYNB[2]
   filterWords = list(filterWords)
   for ndx, item in enumerate(filterWords):
    filterWords[ndx] = item.strip().lower()
  else:
   filterWords = None
  if mode == CC2Ekb.VV70TO:
   blackList = None
   if FFKbVo(VVnZCL):
    blackList = FF2kXa(VVnZCL)
    if blackList:
     blackList = set(blackList)
  elif mode == CC2Ekb.VVKtoE:
   tp = CCrDr0()
  VVuDJZ, VVlt7s = FFmCsn()
  if mode in (CC2Ekb.VVdKU3, CC2Ekb.VVPiun):
   VVuGUx = {}
  else:
   VVuGUx = []
  tagFound = False
  with ioOpen(VVO4q6, "r", encoding="utf-8") as f:
   lines = []
   for line in f:
    line = str(line).strip()
    if tagFound:
     if line == "end":
      break
     lines.append(line)
     if len(lines) >= 3:
      chCode = lines[0].upper()
      VVUwmk = lines[1]
      chProv = lines[2]
      if chCode.count(":") > 4 and not "," in chCode:
       parts = chCode.split(":")
       SID   = parts[0]
       NameSpace = parts[1]
       TSID  = parts[2]
       ONID  = parts[3]
       STYPE  = parts[4]
      else:
       SID = NameSpace = TSID = ONID = STYPE = SNUM = VVq9SN = ""
      chProvOrig = chProv
      if ","  in chProv : chProv = chProv.split(",")[0].strip()
      if "p:" in chProv : chProv = chProv.split("p:")[1].strip()
      if len(VVUwmk) == 0 : VVUwmk = "-"
      if len(chProv) == 0 : chProv = "-"
      s = NameSpace.zfill(8)[:4]
      val = int(s, 16)
      sat = FFYCut(val)
      try:
       sTypeInt = int(STYPE)
       servTypeHex = (hex(sTypeInt))[2:].upper()
      except:
       sTypeInt = 0
       servTypeHex = "0"
      if mode == CC2Ekb.VVvFUZ:
       if sTypeInt in VVuDJZ:
        STYPE = VVlt7s[sTypeInt]
       tRow = (VVUwmk, chProv, servTypeHex, STYPE, sat, NameSpace, SID, TSID, ONID)
       if filterWords:
        tmp = tRow[filterCol].lower()
        if asPrefix:
         if any(tmp.startswith(x) for x in filterWords) : VVuGUx.append(tRow)
        elif any(x in tmp for x in filterWords)    : VVuGUx.append(tRow)
       else:
        VVuGUx.append(tRow)
      else:
       VVq9SN = "1:0:%s:%s:%s:%s:%s:0:0:0" % (servTypeHex, SID.lstrip("0"), TSID.lstrip("0"), ONID.lstrip("0"), NameSpace.lstrip("0") )
       VVq9SN = VVq9SN.replace("::", ":0:")
       if mode == CC2Ekb.VVdKU3:
        VVuGUx[VVq9SN.replace(":", "_")] = (VVUwmk, sat, 1)
       elif mode == CC2Ekb.VVPiun:
        VVuGUx[VVUwmk] = VVq9SN
       elif mode == CC2Ekb.VV70TO:
        if blackList and VVq9SN + ":" in blackList : isBlackList = "Yes"
        else          : isBlackList = "No"
        flag = iSearch(r"f:([A-Fa-f0-9]+)", chProvOrig)
        if flag and int(flag.group(1), 16) & 2 == 2 : hidStr = "Yes"
        else          : hidStr =  "No"
        tRow = (VVUwmk, chProv, sat, VVq9SN, isBlackList, hidStr)
        if filterWords:
         tmp = tRow[filterCol].lower()
         if asPrefix:
          if any(tmp.startswith(x) for x in filterWords) : VVuGUx.append(tRow)
         elif any(x in tmp for x in filterWords)    : VVuGUx.append(tRow)
        else:
         VVuGUx.append(tRow)
       elif mode == CC2Ekb.VVKtoE:
        if sTypeInt in VVuDJZ:
         STYPE = VVlt7s[sTypeInt]
        freq, pol, fec, sr, syst = tp.VV6RhP(VVq9SN)
        if not "-S" in syst:
         sat = syst
        if freq == "-" : tpStr = "-"
        else   : tpStr = sat + " " + freq + " " + pol + " " + fec + " " + sr
        tRow = (VVUwmk, chProv, STYPE, VVq9SN, sat, tpStr, freq, pol, fec, sr)
        if filterWords:
         tmp = tRow[filterCol].lower()
         if asPrefix:
          if any(tmp.startswith(x) for x in filterWords) : VVuGUx.append(tRow)
         elif any(x in tmp for x in filterWords)    : VVuGUx.append(tRow)
        else:
         VVuGUx.append(tRow)
       elif mode == CC2Ekb.VVJ8bI:
        flag = iSearch(r"f:([A-Fa-f0-9]+)", chProvOrig)
        if flag and int(flag.group(1), 16) & 2 == 2:
         VVuGUx.append((VVUwmk, chProv, sat, VVq9SN))
       elif mode == CC2Ekb.VV6xi4:
        VVuGUx.append((VVUwmk, chProv, sat, VVq9SN))
      lines = []
    elif line == "services":
     tagFound = True
  if not VVuGUx and VVf6Ho:
   FFbBGq(SELF, "No services found!")
  return VVuGUx, ""
 @FFJRPn(par=1)
 def VVmFAO(self, obj, title):
  if FFKbVo(VVnZCL):
   lines = FF2kXa(VVnZCL)
   if lines:
    newRows = []
    VVuGUx, err = CC2Ekb.VVTefV(self, self.VV6xi4)
    if VVuGUx:
     lines = set(lines)
     for item in VVuGUx:
      VVq9SN = item[3] + ":"
      if VVq9SN in lines:
       newRows.append((item[0], item[1], item[2], VVq9SN))
     if newRows:
      VVuGUx = newRows
      VVuGUx.sort(key=lambda x: x[0].lower())
      VVmolf = ("", self.VV5Ozo, [])
      VVj7lw = ("Zap", self.VVjhnq, [])
      self.VVhs97(title, VVuGUx, VVj7lw=VVj7lw, VVmolf=VVmolf)
     else:
      FFSMJz(self, "No matching Reference Code found !\n\nPC Lines\t: %d\nLameDB\t: %d" % (len(lines), len(VVuGUx)))
   else:
    FF0onH(self, "No active Parental Control services.", FFJ4QU())
  else:
   FFWfGZ(self, VVnZCL)
 @FFJRPn(par=1)
 def VVBZLz(self, obj, title):
  VVuGUx, err = CC2Ekb.VVTefV(self, self.VVJ8bI)
  if VVuGUx:
   VVuGUx.sort(key=lambda x: x[0].lower())
   VVmolf = ("" , self.VV5Ozo, [])
   VVj7lw  = ("Zap", self.VVjhnq, [])
   self.VVhs97(title, VVuGUx, VVj7lw=VVj7lw, VVmolf=VVmolf)
  elif err:
   pass
  else:
   FF0onH(self, "No hidden services.", FFJ4QU())
 @FFJRPn()
 def VV2P6B(self):
  title = "Services unused in Tuner Configuration"
  VVO4q6, err = CC2Ekb.VV2g3w(self, title=title)
  if err:
   return
  nsLst = set()
  usedSats = CC2Ekb.VVIDXh()
  for tuner in usedSats:
   for item in tuner[1]:
    ns = self.VVQ6Zz(str(item[0]))
    nsLst.add(ns)
  sysLst = CC2Ekb.VVwkaL("1:7:")
  tpLst  = CC2Ekb.VVXiSy(VVO4q6, mode=1)
  VVuGUx = []
  for VVq9SN, VVUwmk in sysLst:
   servID = CC2Ekb.VVpvrS(VVq9SN)
   tpID = CC2Ekb.VVov2P(VVq9SN)
   refNs = VVq9SN.split(":")[6].zfill(8)[:4]
   if not tpID in tpLst or not refNs in nsLst:
    VVuGUx.append((VVUwmk, FFgAAw(VVq9SN, False), VVq9SN, servID))
  if VVuGUx:
   VVuGUx.sort(key=lambda x: x[0].lower())
   VV46TD = ("Options"   , BF(self.VV6bJ2, title), [])
   header   = ("Name" , "Media" , "Reference" , '"lamedb" Code' )
   widths   = (55  , 10  , 0    , 35    )
   VV4Uoc  = (LEFT  , CENTER , LEFT   , CENTER   )
   FFCXsL(self, None, title=title, header=header, VVXpNQ=VVuGUx, VV4Uoc=VV4Uoc, VV8boH=widths, VVPYL1=26, VV46TD=VV46TD, VVfWsQ="#0a001122", VVB5I5="#0a001122", VVYCun="#0a001122", VVmErq="#00004455", VVK8UQ="#0a333333", VVgSJJ="#11331100", VVAGe1=CFG.lastFindServices)
  else:
   FF0onH(self, "No invalid service found !", title=title)
 def VV6bJ2(self, Title, VVAIxO, title, txt, colList):
  mSel = CC17aQ(self, VVAIxO)
  isMulti = VVAIxO.VVGZGK
  if isMulti : txt = "Remove %s Services" % FFKrMM(VVAIxO.VVAGI8(), VVU4M8)
  else  : txt = "Remove : %s" % FFKrMM(VVAIxO.VVQDwi()[0], VVU4M8)
  VV9cxb = [(txt, "del")]
  cbFncDict = {"del": BF(FF7iMz, VVAIxO, BF(self.VVZlji, VVAIxO, Title))}
  mSel.VV4sFy(VV9cxb, cbFncDict)
 def VVZlji(self, VVAIxO, title):
  VVO4q6, err = CC2Ekb.VV2g3w(self, title=title)
  if err:
   return
  isMulti = VVAIxO.VVGZGK
  skipLst = []
  if isMulti : skipLst = VVAIxO.VVKa9C(3)
  else  : skipLst = [VVAIxO.VVQDwi()[3]]
  tpLst = CC2Ekb.VVXiSy(VVO4q6, mode=0)
  servLst = CC2Ekb.VVXiSy(VVO4q6, mode=10)
  tmpDbFile = VVO4q6 + ".tmp"
  lines   = FF2kXa(VVO4q6)
  skip = False
  with open(tmpDbFile, "w") as f:
   for line in lines:
    tLine = line.strip()
    if tLine == "services":
     skip = True
     f.write(line + "\n")
     for item in servLst:
      if not item[0].upper() in skipLst:
       for L in item:
        f.write(L + "\n")
    elif skip and tLine == "end":
     skip = False
    if not skip:
     f.write(line + "\n")
  FFlonU("mv -f '%s' '%s'" % (tmpDbFile, VVO4q6))
  VVuGUx = []
  for row in VVAIxO.VVGpBN():
   if not row[3] in skipLst:
    VVuGUx.append(row)
  FFANYL()
  FFSMJz(self, "Removed Services : %d" % len(skipLst), title="Remove Services")
  if VVuGUx:
   VVAIxO.VVEEBV(VVuGUx, title)
   VVAIxO.VVurYr()
  else:
   VVAIxO.cancel()
 @FFJRPn(par=1)
 def VVeVg6(self, obj, title):
  VVO4q6, err = CC2Ekb.VV2g3w(self)
  if err:
   return
  totT, totC, totA, totS, totS2, satList = self.VVXce9(VVO4q6)
  txt = FFKrMM("Total Transponders:\n\n", VV1l75)
  txt += "   DVB-S    Satellite\t: %d \n"  % totS
  txt += "   DVB-S2  Satellite\t: %d\n"  % totS2
  txt += "   DVB-T    Terrestrial\t: %d\n" % totT
  txt += "   DVB-C    Cable\t: %d\n"   % totC
  txt += "   DVB-A    ATSC\t: %d\n"   % totA
  if satList and len(satList) > 0:
   txt += FFKrMM("\nSatellite Transponders (Total=%d):\n\n" % (totS + totS2), VV1l75)
   uniqSat = []
   for sat in satList:
    if not sat in uniqSat:
     uniqSat.append(sat)
   uniqSat.sort(key=lambda x: int(x))
   for item in uniqSat:
    txt += "   %s\t: %d\n" % (FFPjK2(item), satList.count(item))
  FFSMJz(self, txt, title)
 def VVXce9(self, VVO4q6):
  totT = totC = totA = totS = totS2 = 0
  satList = []
  tagFound = False
  with ioOpen(VVO4q6, "r", encoding="utf-8") as f:
   lines = []
   for line in f:
    line = str(line).strip()
    if tagFound:
     if line == "end"    : break
     elif line.startswith("t")  : totT += 1
     elif line.startswith("c")  : totC += 1
     elif line.startswith("a")  : totA += 1
     elif line.startswith("s"):
      c = line.count(":")
      if   c > 9: totS2 += 1
      elif c > 5: totS  += 1
      if c > 5:
       satList.append(line.split(":")[4])
    elif line == "transponders":
     tagFound = True
  return totT, totC, totA, totS, totS2, satList
 @FFJRPn(par=1)
 def VVkJ8P(self, obj, title):
  p1 = "/etc/enigma2/satellites.xml"
  p2 = "/etc/tuxbox/satellites.xml"
  if   FFKbVo(p1) : path = p1
  elif FFKbVo(p2) : path = p2
  else    : path = ""
  if not path:
   FFWfGZ(self, "%s\n.. or ..\n%s" % (p1, p2), title=title)
   return
  elif not CC17eA.VV9kj1(self, path, title):
   return
  if not CCCusX.VVbBWp(self):
   return
  tree = CC2Ekb.VVF6XZ(self, path, title=title)
  if not tree:
   return
  VVuGUx = []
  root  = tree.getroot()
  totTpColor = "#f#00FFFF55#"
  for sat in root.findall("sat"):
   name = str(sat.get("name", "").encode("UTF-8").decode())
   pos  = sat.get("position", "")
   totTp = len(sat)
   hor = ver = cirL = cirR = unk = 0
   dvbS = dvbS2 = dvbUnk = 0
   for tp in sat.findall("transponder"):
    pol = tp.get("polarization")
    if   pol == "0" : hor += 1
    elif pol == "1" : ver += 1
    elif pol == "2" : cirL += 1
    elif pol == "3" : cirR += 1
    Sys = tp.get("system")
    if   Sys == "0" : dvbS += 1
    elif Sys == "1" : dvbS2 += 1
   try:
    posNum = int(pos)
    if posNum == 1801:
     posCalc = "180.1E"
    else:
     if posNum < 0:
      posNum += 3600
     posCalc = FFYCut(posNum)
   except:
    posCalc = "?"
    pos  = "-9999"
   if " " in name : posXml, name = name.split(" ", 1)
   else   : posXml = posCalc
   bg = "" if posCalc.endswith("W") else "#b#00003333#"
   VVuGUx.append((bg + name, pos, posXml, posCalc, totTpColor + str(totTp), str(hor), str(ver), str(cirL), str(cirR), str(dvbS), str(dvbS2)))
  if VVuGUx:
   VVuGUx.sort(key=lambda x: int(x[1]))
   VVwqVu = ("Current Satellite", BF(self.VVWwwF, 3), [])
   header   = ("Satellite" , "Pos #" , "xml Pos" , "Position", "TP" , "Hor" , "Ver" , "Circ-L" , "Circ-R" , "DVB-S" , "DVB-S2" )
   widths   = (36    , 8   , 0   , 10  , 6  , 5  , 5  , 7   , 7   , 8   , 8   )
   VV4Uoc  = (LEFT   , CENTER , CENTER , CENTER , CENTER, CENTER, CENTER, CENTER , CENTER , CENTER , CENTER )
   FFCXsL(self, None, title=path, header=header, VVXpNQ=VVuGUx, VV4Uoc=VV4Uoc, VV8boH=widths, VVPYL1=25, VVul85=1, VVwqVu=VVwqVu, VVAGe1=CFG.lastFindSatName)
  else:
   FFbBGq(self, "No data found !", title=title)
 def VVWwwF(self, satCol, VVAIxO, title, txt, colList):
  sat = FFgAAw(CCZv30(self.session).VVq9SN, False)
  for ndx, row in enumerate(VVAIxO.VVGpBN()):
   if sat == row[satCol].strip():
    VVAIxO.VVt5t9(ndx)
    break
  else:
   FFoTZI(VVAIxO, "Not in list", 1500)
 @FFJRPn()
 def VVidN2(self):
  satLst = nimmanager.getSatList()
  if not satLst:
   FFbBGq(self, "No Satellites found !")
   return
  usedSats = CC2Ekb.VVIDXh()
  VVuGUx = []
  for sat in satLst:
   tunerLst = []
   for tuner, sats in usedSats:
    if sat in sats:
     tunerLst.append(tuner)
   tunerLst.sort()
   tuners = " , ".join(tunerLst) if tunerLst else ""
   posVal = sat[0]
   if posVal > 1800: posTxt = str(posVal - 3600)
   else   : posTxt = str(posVal)
   VVuGUx.append((sat[1], posTxt, FFYCut(sat[0]), tuners, str(posVal)))
  if VVuGUx:
   VVYCun = "#11222222"
   VVuGUx.sort(key=lambda x: int(x[1]))
   VVwqVu = ("Current Satellite" , BF(self.VVWwwF, 2) , [])
   VV46TD = ("Options"   , self.VVdfkU  , [])
   header   = ("Satellite" , "Pos #" , "Position", "Tuners" , "posVal" )
   widths   = ( 50    , 10  , 10  , 30  , 0   )
   VV4Uoc  = ( LEFT  , CENTER , CENTER , CENTER , CENTER )
   FFCXsL(self, None, header=header, VVXpNQ=VVuGUx, VV4Uoc=VV4Uoc, VV8boH=widths, VVPYL1=28, VVwqVu=VVwqVu, VV46TD=VV46TD, VVfWsQ=VVYCun, VVB5I5=VVYCun, VVYCun=VVYCun, VVmErq="#0a884400", VVAGe1=CFG.lastFindSatName)
  else:
   FFbBGq(self, "No data found !")
 def VVdfkU(self, VVAIxO, title, txt, colList):
  mSel = CC17aQ(self, VVAIxO)
  isMulti = VVAIxO.VVGZGK
  if isMulti : txt = "Remove ALL Services on %s Satellites" % FFKrMM(VVAIxO.VVAGI8(), VVU4M8)
  else  : txt = "Remove ALL Services on : %s" % FFKrMM(VVAIxO.VVQDwi()[0], VVU4M8)
  VV9cxb = []
  VV9cxb.append((txt, "deleteSat"))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Delete Empty Bouquets", "VVktJH"))
  cbFncDict = { "deleteSat"   : BF(FF7iMz, VVAIxO, BF(self.VVNHTe, VVAIxO))
     , "VVktJH" : BF(self.VVktJH, VVAIxO)
     }
  mSel.VV4sFy(VV9cxb, cbFncDict)
 def VVNHTe(self, VVAIxO):
  posLst = []
  isMulti = VVAIxO.VVGZGK
  posLst = []
  if isMulti : posLst = VVAIxO.VVKa9C(4)
  else  : posLst = [VVAIxO.VVQDwi()[4]]
  nsLst = []
  for pos in posLst:
   nsLst.append(self.VVQ6Zz(pos))
  db = eDVBDB.getInstance()
  if db:
   for pos in posLst:
    db.removeServices(-1, -1, -1, int(pos))
  totCh, totBoq = self.VV5EYr(nsLst)
  FFANYL(True)
  FFSMJz(self, "Deleted Satellites:\n%d\n\nDeleted Services:\n%d\n\nCleaned Bouquets:\n%d" % (len(posLst), totCh, totBoq), title="Delete Satellites")
 def VVktJH(self, winObj):
  title = "Delete Empty Bouquets"
  FF6pUe(self, BF(FF7iMz, winObj, BF(self.VVYHh9, title)), "Delete bouquets with no services ?", title=title)
 def VVYHh9(self, title):
  bList = CC8i1k.VVkiEP()
  bNames = []
  if bList:
   fList = []
   for bName, bRef in bList:
    bFile = CC8i1k.VVRPbd(bRef)
    bPath = VVgVTn + bFile
    FFnE7j(bPath)
    bNames.append(bName)
    fList.append(bFile)
   if fList:
    for fil in ("bouquets.tv", "bouquets.radio"):
     path = VVgVTn + fil
     if FFKbVo(path):
      lines = FF2kXa(path)
      newLines = []
      for line in lines:
       for bFile in fList:
        if bFile in line:
         break
       else:
        newLines.append(line)
      if newLines:
       with open(path, "w") as f:
        f.write("\n".join(newLines) + "\n")
   FFANYL(True)
  if bNames: txt = "%s\n\n%s" % (FFKrMM("Deleted Bouquets:", VVk4x7), "\n".join(bNames))
  else  : txt = "No empty bouquets."
  FFSMJz(self, txt, title=title)
 def VVQ6Zz(self, pos):
  pos = int(pos.strip())
  if pos < 0:
   pos += 3600
  return ("%04x" % pos).upper()
 def VV5EYr(self, nsLst):
  totCh = totBoq = 0
  files = iGlob("%suserbouquet.*.tv" % VVgVTn)
  for srcF in files:
   if FFKbVo(srcF):
    lines = FF2kXa(srcF)
    newLines = []
    found = False
    for line in lines:
     span = iSearch(r"#SERVICE\s+((?:[A-Za-z0-9]+:){10})$", line, IGNORECASE)
     if span:
      ns = FFikHv(span.group(1))
      if ns in nsLst:
       found = True
       totCh += 1
       continue
     newLines.append(line)
    if found and newLines:
     totBoq += 1
     with open(srcF, "w") as f:
      f.write("\n".join(newLines) + "\n")
  return totCh, totBoq
 @FFJRPn(par=1)
 def VVf9vk(self, VVhzhr, title, isWithPIcons):
  piconsPath = CCRGqC.VV5G3P()
  if VVkY7E(piconsPath):
   totalPicons = 0
   for fName, fType in CCRGqC.VVkuaE(piconsPath):
    if fName:
     totalPicons +=1
   if totalPicons > 0:
    VVuGUx, err = CC2Ekb.VVTefV(self, self.VV6xi4)
    if VVuGUx:
     channels = []
     for (VVUwmk, chProv, sat, VVq9SN) in VVuGUx:
      fName = VVq9SN.replace(":", "_") + ".png"
      pFile = FFtLHn(piconsPath, fName)
      if isWithPIcons:
       if pFile:
        channels.append((VVUwmk, chProv, sat, VVq9SN))
      else:
       if not pFile:
        channels.append((VVUwmk, chProv, sat, VVq9SN))
     totalServices = len(VVuGUx)
     totalFound  = len(channels)
     if isWithPIcons:
      totalWithPIcons  = totalFound
      totalMissingPIcons = totalServices - totalWithPIcons
     else:
      totalMissingPIcons = totalFound
      totalWithPIcons  = totalServices - totalMissingPIcons
     def VVqz4B(key, val):
      return "%s\t\t: %s\n" % (key, str(val))
     txt = ""
     txt += VVqz4B("PIcons Path"  , piconsPath)
     txt += VVqz4B("Total PIcons" , totalPicons)
     txt += "\n"
     txt += VVqz4B("Total services" , totalServices)
     txt += VVqz4B("With PIcons"  , totalWithPIcons)
     txt += VVqz4B("Missing PIcons" , totalMissingPIcons)
     if totalFound == 0:
      FFSMJz(self, txt)
     else:
      VVmolf     = (""      , self.VV5Ozo , [])
      if isWithPIcons : VViMvb = ("Export Current PIcon", self.VVKdba  , [])
      else   : VViMvb = None
      VV46TD     = ("Statistics", FFSMJz, [txt])
      VVj7lw      = ("Zap", self.VVjhnq, [])
      channels.sort(key=lambda x: x[0].lower())
      self.VVhs97(title, channels, VVj7lw=VVj7lw, VVmolf=VVmolf, VV46TD=VV46TD, VViMvb=VViMvb)
   else:
    FFbBGq(self, "No picons found in path:\n\n%s" % piconsPath)
  else:
   FFbBGq(self, "PIcons path not found.\n\n%s" % piconsPath)
 def VV5Ozo(self, VVAIxO, title, txt, colList):
  VVq9SN, VVadS0, VVjgtq, VVVmGQ, VVUwmk = FFLlAM(self)
  VVq9SN1 = colList[3]
  if VVq9SN == VVq9SN1:
   txt = ""
  else:
   txt = "%s\n\n%s" % (title, txt)
  CCpebE.VV1v7b(self, VV6tGM=CCpebE.VVZrW7, params=(VVq9SN1, colList[0], txt))
 def VVKdba(self, VVAIxO, title, txt, colList):
  png, path = CCRGqC.VVep9Y(colList[3], colList[0])
  if path:
   CCRGqC.VVAI7e(self, png, path)
 @staticmethod
 def VV2yDM():
  VVO4q6  = "%slamedb" % VVgVTn
  VVdRDV = "%slamedb.disabled" % VVgVTn
  return VVO4q6, VVdRDV
 @staticmethod
 def VVnOwm():
  VVVKXl  = "%slamedb5" % VVgVTn
  VVGgJ3 = "%slamedb5.disabled" % VVgVTn
  return VVVKXl, VVGgJ3
 def VVBekV(self, isEnable):
  VVO4q6, VVdRDV = CC2Ekb.VV2yDM()
  if isEnable and not FFKbVo(VVdRDV):
   FF0onH(self, "Aready enabled.")
  elif not isEnable and not FFKbVo(VVO4q6):
   FFbBGq(self, "LameDB File not found!")
  else:
   if isEnable : word = "Enable"
   else  : word = "Disable"
   FF6pUe(self, BF(self.VVcbXN, isEnable), "%s Hidden Channels ?" % word)
 def VVcbXN(self, isEnable):
  VVO4q6 , VVdRDV = CC2Ekb.VV2yDM()
  VVVKXl, VVGgJ3 = CC2Ekb.VVnOwm()
  cmd = ""
  if isEnable:
   word = "Enabled"
   cmd += "if [ -f '%s' ]; then mv -f '%s' '%s'; fi;"   % (VVdRDV, VVdRDV, VVO4q6)
   cmd += "if [ -f '%s' ]; then mv -f '%s' '%s'; fi;"   % (VVGgJ3, VVGgJ3, VVVKXl)
  else:
   word = "Disabled"
   cmd += "if [ -f '%s' ]; then cp -f '%s' '%s'; fi;"   % (VVO4q6  , VVO4q6 , VVdRDV)
   cmd += "if [ -f '%s' ]; then cp -f '%s' '%s'; fi;"   % (VVVKXl , VVVKXl, VVGgJ3)
   cmd += "if [ -f '%s' ]; then sed -i 's/,f:2//' '%s'; fi;" % (VVdRDV, VVO4q6 )
   cmd += "if [ -f '%s' ]; then sed -i 's/,f:2//' '%s'; fi;" % (VVGgJ3, VVVKXl)
  ok = FFlonU(cmd)
  FFANYL()
  if ok: FF0onH(self, "Hidden List %s" % word)
  else : FFbBGq(self, "Error while restoring:\n\n%s" % fileName)
 def VVi1b1(self):
  cmd = ""
  cmd += "echo -e 'Reading current settings ...';"
  cmd += "cat %s | grep -v 'config.ParentalControl' > /tmp/settings_my_tmp.txt;" % VVlLfA
  cmd += "echo -e 'Applying new settings ...';"
  cmd += "mv /tmp/settings_my_tmp.txt %s" % VVlLfA
  FF9CWb(self, cmd)
 @FFJRPn()
 def VVNJXm(self):
  VVO4q6, err = CC2Ekb.VV2g3w(self)
  if err:
   return
  tmpFile = "/tmp/ajp_lamedb"
  FFnE7j(tmpFile)
  totChan = totRemoved = 0
  lines = FF2kXa(VVO4q6, keepends=True)
  with open(tmpFile, "w") as f:
   servFound = False
   servLines = []
   for line in lines:
    if servFound:
     if line.strip() == "end":
      f.write(line)
      break
     else:
      servLines.append(line)
      if len(servLines) == 3:
       if len(servLines[1].strip()) > 0:
        totChan += 1
        f.write(servLines[0])
        f.write(servLines[1])
        f.write(servLines[2])
       else:
        totRemoved += 1
       servLines = []
    else:
     f.write(line)
     if line.strip() == "services":
      servFound = True
  if totRemoved:
   FF6pUe(self, BF(self.VVC9ks, tmpFile, VVO4q6, totRemoved, totChan)
      , "Delete %d servce%s (out of %d service%s) ?" % (totRemoved, FFaRsj(totRemoved), totChan, FFaRsj(totChan))
      , callBack_No=BF(self.VVqgve, tmpFile))
  else:
   FFSMJz(self, "Total Channels\t: %d\nWith no names\t: %d" % (totChan, totRemoved))
 @FFJRPn()
 def VVC9ks(self, tmpFile, VVO4q6, totRemoved, totChan):
  FFlonU("mv -f '%s' '%s'" % (tmpFile, VVO4q6))
  FFANYL()
  FFSMJz(self, "Total Channels\t: %d\nTotal Removed\t: %d" % (totChan, totRemoved))
 def VVqgve(self, tmpFile):
  FFnE7j(tmpFile)
 @staticmethod
 def VV2g3w(SELF, VVFiGB=True, title=""):
  VVO4q6, VVdRDV = CC2Ekb.VV2yDM()
  if   not FFKbVo(VVO4q6)       : err = "File not found !\n\n%s" % VVO4q6
  elif not CC17eA.VV9kj1(SELF, VVO4q6) : err = "'lamedb' file is not in 'UTF-8' Encoding !"
  else             : err = ""
  if err and VVFiGB:
   FFbBGq(SELF, err, title=title)
  return VVO4q6, err
 @staticmethod
 def VVov2P(VVq9SN):
  _, flg, _, _, tsid, nid, ns, _, _, _ = VVq9SN.rstrip(":").split(":")
  if flg == "0": return (":".join([ns.zfill(8), tsid.zfill(4), nid.zfill(4)])).upper()
  else   : return ""
 @staticmethod
 def VVpvrS(VVq9SN):
  _, flg, st, sid, tsid, nid, ns, _, _, _ = VVq9SN.rstrip(":").split(":")
  if flg == "0": return (":".join([sid.zfill(4), ns.zfill(8), tsid.zfill(4), nid.zfill(4), str(int(st, 16)), "0", "0"])).upper()
  else   : return ""
 @staticmethod
 def VVRKzP(lameDbServId):
  return ":".join(lameDbServId.rstrip(":").split(":")[1:4]).upper()
 @staticmethod
 def VVwkaL(servTypes):
  VVimsO  = eServiceCenter.getInstance()
  VVAGxB   = '%s ORDER BY name' % servTypes
  VVPyqT   = eServiceReference(VVAGxB)
  VVmIIz = VVimsO.list(VVPyqT)
  if VVmIIz: return VVmIIz.getContent("CN", False)
  else     : return []
 @staticmethod
 def VVIDXh():
  slotSats = []
  for slot in nimmanager.nim_slots:
   if slot.frontend_id is not None:
    lst = nimmanager.getSatListForNim(slot.frontend_id)
    if lst:
     slotSats.append((slot.getSlotName(), lst))
  return slotSats
 @staticmethod
 def VVIMKA(session):
  serv = session.nav.getCurrentlyPlayingServiceReference()
  if serv:
   shown = InfoBar.instance.shown
   session.nav.stopService()
   session.nav.playService(serv)
   if not shown: InfoBar.instance.hide()
 @staticmethod
 def VVEUkc():
  inst = InfoBar.instance
  return inst and hasattr(inst, "checkStreamrelay") or hasattr(inst, "ToggleStreamrelay")
 @staticmethod
 def VVOTBF():
  try:
   host = config.misc.softcam_streamrelay_url.value
   port = config.misc.softcam_streamrelay_port.value
   return host, port
  except:
   return "", ""
 @staticmethod
 def VV0kGE():
  lst = []
  for line in FF2kXa(VVrOPV):
   line = line.strip()
   if iMatch(r"^((?:[A-Fa-f0-9]+:){10})$", line):
    lst.append(line.rstrip(":").upper())
  return lst
 @staticmethod
 def VVZeVo(r, unknown="?"):
  serv = eServiceReference(r)
  if serv:
   path = serv.getPath()
   if not path     : return FFgAAw(r, False)
   elif path.startswith("/") : return "Local"
   elif FFKeSw(r)  : return "Stream Relay"
   elif FFC4pX(r)    : return "IPTV"
  return unknown
 @staticmethod
 def VV7p8T():
  try: InfoBar.instance.showServiceListOrMovies()
  except: pass
 @staticmethod
 def VVRjb1(session, cbFnc, plServ=True, VV17at=None, retServ=False):
  cSel = None
  try:
   def VVxN3u(*args):
    if args:
     serv = args[0]
     if plServ : FFQ2Oi(session, serv)
     if retServ : cbFnc(serv)
     else  : cbFnc()
   from Screens.ChannelSelection import SimpleChannelSelection
   cSel = session.openWithCallback(VVxN3u, SimpleChannelSelection, "Select a channel")
   if cSel:
    rSrv = InfoBar.instance.servicelist.getRoot()
    if rSrv: cSel.enterPath(rSrv)
    if VV17at: cSel.setCurrentSelection(VV17at)
  except:
   pass
  return cSel
 @staticmethod
 def VVwii4():
  try: return [serv[-1] for serv in InfoBar.instance.servicelist.history]
  except: return []
 @staticmethod
 def VVthPE(session, mode=0):
  hLst = list(reversed(CC2Ekb.VVwii4()))
  if mode in (0, 1):
   for srv in hLst:
    if not srv.getPath().startswith(("/", "http")):
     FFQ2Oi(session, srv)
     return srv
  if mode in (0, 2):
   for srv in hLst:
    if not srv.getPath().startswith("/"):
     FFQ2Oi(session, srv)
     return srv
  return None
class CCvFMf():
 def __init__(self, gapX=0, gapY=0):
  self.VVCVTZ  = []
  self["myPicF"]   = Label()
  self["myPicB"]   = Label()
  self["myPic"]   = Pixmap()
  self.VV9zlM()
  x, y, w, h = self.VVmNvK["retPar"]
  x -= gapX
  y += gapY
  self.VVCVTZ = ((x-1, y-1, w+2, h+2), (x, y, w, h), (x, y, w, h))
 def VVgwPx(self, path):
  self.VV9zlM()
  if not (os.path.isfile(path) and CC00KO.VVuedz(path) == "pic"):
   return False
  sz = FFLjtI(path)
  if sz == 0:
   self.VVLw1v()
   return  False
  x, y, w, h = self.VVCVTZ[2]
  right = x + w
  newW, newH, err = CCM6jS.VVk3nS(path)
  if not err:
   x1, y1, w, h = CCanwj.VV4c0B(newW, newH, w, h)
   if newH > newW:
    w, h = int(w * 1.6), int(h * 1.6)
   x = right - w
  self.VVF6mO(x, y, w, h)
  if FFZ27n(self["myPic"], path, fncCb_fail=self.VVLw1v):
   self.VVgnwK()
   return True
  else:
   self.VVLw1v()
   return False
 def VVLw1v(self):
  self.VV9zlM()
  if FFHTca(self["myPic"], "noPic"):
   x, y, w, h = self.VVCVTZ[2]
   right = x + w
   w = h
   x = right - w
   self.VVF6mO(x, y, w, h)
   self.VVgnwK()
 def VVF6mO(self, x, y, w, h):
  for i, obj in enumerate(self.VVeRwl()):
   if i == 0: x1, y1, w1, h1 = x-1, y-1, w+2, h+2
   else  : x1, y1, w1, h1 = x, y, w, h
   if all((x, y, w, h)):
    obj.instance.move(ePoint(int(x1), int(y1)))
    obj.instance.resize(eSize(*(int(w1), int(h1))))
 def VVeRwl(self):
  return [self[x] for x in ("myPicF", "myPicB", "myPic")]
 def VVgnwK(self):
  try:
   for w in self.VVeRwl(): w.show()
  except:
   pass
 def VV9zlM(self):
  for w in self.VVeRwl(): w.hide()
 def VVefsq(self):
  return self["myPicF"].getVisible()
 def VVxqQr(self):
  return self["myPicF"].instance.size().height() if self.VVefsq() else 0
class CCpebE(Screen, CCvFMf):
 VVbdzi  = 0
 VVZrW7    = 1
 VVaclA    = 2
 VVxbjT   = 3
 VVuYDw   = 4
 VVaj4O   = 5
 VVHHG8    = 6
 VVfGBj    = 7
 VVsuho   = 8
 VVF9O7   = 9
 VVjPkL   = 10
 VV5H8C   = 11
 VVtIil   = 12
 VVsy7G   = 13
 def __init__(self, session, VV6tGM, title="", params=None, VVHkge=""):
  self.skin, self.VVmNvK = FFQaOH(VV0v8m, 1400, 1000, 50, 30, 10, "#05001921", "#05001921", 30, VV05bd=(0, 0))
  self.session  = session
  self.VV6tGM  = VV6tGM
  self.Title   = title or "Service Info."
  self.params   = params
  self.VVwlbb  = None
  self.VVq9SN  = ""
  self.VVHK1O  = ""
  self.VVadS0  = ""
  self.VVVmGQ  = ""
  self.VVUwmk   = ""
  self.VVVSru = ""
  self.VVuPzU   = ""
  self.VVHkge  = VVHkge
  self.VVBWwy  = ""
  self.chUrl   = ""
  self.VVrdH5 = ""
  self.VVAqnX  = False
  self.VVJVAP  = ""
  self.VVhv5i  = ""
  self.VVfMio  = ""
  self.VVU0R9  = ""
  self.VV8sIv  = False
  self.VVKVY4 = False
  self.Sep   = FFKrMM("%s\n", VV3Hcc) % SEP
  self.VVHypR = eTimer()
  FFNhKZ(self, title=self.Title + FFKrMM("    Processing ...", VV3Hcc), addScrollLabel=True)
  CCvFMf.__init__(self)
  FFmpyO(self,
  {
   "info" : self.VVOcR8 ,
   "ok" : self.cancel   ,
   "cancel": self.cancel
  })
  self.onShown.append(self.VVf1Ra)
  self.onClose.append(self.onExit)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  self["myLabel"].VVesH9(outputFileToSave="chann_info")
  if   self.VV6tGM == self.VVbdzi : fnc = self.VVkgQP
  elif self.VV6tGM == self.VVZrW7  : fnc = self.VVrZ74
  elif self.VV6tGM == self.VVaclA  : fnc = self.VVk7M8
  elif self.VV6tGM == self.VVxbjT  : fnc = self.VVVqG2
  elif self.VV6tGM == self.VVuYDw : fnc = self.VVuzdX
  elif self.VV6tGM == self.VVaj4O  : fnc = self.VVZ63p
  elif self.VV6tGM == self.VVHHG8  : fnc = self.VVTIKE
  elif self.VV6tGM == self.VVfGBj  : fnc = self.VVahcX
  elif self.VV6tGM == self.VVsuho  : fnc = self.VVRozD
  elif self.VV6tGM == self.VVF9O7 : fnc = self.VVeJYX
  elif self.VV6tGM == self.VVjPkL  : fnc = self.VV8M5g
  elif self.VV6tGM == self.VV5H8C : fnc = self.VVh52d
  elif self.VV6tGM == self.VVtIil : fnc = self.VVSJvf
  elif self.VV6tGM == self.VVsy7G  : fnc = self.VVF4Aw
  try: self.VVHypR_conn = self.VVHypR.timeout.connect(self.VVioZu)
  except: self.VVHypR.callback.append(self.VVioZu)
  self.VVHypR.start(50, False)
  self["myLabel"].setText("\n   Reading Info ...")
  self["myLabel"].VVJS7j()
  FFvfpL(fnc)
 def onExit(self):
  self.VVHypR.stop()
 def cancel(self):
  if self.VVKVY4:
   self.close()
 def VVkgQP(self):
  try: dum = self.session
  except: return
  s = CCZv30(self.session)
  if not s.info:
   self.VVaRQX()
   self.VV8sIv = self.VVKVY4 = True
   return
  fPath, fDir, fName = CC17eA.VVNGSU(self)
  self.VVVSru = fPath
  self.VVwlbb  = s.info
  self.VVq9SN  = s.VVq9SN
  self.VVHK1O  = s.VVHK1O
  self.VVVmGQ  = s.VVVmGQ
  self.VVUwmk   = s.VVUwmk
  self.VVJVAP  = self.VVdke3(s)
  self.VVtAoV(s.VVadS0)
 def VVrZ74(self):
  self.VVq9SN, self.VVUwmk, self.VVBWwy = self.params
  self.VVtAoV(self.VVq9SN)
 def VVk7M8(self):
  self.VVq9SN, self.VVUwmk, self.VVBWwy = self.params
  self.VVtAoV(self.VVq9SN)
 def VVVqG2(self):
  self.VVq9SN, self.VVUwmk, self.VVBWwy = self.params
  self.VVtAoV(self.VVq9SN)
 def VVuzdX(self):
  self.VVq9SN, self.VVUwmk, self.VVBWwy = self.params
  self.VVtAoV()
 def VVZ63p(self):
  self.VVq9SN, self.VVUwmk, self.VVBWwy, self.VVHkge = self.params
  self.VVtAoV()
 def VVTIKE(self):
  self.VVq9SN, self.VVUwmk, self.VVBWwy, self.VVadS0, self.VVVmGQ = self.params
  self.VVtAoV(self.VVVmGQ)
 def VVahcX(self):
  self.VVadS0, self.VVUwmk, self.VVBWwy, self.VVuPzU = self.params
  self.VVtAoV()
 def VVRozD(self):
  self.VVq9SN, self.VVUwmk, self.VVBWwy, self.chUrl, self.VVuPzU = self.params
  self.VVtAoV(self.chUrl)
 def VVeJYX(self):
  self.VVUwmk, self.VVBWwy, self.VVuPzU = self.params
  self.VVtAoV()
 def VV8M5g(self):
  self.VVq9SN, self.chUrl, self.VVUwmk, self.VVBWwy, self.VVuPzU = self.params
  self.VVtAoV(self.chUrl)
 def VVh52d(self):
  self.VVUwmk, self.VVBWwy, self.VVuPzU = self.params
  self.VVtAoV()
 def VVSJvf(self):
  self.VVBWwy, self.VVHkge = self.params
  self.VVtAoV()
 def VVF4Aw(self):
  self.VVBWwy, self.VVuPzU = self.params
  self.VVuPzU = FF5ov5(self.VVuPzU)
  self.VVtAoV()
 def VVioZu(self):
  if self.VV8sIv:
   self["myTitle"].setText("  %s" % self.Title)
   self.VVHypR.stop()
  if self.VVhv5i:
   txt, self.VVhv5i = self.VVhv5i, ""
   txt = self["myLabel"].getText().strip() + "\n\n" + txt.strip()
   self["myLabel"].setText("\n" + txt, VV5wgt=VVhlSe)
   self.VVzN07()
  if self.VVfMio:
   evLst, self.VVfMio = self.VVfMio, ""
   self.VVyjVY(evLst)
  if self.VVU0R9:
   path, self.VVU0R9 = self.VVU0R9, ""
   self.VVAqnX = self.VVVEAi(path)
   self.VVjnZc(path)
 def VVaRQX(self):
  txt = self.VVBWwy.strip()
  cTxt = self.VVJVAP.strip()
  if txt and cTxt : txt += "\n\n%s\n%s" % (self.Sep, cTxt)
  else   : txt += cTxt
  self["myLabel"].setText(txt or "   No active service", VV5wgt=VVhlSe)
  self.VVzN07()
 def VVzN07(self):
  self["myLabel"].VVJS7j(minHeight=self.VVxqQr())
 def VVVEAi(self, path):
  isOk = self.VVgwPx(path)
  if isOk:
   self.VVzN07()
  return isOk
 def VVtAoV(self, ref=""):
  if ref:
   span = iSearch(r"((?:[A-Fa-f0-9]+[:]){10})*(.+\/\/.+)", ref)
   if span:
    self.VVrdH5 = FF5ov5(span.group(1))
    self.VVadS0 = FF5ov5(span.group(2))
  if not self.VVrdH5:
   self.VVrdH5 = CCpebE.VVVRNj(self.VVq9SN) or CCpebE.VVVRNj(self.VVVmGQ)
  if self.VVadS0 and not "URL:" in self.VVJVAP and not "URL:" in self.VVBWwy:
   self.VVBWwy = self.VVBWwy.rstrip() + "\n\nURL:\n%s\n" % FFKrMM(CCpebE.VVcJv3(self.VVadS0), VV0p9P)
  self.VVaRQX()
  FFvfpL(self.VV2q6p)
 def VV2q6p(self):
  if not self.VVAqnX and self.VVHkge:
   self.VVAqnX = self.VVVEAi(self.VVHkge)
  if not self.VVAqnX and self.VVq9SN:
   png, path = CCRGqC.VVep9Y(self.VVq9SN, self.VVUwmk)
   if png: self.VVAqnX = self.VVVEAi(path)
  if not self.VVAqnX and self.VVHK1O:
   png, path = CCRGqC.VVep9Y(self.VVHK1O, self.VVUwmk)
   if png: self.VVAqnX = self.VVVEAi(path)
  FFvfpL(self.VVFMzZ)
 def VVFMzZ(self):
  VVOnvh = CCtAi7.VVt9oe(self.VVq9SN)
  if VVOnvh: VV9Ems = []
  else  : VV9Ems = CCtAi7.VVvPPk(self.VVwlbb, self.VVq9SN)
  iThread(name="ajp_info_pic", target=BF(self.VVeXxO, VVOnvh, VV9Ems)).start()
  self.VVKVY4 = True
 def VVeXxO(self, VVOnvh, VV9Ems):
  try:
   title = FFFGRS("EPG:", VVk4x7)
   epg = ""
   evLst = []
   netOk = CC9qM0.VVQ0uB
   if netOk:
    self.VVnrsy(self.VVuPzU)
    if self.VVadS0:
     epg, evLst, VVuPzU, err = CCpebE.VVZlns(self.VVadS0)
     self.VVnrsy(VVuPzU)
    if not epg and self.VVadS0:
     epg, evLst, err = CCTe4w.VVQtfm(self.VVadS0)
    if epg : self.VVhv5i = title + epg
    if evLst: self.VVfMio = evLst
   if not epg and (VVOnvh or VV9Ems):
    if   not netOk  : totTr = 0
    elif VVOnvh  : totTr = 2
    elif VV9Ems : totTr = 2
    self.VVhv5i = title + CCtAi7.VVZnm6(VVOnvh or VV9Ems, totTr)
   self.VVPxIa()
  except:
   pass
  self.VV8sIv = True
 def VVPxIa(self):
  txt = ""
  if self.VVVSru:
   txt = CCM6jS.VVqVLH(self.VVVSru)
  elif self.VVadS0 and self.VVUwmk:
   path, headers = CCM6jS.VVMW8Y(self.VVadS0, self.VVUwmk)
   if path:
    txt = CCM6jS.VVqVLH(path, headers)
  if txt:
   self.VVhv5i = txt
 @staticmethod
 def VVZlns(VVadS0):
  if "chCode" in VVadS0:
   p = CCr0nV()
   valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVjhBj(VVadS0)
   uHost = uUser = uPass = uId = ""
   p, pUrl, pUrlAcc, pUrlDnld, pHost, pUser, pPass, err = CCr0nV.VVGc5K(host=host, mac=mac, ph1=ph1)
   if all((pHost, pUser, pPass, stID)) : uType, uHost, uUser, uPass, uId = mode, pHost, pUser, pPass, stID
   else        : return "", "", "", "No EPG (invalid URL) !"
  else:
   uType, uHost, uUser, uPass, uId, uChName = CCTe4w.VVqy70(VVadS0)
   if not all([uHost, uUser, uPass, uId]):
    return "", "", "", "No EPG (invalid URL) !"
   span = iSearch(r"S\d{2,3}E\d{2,3} \((.+)\)", uChName)
   catID = span.group(1) if span else ""
  qUrl = "%s/player_api.php?username=%s&password=%s&action=" % (uHost, uUser, uPass)
  if   uType in ("live", "itv") : qUrl += "get_simple_data_table&stream_id=%s" % (uId)
  elif uType in ("movie", "vod") : qUrl += "get_vod_info&vod_id=%s" % (uId)
  elif uType == "series" and catID: qUrl += "get_series_info&series_id=%s" % (catID)
  else       : return "", "", "", "Cannot process this channels"
  txt, err = CCTe4w.VVwngR(qUrl, timeout=3)
  if err: return "", "", "", "No EPG from server (%s)" % err
  epg = VVuPzU = ""
  evLst = []
  if   uType in ("live", "itv") : epg, evLst, err = CCTe4w.VVWf3s(txt, mode=3)
  elif uType in ("movie", "vod") : epg, VVuPzU, err = CCTe4w.VVSRji(txt)
  elif uType == "series"   : epg, VVuPzU, err = CCTe4w.VVv4A8(txt, VVadS0)
  err = "" if epg else "No EPG from server !"
  return epg, evLst, VVuPzU, err
 def VVnrsy(self, url):
  if url and not self.VVAqnX:
   path, err = FFUzwU(url, "ajp_tmp.png", timeout=2, mustBeImage=True)
   if path:
    self.VVU0R9 = path
 def VVyjVY(self, evLst):
  if self.VVrdH5 and evLst:
   totEv, totOK = CCtAi7.VVRFU9(self.VVrdH5, evLst, longDescDays=7)
   if totOK > 0:
    CCtAi7.VVFxed()
 def VVjnZc(self, path):
  if self.VVAqnX and self.VVrdH5 and FFKbVo(path) and FFW91j("ffmpeg"):
   pPath = CCRGqC.VV5G3P()
   if VVkY7E(pPath):
    picon = self.VVrdH5.replace(":", "_") + ".png"
    cmd = CCpebE.VV4mAF(path)
    cmd += FFQWwc("mv -f '%s' '%s%s'" % (path, pPath, picon))
    FFlonU(cmd)
 def VVdke3(self, s):
  tab = lambda x, y: "%s\t: %s\n" % (x, y)
  txt = ""
  txt += tab("Service Name", FFKrMM(s.VVUwmk, VVk4x7))
  txt += tab("Channel Num", s.chNum) if s.chNum > 0 else ""
  txt += tab("Provider" , s.prov) if s.prov else ""
  if s.state: txt += tab("State", (FFKrMM(s.state.replace("*", ""), VVdLWL) if s.state.startswith("*") else s.state))
  vRes = CCpebE.VVBoCX(s.info)
  if vRes: txt += tab("Dimensions", vRes)
  aspect = self.VV7pIH(s.info)
  if aspect: txt += tab("Video Format", aspect)
  txt += self.VVqz4B(s.info, "Video Type", iServiceInformation.sVideoType, 4)
  rate = FFbhVV(s.info, iServiceInformation.sFrameRate)
  if rate.isdigit() and not rate == "0":
   txt += "Frame Rate\t: %s\n" % rate
  if FF7iI0(s.info, iServiceInformation.sIsCrypted) == "1":
   txt += "Crypted\t: Yes\n"
  tot = CCpebE.VVJKB2(self.session)
  if tot > -1: txt += tab("Audio Tracks", tot)
  tot = CCpebE.VVG8GI()
  if tot > -1: txt += tab("Subtitles", tot)
  fPath, fDir, fName, picFile = CCpebE.VVTeST(self)
  isLocal = False
  isIptv  = len(s.VVVmGQ) > 0
  if isIptv:
   txt += tab("Service Type", FFKrMM("Stream-Relay" if FFKeSw(s.VVadS0) else "IPTV", VV1l75))
   if s.VVq9SN and s.VVHK1O and s.VVq9SN != s.VVHK1O:
    txt += tab("S. Relay Ref.", s.VVHK1O)
   txt += CCpebE.VVLKHh(s.VVVmGQ)
  elif fPath:
   isLocal = True
   txt += tab("Reference", s.VVF8zm)
   txt += tab("Service Type", "Local Recording")
   txt += tab("File", fName)
   txt += tab("Directory", fDir)
   if FFKbVo(picFile):
    self.VVHkge = picFile
  elif s.VVq9SN:
   txt += tab("Reference", s.VVq9SN)
  if s.VVq9SN.startswith("1:64:"):
   return txt
  if not isLocal or s.VVq9SN.endswith(":" + s.VVUwmk):
   bouq = self.VVEQ1c(s.VVq9SN, s.VVHK1O, s.VVVmGQ, s.VVUwmk)
   if bouq:
    txt += "\n" + bouq
  if not isLocal and not isIptv or s.VVHK1O:
   txt += "\n"
   txt += self.Sep
   namespace = None
   if s.VVq9SN:
    tp = CCrDr0()
    tpTxt, namespace = tp.VVLaED([s.VVq9SN, s.VVHK1O])
    if tpTxt:
     txt += FFKrMM("Tuner:\n", VVk4x7)
     txt += tpTxt
     txt += "\n"
     txt += self.Sep
   txt += FFKrMM("Codes:\n", VVk4x7)
   if namespace: txt += "Namespace\t: %s\n" % namespace
   else  : txt += self.VVqz4B(s.info, "Namespace", iServiceInformation.sNamespace, 1, 8)
   txt += self.VVqz4B(s.info, "Video PID" , iServiceInformation.sVideoPID , 2, 4)
   txt += self.VVqz4B(s.info, "Audio PID" , iServiceInformation.sAudioPID , 2, 4)
   txt += self.VVqz4B(s.info, "PCR PID" , iServiceInformation.sPCRPID , 2, 4)
   txt += self.VVqz4B(s.info, "PMT PID" , iServiceInformation.sPMTPID , 2, 4)
   txt += self.VVqz4B(s.info, "TXT PID" , iServiceInformation.sTXTPID , 2, 4)
   txt += self.VVqz4B(s.info, "SID"  , iServiceInformation.sSID  , 2, 4)
   txt += self.VVqz4B(s.info, "ONID"  , iServiceInformation.sONID  , 2, 4)
   txt += self.VVqz4B(s.info, "TSID"  , iServiceInformation.sTSID  , 2, 4)
  return txt
 def VVqz4B(self, info, name, what, mode=0, digits=0):
  tab = "\t"
  txt = str(FFbhVV(info, what))
  if len(txt) > 0:
   try  : hexVal = hex(int(txt))[2:].upper()
   except : hexVal = ""
   if digits > 0:
    hexVal = hexVal.zfill(digits)
   if   mode == 1     : txt = hexVal
   elif mode == 2     : txt = "%s\tdec: %s" % (hexVal, txt)
   elif mode == 3     : txt = "Yes" if txt=="1" else "No"
   elif mode == 4     : txt = self.VVqj6v(txt)
   if txt : return "%s%s: %s\n" % (name, tab, txt)
   else : return ""
  else:
   return ""
 def VVqj6v(self, sVideoType):
  codec_data = { -1: "", 0: "MPEG-2", 1: "H.264 (MPEG-4 AVC)", 2: "H.263", 3: "VC1", 4: "MPEG-4 (VC)", 5: "VC1-SM", 6: "MPEG-1", 7: "H.265 (HEVC)", 8: "VP8", 9: "VP9", 10: "XVID", 11: "11", 12: "12", 13: "DIVX 3.11", 14: "DIVX 4", 15: "DIVX 5", 16: "AVS", 17: "17", 18: "VP6", 19: "19", 20: "20", 21: "SPARK" }
  return codec_data.get(int(sVideoType), "")
 def VVEQ1c(self, VVq9SN, sRelRef, VVVmGQ, VVUwmk):
  VVq9SN = FFeWgN(VVq9SN, VVVmGQ, VVUwmk)
  if not VVq9SN:
   return ""
  fList = []
  txt = FFmx8y(VVgVTn + "bouquets.tv")
  list =  iFindall(r"(userbouquet[.].*[.]tv)", txt, IGNORECASE)
  if list: fList += list
  txt = FFmx8y(VVgVTn + "bouquets.radio")
  list =  iFindall(r"(userbouquet[.].*[.]radio)", txt, IGNORECASE)
  if list: fList.extend(list)
  VVXpNQ = []
  ref1 = FF5ov5(VVq9SN)
  for item in fList:
   path = VVgVTn + item
   if FFKbVo(path):
    txt = FF5ov5(FFmx8y(path))
    if ref1 in txt or sRelRef and sRelRef in txt:
     span = iSearch(r"#NAME\s+(.*)", txt, IGNORECASE)
     if span : bName = span.group(1)
     else : bName = "[ No Name ]"
     VVXpNQ.append((bName, os.path.basename(path)))
  if not VVXpNQ:
   return ""
  txt = self.Sep
  if len(VVXpNQ) == 1:
   txt += "%s\t: %s%s\n" % (FFKrMM("Bouquet", VVk4x7), VVXpNQ[0][0], " (%s)" % VVXpNQ[0][1] if VVIlCj else "")
  else:
   txt += FFKrMM("Bouquets:\n", VVk4x7)
   for ndx, item in enumerate(VVXpNQ):
    txt += "%d- %s%s\n" % (ndx + 1, item[0].strip(), " (%s)" % item[1] if VVIlCj else "")
  return txt
 def VVOcR8(self):
  if not VVSm4H:
   return
  def VVqz4B(key, val):
   return "%s= %s\n" % (key.ljust(12), val)
  txt = ""
  s = CCZv30(self.session)
  n = ("VVq9SN", "VVadS0", "VVjgtq", "VVVmGQ", "VVUwmk", "prov", "state")
  v = (s.VVq9SN, s.VVadS0, s.VVjgtq, s.VVVmGQ, s.VVUwmk, s.prov, s.state)
  for i in range(len(n)):
   txt += VVqz4B(n[i], v[i])
  if "chCode" in s.VVVmGQ:
   p = CCr0nV()
   valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVjhBj(s.VVadS0)
   n = ("valid", "ph1", "playHost", "mode", "host", "mac", "epNum", "epId", "chCm", "query")
   v = (valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, query)
   for i in range(len(n)):
    txt += VVqz4B(n[i], v[i])
  path = "/tmp/ajp_channel_details"
  with open(path, "a") as f:
   f.write("%s\n%s\n" % (SEP, txt))
  FFoTZI(self, "Saved to : %s" % path, 1000)
 @staticmethod
 @FFJRPn("Checking Server")
 def VVNiKh(SELF):
  if not CC6V53.VVZTHq(SELF):
   return
  title = "File Size"
  fSize = "Not received from server"
  VVq9SN, VVadS0, VVjgtq, VVVmGQ, VVUwmk = FFLlAM(SELF)
  seekable, percVal, durVal, posVal, remVal, percTxt, durTxt, posTxt, remTxt = CCsmqb.VVKbqb(SELF)
  err = url =  fSize = resumable = ""
  if VVadS0 and seekable == 3 and durVal > 0:
   url = iSub(r"[&?]mode=.+end=", r"", VVadS0, flags=IGNORECASE)
   url = iSub(r"[?]play_token.+", r"", url, flags=IGNORECASE)
   if url.endswith(":" + VVUwmk):
    url = url[:-(len(VVUwmk) + 1)]
   if "chCode" in VVadS0:
    url = CCr0nV.VVULQ1(VVadS0)
   try:
    import requests
    resp = requests.get(url, headers=CCTe4w.VVFbRP(), timeout=4, stream=True, verify=False)
    if not resp.ok:
     FFbBGq(SELF, "Err-%d : %s" % (resp.status_code, resp.reason), title=title)
     return
    hSize = resp.headers.get("Content-Length", "")
    if hSize and hSize.isdigit():
     size = int(hSize)
     fSize = CC17eA.VVxNgx(size)
     if "vnd.apple" in resp.headers.get("content-type", ""):
      fSize += FFKrMM(" (M3U/M3U8 File)", VV0p9P)
    else:
     fSize = "No info. from server. Try again later."
    resumable = "Yes" if CClaHD.VVRXW0(resp) else "No"
   except requests.Timeout as e: err = "Connection Timeout"
   except      : err = "Connection Error"
  else:
   err = "Not a Movie/Series !"
  def VVPiNc(subj, val):
   return "%s\n%s\n\n" % (FFKrMM("%s:" % subj, VVk4x7), val)
  title = "File Size"
  txt  = VVPiNc(title , fSize or "?")
  txt += VVPiNc("Name" , VVUwmk)
  txt += VVPiNc("URL" , url)
  if resumable: txt += VVPiNc("Supports Download-Resume", resumable)
  if err  : txt += FFKrMM("Error:\n", VVdLWL) + err
  FFSMJz(SELF, txt, title=title)
 @staticmethod
 def VVTeST(SELF):
  fPath, fDir, fName = CC17eA.VVNGSU(SELF)
  if fPath:
   fPic = ""
   fNameNoExt, fExt = os.path.splitext(fName)
   for ext in ("png", "jpg", "bmp", "gif", "jpe", "jpeg"):
    pic = "%s%s.%s" % (fDir, fNameNoExt, ext)
    if FFKbVo(pic):
     fPic = pic
     break
   return fPath, fDir, fName, fPic
  else:
   return "", "", "", ""
 @staticmethod
 def VV4mAF(path, maxW=132):
  return FFQWwc("ffmpeg -y -i '%s' -vf scale=-1:%d '%s'" % (path, maxW, path))
 @staticmethod
 def VVQUv3(VVq9SN):
  VVq9SN = CCpebE.VVVRNj(VVq9SN)
  if VVq9SN : return CCRGqC.VV5G3P() + VVq9SN.replace(":", "_").upper() + ".png"
  else  : return ""
 @staticmethod
 def VVVRNj(VVq9SN):
  span = iSearch(r"^((?:[a-f0-9]+:){9}(?:[a-f0-9]+))", VVq9SN, IGNORECASE)
  return span.group(1).upper() if span else ""
 @staticmethod
 def VVcJv3(url):
  if not FFKeSw(url):
   span = iSearch(r"(?:[A-Fa-f0-9]+[:]){10}(.+)", url, IGNORECASE)
   if span:
    url = span.group(1)
   if not VVSm4H:
    url = iSub(r"[&?]mode=.+end=", "", url, flags=IGNORECASE)
  return FF5ov5(url)
 @staticmethod
 def VVLKHh(VVq9SN, showUrl=True):
  VVq9SN, VVadS0, VVjgtq, VVVmGQ = CCZv30.VVXF8h(VVq9SN)
  if VVadS0:
   txt = "Reference\t: %s\n" % VVq9SN
   p = CCr0nV()
   valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVjhBj(VVadS0)
   if valid:
    txt += "Portal Host\t: %s\n" % host
    txt += "Portal MAC\t: %s\n"  % mac
    txt += "Portal Mode\t: %s\n" % {"itv":"Live", "vod":"VOD", "series":"Series"}.get(mode, "?")
   if showUrl:
    txt += "\n"
    txt += FFKrMM("URL:", VV1l75) + "\n%s\n" % CCpebE.VVcJv3(VVadS0)
  else:
   txt = "\n"
   txt += FFKrMM("Reference:", VV1l75) + "\n%s\n" % VVq9SN
  return txt
 @staticmethod
 def VV1v7b(SELF, **kwargs):
  cbFnc = kwargs.pop("cbFnc", None)
  SELF.session.openWithCallback(cbFnc, CCpebE, **kwargs)
 @staticmethod
 def VVHeuY(session):
  session.open(CCpebE, VV6tGM=CCpebE.VVbdzi)
 @staticmethod
 def VVG8GI():
  try: return len(InfoBar.instance.getCurrentServiceSubtitle().getSubtitleList())
  except: return -1
 @staticmethod
 def VVRgsO():
  try: lst = InfoBar.instance.getCurrentServiceSubtitle().getSubtitleList() or []
  except: lst = []
  tEmb = tFil = 0
  for item in lst:
   if len(item) >= 5:
    typ, src = item[0], item[2]
    if  typ == 0: tEmb += 1
    elif typ == 1: tEmb += 1
    elif typ == 2:
     if  src == 1  : tEmb += 1
     elif 2 <= src <= 6 : tFil += 1
  if   tEmb and not tFil : return 1
  if   tFil and not tEmb : return 2
  elif tFil and tEmb  : return 3
  else     : return 0
 @staticmethod
 def VVJKB2(session):
  try: return session.nav.getCurrentService().audioTracks().getNumberOfTracks() or 0
  except: return -1
 @staticmethod
 def VV7pIH(info):
  if info:
   aspect = FFbhVV(info, iServiceInformation.sAspect)
   if aspect.isdigit():
    aspect = int(aspect)
    if aspect in ( 1, 2, 5, 6, 9, 0xA, 0xD, 0xE ) : return "4:3"
    else           : return "16:9"
  return ""
 @staticmethod
 def VVBoCX(info):
  w = FFbhVV(info, iServiceInformation.sVideoWidth)
  h = FFbhVV(info, iServiceInformation.sVideoHeight)
  if w and h and (w, h) != ("0", "0") : return "%s x %s" % (w, h)
  else        : return ""
class CCr0nV():
 def __init__(self):
  self.VVJAdE()
  self.VVyNVX    = ""
  self.VVTuxb   = "#f#11ffffaa#User"
  self.VV12Wl   = "#f#11aaffff#Server"
  self.portal_firstResponse = {}
  self.portal_latestResponse = {}
 def VVJAdE(self):
  self.VVy9Fm   = ""
  self.VVfHA5    = ""
  self.VVruLM   = ""
  self.VVIav8 = ""
  self.VV6Dbe  = ""
  self.VV875P = 0
 def VVLiCA(self, url, mac, ph1="", VVAdNn=True):
  self.VVJAdE()
  self.VVyNVX = {"s": "/server/load.php", "p": "/portal.php", "q": "/portal1.php"}.get(ph1, "")
  host = self.VVqojZ(url)
  if not host:
   if VVAdNn:
    self.VVJf3H("Incorrect URL Format !\n\n%s" % url)
   return False
  mac = self.VVfyrR(mac)
  if not host:
   if VVAdNn:
    self.VVJf3H("Incorrect MAC Format !\n\n%s" % mac)
   return False
  self.VVy9Fm = host
  self.VVfHA5  = mac
  return True
 def VVvJwJ(self):
  return {"/server/load.php":"s", "/portal.php":"p", "/portal1.php":"q"}.get(self.VVyNVX, "")
 def VVqojZ(self, url):
  if url.endswith("mac=") : url = url[:-4]
  if url.endswith("mac") : url = url[:-3]
  url = url.rstrip("/?")
  if url.endswith("/c") : url = url[:-2]
  url = url.rstrip("/ :")
  span = iSearch(r"(.+)(\/playlist.+mac)", url, IGNORECASE)
  if span:
   url = span.group(1)
  return url
 def VVfyrR(self, mac):
  span = iSearch(r"((?:[A-Fa-f0-9]{2}:){5}[A-Fa-f0-9]{2})", mac, IGNORECASE)
  if span : return span.group(1).upper()
  else : return ""
 def VV1phT(self):
  h = self.portal_firstResponse.get("resHeaders", "")
  if h: return h.get("Server", "")
  else: return ""
 def VVRYqT(self):
  res, err = self.VVgit8(self.VVCANs())
  self.portal_firstResponse = self.portal_latestResponse
  if "403" in err or "404" in err or res and res.status_code == 200 and not res.text.strip():
   if self.VVy9Fm.endswith("/c"):
    self.VVy9Fm = self.VVy9Fm[:-2]
    res, err = self.VVgit8(self.VVCANs())
   elif self.VVy9Fm.endswith("/stalker_portal"):
    self.VVy9Fm = self.VVy9Fm[:-15]
    res, err = self.VVgit8(self.VVCANs())
   else:
    self.VVy9Fm += "/c"
    res, err = self.VVgit8(self.VVCANs())
  token = rand = ""
  if not err:
   try:
    tDict = jLoads(res.text)
    token = FFSlBO(tDict["js"], "token")
    rand  = FFSlBO(tDict["js"], "random")
   except:
    pass
  return token.strip(), rand.strip(), err
 def VVOnvR(self, VVAdNn=True):
  if not self.VVyNVX:
   self.VVF0lg()
  err = blkMsg = FF0onHTxt = ""
  try:
   token, rand, err = self.VVRYqT()
   if token:
    self.VVruLM = token
    self.VVIav8 = rand
    if rand:
     self.VV875P = 2
    prof, retTxt = self.VVaBNg(True)
    if prof:
     self.VV6Dbe = retTxt
     if any(x in retTxt for x in ("device_id mismatch", "old firmware")):
      self.VV875P = 3
      prof, retTxt = self.VVaBNg(False)
      if retTxt:
       self.VV6Dbe = retTxt
    return token, prof, ""
  except:
   pass
  tErr = err or "Could not get Token from server !"
  if blkMsg or FF0onHTxt:
   tErr += "\n"
   if blkMsg: tErr += "\n%s" % blkMsg
   if FF0onHTxt: tErr += "\n%s" % FF0onHTxt
  if VVAdNn:
   self.VVJf3H(tErr)
  return "", "", tErr
 def VVF0lg(self):
  try:
   import requests
   url = self.VVi62k()
   jsFile = "xpcom.common.js"
   res = requests.get("%s/stalker_portal/c/%s" % (url, jsFile), headers=CCTe4w.VVFbRP(), stream=True, timeout=2)
   if not res.ok or not "javascript" in res.headers.get("content-type"):
    res = requests.get("%s/c/%s" % (url, jsFile), headers=CCTe4w.VVFbRP(), stream=True, timeout=2)
   if res.ok and "javascript" in res.headers.get("content-type"):
    patt = ""
    for line in res.iter_lines():
     if len(line) > 500:
      continue
     elif line:
      line = str(line.decode('utf-8'))
      span = iSearch(r"\s*var\s+pattern\s*=\s*\/(.+)\/\s*;", line, IGNORECASE)
      if span:
       patt = span.group(1)
      span = iSearch(r".+ajax_loader.+'(\/.+\.php)'", line, IGNORECASE)
      if span:
       if "portal_path" in line:
        if patt.endswith(r"*\/(.)*"): url += "/c"
        else      : url += "/stalker_portal"
       self.VVy9Fm = url
       self.VVyNVX = span.group(1)
       return
  except:
   pass
  self.VVyNVX = "/server/load.php"
 def VVi62k(self):
  url = self.VVy9Fm.rstrip("/")
  if url.endswith("/c")    : url = url[:-2]
  if url.endswith("/stalker_portal") : url = url[:-15]
  if url.endswith("/c")    : url = url[:-2]
  return url
 def VV0qqk(self, url, isJsFile=False):
  import requests
  jsFile = "xpcom.common.js" if isJsFile else "version.js"
  res, err = self.VVgit8("%s/stalker_portal/c/%s" % (url, jsFile))
  if not res or not "javascript" in res.headers.get("content-type"):
   res, err = self.VVgit8("%s/c/%s" % (url, jsFile))
  if res and "javascript" in res.headers.get("content-type"):
   if isJsFile:
    return str(res.content), ""
   else:
    span = iSearch(r"var\s+ver\s*=\s*'(.+)'", res.text, IGNORECASE)
    if span:
     return span.group(1), ""
  return "", err
 def VVaBNg(self, capMac):
  res, err = self.VVgit8(self.VViaFg(capMac))
  if not err:
   try:
    tDict = jLoads(res.text)
    word = "m" + "sg"
    blkMsg = FFSlBO(tDict["js"], "block_%s" % word)
    FF0onHTxt = FFSlBO(tDict["js"], word)
    return tDict, FF0onHTxt.strip() or blkMsg.strip()
   except:
    pass
  return "", ""
 def VViaFg(self, capMac):
  param = ""
  if self.VV6Dbe or self.VVIav8:
   param = self.getMoreAuth_params(self.getMoreAuth_IDs(self.VVfHA5.upper() if capMac else self.VVfHA5.lower(), self.VVIav8))
  elif FF9fW8("bW9sLTI=") in self.VVy9Fm:
   param = self.getMoreAuth_basic(self.VVfHA5.upper())
  return self.VVoH2f() + "type=stb&JsHttpRequest=1-xml&action=get_profile" + param
 exec(FF9fW8("ZGVmIGdldE1vcmVBdXRoX3BhcmFtcyhzZWxmLCBJZCk6DQogcGFyYW0gPSAiJmF1dGhfc2Vjb25kX3N0ZXA9MSZod192ZXJzaW9uPTIuMTctSUItMDAmaHdfdmVyc2lvbl8yPTYyJnNuPSVzJmRldmljZV9pZD0lcyZkZXZpY2VfaWQyPSVzJnNpZ25hdHVyZT0lcyIgJSAoSWRbMF0sIElkWzFdLCBJZFsxXSwgSWRbMl0pDQogcmV0dXJuIHBhcmFtICsgJyZ2ZXI9UGxheWVyIEVuZ2luZSB2ZXJzaW9uOiAweDU4YyZtZXRyaWNzPXsibWFjIjoiJXMiLCJzbiI6IiVzIiwidHlwZSI6IlNUQiIsIm1vZGVsIjoiTUFHMjUwIiwicmFuZG9tIjoiJXMifScgJSAoSWRbM10sIElkWzBdLCBJZFs0XSkNCmRlZiBnZXRNb3JlQXV0aF9JRHMoc2VsZiwgbSwgcik6DQogaW1wb3J0IGhhc2hsaWINCiBtYWNVdGY4ID0gbS5lbmNvZGUoJ3V0Zi04JykNCiBzID0gaGFzaGxpYi5tZDUobWFjVXRmOCkuaGV4ZGlnZXN0KCkudXBwZXIoKVs6MTNdDQogcmV0dXJuIHMsIGhhc2hsaWIuc2hhMjU2KG1hY1V0ZjgpLmhleGRpZ2VzdCgpLnVwcGVyKCksIGhhc2hsaWIuc2hhMjU2KChzICsgbSkuZW5jb2RlKCd1dGYtOCcpKS5oZXhkaWdlc3QoKS51cHBlcigpLCBtLCBy"))
 exec(FF9fW8("ZGVmIGdldE1vcmVBdXRoX2Jhc2ljKHNlbGYsIG0pOiByZXR1cm4gJyZod192ZXJzaW9uPTEuNy1CRC0wMCZtZXRyaWNzPXsibWFjIjoiJXMiLCJzbiI6IiVzIiwibW9kZWwiOiJNQUcyNTAiLCJ0eXBlIjoiU1RCIn0nICUgKG0sIGhhc2hsaWIubWQ1KG0uZW5jb2RlKCd1dGYtOCcpKS5oZXhkaWdlc3QoKS51cHBlcigpWzoxM10p"))
 def VVaTZG(self, forceMoreInfo=False):
  rows = []
  if not forceMoreInfo:
   rows = self.VVpdIr()
  if len(rows) < 10:
   rows = self.VVv5Mn()
  if not rows or len(rows[0]) == 2:
   rows.append(("Host"    , self.VVy9Fm ))
   rows.append(("MAC (from URL)" , self.VVfHA5 ))
   rows.append(("Token"   , self.VVruLM ))
   rows.sort(key=lambda x: x[0].lower())
   return rows, 2
  else:
   rows.append(("1", self.VVTuxb  , "MAC" , self.VVfHA5 ))
   rows.append(("2", self.VV12Wl, "Host" , self.VVy9Fm ))
   rows.append(("2", self.VV12Wl, "Token" , self.VVruLM ))
   rows.sort(key=lambda x: (x[0], x[2]))
   return rows, 4
 def VVpdIr(self):
  p, pUrl, pUrlAcc, pUrlDnld, pHost, pUser, pPass, err = CCr0nV.VVGc5K(host=self.VVy9Fm, mac=self.VVfHA5)
  rows = []
  if pUrlAcc:
   res, err = self.VVgit8(pUrlAcc)
   if not err:
    try:
     tDict = jLoads(res.text)
     for key, val in tDict["user_info"].items() :
      if any(x in key for x in ("exp_date", "created_at")): val = FFG6of(int(val))
      if isinstance(val, list): val = str(" , ".join(val))
      else     : val = str(val)
      rows.append(("1", self.VVTuxb, str(key).replace("_", " ").title(), val))
     for key, val in tDict["server_info"].items():
      if "timestamp_now"  in key : val = FFG6of(int(val))
      else      : val = str(val)
      rows.append(("2", self.VV12Wl, str(key).replace("_", " ").title(), val))
    except:
     pass
  return rows
 def VVv5Mn(self):
  token, profile, tErr = self.VVOnvR()
  try:
   item = profile["js"]
  except:
   return []
  if not isinstance(item, dict):
   return []
  rows = []
  c  = "#f#11ffff55#"
  rows = []
  for key, val in item.items():
   if not val:
    continue
   try:
    if key == "mac":
     if val and FFvVUT(val): val = FF9fW8(val.decode("UTF-8"))
     else     : val = self.VVfHA5
    elif key == "play_token":
     parts = val.split(":")
     if len(parts) == 3:
      pToken = parts[0]
      started = FFG6of(int(parts[1]))
      if parts[2] : ends = FFG6of(int(parts[1]) + int(parts[2]))
      else  : ends = ""
      val = "%s (%s ... %s)" % (pToken, started, ends)
    elif key == "aspect":
     val = " , ".join(["%s=%s" % (k, v) for k, v in jLoads(val)["js"].items()])
    elif key in ("created", "last_watchdog"):
     val = FFG6of(int(val))
    elif isinstance(val, list):
     val = str(" , ".join(val))
    elif isinstance(val, dict):
     val = str(val).replace("u'", "").replace("'", "").strip("{} ")
    else:
     val = str(val).strip()
   except:
    val = str(val)
   rows.append(((str(key).replace("_", " ").title(), str(val))))
  return rows
 def VVNaCw(self, mode, chCm, epNum, epId):
  token, profile, tErr = self.VVOnvR(VVAdNn=False)
  if not token:
   return ""
  crLinkUrl = self.VVHItC(mode, chCm, epNum, epId)
  res, err = self.VVgit8(crLinkUrl)
  chUrl = ""
  if not err:
   try: chUrl = FFSlBO(jLoads(res.text)['js'], "cmd")
   except: pass
  chUrl = chUrl.replace("\t", "")
  if " " in chUrl:
   chUrl = chUrl.split(" ")[1].strip(" _")
  chUrl = chUrl.replace(":", "%3a")
  return chUrl
 def VVoH2f(self):
  return self.VVy9Fm + self.VVyNVX + "?"
 def VVCANs(self):
  return self.VVoH2f() + "type=stb&action=handshake&JsHttpRequest=1-xml&token="
 def VV1CxE(self, mode):
  url = self.VVoH2f() + "type=%s&JsHttpRequest=1-xml&action=" % mode
  if   mode == "itv"  : url += "get_genres"
  elif mode == "vod"  : url += "get_categories&force_ch_link_check="
  elif mode == "series": url += "get_categories"
  return url
 def VVTKvN(self, catID):
  return self.VVoH2f() + "type=series&action=get_ordered_list&sortby=added&movie_id=%s&p=1" % catID
 def VVfk6b(self, mode, catID, page):
  url = self.VVoH2f() + "type=%s&JsHttpRequest=1-xml&action=get_ordered_list&sortby=number&p=%d&" % (mode, page)
  if mode == "itv": url += "genre=%s" % catID
  else   : url += "category=%s&force_ch_link_check=" % catID
  return url
 def VVIy07(self, mode, searVVUwmk, catId, page):
  catId = ("&category=%s" % catId) if catId else ""
  return self.VVoH2f() + "type=%s&JsHttpRequest=1-xml&action=get_ordered_list&search=%s&%s&p=%d" % (mode, searVVUwmk, catId, page)
 def VVgPkn(self, stID):
  return self.VVoH2f() + "type=itv&JsHttpRequest=1-xml&action=get_short_epg&ch_id=%s" % stID
 def VVHItC(self, mode, chCm, serCode, serId):
  url = self.VVoH2f() + "action=create_link&"
  if mode == "series" : url += "type=vod&series=%s&JsHttpRequest=1-xml&cmd=/media/%s.mpg" % (serCode, serId)
  else    : url += "type=%s&cmd=%s&JsHttpRequest=1-xml&forced_storage=0&disable_ad=0&download=0" % (mode, chCm)
  return url
 def VVfH1x(self):
  return self.VVoH2f() + "type=itv&JsHttpRequest=1-xml&action=create_link"
 def VVaJI6(self, host, mac, mode, VVUwmk, catID, stID, chNum, chCm, serCode, serId):
  VVq9SN = self.VVzrYF(catID, stID, chNum)
  query = self.VVZ0Kz(mode, self.VVvJwJ(), FFaC9A(host), FFaC9A(mac), serCode, serId, chCm, catID, stID)
  if   chCm.endswith(".m3u8") : chUrl = "%s?%s" % (chCm, query)
  elif "deviceMac=" in chCm : chUrl = "%s?%s" % (chCm, query)
  else      : chUrl = "%s/j.php?%s" % (host, query)
  chUrl = VVq9SN + chUrl.replace(":", "%3a") + ":" + VVUwmk
  return VVq9SN, chUrl
 def VVZ0Kz(self, mode, ph1, host, mac, serCode, serId, chCm, catID, stID):
  query = "mode=%s&ph1=%s&hst=%s&chCode=%s&epNum=%s&epId=%s&cId=%s&sId=%s&chCm=%s&end=" % (mode, ph1, host, mac, serCode, serId, catID, stID, chCm)
  return query.replace("ffmpeg ", "").replace(":", "%3a")
 def VVjhBj(self, url):
  if   "mode=itv"  in url: mode = "itv"
  elif "mode=vod"  in url: mode = "vod"
  elif "mode=series" in url: mode = "series"
  else       : return False, "", "", "", "", "", "", "", "", "", "", ""
  res  = iUrlparse(url)
  scheme = res.scheme
  netloc = res.netloc
  tDict = iUrlparse_qs(res.query)
  ph1  = tDict.get("ph1" , [""])[0].strip()
  host = tDict.get("hst" , [""])[0].strip()
  mac  = tDict.get("chCode", [""])[0].strip()
  epNum = tDict.get("epNum" , [""])[0].strip().replace(":" , "%3a")
  epId = tDict.get("epId" , [""])[0].strip().replace(":" , "%3a")
  chCm = tDict.get("chCm" , [""])[0].strip().replace("ffmpeg ", "").replace(":" , "%3a")
  catID = tDict.get("cId" , [""])[0].strip()
  stID = tDict.get("sId" , [""])[0].strip()
  span = iSearch(r"chCm=(.+)&end=", url, IGNORECASE)
  if span: chCm = span.group(1)
  query = self.VVZ0Kz(mode, ph1, host, mac, epNum, epId, FFTnsB(chCm), catID, stID)
  if scheme: scheme += "://"
  playHost = scheme + netloc
  host  = FF9fW8(host)
  mac   = FF9fW8(mac)
  valid = False
  if self.VVqojZ(playHost) and self.VVqojZ(host) and self.VVqojZ(mac):
   if (mode in ("itv", "vod") and chCm) or (mode == "series" and epNum and epId):
    valid = True
  return valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query
 def VVntPA(self, url):
  return iSub(r"[&?]mode=.+end=", "", url, flags=IGNORECASE)
 def VVgit8(self, url, useCookies=True):
  self.portal_latestResponse = {"url": url, "resErr": ""}
  try: import requests
  except: return "", 'The "Requests" library is not installed'
  err = ""
  crErr = False
  try:
   headers = CCTe4w.VVFbRP()
   if self.VVruLM:
    headers["Authorization"] = "Bearer %s" % self.VVruLM
   self.portal_latestResponse["headers"] = headers
   if useCookies : cookies = {"mac": self.VVfHA5, "stb_lang": "en"}
   else   : cookies = None
   self.portal_latestResponse["cookies"] = cookies
   res = requests.get(url, headers=headers, allow_redirects=True, timeout=CFG.portalConnTimeout.getValue(), cookies=cookies)
   self.portal_latestResponse["resHeaders"] = res.headers
   self.portal_latestResponse["resErrCode"] = res.status_code
   if res.ok:
    return res, ""
   else:
    if res.status_code == 407: reason = "Proxy Authentication Required"
    if res.status_code == 423: reason = "Access Locked"
    if res.status_code == 521: reason = "Server Is Down"
    else      : reason = "Unknown"
    err = "Err-%d : %s" % (res.status_code, res.reason or reason)
  except requests.Timeout as e  : crErr, err = True, "Connection Timeout"
  except requests.ConnectionError as e: crErr, err = True, "Connection Error"
  except Exception as e    : crErr, err = True, "Error\n" + str(e)[:120]
  self.portal_latestResponse["resErr"] = err
  self.portal_latestResponse["resCritical"] = crErr
  return "", err
 @staticmethod
 def VVyFjr(url, extraHeaders=None, cookies=None, timeout=3, verify=False):
  resp, txt, err = None, "", ""
  try:
   import requests
   headers = CCTe4w.VVFbRP()
   if extraHeaders: headers.update(extraHeaders)
   resp = requests.get(url, headers=headers, allow_redirects=True, timeout=timeout, cookies=cookies, verify=verify)
   if resp.ok : txt = str(resp.text)
   else  : err = "Error %d\n\n%s" % (resp.status_code, resp.reason)
  except:
   err = "Error while contacting server !"
  return resp, txt, err
 def VVJf3H(self, err, title="Portal Browser"):
  FFbBGq(self, str(err), title=title)
 def VV2bkQ(self, mode):
  if   mode in ("itv"  , CCTe4w.VVqyuy , CCTe4w.VV9a1K)  : return "Live"
  elif mode in ("vod"  , CCTe4w.VVdqLS , CCTe4w.VVciGe)  : return "VOD"
  elif mode in ("series" , CCTe4w.VVeQf7 , CCTe4w.VV2SEW) : return "Series"
  else                          : return "IPTV"
 def VVHNUV(self, mode, searVVUwmk):
  return 'Find in %s : %s' % (self.VV2bkQ(mode), FFKrMM(searVVUwmk, VV0p9P))
 def VVHwpV(self, catchup=False):
  VV9cxb = []
  VV9cxb.append(("Live"    , "live"  ))
  VV9cxb.append(("VOD"    , "vod"   ))
  VV9cxb.append(("Series"   , "series"  ))
  if catchup:
   VV9cxb.append(VVbM5H)
   VV9cxb.append(("Catch-up TV" , "catchup"  ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Account Info." , "accountInfo" ))
  return VV9cxb
 @staticmethod
 def VVk0Jq(VVadS0):
  p = CCr0nV()
  valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVjhBj(VVadS0)
  if valid and chCm:
   if   mode == "itv"  : patt = r'.+ch\/(\d+)_'
   elif mode == "vod"  : patt = r'stream_id":"*(\d+)'
   elif mode == "series": patt = r'series_id":"*(\d+)'
   span = iSearch(patt, FF9fW8(chCm), IGNORECASE)
   if span:
    return span.group(1)
  return ""
 @staticmethod
 def VVULQ1(VVadS0):
  p = CCr0nV()
  valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVjhBj(VVadS0)
  if valid:
   if CCr0nV.VVczC3(chCm):
    return FF5ov5(chCm)
   else:
    ok = p.VVLiCA(host, mac, ph1, VVAdNn=False)
    if ok:
     try:
      chUrl = p.VVNaCw(mode, chCm, epNum, epId)
      return FF5ov5(chUrl)
     except:
      pass
  return ""
 @staticmethod
 def VVczC3(chCm):
  return chCm.startswith("http") and not "//localhost/" in chCm
 @staticmethod
 def VVHzpJ(VVadS0):
  if not "chCode" in VVadS0: return None, "Not Portal"
  p = CCr0nV()
  valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVjhBj(VVadS0)
  if not valid: return None, "Invalid URL"
  return CCr0nV.VVqtPI(host, mac, ph1)
 @staticmethod
 def VVqtPI(host, mac, ph1=""):
  p = CCr0nV()
  if not p.VVLiCA(host, mac, ph1=ph1, VVAdNn=False): return None, "Invalid Host/MAC"
  token, profile, tErr = p.VVOnvR(VVAdNn=False)
  if not token: return None, tErr
  return p, ""
 @staticmethod
 def VVGc5K(VVadS0="", host="", mac="", ph1=""):
  pUrl = pUrlAcc = pUrlDnld = pHost = pUser = pPass = err = ""
  if   VVadS0  : p, err = CCr0nV.VVHzpJ(VVadS0)
  elif host and mac : p, err = CCr0nV.VVqtPI(host, mac, ph1=ph1)
  else    : p, err = None, "Incorrect fnc params"
  if err:
   return p, pUrl, pUrlAcc, pUrlDnld, pHost, pUser, pPass, err
  url = p.VVfH1x()
  res, err = p.VVgit8(url)
  try: cmd = FFSlBO(jLoads(res.text)["js"], "cmd")
  except: return p, pUrl, pUrlAcc, pUrlDnld, pHost, pUser, pPass, err
  cmd = cmd.replace("\t", "")
  span = iSearch(r"(http.+)\/(.+)\/(.+)(\/\?.+)", cmd)
  if span:
   pHost = span.group(1)
   pUser = FFTnsB(span.group(2))
   pPass = FFTnsB(span.group(3))
   pUrl = "%s/%s/%s/" % (pHost, pUser, pPass)
   pUrlAcc = "%s/player_api.php?username=%s&password=%s" % (pHost, pUser, pPass)
   pUrlDnld= "%s/get.php?username=%s&password=%s&type=m3u" % (pHost, pUser, pPass)
  else:
   err = "Not found"
  return p, pUrl, pUrlAcc, pUrlDnld, pHost, pUser, pPass, err
class CCzLyd(CCr0nV):
 def __init__(self):
  CCr0nV.__init__(self)
  self.mode   = ""
  self.VVq9SN  = ""
  self.VVUwmk   = ""
  self.VVVmGQ  = ""
  self.chCm   = ""
  self.epNum   = ""
  self.epId   = ""
  self.query   = ""
 def VVRHrB(self, VVq9SN, VVUwmk, VVadS0, VVVmGQ):
  valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = self.VVjhBj(VVadS0)
  if valid:
   if self.VVLiCA(host, mac, ph1, VVAdNn=False):
    self.mode  = mode
    self.VVq9SN = VVq9SN
    self.VVUwmk  = VVUwmk
    self.VVVmGQ = VVVmGQ
    self.chCm  = chCm
    self.epNum  = epNum
    self.epId  = epId
    self.query  = query
    return True
  return False
 def VVj7dt(self, session):
  chUrl = ""
  try:
   if self.chCm.startswith("Zz1"):
    self.chCm = FF9fW8(self.chCm[3:])
   else:
    chUrl = self.VVNaCw(self.mode, self.chCm, self.epNum, self.epId)
  except:
   return False
  if CCr0nV.VVczC3(self.chCm) and ("get_download_link" in chUrl or not chUrl):
   chUrl = FF5ov5(self.chCm)
   chUrl = FFTnsB(self.chCm)
   chUrl = chUrl.replace("%253a", "%3a")
   if not "?" in chUrl:
    chUrl += "?"
  elif " " in self.chCm or " " in chUrl:
   if " " in chUrl:
    chUrl = chUrl.split(" ")[1]
   if not "?" in chUrl:
    chUrl += "?"
  if not chUrl.startswith("http"):
   return False
  if not self.VVq9SN.endswith(":"):
   self.VVq9SN += ":"
  chUrl = chUrl.strip()
  chUrl = self.VVq9SN + chUrl + ":" + self.VVUwmk
  newIptvRef = self.VV6W7a(chUrl, self.VVUwmk)
  bPath = CC8i1k.VVPik6()
  if newIptvRef:
   newIptvRef1 = newIptvRef
   if CFG.simplePortal.getValue():
    newIptvRef1 = self.VVntPA(newIptvRef)
   FF9SoI(session, newIptvRef1)
   if self.VVVmGQ and newIptvRef and bPath:
    serv = eServiceReference(newIptvRef)
    newCode = serv and serv.toString()
    if newCode:
     self.VVNN83(self.VVVmGQ, newCode, bPath)
   return True
  else:
   return False
 def VV6W7a(self, chUrl, VVUwmk):
  newIptvRef = ""
  playMarks = ("play_token=", "/play/", "lid=")
  for toFind in playMarks:
   if toFind in chUrl:
    ndx = chUrl.find(toFind)
    if ndx > -1:
     ndx = chUrl.find(":", ndx)
     if ndx > -1:
      left  = chUrl[:ndx]
      right  = chUrl[ndx:]
      newIptvRef = left + "&" + self.query + right
    break
  if not newIptvRef:
   x1 = chUrl.find("?")
   if x1 > -1:
    x2 = chUrl[x1:].find(":")
    if x2 > -1:
     newIptvRef = chUrl[:x1+x2] + "&" + self.query + chUrl[x1+x2:]
  if not newIptvRef and VVUwmk:
   VVUwmk = ":" + VVUwmk
   if chUrl.endswith(VVUwmk):
    newIptvRef = chUrl[:-len(VVUwmk)].rstrip("?&") + "&" + self.query + VVUwmk
  return newIptvRef
 def VVNN83(self, oldCode, newCode, bPath):
  patt = r"((?:[A-Fa-f0-9]+[:]){10}).+(mode=.+)chCm="
  span = iSearch(patt, newCode, IGNORECASE)
  if span:
   newRef, newPar = span.group(1).upper(), span.group(2)
   params = ("ph1", "cId", "sId")
   for par in params:
    newPar = iSub(r"&%s=.*?&" % par, "&", newPar)
   span = iSearch(r"(sId=.+?)&", oldCode)
   sidTxt = span.group(1) if span else ""
   lines = FF2kXa(bPath)
   for ndx, line in enumerate(lines):
    span = iSearch(patt, line, IGNORECASE)
    if span and sidTxt in line:
     fileRef, filePar = span.group(1).upper(), span.group(2)
     if newRef == fileRef:
      for par in params:
       filePar = iSub(r"&%s=.*?&" % par, "&", filePar)
      if newPar == filePar:
       lines[ndx] = "#SERVICE %s" % newCode
       with open(bPath, "w") as f: f.write("\n".join(lines) + "\n")
       FFANYL()
class CCnaRX(Screen):
 def __init__(self, session):
  self.skin, self.VVmNvK = FFQaOH(VV7rcW, 510, 510, 30, 0, 0, "#ff000000", "#ff000000", 30, VVNLQc=False)
  self.session  = session
  self.Title   = "Movies Resume History"
  self.tbl   = None
  self.VVd3gL = 0
  FFNhKZ(self)
  self.onShown.append(self.VVf1Ra)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  self.VVykOg()
 @FFJRPn()
 def VVykOg(self):
  path, lst, err = CCnaRX.VVqFJV()
  if not lst:
   FFbBGq(self, "No resume points.", title=self.Title)
   self.cancel()
   return
  fName, fTxt, VVUwmk, VVZWTf = CCZ3EO.VVNS7h(self.session)
  self.VVd3gL = grnB = 0
  rows = []
  for fName1 in lst:
   d = CCZ3EO.VV1fKj(path + fName1)
   if d:
    if fName == fName1 : c, grnB = "#f#0022ff22#", 1
    else    : c = ""
    prog = str(int(round(100.0 * d["pos"] / d["dur"])))
    rows.append((c + d["nm"], c + FFrTEd(d["dur"] / 90000.0), c + FFrTEd(d["pos"] / 90000.0), "", prog, c + FFG6of(d["w"]), fName1, d["u"], d["r"]))
   else:
    self.VVd3gL += 1
  if self.tbl:
   self.tbl.VVEEBV(rows)
  elif rows:
   settTxt = FFKrMM("Settings : ", VV0p9P) + (FFKrMM(CFG.resumeMovies.getText(), VVPI2q if CFG.resumeMovies.getValue() == "off" else VVWH8U))
   rows.sort(key=lambda x: x[0][12:].lower() if iMatch(r"^\s*#(f|b)#[a-fA-F0-9]{8}#", x[0]) else x[0].lower())
   bg = "#1a111020"
   VVYdyj = (3, 4, 80, 20)
   VVpW7I = self.cancel
   VVDPcX = (""  , BF(self.VVP3iU, False), [])
   VVj7lw  = ("Play" , self.VVOECY     , [])
   VVmolf = (""  , self.VVIgcO    , [])
   VVwqVu = ("Current", BF(self.VVP3iU, True) , [])
   VV46TD = ("Options", self.VVRMyg    , [])
   header  = ("Name" , "Duration", "Resume" , "Pos %" , "Pos %" , "Watched" , "File", "Source" , "ref" )
   widths  = (46  , 12  , 12  , 7   , 0.03  , 23  , 0.01 , 0.01  , 0  )
   VV4Uoc = (LEFT  , CENTER , CENTER , CENTER , CENTER , CENTER , LEFT , LEFT  , LEFT )
   self.tbl = FFCXsL(self, None, title=self.Title, VVEk4e=settTxt, header=header, VVXpNQ=rows, VV4Uoc=VV4Uoc, width=1600, height=900, VV8boH=widths, VVPYL1=27, VVYdyj=VVYdyj, VVDPcX=VVDPcX, VVj7lw=VVj7lw, VVpW7I=VVpW7I, VVmolf=VVmolf, VVwqVu=VVwqVu, VV46TD=VV46TD
        , VVfWsQ=bg, VVB5I5=bg, VVYCun=bg, VVmErq="#06004455", VVK8UQ="#00333333", VVgSJJ="#0a332244")
  else:
   FFbBGq(self, err, title=self.Title)
   self.cancel()
  if self.tbl:
   if grnB : self.tbl.VVdqRF()
   else : self.tbl.VVQBxV()
 def cancel(self, VVAIxO=None):
  if self.tbl: self.tbl.cancel()
  self.close()
 def VVOECY(self, VVAIxO, title, txt, colList):
  CCsmqb.VVlIAT(self.session, VVinUd=False, VVNO3H=False, VVdxJv=colList[8], cbFnc=self.VVykOg)
 def VVIgcO(self, VVAIxO, title, txt, colList):
  txt = "%s\n\n%s" % (title, txt)
  VVUwmk, VVq9SN = colList[0], colList[8]
  span = iSearch(r"^((?:[a-f0-9]+:){9}(?:[a-f0-9]+))", VVq9SN.strip(), IGNORECASE)
  if span:
   VVq9SN = span.group(1)
  CCpebE.VV1v7b(self, VV6tGM=CCpebE.VVuYDw, params=(VVq9SN, VVUwmk, txt))
 def VVP3iU(self, VVAdNn, VVAIxO, title, txt, colList):
  fName, fTxt, VVUwmk, VVZWTf = CCZ3EO.VVNS7h(self.session)
  if fName:
   VVAIxO.VVSepa(6, fName, VVAdNn=VVAdNn)
 def VVRMyg(self, VVAIxO, title, txt, colList):
  isMulti = VVAIxO.VVGZGK
  rows = VVAIxO.VVdxfP()
  ok = not isMulti or isMulti and rows
  VV9cxb = []
  VV9cxb.append(FFH04v("Delete All"         , "all", not isMulti, VVdLWL))
  VV9cxb.append(FFH04v("Delete Selected Row%s" % FFaRsj(len(rows)) , "sel", ok))
  if self.VVd3gL:
   VV9cxb.append(VVbM5H)
   VV9cxb.append((VVWH8U + "Clear Unreadable Files"  , "bad"))
  params = [VVAIxO, isMulti, rows]
  cbFncDict = { "all": BF(self.VV0YeM, params + ["all"])
     , "sel": BF(self.VV0YeM, params + ["sel"])
     , "bad": BF(self.VV0YeM, params + ["bad"])
     }
  CC17aQ(self, VVAIxO, setsOk=True).VV4sFy(VV9cxb, cbFncDict, width=500)
 def VV0YeM(self, params):
  VVAIxO, isMulti, rows, item = params
  if item:
   if item == "sel":
    tot = len(rows)
    if isMulti : ques = "Delete %d Resume Point%s ?" % (tot, FFaRsj(tot))
    else  : ques = "Delete Selected Point ?"
   elif item == "all" : ques = "Delete all Resume Points ?"
   elif item == "bad" : ques = "Found %d unusable file%s that could not be added to table.\n\nDelete unusable files ?" % (self.VVd3gL, FFaRsj(self.VVd3gL))
   FF6pUe(self, BF(self.VVfYZ7, params), ques, title=self.Title)
 def VVfYZ7(self, params):
  VVAIxO, isMulti, rows, item = params
  path = CCZ3EO.VVC06L("")
  if item == "sel":
   if isMulti:
    for fName in self.tbl.VVKa9C(6):
     FFnE7j(CCZ3EO.VVC06L(fName))
   else:
    FFnE7j(CCZ3EO.VVC06L(self.tbl.VVYmuZ(6)))
   self.VVykOg()
  elif item == "all":
   for row in self.tbl.VVGpBN():
    FFnE7j(path + row[6])
   FFv2op(self.session, "Done")
   self.cancel()
  elif item == "bad":
   path, lst, err = CCnaRX.VVqFJV()
   tot = 0
   for fName in lst:
    d = CCZ3EO.VV1fKj(path + fName)
    if not d:
     FFnE7j(path + fName)
     tot += 1
   self.VVd3gL = 0
   FF0onH(self, "Deleted %d unreadable file%s." % (tot, FFaRsj(tot)) if tot else "All files are OK.", title=self.Title)
 @staticmethod
 def VVqFJV():
  path = CCZ3EO.VVC06L("")
  try:
   return path, os.listdir(path), ""
  except Exception as e:
   return path, [], str(e)
class CCZ3EO():
 def __init__(self, VVH7fa):
  self.VVk0ZB = None
  self.VVeuWz = False
  self.VVzu8A = 0
  self.VVrPjz = 0
  self.VVKLen = eTimer()
  try: self.VVKLen_conn = self.VVKLen.timeout.connect(self.VV7gaQ)
  except: self.VVKLen.callback.append(self.VV7gaQ)
  self.VVKLen.start(500, False)
  self.VVujes()
 def VVujes(self):
  path = self.VVC06L("")
  if VVkY7E(path):
   return os.path.isdir(path)
  else:
   try:
    os.makedirs(path)
    return True
   except:
    return False
 def VV7gaQ(self):
  self.VVzu8A, self.VVrPjz = CCZ3EO.VVTn13(self.VVH7fa)
  if self.VVeuWz and self.VVzu8A:
   self.VVeuWz = False
   self.VVBODX()
 def VVPu1e(self):
  self.VVeuWz = True
 def VVBODX(self):
  fName, fTxt, VVUwmk, VVZWTf = CCZ3EO.VVNS7h(self.VVH7fa)
  if not fName or self.VVk0ZB == fName:
   return
  tDict = CCZ3EO.VV1fKj(self.VVC06L(fName))
  if tDict and "pos" in tDict and "dur" in tDict:
   newPos, newDur = tDict["pos"], tDict["dur"]
   if abs(self.VVzu8A - newPos) // 90000.0 and newPos > 900000 and newPos < self.VVzu8A - 900000:
    InfoBar.instance.doSeek(int(newPos))
    InfoBar.instance.hide()
    self.VVk0ZB = fName
 def VVnPTj(self):
  self.VVk0ZB = None
  fName, fTxt, VVUwmk, VVZWTf = CCZ3EO.VVNS7h(self.VVH7fa)
  if not fName or self.VVzu8A == 0:
   return
  if abs(self.VVzu8A - self.VVrPjz) < 90000 * 2:
   FFnE7j(self.VVC06L(fName))
   return
  if self.VVrPjz > 90000 * 60 and self.VVrPjz < self.VVzu8A - 900000 and self.VVzu8A > 90000 * 60:
   self.VVujes()
   tDict = {"v":1, "nm": str(VVUwmk), "u": str(fTxt), "r": str(VVZWTf), "pos": self.VVrPjz, "dur": self.VVzu8A, "w": int(iTime())}
   try:
    import pickle
    with open(self.VVC06L(fName), 'wb') as f:
     pickle.dump(tDict, f, 2)
   except:
    pass
 @staticmethod
 def VVNS7h(session):
  s = CCZv30(session)
  fName = fTxt = ""
  conf = CFG.resumeMovies.getValue()
  if   conf in ("a", "i") and FFn8GR(s.VVadS0): pass
  elif conf in ("a", "l") and s.Path.startswith("/")   : pass
  else              : return fName, fTxt, s.VVUwmk, s.VVZWTf
  fName = FF5c8a(s.uniqueId)
  fTxt = s.userTxt
  return fName, fTxt, s.VVUwmk, s.VVZWTf
 @staticmethod
 def VV1fKj(fPath):
  try:
   import pickle
   with open(fPath, 'rb') as f:
    d = pickle.load(f)
    if all(k in d for k in ("v", "nm", "u", "r", "pos", "dur", "w")):
     d["nm"], d["u"], d["r"] = str(d["nm"]), str(d["u"]), str(d["r"])
     return d
  except:
   pass
  return None
 @staticmethod
 def VVC06L(fName):
  return "%sajpanel_resume/%s" % (FFJv8S(), fName)
 @staticmethod
 def VVTn13(session):
  serv = session.nav.getCurrentService()
  pSeek = serv and serv.seek()
  if not pSeek is None:
   durLst = pSeek.getLength()
   posLst = pSeek.getPlayPosition()
   if durLst[0] == 0 and posLst[0] == 0:
    return durLst[1], posLst[1]
  return 0, 0
class CCsyJ5(CCZ3EO):
 VVE2Uu = "START"
 VVoJfl = "INFO"
 VV3Z28 = "EOF"
 VVC5Zd = "End"
 def __init__(self, VVH7fa):
  CCZ3EO.__init__(self, VVH7fa)
  self.VVH7fa   = VVH7fa
  self.VV1pmU    = eTimer()
  self.VVakhM    = None
  self.VVZiwQ  = 0
  self.VVakzz   = ""
  self.VVv3R8   = ""
  self.lastSimulatedEOF  = ""
  self.VVh2QS   = ""
  CC73QP.VVUGUn(VV6Thi  )
  CC73QP.VVUGUn(VVDtIm)
  CC73QP.VVUGUn(VVIKra  )
  CC73QP.VVUGUn(VVTKvf  )
  try:
   from Components.ServiceEventTracker import ServiceEventTracker
   from enigma import iPlayableService
   evTrk = ServiceEventTracker(screen=self.VVH7fa.screen, eventmap={iPlayableService.evStart: self.VV0hYH, iPlayableService.evEOF: self.VVMNgJ, iPlayableService.evEnd: self.VViFon, iPlayableService.evUpdatedInfo: self.VVXEkw})
  except:
   pass
  try: self.VV1pmU_conn = self.VV1pmU.timeout.connect(self.VVLCdr)
  except: self.VV1pmU.callback.append(self.VVLCdr)
  self.VV1pmU.start(3000, False)
  self.VVLCdr()
 def VVLCdr(self):
  if not CFG.downloadMonitor.getValue():
   self.VVTQRT()
   return
  lst = CClaHD.VVwIzh()
  avPerc = []
  txt = ""
  if lst:
   for path, totSz, logF in lst:
    if totSz:
     totSz = int(totSz) if totSz.isdigit() else 0
     curSz = 0
     sz = FFLjtI(path)
     if sz > -1:
      curSz = sz
     if totSz:
      perc = (float(curSz) / float(totSz) * 100.0)
      avPerc.append(perc)
    elif logF:
     perc = CClaHD.VVDowb(logF)
     if perc > -1:
      avPerc.append(perc)
   if lst:
    txt = "Files=%d" % len(lst)
    if avPerc:
     perc = sum(avPerc) / len(avPerc)
     if perc: txt += "   %.2f %%" % perc
  if txt:
   if not self.VVakhM : self.VVakhM = CCJe5E.VV9IOS(self.VVH7fa, txt, 30)
   else    : CCJe5E.VVQVcM(self.VVakhM, txt)
  elif self.VVakhM:
   self.VVTQRT()
 def VVTQRT(self):
  if self.VVakhM:
   self.VVH7fa.deleteDialog(self.VVakhM)
   self.VVakhM = None
 def VV0hYH(self):
  self.VVZgVt(CCsyJ5.VVE2Uu)
 def VVXEkw(self):
  self.VVZgVt(CCsyJ5.VVoJfl)
  VVq9SN, VVadS0, VVVmGQ, VV1ldg = self.VVzmKR()
  self.VVh2QS = VV1ldg
  self.VVPu1e()
 def VViFon(self):
  self.VVZgVt(CCsyJ5.VVC5Zd)
  self.VVh2QS = ""
  FFdBYP(self, 1000, self.VV0xm7)
  self.VVnPTj()
 def VVMNgJ(self):
  self.VVZgVt(CCsyJ5.VV3Z28)
  if CFG.autoResetFrozenIptvChan.getValue() == "off":
   return
  VVq9SN, VVadS0, VVVmGQ, VV1ldg = self.VVzmKR()
  if not VVVmGQ or "file?file" in VVVmGQ or ":ftp%3a//" in VVVmGQ:
   return
  if iMatch(r"http.+(?:[A-Za-f0-9]+(%3a|:)){10}", VVadS0):
   return
  if self.VVv3R8 == VV1ldg and self.VVZiwQ > 0 and (iTime()- self.VVZiwQ) < 10:
   return
  if self.VVh2QS == VV1ldg:
   if CFG.autoResetFrozenIptvChan.getValue() == "on+":
    CCJe5E(self.VVH7fa, "Refreshing")
   CC2Ekb.VVIMKA(self.VVH7fa)
  elif "&end=:" in VVVmGQ:
   VVUwmk = VVVmGQ[VVVmGQ.index("&end=:") + 6:]
   pr = CCzLyd()
   if pr.VVRHrB(VVq9SN, VVUwmk, VVadS0, VVVmGQ):
    shown = InfoBar.instance.shown
    pr.VVj7dt(self.VVH7fa)
    if not shown: InfoBar.instance.hide()
  self.VVv3R8 = VV1ldg
  self.VVZiwQ = iTime()
 def VV0xm7(self):
  VVq9SN, VVadS0, VVVmGQ, VV1ldg = self.VVzmKR()
  if VVq9SN.startswith("4097:") and self.lastSimulatedEOF != VV1ldg:
   FFdBYP(self, 1000, BF(self.VVnS7t, VV1ldg))
 def VVnS7t(self, ref):
  VVq9SN, VVadS0, VVVmGQ, VV1ldg = self.VVzmKR()
  if ref == VV1ldg and self.VVakzz in (CCsyJ5.VVE2Uu, CCsyJ5.VVC5Zd):
   self.lastSimulatedEOF = VV1ldg
   self.VVMNgJ()
 def VVzmKR(self):
  s = CCZv30(self.VVH7fa)
  return s.VVq9SN, s.VVadS0, s.VVVmGQ, s.myPhp or s.VVadS0
 def VVZgVt(self, state):
  self.VVakzz = state
  global VViIgK_VAL
  VViIgK_VAL = state
class CCB02H():
 def __init__(self, SELF):
  self.SELF  = SELF
  self.Title  = "Update Current Bouquet EPG/PIcons"
  self.pPath  = CCRGqC.VV5G3P()
  self.updErr  = ""
  self.isFfmpeg = FFW91j("ffmpeg")
  self.totCh  = 0
  self.totIptv = 0
  self.totNotIptv = 0
  self.totEpgDnl = 0
  self.totPic  = 0
  self.totPicOK = 0
  self.epgLst  = []
  self.bName  = ""
  CCV3Gw.VVgWD3(SELF
      , VVuSHu  = self.VVEp5b
      , VVhK3C = self.VVIKf3)
 def VVEp5b(self, VVqeT6):
  VVqeT6.VVX5nT("Reading Services ...")
  self.bName = CC8i1k.VVW657()
  services = CC8i1k.VV2lFz()
  if not services:
   self.updErr = 'Cannot read service from: \n\n"%s"' % self.bName
   return
  elif len(services) == 0:
   self.updErr = 'No services in: \n\n"%s"' % self.bName
   return
  else:
   self.totCh = len(services)
  if not VVqeT6 or VVqeT6.isCancelled: return
  VVqeT6.VVfT17(self.totCh)
  VVqeT6.VVX5nT("Downloading ...")
  for ndx, (VVZWTf, VVUwmk) in enumerate(services):
   if not VVqeT6 or VVqeT6.isCancelled: return
   if FFC4pX(VVZWTf):
    self.totIptv += 1
    VVq9SN, VVadS0, VVjgtq, VVVmGQ = CCZv30.VVXF8h(VVZWTf)
    if not VVqeT6 or VVqeT6.isCancelled: return
    evLst = []
    epg = VVuPzU = ""
    if VVadS0:
     epg, evLst, VVuPzU, err = CCpebE.VVZlns(VVadS0)
     if VVuPzU: self.totPic += 1
    else:
     continue
    if not VVqeT6 or VVqeT6.isCancelled: return
    VVqeT6.VVVMVI(self.totEpgDnl, self.totPic)
    if not epg:
     epg, evLst, err = CCTe4w.VVQtfm(VVadS0)
    if evLst:
     self.epgLst.append((VVq9SN, evLst))
     self.totEpgDnl += len(evLst)
    if not VVqeT6 or VVqeT6.isCancelled: return
    VVqeT6.VVVMVI(self.totEpgDnl, self.totPic)
    self.totPicOK += self.VV2IlB(VVZWTf, VVuPzU)
    if not VVqeT6 or VVqeT6.isCancelled: return
    VVqeT6.VVVMVI(self.totEpgDnl, self.totPic)
   else:
    self.totNotIptv += 1
   if not VVqeT6 or VVqeT6.isCancelled: return
   VVqeT6.VVqE9L(1)
 def VVIKf3(self, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  if self.updErr:
   FFbBGq(self.SELF, self.updErr, title=self.Title)
   return
  totEpgOK = 0
  for VVq9SN, evLst in self.epgLst:
   if evLst:
    totEv, totOK = CCtAi7.VVRFU9(VVq9SN, evLst)
    totEpgOK += totOK
  if totEpgOK > 0:
   CCtAi7.VVFxed()
  tab = lambda x, y: "%s\t: %s\n" % (x, y)
  txt = ""
  txt += tab("Bouquet"  , self.bName)
  txt += "\n"
  txt += tab("Services"  , self.totCh)
  txt += tab("Processed"  , self.totIptv)
  txt += tab("Non-IPTV"  , self.totNotIptv)
  txt += "\n"
  txt += tab("Events Found" , self.totEpgDnl)
  txt += tab("Events Added" , totEpgOK)
  txt += "\n"
  txt += tab("PIcons Found" , self.totPic)
  txt += tab("PIcons Added" , self.totPicOK)
  if not VV6ZvL:
   self.Title += "  (stopped)"
  FFSMJz(self.SELF, txt, title=self.Title)
 def VV2IlB(self, VVZWTf, url):
  if not all((url, self.isFfmpeg, VVkY7E(self.pPath))):
   return 0
  path, err = FFUzwU(url, "ajp_tmp.png", timeout=2, mustBeImage=True)
  if not FFKbVo(path) or not VVkY7E(self.pPath):
   return 0
  VVq9SN = CCpebE.VVVRNj(VVZWTf)
  picon = VVq9SN.replace(":", "_") + ".png"
  cmd = CCpebE.VV4mAF(path)
  cmd += FFQWwc("mv -f '%s' '%s%s'" % (path, self.pPath, picon))
  ok = FFlonU(cmd)
  return 1 if ok else 0
class CConSF():
 def __init__(self, VV4j3C=False):
  self.VVbGi9  = CFG.hideIptvServerChannPrefix.getValue()
  self.VVYVaP  = VV4j3C or CFG.hideIptvServerAdultWords.getValue()
  self.VV1B49 = r"(b[-]*e[-]*I[-]*N)"
  self.VVnkjj  = r"beIN"
  self.VVDCs6 = iCompile( r"\s*^[A-Za-z]{2,3}\d*\s*[|:-]+\s*(.+)"
          r"|^\[.{2}\]\s*(.+\[.{2}\]\s*\[.{2,}\])"
          r"|^(?!\[)*\s*[\[(|:][ A-Za-z0-9\/\-._:|\]\[]+[\])|:](.+)"
          r"|^[A-Za-z]{,3}[^\x21-\x7E]\s(.+)")
  self.VVpNYG = self.VV7t9z(self.VVbGi9, "ajpanel_iptv_prefix", False, ())
  self.VVuQJr = self.VV7t9z(self.VVYVaP, "ajpanel_iptv_blacklist", True, ("+18","18 rated","18+","aduld","adult","adulte","adulto","aikuinen","blue film","blue movie","dirty film","dirty movie","dorosly","erotic","erwachsene","porn","r-17 film","r-17 movie","r-18 film","r-18 movie","r18 film","r18 movie","sex","skin flick","voksen","volwassen","vuxen","x-rated","xrated","xxi","xx","xvideo","xyz"))
 def VV7t9z(self, cond, fName, isLower, tSet):
  tSet = set(tSet)
  if cond:
   for path in (VVK8DT, FFJv8S()):
    path += fName
    if FFKbVo(path):
     for line in FF2kXa(path):
      line = line.strip()
      if len(line) >= 3:
       tSet.add(line.lower() if isLower else line)
  return tuple(sorted(tSet, key=lambda x: x.lower()))
 def VVYMFT(self, name,  censored=""):
  if self.VVYVaP and (censored == "1" or any(x in name.lower() for x in self.VVuQJr)):
   return ""
  name = iSub(self.VV1B49, self.VVnkjj, name, flags=IGNORECASE).strip()
  if CCTe4w.VVs8ai(name):
   return CCTe4w.VV6Gyk(name)
  return self.VVhmH6(name)
 def VVhmH6(self, name):
  newName = ""
  if self.VVbGi9:
   span = iSearch(self.VVDCs6, name)
   if span:
    tName = span.group(1) or span.group(2) or span.group(3) or span.group(4)
    if not tName.startswith(("HD", "[HD]", "SD", "[SD]")):
     newName = tName
   for t in self.VVpNYG:
    if name.startswith(t):
     newName = name[len(t):]
     break
  return newName.strip() or name
 def VVPjh3(self, name):
  name = iSub(self.VV1B49, self.VVnkjj, name, flags=IGNORECASE).strip()
  name = self.VVhmH6(name)
  return name.lower().replace(" hd", "").replace(" fm", "").replace(" 4k", "").replace(" tv", "").replace(" sd", "").strip()
 def VVoWRq(self, name):
  if self.VVYVaP and any(x in name.lower() for x in self.VVuQJr):
   return ""
  return name.strip()
 def VVJ6GT(self, wordsList):
  lst = list(map(str.lower, wordsList))
  return any(x in self.VVuQJr for x in lst)
 def VVhVMo(self):
  return 'Cannot continue with adults words !\n\n"Skip Adults Channels" is activated in settings.'
class CCsma2(CConSF):
 def __init__(self, SELF, VV4A6n, VV682V="", VVFjwO="", cbFnc=None, chkExt=False):
  self.SELF  = SELF
  self.VV4A6n = VV4A6n
  self.VV682V  = VV682V
  self.outD  = "%s%s/" % (CCGSVa.VVMhBD(), VVFjwO or os.path.basename(VV4A6n)[:-4])
  self.cbFnc  = cbFnc
  self.chkExt  = chkExt
  self.Title  = "Create Local Server"
  self.err  = ""
  self.totGrp  = 0
  self.totCh  = 0
  self.totL  = self.totLh = 0
  self.totV  = self.totVh = 0
  self.totS  = self.totSh = 0
  self.totK  = self.totKh = 0
  self.totM  = self.totMh = 0
  self.totR  = self.totRh = 0
  self.totD  = self.totDh = 0
  self.totF  = self.totFh = 0
  self.totAll  = 0
  self.lineNum = 0
  CConSF.__init__(self, VV4j3C=True)
  CCV3Gw.VVgWD3(self.SELF, VVN6I4="Checking File ...", titleBg="#22220022", bodyBg="#22220022"
      , VVuSHu  = self.VVH6Dv
      , VVhK3C = self.VVMRa6)
 def VVH6Dv(self, VVqeT6):
  if VVkY7E(self.outD):
   for f in iGlob(FF9Uvy(self.outD) + "*"):
    FFnE7j(f)
  elif not FFlonU("mkdir -p '%s'" % self.outD):
   self.err = "Cannot make directory."
   return
  par = grp = url = marker = ""
  bDict = {}
  enc, totLines = CC6ntZ.VVrBqT(self.VV4A6n)
  if not VVqeT6 or VVqeT6.isCancelled: return
  VVqeT6.VVfT17(totLines)
  with ioOpen(self.VV4A6n, "r", encoding=enc) as f:
   for line in f:
    self.lineNum += 1
    if not VVqeT6 or VVqeT6.isCancelled: return
    VVqeT6.VVqE9L(1)
    line = str(line.strip())
    if line.startswith("#EXTINF:"):
     par = line
     continue
    elif line.startswith("#EXTGRP:"):
     grp = line.partition("#EXTGRP:")[2].strip()
     continue
    elif not line.startswith("#"):
     url = line
    elif line.startswith("#EXTM3U"):
     continue
    if not (par and url):
     continue
    par = par.replace('""', '" "')
    span = iSearch(r'(?:tvg-name="(.+?)")*.+,(.+)', par, IGNORECASE)
    VVUwmk = (((span.group(1) or span.group(2))).replace(":", "|").replace("||", "|").strip() if span else "") or "No-name"
    chBlk = 0 if self.VVYMFT(VVUwmk) else 1
    span = iSearch(r'tvg-logo="(.+?)"', par, IGNORECASE)
    icn = ((span.group(1)).replace("\t", "").strip() if span else "") or "-"
    span = iSearch(r'group-title="(.+?)"', par, IGNORECASE)
    cat = (grp or (span.group(1) if span else "")).replace("\t", "").strip()
    catBlk = 1 if cat and not self.VVoWRq(cat) else 0
    val1 = catBlk or chBlk
    typ = CCGSVa.VVqRH8(url, self.chkExt)
    if   typ == "Live"  : self.totL, self.totLh = self.totL + 1, self.totLh + 1 * val1
    elif typ == "VOD"  : self.totV, self.totVh = self.totV + 1, self.totVh + 1 * val1
    elif typ == "Series" : self.totS, self.totSh = self.totS + 1, self.totSh + 1 * val1
    elif typ == "Marker" : self.totK, self.totKh = self.totK + 1, self.totKh + 1 * val1
    elif typ == "Movie"  : self.totM, self.totMh = self.totM + 1, self.totMh + 1 * val1
    elif typ == "S.Relay" : self.totR, self.totRh = self.totR + 1, self.totRh + 1 * val1
    elif typ == "DVB"  : self.totD, self.totDh = self.totD + 1, self.totDh + 1 * val1
    elif typ == "FTP"  : self.totF, self.totFh = self.totF + 1, self.totFh + 1 * val1
    cat = cat or "* Uncategorized %s Channels *" % typ
    VVqeT6.VVX5nT("Ch=%s  ( L=%s  V=%s  S=%s )" % (self.totCh, self.totL, self.totV, self.totS))
    if typ == "Marker":
     marker = "%s\t%s\t%s\n" % (url, VVUwmk, "-")
     continue
    fileId = typ + cat
    fName = FF5c8a(fileId)
    totCh = (bDict[fileId][3] + 1) if fileId in bDict else 1
    bDict[fileId] = (typ, catBlk, fName, totCh, cat)
    with open(self.outD + fName, "a") as f:
     if marker:
      f.write(marker)
      marker = ""
      self.totAll += 1
     f.write("%s\t%s\t%s\t%s\n" % (chBlk or catBlk, url, VVUwmk, icn))
     self.totCh += 1
     self.totAll += 1
    par = grp = url = ""
  self.totGrp = len(bDict)
  if bDict:
   bLst = ["\t".join((typ, str(catBlk), fName, str(totCh), cat)) for ttl, (typ, catBlk, fName, totCh, cat) in bDict.items()]
   if bLst:
    try: fmTime = int(os.path.getmtime(self.VV4A6n))
    except: fmTime = ""
    tab = lambda x, y: "#" + " %s: %s\n" % (x, y)
    with open(os.path.join(self.outD, "_main"), "w") as f:
     f.write(tab("File"  , self.VV4A6n))
     f.write(tab("Modified" , fmTime))
     f.write(tab("URL"  , self.VV682V.partition("&type")[0]))
     f.write(tab("Saved"  , FFENz0()))
     f.write(tab("Entries" , self.totAll))
     f.write(tab("Services" , self.totCh))
     f.write(tab("Live"  , self.totL))
     f.write(tab("VOD"  , self.totV))
     f.write(tab("Series" , self.totS))
     if self.totK: f.write(tab("Marker" , self.totK))
     if self.totM: f.write(tab("Movie" , self.totM))
     if self.totR: f.write(tab("S.Relay" , self.totR))
     if self.totD: f.write(tab("DVB"  , self.totD))
     if self.totF: f.write(tab("FTP"  , self.totF))
     if self.totLh: f.write(tab("Blk_Live" , self.totLh))
     if self.totVh: f.write(tab("Blk_VOD" , self.totVh))
     if self.totSh: f.write(tab("Blk_Series" , self.totSh))
     if self.totKh: f.write(tab("Blk_Marker" , self.totKh))
     if self.totMh: f.write(tab("Blk_Movie" , self.totMh))
     if self.totRh: f.write(tab("Blk_S.Relay", self.totRh))
     if self.totDh: f.write(tab("Blk_DVB" , self.totDh))
     if self.totFh: f.write(tab("Blk_FTP" , self.totFh))
     f.write("\n".join(bLst))
 def VVMRa6(self, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  mainOk = FFKbVo(os.path.join(self.outD, "_main"))
  if not VV6ZvL or not mainOk:
   FFqOnh(self.outD)
  ln = "\n\nLine Number : %s" % self.lineNum
  if   not VV6ZvL     : pass
  elif self.err      : FFbBGq(self.SELF, self.err, self.Title)
  elif threadCounter != threadTotal : FFbBGq(self.SELF, "Error in conversion process %s" % ln, self.Title)
  elif not mainOk      : FFbBGq(self.SELF, "Cannot extract channels", self.Title)
  elif self.cbFnc      : self.cbFnc(self.VV4A6n, self.outD)
  else:
   tab = lambda x, y: "%s\t: %s\n" % (x, y)
   txt  = tab("Groups", self.totGrp)
   txt += tab("Services", self.totCh)
   txt += tab("\nEntries" , self.totAll)
   txt += tab("  Live"  , self.totL)
   txt += tab("  VOD"  , self.totV)
   txt += tab("  Series" , self.totS)
   txt += tab("  Movie" , self.totM)
   txt += tab("  DVB"  , self.totD)
   txt += tab("  S.Relay" , self.totR)
   txt += tab("  FTP"  , self.totF)
   txt += tab("  Marker" , self.totK)
   txt += "\n%s\n%s" % (FFKrMM("Output File:", VVWH8U), self.outD)
   FFSMJz(self.SELF, txt, self.Title)
class CCGSVa(CConSF):
 VVg57A   = 0
 VV0wZ1  = 1
 VVauyS = 2
 VVpilh = 3
 VVl6rL  = 4
 VVLmXB   = 5
 def __init__(self, SELF, mode, url="", m3uF="", VVS4vP=None):
  self.SELF   = SELF
  self.mode   = mode
  self.VVS4vP= VVS4vP
  self.Title   = "Local Servers & M3U Cache"
  self.VVmCHr  = ""
  self.url   = ""
  self.hst   = ""
  self.usr   = ""
  self.pas   = ""
  self.VVsMdH  = ""
  self.VV1ctN   = ""
  CConSF.__init__(self)
  if not iZip:
   SELF.VVJf3H('"zipfile" Module not found !')
   return
  if   mode == CCGSVa.VVg57A   : self.VV2ME2()
  elif mode == CCGSVa.VV0wZ1  : self.VVuY4s(self.SELF, m3uF)
  elif mode == CCGSVa.VVauyS : self.VVFjmv(m3uF)
  elif mode == CCGSVa.VVpilh: self.VVZKIP(url)
  elif mode == CCGSVa.VVl6rL : self.VVZKIP(url)
  elif mode == CCGSVa.VVLmXB   : self.VVuY4s(self.SELF, m3uF)
 def VVZKIP(self, url):
  self.url = url
  self.hst, self.usr, self.pas, self.VVsMdH = CCGSVa.VV96YL(self.url)
  if not all((self.hst, self.usr, self.pas, self.VVsMdH)):
   self.VVJf3H("Cannot process URL")
   return
  VV9cxb = []
  zipFile = "%s%s.zip" % (CCGSVa.VVMhBD(), self.VVsMdH)
  if FFKbVo(zipFile):
   VV9cxb.append(("Browse Local Server"       , "brwLS"))
   VV9cxb.append(("Update Local Server"       , "updLS"))
  else:
   VV9cxb.append(("Download Resources and Browse Locally"  , "newLS"))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Download M3U - Categorized Channels  (Live=ts)" , "ful" ))
  VV9cxb.append(("Download M3U - Categorized Channels  (Live=m3u8)" , "ful8"))
  VV9cxb.append(("Download M3U - Uncategorized Channels"   , "low" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Download EPG (XML-TV File)"      , "epg" ))
  FFO9kU(self.SELF, BF(self.VVovq5, zipFile), title="Server Resources", VV9cxb=VV9cxb, width=1000, VVDkqE=True)
 def VVovq5(self, zipFile, item=""):
  if item:
   title, ref, ndx = item
   if   ref == "brwLS" : self.VVkXn6(zipFile)
   elif ref == "updLS" : FF6pUe(self.SELF, BF(self.VV9p6p, title, "newLS"), 'Update Local Cache ?\n\n"%s"' % self.VVsMdH, title=self.Title)
   else    : self.VV9p6p(title, ref)
 def VV9p6p(self, title, ref):
  if ref == "epg" : ext, php, fNm, typ = "xml", "xmltv", "epg"  , ""
  else   : ext, php, fNm, typ = "m3u", "get"  , "channels_" , "&type=m3u"
  if ref in ("newLS", "ful", "ful8"): typ += "_plus"
  if ref == "ful8": typ += "&output=m3u8"
  url = "%s/%s.php?username=%s&password=%s%s" % (self.hst, php, self.usr, self.pas, typ)
  if   ref == "epg": pass
  elif ref == "low": fNm += "uncat"
  else    : fNm += "grouped_" + ("m3u8" if ref == "ful8" else "ts")
  fName = "%s_%s_%s.%s" % (iUrlparse(self.hst).hostname, fNm, FFRIlf(), ext)
  cbFnc = self.VVuSAo if ref == "newLS" else None
  timeout = 90
  CCfPHj(self.SELF, url, os.path.join(FFJv8S(), fName), title=self.Title, pbTxt="Preparing file in server ...", cbFnc=cbFnc, timeout=timeout)
 def VVuSAo(self, ok, url, webFile, path):
  if ok:
   VVGKHT = iUrlparse(url).hostname
   cbFnc = BF(self.VVxUd7, True)
   CCsma2(self.SELF, VV4A6n=path, VV682V=url, VVFjwO=VVGKHT, cbFnc=cbFnc)
  else:
   FFnE7j(path)
 def VVFjmv(self, path):
  m3File, m3Dir, VV0Dqv, zPath, zFound = CCGSVa.VV4vqh(path)
  cbFnc = BF(self.VVxUd7, False)
  CCsma2(self.SELF, VV4A6n=path, VVFjwO=VV0Dqv, cbFnc=cbFnc)
 def VVxUd7(self, delSrc, path, outD):
  if VVkY7E(outD):
   if delSrc : FFnE7j(path)
   VV107U = outD.rstrip("/") + ".zip"
   CCGSVa.VVvYm7(self.SELF, outD, VV107U, cbFnc=BF(self.VVs5QR, outD))
 def VVs5QR(self, outD, VV107U, tot, err):
  FFqOnh(outD)
  if   tot: self.VVkXn6(VV107U)
  elif err: self.VVJf3H(err)
  else : self.VVJf3H("No files to compress !")
 @FFJRPn("Checking File Encoding ...", par=1)
 def VVuY4s(self, SELF, path):
  if not self.VVkeB4(path):
   m3File, m3Dir, VV0Dqv, zPath, zFound = CCGSVa.VV4vqh(path)
   if zFound: self.VVkXn6(zPath)
   else  : self.VVFjmv(path)
 def VVkeB4(self, path):
  if FFLjtI(path) > pow(10, 4):
   return False
  m3u8 = False
  lst = []
  par = url = ""
  try:
   enc = CC6ntZ.VVC1NW(path)
   with ioOpen(path, "r", encoding=enc) as f:
    c = 0
    for line in f:
     c += 1
     line = str(line).strip()
     if   c > 30          : break
     elif line.startswith("#EXTM3U")     : continue
     elif line.startswith("#EXTINF:")    : par = line
     elif line.startswith("#EXT-X-MEDIA-SEQUENCE:") : m3u8 = True
     elif par and not line.startswith("#")   : url = line
     if par and url:
      lst.append((par, url))
  except:
   self.VVJf3H("Cannot read file.\n\n%s" % path)
   return True
  if m3u8:
   VVUwmk = os.path.splitext(os.path.basename(path))[0]
   VVq9SN, chUrl, VVadS0 = CCGSVa.VVFAtf(1, path, VVUwmk)
   CCsmqb.VVlIAT(self.SELF.session, VVdxJv=chUrl)
   return True
  if len(lst) == 1: par, url = lst[0]
  else   : return False
  if iMatch(r"^(?:[A-Za-z0-9]+:){10}$", url):
   CCsmqb.VVlIAT(self.SELF.session, VVdxJv=url)
   return True
  span = iSearch(r"^http.+((?:[A-Za-z0-9]+:){10})$", url)
  if span:
   CCsmqb.VVlIAT(self.SELF.session, VVdxJv=span.group(1))
   return True
  span = iSearch(r"^http.+\/((?:[A-Za-z0-9]+:){10}\/.+)", url)
  if span:
   CCsmqb.VVlIAT(self.SELF.session, VVdxJv=span.group(1))
   return True
  span = iSearch(r'(?:tvg-name="(.+?)")*.+,(.+)', par, IGNORECASE)
  VVUwmk = ((span.group(1) or span.group(2))).replace(":", "|").replace("||", "|").strip() if span else ""
  VVUwmk = VVUwmk or os.path.splitext(os.path.basename(path))[0]
  span = iSearch(r"^((?:[A-Za-z0-9]+:){10})(http.+(?:[A-Za-z0-9]+:){10})$", url)
  if span:
   chUrl = "%s%s:%s" % (span.group(1), FFTnsB(span.group(2)), VVUwmk)
   CCsmqb.VVlIAT(self.SELF.session, VVdxJv=chUrl)
   return True
  return False
 def VV2ME2(self):
  lst = [(os.path.splitext(os.path.basename(f))[0], f) for f in iGlob("%s/*.zip" % CCGSVa.VVMhBD()) if os.path.isfile(f)]
  if lst:
   lst.sort(key=lambda x: x[0].lower())
   VVQ4hk  = self.VVRL6D
   VVF79M  = self.VVpINm
   VVXpo8  = ("Home Menu" , FF5vVS)
   VVGbyT  = ("Rename" , self.VVvEYP)
   FFO9kU(self.SELF, None, title=self.Title, VV9cxb=lst, width=1200, VV3an7=3, VV1NnQ="", VVQ4hk=VVQ4hk, VVF79M=VVF79M, VVXpo8=VVXpo8, VVGbyT=VVGbyT
     , VVfWsQ="#08000011", VVB5I5="#08111122", VVfINZ="#08333344")
  else:
   self.VVJf3H('No Local Servers.\n\nYou can add local server form %s.' % FFKrMM("Server Resources", VVk4x7))
 def VVRL6D(self, item):
  self.VVkXn6(item[2])
 def VVpINm(self, VVhzhr, txt, ref, ndx):
  self.VVNKwo(ref)
 def VVvEYP(self, VVhzhr, path):
  oName = os.path.basename(path)[:-4]
  FFANcN(self.SELF, BF(self.VVfx4o, VVhzhr, path, oName), defaultText=oName, title="Rename", message="New name")
 def VVfx4o(self, VVhzhr, path, oName, nName):
  if not nName or not nName.strip(): return
  title = "Rename : %s" % oName
  nName = nName.strip()
  nPath = os.path.join(os.path.dirname(path), "%s.zip" % nName)
  if   path == nPath  : FFoTZI(VVhzhr, "No change", 800)
  elif FFKbVo(nPath) : FFbBGq(self.SELF, "Name already exists:\n\n%s" % nName, title=title)
  else     : FF6pUe(self.SELF, BF(self.VV1J9G, VVhzhr, title, path, nPath, nName), "Rename to:\n\n%s" % nName, title=title)
 def VV1J9G(self, VVhzhr, title, path, nPath, nName):
  try:
   os.rename(path, nPath)
   VVhzhr.VVVN5V((nName, nPath))
   FFxHED(VVhzhr, "Renamed", 800)
  except Exception as e:
   FFbBGq(self.SELF, str(e), title=title)
 def VVkXn6(self, path):
  if path:
   self.VV1ctN = path
   title = os.path.splitext(FFiZj6(path))[0]
   if len(title) > 40: title = "%s .." % title[:40]
   cl = CCGSVa.VVuhBT(path)
   if cl.err or not cl.valid or not cl.totAll:
    self.VVJf3H("Invalid file:\n\n%s" % os.path.basename(path))
    return
   lst = []
   lst.append(("Live" , cl.totL, cl.totChL))
   lst.append(("VOD" , cl.totV, cl.totChV))
   lst.append(("Series", cl.totS, cl.totChS))
   if cl.totM or cl.totChM: lst.append(("Movie" , cl.totM, cl.totChM))
   if cl.totD or cl.totChD: lst.append(("DVB"  , cl.totD, cl.totChD))
   if cl.totR or cl.totChR: lst.append(("S.Relay" , cl.totR, cl.totChR))
   if cl.totF or cl.totChF: lst.append(("FTP"  , cl.totF, cl.totChF))
   lst = [(s, str(g), str(ch))for s, g, ch in lst]
   yelBtn = self.mode != CCGSVa.VVg57A
   VVj7lw  = (""    , BF(self.VVVZFo, path)   , [])
   VVmolf = (""    , BF(self.VVs7AI, path) , [])
   VVjW3s = ("Home Menu"  , FF5vVS             , [])
   VV46TD = ("Delete Cache" , BF(self.VV64H0, path) , []) if yelBtn else None
   header  = ("Type" , "Groups" , "Channels")
   widths  = (50  , 25  , 25  )
   VV4Uoc = (LEFT  , CENTER , CENTER )
   FFCXsL(self.SELF, self.VVS4vP, title=title, header=header, VVXpNQ=lst, VV4Uoc=VV4Uoc, VV8boH=widths
     , VVAQi3=30, VVHzN4=20, width=1000, VVPYL1=28, VVj7lw=VVj7lw, VVmolf=VVmolf, VVjW3s=VVjW3s, VV46TD=VV46TD, VVRtfk=2
     , VVfWsQ="#08222233", VVB5I5="#08222233", VVYCun="#08222233", VVmErq="#083a4a4a", VVK8UQ="#08222233", VVgSJJ="#08333355")
 def VVs7AI(self, path, VVAIxO, txt, ref, ndx):
  self.VVNKwo(path)
 def VV64H0(self, path, VVAIxO, txt, ref, ndx):
  FF6pUe(self.SELF, BF(self.VV1lc1, VVAIxO, path), "Delete ?\n\n%s" % path, title="Delete Local Cache")
 def VV1lc1(self, VVAIxO, path):
  FFnE7j(path)
  if FFKbVo(path) : FFoTZI(VVAIxO, "No deleted", 1000)
  else    : VVAIxO.close()
 @FFJRPn(par=2)
 def VVVZFo(self, path, VVAIxO, title, txt, colList):
  self.VVmCHr = colList[0]
  lines, err = CCGSVa.VVlQjb(path, "_main", mode=1)
  if err:
   self.VVJf3H(err)
   return
  lst = []
  srcFil = VV682V = srcTm = ""
  for line in lines:
   if line.startswith("#"):
    subj, _, val = line.partition(":")
    subj, val = subj[1:].strip().lower(), val.strip()
    if   subj == "file"  : srcFil = val
    elif subj == "url"   : VV682V = val
    elif subj == "created" : srcTm  = val
   else:
    parts = line.split("\t")
    if len(parts) == 5:
     typ, catBlk, fName, totCh, cat = parts
     cat = self.VVoWRq(cat)
     if cat and typ == self.VVmCHr:
      lst.append((cat, totCh, fName))
  if len(lst) == 1 and iMatch(r"\* Uncategorized.+Channels \*", lst[0][0]):
   self.VVovDF(VVAIxO, path, lst[0][0], lst[0][2])
  elif lst:
   mode = {"l": CCTe4w.VVqyuy, "v": CCTe4w.VVdqLS, "s": CCTe4w.VVeQf7}.get(self.VVmCHr[:1].lower())
   VVfWsQ, VVB5I5, VVYCun, VVmErq = CCTe4w.VVq4P3(mode)
   lst.sort(key=lambda x: x[0].lower())
   VVj7lw  = ("Channels" , BF(self.VVQMTV, path), [])
   VVjW3s = ("Home Menu" , FF5vVS         , [])
   VV46TD = ("Find in %s" % self.VVmCHr, BF(self.VVoPPz, path) , [])
   header  = ("Category" , "Channels", "fName")
   widths  = (84   , 16  , 0   )
   VV4Uoc = (LEFT   , CENTER , CENTER )
   FFCXsL(self.SELF, None, title=self.VVmCHr, header=header, VVXpNQ=lst, VV4Uoc=VV4Uoc, VV8boH=widths, width=1200, height=960, VVPYL1=30, VVj7lw=VVj7lw, VVjW3s=VVjW3s, VV46TD=VV46TD, VVfWsQ=VVfWsQ, VVB5I5=VVB5I5, VVYCun=VVYCun, VVmErq=VVmErq)
  else:
   FF8bV6(VVAIxO, "No Groups/Channels", 1000)
 def VVoPPz(self, path, VVAIxO, title, txt, colList):
  VV9cxb = []
  VV9cxb.append(("Keyboard"  , "manualEntry"))
  VV9cxb.append(("From Filter" , "fromFilter"))
  FFO9kU(self.SELF, BF(self.VVkqHy, VVAIxO, path), title="Input Type", VV9cxb=VV9cxb, width=400)
 def VVkqHy(self, VVAIxO, path, item=None):
  if item == "manualEntry":
   FFANcN(self.SELF, BF(self.VVcuvi, VVAIxO, path), defaultText=CFG.lastFindIptv.getValue(), title="Find", message="Enter Name (or names separated by a comma)")
  elif item == "fromFilter":
   filterObj = CCuHRT(self.SELF)
   filterObj.VVaNK8(BF(self.VVcuvi, VVAIxO, path))
 def VVcuvi(self, VVAIxO, path, item):
  if not item is None:
   title = "Find in %s" % self.VVmCHr
   words = None
   toFind = item.strip()
   FFBWtx(CFG.lastFindIptv, toFind)
   if toFind:
    words, asPrefix = CCuHRT.VVzdEZ(toFind)
    if words:
     if len(words) == 1 and len(words[0]) < 3:
      self.VVJf3H("Enter at least 3 characters.", title=title)
      return
     else:
      for word in words:
       if len(word) < 3:
        self.VVJf3H("All words must be at least 3 characters !", title=title)
        return
     if CFG.hideIptvServerAdultWords.getValue() and self.VVJ6GT(words):
      self.VVJf3H(self.VVhVMo(), title="Find: %s" % " , ".join(words))
      return
     else:
      CCV3Gw.VVgWD3(self.SELF, VVN6I4="Searching for:%s" % toFind[:15], totBars=2
          , VVuSHu  = BF(self.VVb8RL, VVAIxO, path, title, words, toFind, asPrefix)
          , VVhK3C = BF(self.VVvsZU, VVAIxO, title))
   if not words:
    FFoTZI(VVAIxO, "Nothing to find !", 1500)
 def VVb8RL(self, VVAIxO, path, title, words, toFind, asPrefix, VVqeT6):
  VVqeT6.VVL8uX = []
  VVqeT6.VVfT17(VVAIxO.VVM62I())
  c = 0
  for ndx, (cat, totCh, fName) in enumerate(VVAIxO.VVGpBN()):
   lines, err = CCGSVa.VVlQjb(path, fName, mode=1)
   if not VVqeT6 or VVqeT6.isCancelled: return
   VVqeT6.VVqE9L(1)
   VVqeT6.VVH2AI(len(lines))
   VVqeT6.VVuDjj(0)
   VVqeT6.VVEfKX(cat)
   for line in lines:
    if not VVqeT6 or VVqeT6.isCancelled: return
    VVqeT6.VVpqYW(1)
    parts = line.split("\t")
    if len(parts) == 4:
     chBlk, url, name, icn = parts
     name = self.VVYMFT(name)
     if name:
      nm = name.lower()
      if asPrefix and not nm.startswith(words): continue
      elif any(x in nm for x in words)  : pass
      else         : continue
      if CCTe4w.VVs8ai(name):
       name = CCTe4w.VV6Gyk(name)
      if icn == "-": icn =""
      c += 1
      if not VVqeT6 or VVqeT6.isCancelled: return
      VVqeT6.VVL8uX.append((str(c), name, "Yes" if icn else "", url, icn))
 def VVvsZU(self, winObj, cat, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  if VVL8uX : self.VVzXq5(cat, VVL8uX)
  elif VV6ZvL : FF8bV6(winObj, "Not found", 1500)
 def VVQMTV(self, path, VVAIxO, title, txt, colList):
  cat, totCh, fName = colList
  self.VVovDF(VVAIxO, path, cat, fName)
 def VVovDF(self, winObj, path, cat, fName):
  CCV3Gw.VVgWD3(self.SELF, VVN6I4="Reading Channels ...", VV32kU=CCV3Gw.VVQFxC
      , VVuSHu  = BF(self.VVVXGW, path, fName)
      , VVhK3C = BF(self.VV8Wzc, winObj, cat))
 def VVVXGW(self, path, fName, VVqeT6):
  VVqeT6.VVL8uX = []
  lines, err = CCGSVa.VVlQjb(path, fName, mode=1)
  if err:
   self.VVJf3H(err)
   return
  if not VVqeT6 or VVqeT6.isCancelled: return
  VVqeT6.VVfT17(len(lines))
  c = 0
  for line in lines:
   if not VVqeT6 or VVqeT6.isCancelled: return
   VVqeT6.VVqE9L(1)
   parts = line.split("\t")
   if len(parts) == 4:
    chBlk, url, name, icn = parts
    name = self.VVYMFT(name)
    if name:
     if CCTe4w.VVs8ai(name):
      name = CCTe4w.VV6Gyk(name)
     if icn == "-": icn =""
     c += 1
     if not VVqeT6 or VVqeT6.isCancelled: return
     VVqeT6.VVL8uX.append((str(c), name, "Yes" if icn else "", url, icn))
 def VV8Wzc(self, winObj, cat, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  if VVL8uX : self.VVzXq5(cat, VVL8uX)
  else   : FF8bV6(winObj, "No channels", 1000)
 def VVzXq5(self, cat, lst):
  showGrn = self.VVclRb() != "m3u"
  VVfWsQ, VVB5I5, VVYCun, VVmErq = CCTe4w.VVq4P3(CCTe4w.VV9a1K)
  VVj7lw  = ("Play"   , self.VVNKxu   , [])
  VVmolf = (""    , self.VVJaso, [])
  VVjW3s = ("Home Menu"  , FF5vVS      , [])
  VVwqVu = ("Download Options", self.VVvINh,[]) if showGrn else None
  VV46TD = ("Options"  , BF(self.VVLprG, cat), [])
  VViMvb = ("Posters Mode" , self.VVZW9X , [])
  header  = ("Num" , "Name", "Logo", "url" , "icn" )
  widths  = (8  , 84 , 8  , 0  , 0  )
  VV4Uoc = (CENTER , LEFT , CENTER, CENTER, CENTER)
  FFCXsL(self.SELF, None, title=cat, header=header, VVXpNQ=lst, VV4Uoc=VV4Uoc, VV8boH=widths, VVj7lw=VVj7lw, VVmolf=VVmolf, VVjW3s=VVjW3s, VVwqVu=VVwqVu, VV46TD=VV46TD, VViMvb=VViMvb, VVfWsQ=VVfWsQ, VVB5I5=VVB5I5, VVYCun=VVYCun, VVmErq=VVmErq, VVoNmU=True, VVMBr1=1)
 def VVLprG(self, VVaSrd, VVAIxO, title, txt, colList):
  isMulti = VVAIxO.VVGZGK
  itemsOK = True
  totTxt = "ALL"
  if isMulti:
   tot = VVAIxO.VVAGI8()
   totTxt = "%d Service%s" % (tot, FFaRsj(tot))
   if tot < 1:
    itemsOK = False
  totTxt = FFKrMM(totTxt, VVk4x7)
  cl = CCGSVa.VVuhBT(self.VV1ctN)
  hst, usr, pas, VVsMdH = CCGSVa.VV96YL(cl.VV682V)
  if not VVsMdH:
   num, name, logo, url, VVuPzU = colList
   hst, usr, pas, VVsMdH = CCGSVa.VV96YL(url)
  VVaSrd2 = ("%s (%s)" % (VVaSrd, VVsMdH)) if VVsMdH else ""
  mSel = CC17aQ(self.SELF, VVAIxO, addSep=False, setsOk=True, setsBlue=True)
  VV9cxb, cbFncDict = [], None
  VV9cxb.append(VVbM5H)
  if itemsOK:
   VV9cxb.append(("Add %s to New Bouquet : %s"    % (totTxt, FFKrMM(VVaSrd , VVOQkl)), "addToCur1"))
   if VVaSrd2: VV9cxb.append(("Add %s to New Bouquet : %s" % (totTxt, FFKrMM(VVaSrd2, VV1l75)) , "addToCur2"))
   VV9cxb.append(("Add %s to Existing/New Bouquet ..."  % (totTxt)            , "addToNew" ))
   title = "Add to Bouquet"
   cbFncDict = { "addToCur1": BF(self.VVzYub , VVaSrd , VVAIxO, title)
      , "addToCur2": BF(self.VVzYub , VVaSrd2, VVAIxO, title)
      , "addToNew" : BF(self.VV1ovn, VVaSrd, VVAIxO, title)
      }
  else:
   VV9cxb.append(("Add to Bouquet (nothing selected)", ))
  mSel.VV4sFy(VV9cxb, cbFncDict, width=1400)
 @FFJRPn("Adding Services ...", par=2)
 def VVzYub(self, VVaSrd, VVAIxO, Title):
  chUrlLst = self.VVMIoW(VVAIxO)
  CC8i1k.VVWTLg(self.SELF, Title, VVaSrd, "", chUrlLst)
 def VV1ovn(self, VVaSrd, VVAIxO, Title):
  picker = CC8i1k(self.SELF, VVAIxO, Title, BF(self.VVMIoW, VVAIxO), VVLpD7=VVaSrd)
 def VVMIoW(self, VVAIxO):
  isMulti = VVAIxO.VVGZGK
  chUrlLst = []
  rowNum = 0
  for ndx, (num, name, logo, url, VVuPzU) in enumerate(VVAIxO.VVGpBN()):
   if not isMulti or VVAIxO.VVDjAB(ndx):
    chUrl = self.VVTVDv(rowNum, url, name)
    rowNum += 1
    if chUrl and name:
     chUrlLst.append(chUrl)
  return chUrlLst
 def VVvINh(self, VVAIxO, title, txt, colList):
  isMulti = VVAIxO.VVGZGK
  tot  = VVAIxO.VVAGI8()
  if isMulti:
   if tot < 1:
    FFoTZI(VVAIxO, "Select rows first.", 1000)
    return
   else:
    name = "%d Selected" % tot
   plural = FFaRsj(tot)
  else:
   name = "ALL"
   plural = "s"
  VV9cxb = []
  VV9cxb.append(("Download %s %s%s" % (name, "PIcon" if self.VVmCHr == "Live" else "Poster", plural), "dnldPicons" ))
  if self.VVmCHr in ("VOD", "Series"):
   VV9cxb.append(VVbM5H)
   tName = "Movie" if self.VVmCHr == "VOD" else "Episode"
   VV9cxb.append(("Download Current %s" % tName    , "dnldSel"  ))
   VV9cxb.append(("Add Current %s to Download List" % tName , "addSel"  ))
   if not CClaHD.VVyZwz():
    VV9cxb.append(VVbM5H)
    VV9cxb.append(("Download Manager"      , "dload_stat" ))
  FFO9kU(self.SELF, BF(self.VVGI8s, VVAIxO, colList), title="Download Options", VV9cxb=VV9cxb)
 def VVGI8s(self, VVAIxO, colList, item=None):
  if item:
   if   item == "dnldPicons" : CCTe4w.VVvySR(self.SELF, VVAIxO, "m3u")
   elif item == "dnldSel"  : self.VV9Yo3(VVAIxO, colList, True)
   elif item == "addSel"  : self.VV9Yo3(VVAIxO, colList, False)
   elif item == "dload_stat" : CClaHD.VVRi6O(self.SELF, VVAIxO)
 def VV9Yo3(self, VVAIxO, colList, startDnld):
  VVq9SN, VVUwmk, chUrl, VVuPzU, VVadS0, isMark = self.VVsRLo(colList)
  if startDnld:
   CClaHD.VVuNb5(self.SELF, VVadS0)
  else:
   self.VVFbCm(VVAIxO, "Add to Download list", VVUwmk, [VVadS0], startDnld)
 def VVFbCm(self, VVAIxO, title, VVUwmk, VVY8fX, startDnld):
  FF6pUe(self.SELF, BF(self.VVLhdj, VVAIxO, VVY8fX, startDnld), VVUwmk, title=title)
 def VVLhdj(self, VVAIxO, VVY8fX, startDnld):
  added, skipped = CClaHD.VVSjKX(VVY8fX)
  FFoTZI(VVAIxO, "Added", 1000)
 def VVNKxu(self, VVAIxO, title, txt, colList):
  VVq9SN, VVUwmk, chUrl, VVuPzU, VVadS0, isMark = self.VVsRLo(colList)
  if isMark:
   FFoTZI(VVAIxO, "Cannot play markers", 500)
  else:
   chUrl = CC6V53.VVZOQd(self.SELF, chUrl)
   VVHkge = self.VVFGpZ(VVuPzU)
   CCsmqb.VVlIAT(self.SELF.session, VVu1kk=(self, VVAIxO, "localServer"), VVdxJv=chUrl, VVHkge=VVHkge)
 def VVsRLo(self, colList):
  return CCGSVa.VVFYqm(self.SELF, colList)
 def VVZ8rX(self, VVAIxO, colList, isUp):
  VVq9SN, VVUwmk, chUrl, VVuPzU, VVadS0, isMark = self.VVsRLo(colList)
  if isMark:
   for i in range(VVAIxO.VVM62I()):
    if isUp : VVAIxO.VVDGX5()
    else : VVAIxO.VVSmob()
    VVq9SN, VVUwmk, chUrl, VVuPzU, VVadS0, isMark = self.VVsRLo(VVAIxO.VVQDwi())
    if not isMark:
     break
  VVHkge = self.VVFGpZ(VVuPzU)
  return VVUwmk, chUrl, VVHkge
 def VVJaso(self, VVAIxO, title, txt, colList):
  VVq9SN, VVUwmk, chUrl, VVuPzU, VVadS0, isMark = self.VVsRLo(colList)
  CCpebE.VV1v7b(self.SELF, VV6tGM=CCpebE.VVsuho, params=(VVq9SN, VVUwmk, txt, chUrl, VVuPzU))
 def VVZW9X(self, VVAIxO, title, txt, colList):
  FF7iMz(VVAIxO, BF(self.SELF.session.open, CCL8u5, VVAIxO, self.VV0GKH(), 1, 4, 0, "Num"))
 def VVclRb(self):
  return self.VVmCHr.lower() if self.VVmCHr in ("Live", "VOD", "Series") else "m3u"
 def VV0GKH(self):
  return CCTe4w.VVR5UG(self.VVclRb())
 def VVFGpZ(self, VVuPzU):
  return os.path.join(self.VV0GKH(), os.path.basename(VVuPzU)) if VVuPzU else ""
 def VVNKwo(self, path):
  cl = CCGSVa.VVuhBT(path)
  srcFil = cl.srcFil or path
  if any((srcFil, cl.srv, cl.VV682V, cl.srcTm, cl.totAll)):
   c1 = VVk4x7
   tab = lambda x, y: ("   %s\t: %s\n" % (x, y))
   tab1 = lambda x, y: ("   %s\t: %s\n" % (x, y)) if y else ""
   ttl = lambda x, y: "%s:\n%s\n\n" % (FFKrMM(x, c1), str(y)) if y else ""
   txt  = ttl("Name"  , cl.srv)
   txt += ttl("Saved"  , cl.srcTm)
   if FFKbVo(srcFil):
    t = srcFil + FFKrMM("\nNote : Original file was modified.", VVU4M8) if cl.toUpd else ""
    txt += ttl("Source File", t)
   txt += ttl("Source URL"  , cl.VV682V)
   txt += FFKrMM("Total:\n", c1)
   txt += tab("Groups"  , cl.totGrp)
   txt += tab("Services" , cl.totSrv)
   if cl.totEnt:
    txt += FFKrMM("\nEntries (%s):\n" % cl.totEnt, c1)
    txt += tab1("  Live" , cl.totChL)
    txt += tab1("  VOD"  , cl.totChV)
    txt += tab1("  Series" , cl.totChS)
    txt += tab1("  Movie" , cl.totChM)
    txt += tab1("  DVB"  , cl.totChD)
    txt += tab1("  S.Relay" , cl.totChR)
    txt += tab1("  FTP"  , cl.totChF)
    txt += tab1("  Marker" , cl.totChK)
   FFSMJz(self.SELF, txt, "Services")
  else:
   FFoTZI(VVhzhr, "No info", 500)
 @staticmethod
 def VVuhBT(path):
  class CCuVlT():
   def __init__(self):
    self.srv = os.path.splitext(FFiZj6(path))[0]
    self.srcFil = self.srcMod = self.VV682V = self.srcTm = ""
    self.totL = self.totV = self.totS = self.totM = self.totD = self.totR = self.totF = 0
    self.totChL = self.totChV = self.totChS = self.totChM = self.totChD = self.totChR = self.totChF = self.totChK = 0
    self.totEnt = self.totSrv = self.totAll = 0
    self.valid = False
    self.toUpd = False
    self.err = ""
    lines, self.err = CCGSVa.VVlQjb(path, "_main", mode=1)
    if self.err:
     return
    skip = CFG.hideIptvServerAdultWords.getValue()
    tab1 = lambda s, v, t: int(v) if s == t and v.isdigit() else 0
    tab2 = lambda s, v, t: int(v) if s == "blk_" + t and v.isdigit() else 0
    tab3 = lambda x, catBlk: 1 if (line.startswith(x) and not (skip and catBlk)) else 0
    for line in lines:
     if line.startswith("#"):
      subj, _, val = line.partition(":")
      subj, val = subj[1:].strip().lower(), val.strip()
      if   subj == "file"  : self.srcFil = val
      elif subj == "modified" : self.srcMod = val
      elif subj == "url"  : self.VV682V = val
      elif subj == "saved" : self.srcTm  = val
      elif subj == "entries" : self.totEnt = val
      elif subj == "services" : self.totSrv = val
      self.totChL += tab1(subj, val, "live" )
      self.totChV += tab1(subj, val, "vod" )
      self.totChS += tab1(subj, val, "series" )
      self.totChM += tab1(subj, val, "movie" )
      self.totChD += tab1(subj, val, "dvb" )
      self.totChR += tab1(subj, val, "s.relay")
      self.totChF += tab1(subj, val, "ftp" )
      self.totChK += tab1(subj, val, "marker" )
      if skip:
       self.totChL -= tab2(subj, val, "live" )
       self.totChV -= tab2(subj, val, "vod" )
       self.totChS -= tab2(subj, val, "series" )
       self.totChM -= tab2(subj, val, "movie" )
       self.totChD -= tab2(subj, val, "dvb" )
       self.totChR -= tab2(subj, val, "s.relay")
       self.totChF -= tab2(subj, val, "ftp" )
       self.totChK -= tab2(subj, val, "marker" )
     else:
      parts = line.split("\t")
      if len(parts) == 5:
       typ, catBlk, fName, totCh, cat = line.split("\t")
       catBlk = catBlk == "1"
       self.totL += tab3("Live" , catBlk)
       self.totV += tab3("VOD"  , catBlk)
       self.totS += tab3("Series" , catBlk)
       self.totM += tab3("Movie" , catBlk)
       self.totD += tab3("DVB"  , catBlk)
       self.totR += tab3("S.Relay" , catBlk)
       self.totF += tab3("FTP"  , catBlk)
    self.totGrp = self.totL + self.totV + self.totS + self.totM + self.totD + self.totR + self.totF
    self.totCh = self.totChL + self.totChV + self.totChS + self.totChM + self.totChD + self.totChR + self.totChF
    self.totAll = self.totGrp + self.totCh
    self.valid = any((self.srv, self.srcFil, self.VV682V, self.srcTm, self.totAll))
    if self.srcMod and FFKbVo(self.srcFil):
     try:
      old = int(self.srcMod)
      cur = int(os.path.getmtime(self.srcFil))
      self.toUpd = old != cur
     except:
      pass
  return CCuVlT()
 def VVJf3H(self, err, title=""):
  FFbBGq(self.SELF, err, title=title or self.Title)
 def VVTVDv(self, rowNum, url, VVUwmk):
  VVq9SN = CCGSVa.VVZSao(rowNum + 1, url)
  span1 = iSearch(r"((?:[a-z0-9]+:){10})(.+)(:.+)", url, IGNORECASE)
  span2 = iSearch(r"((?:[a-z0-9]+:){10})(.+)"  , url, IGNORECASE)
  span3 = iSearch(r"((?:[a-z0-9]+:){10})$"  , url, IGNORECASE)
  span4 = iSearch(r"(.+)([&?]mode=.+&chCm=)(.*)(&end.+)", url, IGNORECASE)
  if   span1 : return "%s%s%s"  % (span1.group(1), FFTnsB(span1.group(2)), span1.group(3))
  elif span2 : return "%s%s:%s" % (span2.group(1), FFTnsB(span2.group(2)), VVUwmk)
  elif span3 : return span3.group(1)
  elif span4 : return "%s%s:%s" % (VVq9SN, FFTnsB(span4.group(1)) + span4.group(2) + FFTnsB(span4.group(3)) + span4.group(4), VVUwmk)
  else  : return "%s%s:%s" % (VVq9SN, FFTnsB(url), VVUwmk)
 @staticmethod
 def VVZSao(rowNum, url):
  span = iSearch(r".+\/(\d+)\.?", url)
  num = span.group(1) if span else "444"
  catID = "333"
  chNum = str(rowNum)
  stID = num if int(num) < 0xeeee0000 else "444"
  VVq9SN = CCTe4w.VVzrYF(catID, stID, chNum)
  return VVq9SN
 @staticmethod
 def VV4vqh(path):
  m3Dir = FF9Uvy(os.path.dirname(path))
  m3File = os.path.basename(path)
  VV0Dqv = os.path.splitext(m3File)[0]
  zPath = "%s%s.zip" % (CCGSVa.VVMhBD(), VV0Dqv)
  zFound = FFKbVo(zPath)
  return m3File, m3Dir, VV0Dqv, zPath, zFound
 @staticmethod
 def VVMhBD():
  return FFJv8S() + "ajpanel_local_servers/"
 @staticmethod
 def VVFYqm(SELF, colList):
  num, name, logo, url, VVuPzU = colList
  VVUwmk = FFkEjh(name)
  isMark = FFgTKx(url)
  if iMatch(r"^([A-Fa-f0-9]+[:]){10}", url):
   VVq9SN = chUrl = url
   VVadS0 = ""
  else:
   VVq9SN, chUrl, VVadS0 = CCGSVa.VVFAtf(int(num) + 1, url, VVUwmk)
  return VVq9SN, VVUwmk, chUrl, VVuPzU, VVadS0, isMark
 @staticmethod
 def VVFAtf(num, url, VVUwmk):
  VVadS0 = FF5ov5(url)
  VVq9SN = CCGSVa.VVZSao(num, VVadS0)
  span = iSearch(r"(.+)([&?]mode=.+&chCm=)(.*)(&end.+)", VVadS0, IGNORECASE)
  if span : encUrl = FFTnsB(span.group(1)) + span.group(2) + FFTnsB(span.group(3)) + span.group(4)
  else : encUrl = FFTnsB(VVadS0)
  chUrl = "%s%s:%s" % (VVq9SN, encUrl, VVUwmk)
  VVadS0 = "%s:%s" % (VVadS0, VVUwmk)
  return VVq9SN, chUrl, VVadS0
 @staticmethod
 def VVvYm7(SELF, Dir, VV107U, cbFnc=None):
  CCV3Gw.VVgWD3(SELF, VVN6I4="Counting Files ...", titleBg="#22220022", bodyBg="#22002211", barBg="#0a226622"
      , VVuSHu  = BF(CCGSVa.VVZXzi, Dir, VV107U)
      , VVhK3C = BF(CCGSVa.VVEzus, SELF, VV107U, cbFnc))
 @staticmethod
 def VVZXzi(Dir, VV107U, VVqeT6):
  tot = 0
  for root, dirs, files in os.walk(Dir):
   tot += len(files)
  if not VVqeT6 or VVqeT6.isCancelled: return
  VVqeT6.VVfT17(tot)
  VVqeT6.VVL8uX = (0, "")
  tot, err = 0, ""
  try:
   with iZip.ZipFile(VV107U, 'w', iZip.ZIP_DEFLATED) as zipF:
    for root, dirs, files in os.walk(Dir):
     for file in files:
      zipF.write(os.path.join(root, file), os.path.relpath(os.path.join(root, file), os.path.join(Dir, '..')))
      tot += 1
      if not VVqeT6 or VVqeT6.isCancelled: return
      VVqeT6.VVqE9L(1)
      VVqeT6.VVX5nT("Archiving Files : %s" % tot)
      VVqeT6.VVL8uX = (tot, "")
  except Exception as e:
   VVqeT6.VVL8uX = (tot, str(e))
 @staticmethod
 def VVEzus(SELF, VV107U, cbFnc, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  tot, err = VVL8uX
  if err: FFnE7j(VV107U)
  if cbFnc: cbFnc(VV107U, tot, err)
 @staticmethod
 def VVWeLO(Dir, VV107U):
  tot, err = 0, ""
  try:
   with iZip.ZipFile(VV107U, 'w', iZip.ZIP_DEFLATED) as zipF:
    for root, dirs, files in os.walk(Dir):
     for file in files:
      zipF.write(os.path.join(root, file), os.path.relpath(os.path.join(root, file), os.path.join(Dir, '..')))
      tot += 1
  except Exception as e:
   err = str(e)
  return tot, err
 @staticmethod
 def VVlQjb(VV107U, fil, mode=0):
  try:
   with iZip.ZipFile(VV107U) as zipF:
    zInfLst = zipF.infolist()
    for zipInfo in zInfLst:
     fName = os.path.basename(zipInfo.filename)
     if fName == fil:
      with zipF.open(zipInfo.filename) as f:
       txt = f.read().decode()
       if mode == 0: return str(txt), ""
       else  : return [str(x.strip()) for x in txt.splitlines()], ""
  except Exception as e:
   return "", str(e)
  return "", "Missing file"
 @staticmethod
 def VV96YL(url):
  try: res = iUrlparse(url)
  except: return [""] * 4
  scheme = res.scheme
  netloc = res.netloc
  query = res.query
  VVsMdH = res.hostname or ""
  hst  = "%s://%s" % ((scheme or "http"), netloc)
  d = iUrlparse_qs(query)
  usr = d.get("username")[0] if "username" in d else ""
  pas = d.get("password")[0] if "password" in d else ""
  return hst, usr, pas, VVsMdH
 @staticmethod
 def VVqRH8(url, chkExt=False):
  if any(x in url for x in ("/series/", "mode=series")):
   return "Series"
  if any(x in url for x in ("/movie/", "/movie.php", "/media/vod", "mode=vod", "/vod/", "/video/", "/timeshift/")):
   return "VOD"
  if any(x in url for x in ("/live/", "/live.php", "?ext=.ts", "/index.m3u8")):
   return "Live"
  if url.startswith("1:64:")       : return "Marker"
  if url.startswith("/")        : return "Movie"
  if FFKeSw(url)        : return "S.Relay"
  if iMatch(r"^(?:[A-Fa-f0-9]+:){10}", url)   : return "DVB"
  if iMatch(r"^http.+(?:[A-Fa-f0-9]+:){10}", url)  : return "DVB"
  if any(x in url for x in ("file?file", ":ftp%3a//")): return "FTP"
  if chkExt and FFgAmw(url):
   return "VOD"
  return "Live"
class CC6V53(CCr0nV):
 def __init__(self):
  self.curPortalCatId = ""
  CCr0nV.__init__(self)
 def VV1P5c(self):
  if CC6V53.VVZTHq(self):
   self.VVgeMs(2)
 def VVX5v3(self, winSession, url, mac):
  self.VVy6Nm = url
  if CC6V53.VVZTHq(self):
   if self.VVLiCA(url, mac):
    FF7iMz(winSession, self.VVwJUQ, title="Checking Server ...")
   else:
    FFbBGq(self, "Incorrect URL or MAC format !", title="Starting Portal Browser")
 def VVM9NN(self, item=None):
  if item:
   VVhzhr, txt, path, ndx = item
   enc = CC6ntZ.VVC1NW(path, self)
   if enc == -1:
    return
   CCV3Gw.VVgWD3(self, VVN6I4="Processing file lines"
       , VVuSHu  = BF(self.VVIOVV, path, enc)
       , VVhK3C = BF(self.VVddSp, VVhzhr, path))
 def VVIOVV(self, path, enc, VVqeT6):
  urlMacPatt  = r"(.*)(https?:\/\/.+(?::[0-9]+)*)(?:.+)((?:[A-Fa-f0-9]{2}\s*:\s*){5}[A-Fa-f0-9]{2})(.*)"
  urlOnlyPatt = r"\s*(https?:\/\/.+(?::[0-9]+)*)"
  macOnlyPatt = r"((?:(?:.*mac\s*)[^A-Fa-f0-9]\s*)*)((?:(?:(?:[A-Fa-f0-9]{2})\s*:\s*){5})\s*(?:[A-Fa-f0-9]{2}))(.*)"
  tableRows, url = [], ""
  lineNum = 0
  totLines = 0
  with ioOpen(path, "r", encoding=enc) as f:
   for line in f:
    totLines += 1
  VVqeT6.VVfT17(totLines)
  VVqeT6.VVL8uX = []
  def VVxN3u(subj, host, mac, info):
   if host and mac and VVqeT6:
    if not [1 for _, _, _, host1, mac1, _ in VVqeT6.VVL8uX if (host1, mac1) == (host, mac)]:
     VVqeT6.VVL8uX.append((str(len(VVqeT6.VVL8uX) + 1), str(lineNum), subj, host, mac, info))
  with ioOpen(path, "r", encoding=enc) as f:
   for line in f:
    lineNum += 1
    if not VVqeT6 or VVqeT6.isCancelled:
     return
    VVqeT6.VVqE9L(1, True)
    line = str(line).strip()
    if not line or len(line) > 500 or "password" in line:
     continue
    span = iSearch(urlMacPatt, line, IGNORECASE)
    if span:
     subj = span.group(1).strip().strip(',"') or "-"
     url  = span.group(2).strip().split(" ")[0].split("\t")[0].strip()
     mac  = span.group(3).strip().replace(" ", "").upper()
     info = span.group(4).strip().strip(',;"\t') or "-"
     host = self.VVqojZ(url).replace('"mac', "").strip(',"')
     mac  = self.VVfyrR(mac)
     VVxN3u(subj, host, mac, info)
     url = ""
     continue
    if not url:
     span = iSearch(urlMacPatt, line, IGNORECASE)
     if not span:
      span = iSearch(urlOnlyPatt, line, IGNORECASE)
      if span:
       url = span.group(1).split(" ")[0]
    else:
     span = iSearch(macOnlyPatt, line.replace("\t", " "), IGNORECASE)
     if span:
      subj = span.group(1).strip().strip(',"') or "-"
      mac  = span.group(2).strip().replace(" ", "").upper()
      info = span.group(3).strip().strip(',;"') or "-"
      host = self.VVqojZ(url).strip(',;"\t')
      mac  = self.VVfyrR(mac)
      VVxN3u("", host, mac, info)
     else:
      span = iSearch(urlOnlyPatt, line, IGNORECASE)
      if span:
       url = span.group(1).split(" ")[0]
 def VVddSp(self, VVTsOy, path, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  title = "Portals File : %s" % os.path.basename(path)
  if VVL8uX:
   VVjW3s  = ("Home Menu"  , FF5vVS            , [])
   VVwqVu = ("Browse as M3U" , self.VVLitZ        , [])
   VV46TD = ("Edit File"  , BF(self.VVamOW, path)       , [])
   VViMvb = ("Options"  , BF(self.VV4x8p, VVTsOy, path) , [])
   VVj7lw  = ("Select"   , self.VVTJWs , [])
   header   = ("Num" , "LineNum" , "Title" , "Host", "MAC-Address" , "Comments")
   widths   = (7  , 0   , 12  , 36 , 20   , 25  )
   VV4Uoc  = (CENTER , CENTER , LEFT  , LEFT , CENTER  , LEFT  )
   VVAIxO = FFCXsL(self, None, title=title, header=header, VVXpNQ=VVL8uX, VV4Uoc=VV4Uoc, VV8boH=widths, VVPYL1=26, VVj7lw=VVj7lw, VVjW3s=VVjW3s, VVwqVu=VVwqVu, VV46TD=VV46TD, VViMvb=VViMvb, VVfWsQ="#0a001122", VVB5I5="#0a001122", VVYCun="#0a001122", VVmErq="#00004455", VVK8UQ="#0a333333", VVgSJJ="#11331100", VVoNmU=True, VVMBr1=3, VVAGe1=CFG.lastFindServers)
   if not VV6ZvL:
    FFoTZI(VVAIxO, "Stopped at line %s" % threadCounter, 1000)
  else:
   if VV6ZvL:
    FFbBGq(self, "No valid portal data (or incorrect file format) in:\n\n%s" % path, title=title)
 @FFJRPn("Checking Access ...", par=1, clearMsg=False)
 def VVLitZ(self, VVAIxO, title, txt, colList):
  host, mac = colList[3], colList[4]
  p, pUrl, pUrlAcc, pUrlDnld, pHost, pUser, pPass, err = CCr0nV.VVGc5K(host=host, mac=mac)
  VVAIxO.VVEL2E()
  if pUrlAcc and pUrlDnld : self.VVI7E9(VVAIxO, title, pUrlAcc)
  else     : FFbBGq(self, err or "No response from Server !", title="Playlist for : %s" % host)
 def VVTJWs(self, VVAIxO, title, txt, colList):
  self.VVX5v3(VVAIxO, colList[3], colList[4])
 def VVamOW(self, path, VVAIxO, title, txt, colList):
  rowNum = int(colList[1].strip()) - 1
  if FFKbVo(path) : CCNb3y(self, path, VVhK3C=BF(self.VVPVcC, VVAIxO), VVmB4A=rowNum)
  else    : FFWfGZ(self, path)
 def VV4x8p(self, VVTsOy, path, VVAIxO, title, txt, colList):
  VV9cxb =[]
  VV9cxb.append(("Filter Responsive Servers"  , "tok"))
  VV9cxb.append(("Find Servers with Playlist Access", "plst"))
  FFO9kU(self, BF(self.VVIKDQ, VVTsOy, VVAIxO, path), title="Portal Options", VV9cxb=VV9cxb, width=700)
 def VVIKDQ(self, VVTsOy, VVAIxO, path, item):
  if not item: return
  isToken = item == "tok"
  nm, ext = os.path.splitext(os.path.basename(path))
  for s in ("TOKEN_", "PLAYLIST_", "OK_"): nm = nm.replace(s, "")
  nm = iSub(r"(_\d{8})", "", nm)
  nm = iSub(r"(_\d{6})", "", nm)
  nm, _ = os.path.splitext(nm)
  txt = "TOKEN" if item == "tok" else "PLAYLIST"
  nm = "%s_%s_%s.txt" % (nm, "TOKEN" if isToken else "PLAYLIST", FFRIlf())
  outF = os.path.join(os.path.dirname(path), nm)
  self.VV1QcC(VVTsOy, VVAIxO, outF, isToken, VVAIxO.VVGpBN(), VVAIxO.VVM62I())
 def VV1QcC(self, VVTsOy, VVAIxO, outF, isToken, lst, tot):
  CCV3Gw.VVgWD3(self, VVN6I4="Checking Portals"
      , VVuSHu  = BF(self.VVLpxy, outF, isToken, lst, tot)
      , VVhK3C = BF(self.VVFYwu, VVTsOy, VVAIxO, outF, isToken))
 def VVLpxy(self, outF, isToken, lst, tot, VVqeT6):
  totOk = totNotOK = totHstErr = totSkip = 0
  VVqeT6.VVL8uX = (totOk, totNotOK, totHstErr, totSkip, "")
  VVqeT6.VVfT17(tot)
  skipHosts = set()
  for row in lst:
   if not VVqeT6 or VVqeT6.isCancelled: return
   VVqeT6.VVCrM6(0, totOk)
   num, lNum, titl, host, mac, cmnt = row
   valid = False
   if host in skipHosts        : totSkip += 1
   elif self.VVLiCA(host, mac, VVAdNn=False) : valid = True
   else            : totHstErr += 1
   if valid:
    fLine = token = pUrlAcc = ""
    if isToken:
     t1 = iTime()
     token, profile, tErr = self.VVOnvR(VVAdNn=False)
     took = "%.3f" % (iTime() - t1)
     if token:
      fLine = "%s\t%s\t%s\t(Token: %s sec) %s" % (titl, host, mac, took, "" if cmnt == "-" else cmnt)
    else:
     p, pUrl, pUrlAcc, pUrlDnld, pHost, pUser, pPass, err = CCr0nV.VVGc5K(host=host, mac=mac)
     if pUrlAcc:
      fLine = "%s\t%s\n%s\n" % (host, mac, pUrlAcc)
    if not VVqeT6 or VVqeT6.isCancelled: return
    if isToken and token or not isToken and pUrlAcc:
     try:
      with open(outF, "a") as f:
       f.write("%s\n" % fLine)
      totOk += 1
      if not VVqeT6 or VVqeT6.isCancelled: return
      VVqeT6.VVL8uX = (totOk, totNotOK, totHstErr, totSkip, "")
     except Exception as e:
      if not VVqeT6 or VVqeT6.isCancelled: return
      VVqeT6.VVL8uX = (totOk, totNotOK, totHstErr, totSkip, str(e))
      return
    else:
     if self.portal_latestResponse.get("resCritical", ""):
      skipHosts.add(host)
      totSkip += 1
     else:
      totNotOK += 1
   if not VVqeT6 or VVqeT6.isCancelled: return
   VVqeT6.VVL8uX = (totOk, totNotOK, totHstErr, totSkip, "")
   VVqeT6.VVCrM6(1, totOk)
 def VVFYwu(self, VVTsOy, VVAIxO, outF, isToken, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  totOk, totNotOK, totHstErr, totSkip, err = VVL8uX
  c1, c2 = VVOQkl, VVdLWL
  tab = lambda a, b: "%s\t: %s\n" % (a, b)
  txt  = tab("Servers" ,  threadTotal)
  txt += tab("Checked" ,  threadCounter)
  txt += tab("Accessible" ,  FFKrMM(totOk, c1 if totOk else c2))
  if totNotOK   : txt += tab("No Token" if isToken else "Not found", totNotOK)
  if totSkip   : txt += tab("Skipped"  , "%d (host access error)" % totSkip)
  if totHstErr  : txt += tab("Host Error" , totHstErr)
  if err    : txt += tab("\nError" , FFKrMM(err, c2))
  if not VV6ZvL : txt += tab("\nProcess", FFKrMM("Stopped", c2))
  if totOk   : txt += "\n%s\n%s\n" % (FFKrMM("Output File:", c1), outF)
  FFSMJz(self, txt, title="Portal Servers Filtering")
  if totOk:
   if VVTsOy: VVTsOy.VVisOz((outF, outF), isSort=True)
   if VVAIxO: VVAIxO.close()
 def VVwJUQ(self):
  token, profile, tErr = self.VVOnvR()
  if token:
   dots = "." * self.VV875P
   dots += {"s":"", "p":"+", "q":"++"}.get(self.VVvJwJ(), "")
   dots += "*" if not self.VVy9Fm == self.VVy6Nm else ""
   if dots:
    dots = FFKrMM(dots, VV3Hcc)
   if CFG.simplePortal.getValue() : VVfWsQ, VVB5I5 = "#22553344", "#22552233"
   else       : VVfWsQ, VVB5I5 = "#22003344", "#22002233"
   VV9cxb  = self.VVHwpV()
   VVQ4hk = self.VVG6Sn
   VVF79M = BF(self.VVTcrP, 1)
   VVXpo8 = ("Home Menu", FF5vVS)
   VVqj6y= ("Add to Menu", BF(CCTe4w.VVbEgw, self, True, self.VVy9Fm + "\t" + self.VVfHA5))
   VVGbyT = ("Bookmark", BF(CCTe4w.VVnCDW, self, True, self.VVy9Fm + "\t" + self.VVfHA5))
   VVhzhr = FFO9kU(self, None, title="Portal Resources (MAC=%s) %s" % (self.VVfHA5, dots), VV9cxb=VV9cxb, VVQ4hk=VVQ4hk, VVF79M=VVF79M, VVXpo8=VVXpo8, VVqj6y=VVqj6y, VVGbyT=VVGbyT, VVfWsQ=VVfWsQ, VVB5I5=VVB5I5)
   self.VVWMVe(VVhzhr)
 def VVG6Sn(self, item=None):
  if item:
   VVhzhr, title, ref, ndx = item
   if   ref == "live"   : mode = "itv"
   elif ref == "vod"   : mode = "vod"
   elif ref == "series"  : mode = "series"
   elif ref == "accountInfo" : mode = ""
   if mode : FF7iMz(VVhzhr, BF(self.VVfkTw, mode), title="Reading Categories ...")
   else : FF7iMz(VVhzhr, BF(self.VVCvpZ, VVhzhr, title), title="Reading Account ...")
 def VVCvpZ(self, VVhzhr, title, forceMoreInfo=False):
  rows, totCols = self.VVaTZG(forceMoreInfo)
  title = "%s (MAC=%s)" % (title, self.VVfHA5)
  VVjW3s  = ("Home Menu" , FF5vVS           , [])
  VVwqVu  = None
  if VVSm4H:
   VVwqVu = ("Get JS"  , BF(self.VVAZuB, self.VVi62k()) , [])
  if totCols == 2:
   VViMvb = None
   header   = ("Subject" , "Value" )
   widths   = (43   , 57  )
   VVMBr1  = 0
  else:
   VViMvb = ("More Info.", BF(self.VV5pjB, VVhzhr)    , [])
   header   = ("Num", "User/Server" , "Subject" , "Value" )
   widths   = (0 , 15   , 35  , 50  )
   VVMBr1  = 2
  FFCXsL(self, None, title=title, width=1200, header=header, VVXpNQ=rows, VV8boH=widths, VVPYL1=26, VVjW3s=VVjW3s, VVwqVu=VVwqVu, VViMvb=VViMvb, VVfWsQ="#0a00292B", VVB5I5="#0a002126", VVYCun="#0a002126", VVmErq="#00000000", VVMBr1=VVMBr1)
 def VVAZuB(self, url, VVAIxO, title, txt, colList):
  FF7iMz(VVAIxO, BF(self.VVeXph, url), title="Getting JS ...")
 def VVeXph(self, url):
  txt  = "// Host\t: %s\t%s\n" % (url, self.VVfHA5)
  ver, err = self.VV0qqk(url)
  txt += "// Version\t: %s\n\n" % (ver or err)
  js , err = self.VV0qqk(url, isJsFile=True)
  if err: txt += "Error : %s" % err
  else  : txt += js
  FFSMJz(self, txt, title="JS Info", outputFileToSave="Server_xpcom.common.js")
 def VV5pjB(self, VVhzhr, VVAIxO, title, txt, colList):
  VVAIxO.cancel()
  FF7iMz(VVhzhr, BF(self.VVCvpZ, VVhzhr, "Account Info.", forceMoreInfo=True), title="Reading Account ...")
 def VVfkTw(self, mode):
  token, profile, tErr = self.VVOnvR()
  if not token:
   return
  res, err = self.VVgit8(self.VV1CxE(mode))
  list = []
  if not err:
   try:
    tDict = jLoads(res.text)
    if tDict:
     chList = tDict["js"]
     for item in chList:
      Id   = FFSlBO(item, "id"       )
      Title  = FFSlBO(item, "title"      )
      censored = FFSlBO(item, "censored"      )
      Title = self.VVoWRq(Title)
      if Title:
       isAll = Title.strip().lower() in ("all", "all channels")
       if not isAll or isAll and VVIlCj:
        list.append((Title.strip(), Id))
   except:
    pass
  title = self.VV2bkQ(mode)
  if list:
   list.sort(key=lambda x: x[0].lower())
   self.VV5UUF = dict([(x[1], x[0]) for x in list])
   VVfWsQ, VVB5I5, VVYCun, VVmErq = self.VVq4P3(mode)
   mName = self.VV2bkQ(mode)
   VVDPcX  = (""     , BF(self.VVAlU7, mode), [])
   VVj7lw   = ("Show List"   , BF(self.VVWNkS, mode)   , [])
   VVjW3s  = ("Home Menu"   , FF5vVS        , [])
   if mode in ("vod", "series"):
    VV46TD = ("Find in %s" % mName , BF(self.VVQFP8, mode, False), [])
    VViMvb = ("Find in Selected" , BF(self.VVQFP8, mode, True) , [])
   else:
    VV46TD = None
    VViMvb = None
   header   = None
   widths   = (100   , 0  )
   FFCXsL(self, None, title=title, width=1200, header=header, VVXpNQ=list, VV8boH=widths, VVPYL1=30, VVjW3s=VVjW3s, VV46TD=VV46TD, VViMvb=VViMvb, VVDPcX=VVDPcX, VVj7lw=VVj7lw, VVfWsQ=VVfWsQ, VVB5I5=VVB5I5, VVYCun=VVYCun, VVmErq=VVmErq, VVAGe1=CFG.lastFindIptv)
  else:
   s = "Authorization failed"
   if err:
    txt = err
   elif s in res.text:
    txt = s
    if self.VV6Dbe:
     txt += "\n\n( %s )" % self.VV6Dbe
   else:
    txt = "Could not get Categories from server!"
   FFbBGq(self, txt, title=title)
 def VVrib2(self, mode, VVAIxO, title, txt, colList):
  FF7iMz(VVAIxO, BF(self.VVtpIy, mode, VVAIxO, title, txt, colList), title="Downloading ...")
 def VVtpIy(self, mode, VVAIxO, title, txt, colList):
  token, profile, tErr = self.VVOnvR()
  if not token:
   return
  VVGHs6 = colList[1]
  catID  = colList[2]
  res, err = self.VVgit8(self.VVTKvN(catID))
  list = []
  if not err:
   try:
    tDict = jLoads(res.text)
    if tDict:
     chList = tDict["js"]['data']
     for item in chList:
      Id    = FFSlBO(item, "id"    )
      actors   = FFSlBO(item, "actors"   )
      added   = FFSlBO(item, "added"   )
      age    = FFSlBO(item, "age"    )
      category_id  = FFSlBO(item, "category_id"  )
      description  = FFSlBO(item, "description"  )
      director  = FFSlBO(item, "director"   )
      genres_str  = FFSlBO(item, "genres_str"  )
      name   = FFSlBO(item, "name"    )
      path   = FFSlBO(item, "path"    )
      screenshot_uri = FFSlBO(item, "screenshot_uri" )
      series   = FFSlBO(item, "series"   )
      cmd    = FFSlBO(item, "cmd"    )
      cmd    = cmd.replace("ffmpeg ", "")
      for episode in eval(series):
       list.append((VVGHs6, name, str(episode), category_id, Id, added, age, cmd, director, genres_str, actors, description, screenshot_uri, path))
   except:
    pass
  if list:
   list.sort(key=lambda x: (x[1], int(x[2])))
   VVfWsQ, VVB5I5, VVYCun, VVmErq = CCTe4w.VVq4P3("")
   VVDPcX = (""     , BF(self.VVpF63, mode, True)  , [])
   VVj7lw  = ("Play"    , BF(self.VV6m5S, mode)       , [])
   VVmolf = (""     , BF(self.VV40DN, mode)     , [])
   VVjW3s = ("Home Menu"   , FF5vVS            , [])
   VVwqVu = ("Download Options" , BF(self.VVTkzM, mode, "sp", VVGHs6) , [])
   VV46TD = ("Options"   , BF(self.VV2si0, "pEp", mode, VVGHs6) , [])
   VViMvb = ("Posters Mode"  , BF(self.VV9P8h, mode, True)      , [])
   header   = ("Name" , "Season" , "Episode" , "catID" , "ID" , "Added" , "Age" , "cmd" , "Director", "Genre" , "Actors" , "Description" , "Screenshot" , "Path")
   widths   = (65  , 20  , 15  , 0   , 0   , 0.01 , 0.01 , 0  , 0.01  , 0.01  , 0   , 0    , 0    , 0  )
   VV4Uoc  = (LEFT  , LEFT  , CENTER , LEFT  , LEFT  , LEFT , LEFT , LEFT , LEFT  , LEFT  , LEFT  , LEFT   , LEFT   , LEFT )
   FFCXsL(self, None, title=VVGHs6, width=1200, header=header, VVXpNQ=list, VV4Uoc=VV4Uoc, VV8boH=widths, VVPYL1=26, VVDPcX=VVDPcX, VVj7lw=VVj7lw, VVmolf=VVmolf, VVjW3s=VVjW3s, VVwqVu=VVwqVu, VV46TD=VV46TD, VViMvb=VViMvb, VVAGe1=CFG.lastFindIptv, VVfWsQ=VVfWsQ, VVB5I5=VVB5I5, VVYCun=VVYCun, VVmErq=VVmErq)
  else:
   FFbBGq(self, "Could not get Episodes from server!", title=VVGHs6)
 def VVQFP8(self, mode, searchInCat, VVAIxO, title, txt, colList):
  searchCatId = colList[1].strip() if searchInCat else ""
  VV9cxb = []
  VV9cxb.append(("Keyboard"  , "manualEntry"))
  VV9cxb.append(("From Filter" , "fromFilter"))
  FFO9kU(self, BF(self.VV7W5Q, VVAIxO, mode, searchCatId), title="Input Type", VV9cxb=VV9cxb, width=400)
 def VV7W5Q(self, VVAIxO, mode, searchCatId, item=None):
  if item == "manualEntry":
   FFANcN(self, BF(self.VVyxHs, VVAIxO, mode, searchCatId), defaultText=CFG.lastFindIptv.getValue(), title="Find", message="Enter Name (or names separated by a comma)")
  elif item == "fromFilter":
   filterObj = CCuHRT(self)
   filterObj.VVaNK8(BF(self.VVyxHs, VVAIxO, mode, searchCatId))
 def VVyxHs(self, VVAIxO, mode, searchCatId, item):
  if not item is None:
   searVVUwmk = item.strip()
   FFBWtx(CFG.lastFindIptv, searVVUwmk)
   title = self.VVHNUV(mode, searVVUwmk)
   if "," in searVVUwmk : FFbBGq(self, "Use only one word to search in Portal Servers !\n\nRemove the comma.", title=title)
   elif len(searVVUwmk) < 3: FFbBGq(self, "Enter at least 3 characters.", title=title)
   else     :
    if CFG.hideIptvServerAdultWords.getValue() and self.VVJ6GT([searVVUwmk]):
     FFbBGq(self, self.VVhVMo(), title=title)
    else:
     self.VVCPnH(mode, searVVUwmk, "", searVVUwmk, searchCatId)
 def VVWNkS(self, mode, VVAIxO, title, txt, colList):
  bName = colList[0].strip()
  catID = colList[1].strip()
  self.curPortalCatId = catID
  self.VVCPnH(mode, bName, catID, "", "")
 def VVCPnH(self, mode, bName, catID, searVVUwmk, searchCatId):
  CCV3Gw.VVgWD3(self, VVN6I4="Reading from server"
      , VVuSHu  = BF(self.VV2hkN, mode, bName, catID, searVVUwmk, searchCatId)
      , VVhK3C = BF(self.VVEvsG, mode, bName, catID, searVVUwmk, searchCatId))
 def VVEvsG(self, mode, bName, catID, searVVUwmk, searchCatId, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  if searVVUwmk : title = self.VVHNUV(mode, searVVUwmk)
  else   : title = "%s : %s" % (self.VV2bkQ(mode), bName)
  if VVL8uX:
   VVwqVu = None
   VV46TD = None
   if mode == "series":
    VVfWsQ, VVB5I5, VVYCun, VVmErq = self.VVq4P3("series2")
    VVj7lw  = ("Episodes"   , BF(self.VVrib2, mode)           , [])
   else:
    VVfWsQ, VVB5I5, VVYCun, VVmErq = self.VVq4P3("")
    VVj7lw  = ("Play"    , BF(self.VV6m5S, mode)           , [])
    VVwqVu = ("Download Options" , BF(self.VVTkzM, mode, "vp" if mode == "vod" else "", "") , [])
    VV46TD = ("Options"   , BF(self.VV2si0, "pCh", mode, bName)      , [])
   VVDPcX = (""      , BF(self.VVpF63, mode, False)      , [])
   VVmolf = (""      , BF(self.VVRFMV, mode)         , [])
   VVjW3s = ("Home Menu"    , FF5vVS                , [])
   VViMvb = ("Posters Mode"   , BF(self.VV9P8h, mode, False)         , [])
   header   = ("Num" , "Name", "catID", "genreID" , "Icon", "cmd" , "Cat./Genre" , "Logo", "play", "actors" , "descr" , "director", "Catch-up")
   widths   = (9  , 50  , 0   , 0     , 0  , 0  , 25   , 6  , 0  , 0   , 0   , 0   , 10  )
   VV4Uoc  = (CENTER, LEFT  , CENTER , CENTER  , LEFT , LEFT , LEFT   , CENTER, LEFT , LEFT  , LEFT  , LEFT  , CENTER )
   VVAIxO = FFCXsL(self, None, title=title, header=header, VVXpNQ=VVL8uX, VV4Uoc=VV4Uoc, VV8boH=widths, VVPYL1=26, VVjW3s=VVjW3s, VVwqVu=VVwqVu, VV46TD=VV46TD, VViMvb=VViMvb, VVAGe1=CFG.lastFindIptv, VVj7lw=VVj7lw, VVDPcX=VVDPcX, VVmolf=VVmolf, VVfWsQ=VVfWsQ, VVB5I5=VVB5I5, VVYCun=VVYCun, VVmErq=VVmErq, VVoNmU=True, VVMBr1=1)
   if not VV6ZvL:
    if not threadCounter == threadTotal:
     tot = " (Stopped at %d of %d) " % (threadCounter, threadTotal)
     VVAIxO.VVuSAP(VVAIxO.VVAjLb() + tot)
    if threadErr: FFoTZI(VVAIxO, "Error while reading !", 2000)
    else  : FFoTZI(VVAIxO, "Stopped at channel %s" % threadCounter, 1000)
  else:
   if searVVUwmk : FFbBGq(self, "Could not find names with:\n\n%s" % searVVUwmk, title=title)
   else   : FFbBGq(self, "Could not get list from server !", title=title)
 def VVRFMV(self, mode, VVAIxO, title, txt, colList):
  ttl = lambda x, y: "%s:\n%s\n\n" % (FFKrMM(x, VVk4x7), str(y)) if y.strip() and not "N/A" in y else ""
  tab = lambda x, y: "%s\t: %s\n" % (x, y) if y.strip() and not "N/A" in y else ""
  Num, Name, catID, genreID, Icon, cmd, Cat_Genre, Logo, play, actors, descr, director, arch = colList
  txt  = tab("Number"  , Num)
  txt += tab("Name"  , Name)
  txt += tab("Category" , self.VV5UUF.get(genreID, ""))
  txt += tab("Cat./Genre" , Cat_Genre)
  txt += tab("Director" , director)
  txt += "\n"
  txt += ttl("Actors"  , actors)
  txt += ttl("Description", descr)
  play = play.strip()
  if play and not play.startswith("[No "):
   txt += ttl("Cur. Playing", play)
  if mode == "series":
   VVUwmk = colList[1]
   VVuPzU = colList[4]
   txt  = "%s\n\n%s" % (title, txt)
   CCpebE.VV1v7b(self, VV6tGM=CCpebE.VV5H8C, params=(VVUwmk, txt, VVuPzU))
  else:
   self.VVGMGw(mode, VVAIxO, title, txt, colList)
 def VV40DN(self, mode, VVAIxO, title, txt, colList):
  txt += "\n"
  txt += "Actors:\n%s\n\n" % FFKrMM(colList[10], VV0p9P)
  txt += "Description:\n%s" % FFKrMM(colList[11], VV0p9P)
  self.VVGMGw(mode, VVAIxO, title, txt, colList)
 def VVGMGw(self, mode, VVAIxO, title, txt, colList):
  VVUwmk, catID, stID, chNum, chCm, serCode, serId, VVuPzU = self.VV864t(mode, colList)
  VVq9SN, chUrl = self.VVaJI6(self.VVy9Fm, self.VVfHA5, mode, VVUwmk, catID, stID, chNum, chCm, serCode, serId)
  txt = "%s\n\n%s" % (title, txt)
  CCpebE.VV1v7b(self, VV6tGM=CCpebE.VVjPkL, params=(VVq9SN, chUrl, VVUwmk, txt, VVuPzU))
 def VV2hkN(self, mode, bName, catID, searVVUwmk, searchCatId, VVqeT6):
  try:
   token, profile, tErr = self.VVOnvR()
   if not token:
    return
   if VVqeT6.isCancelled:
    return
   VVqeT6.VVL8uX, total_items, max_page_items, err = self.VVJCIZ(mode, catID, 1, 1, searVVUwmk, searchCatId)
   if VVqeT6.isCancelled:
    return
   if VVqeT6.VVL8uX and total_items > -1 and max_page_items > -1:
    VVqeT6.VVfT17(total_items)
    VVqeT6.VVqE9L(max_page_items, True)
    pages = int(iCeil(float(total_items) / float(max_page_items)))
    total_items = pages
    for i in range(pages - 1):
     if VVqeT6.isCancelled:
      return
     page = i + 2
     counter = (i + 1) * max_page_items + 1
     list, total_items, max_page_items, err = self.VVJCIZ(mode, catID, page, counter, searVVUwmk, searchCatId)
     if err:
      VVqeT6.VVY97Z()
     if VVqeT6.isCancelled:
      return
     if list:
      VVqeT6.VVL8uX += list
      VVqeT6.VVqE9L(len(list), True)
  except:
   pass
 def VVJCIZ(self, mode, catID, page, counter, searVVUwmk, searchCatId):
  list = []
  total_items = max_page_items = -1
  if searVVUwmk : url = self.VVIy07(mode, searVVUwmk, searchCatId, page)
  else   : url = self.VVfk6b(mode, catID, page)
  res, err = self.VVgit8(url)
  if not err:
   try:
    tDict = jLoads(res.text)
    if tDict:
     item = tDict["js"]
     total_items  = self.VVByj1(FFSlBO(item, "total_items"  ))
     max_page_items = self.VVByj1(FFSlBO(item, "max_page_items" ))
     chList = tDict["js"]['data']
     cmdStr = "http://localhost/ch/"
     for item in chList:
      Id    = FFSlBO(item, "id"     )
      name   = FFSlBO(item, "name"     )
      o_name   = FFSlBO(item, "o_name"    )
      category_id  = FFSlBO(item, "category_id"   )
      tv_genre_id  = FFSlBO(item, "tv_genre_id"   )
      number   = FFSlBO(item, "number"    ) or str(counter)
      logo   = FFSlBO(item, "logo"     )
      screenshot_uri = FFSlBO(item, "screenshot_uri"  )
      pic    = FFSlBO(item, "pic"     )
      cmd    = FFSlBO(item, "cmd"     )
      censored  = FFSlBO(item, "censored"    )
      genres_str  = FFSlBO(item, "genres_str"   )
      curPlay   = FFSlBO(item, "cur_playing"   )
      actors   = FFSlBO(item, "actors"    )
      descr   = FFSlBO(item, "description"   )
      director  = FFSlBO(item, "director"    )
      archive   = FFSlBO(item, "archive"    )
      archDur   = FFSlBO(item, "tv_archive_duration" )
      catID   = category_id or tv_genre_id
      arch = "Yes" if archive == "1" else ""
      if archDur:
       if archDur.isdigit():
        tot = int(archDur)
        if tot > 0: arch = "%s hour%s" % (tot, FFaRsj(tot))
       else:
        arch = archDur
      name = o_name or name
      if " " in cmd :
       cmd = cmd.split(" ")[1].strip()
      if mode == "itv" and not cmdStr in cmd and not cmd.endswith(".m3u8") and not "ffrt" in cmd:
       if ("token=" in cmd and "d=Mag" in cmd) or "AuthToken=" in cmd or "play_token=" in cmd:
        cmd = "Zz1" + FFaC9A(cmd)
       else:
        span = iSearch(r"stream=(.+)&", cmd)
        if span:
         cmd = "%s%s_" % (cmdStr, span.group(1))
        else:
         span = iSearch(r".+\/.+\/.+\/(.+)", cmd)
         if span:
          cmd = "%s%s_" % (cmdStr, span.group(1))
      if   logo.startswith("http")   : picon = logo
      elif pic.startswith("http")    : picon = pic
      elif screenshot_uri.startswith("http") : picon = screenshot_uri
      else         : picon = logo or screenshot_uri or pic
      sp = "/stalker_portal"
      if picon.startswith(sp):
       picon = (self.VVy9Fm + picon).replace(sp * 2, sp)
      isIcon = "Yes" if picon.startswith("http") else ""
      counter += 1
      name = self.VVYMFT(name, censored=censored)
      if name:
       list.append((number, name, Id, catID, picon, cmd, genres_str, isIcon, curPlay, actors, descr, director, arch))
   except:
    err = "Channel Parse Error !"
  return list, total_items, max_page_items, err
 def VVByj1(self, valStr):
  try:
   return int(valStr)
  except:
   return -1
 def VV6m5S(self, mode, VVAIxO, title, txt, colList):
  VVUwmk, catID, stID, chNum, chCm, serCode, serId, VVuPzU = self.VV864t(mode, colList)
  VVq9SN, chUrl = self.VVaJI6(self.VVy9Fm, self.VVfHA5, mode, VVUwmk, catID, stID, chNum, chCm, serCode, serId)
  if self.VVs8ai(VVUwmk):
   FFoTZI(VVAIxO, "This is a marker!", 300)
  else:
   chUrl = CC6V53.VVZOQd(self, chUrl)
   VVHkge = os.path.join(self.VVR5UG(mode), os.path.basename(VVuPzU)) if VVuPzU else ""
   CCsmqb.VVlIAT(self.session, VVu1kk=(self, VVAIxO, mode), VVdxJv=chUrl, VVHkge=VVHkge)
 def VV1cmR(self, mode, VVAIxO, colList):
  VVUwmk, catID, stID, chNum, chCm, serCode, serId, VVuPzU = self.VV864t(mode, colList)
  VVq9SN, chUrl = self.VVaJI6(self.VVy9Fm, self.VVfHA5, mode, VVUwmk, catID, stID, chNum, chCm, serCode, serId)
  VVHkge = os.path.join(self.VVR5UG(mode), os.path.basename(VVuPzU)) if VVuPzU else ""
  return VVUwmk, chUrl, VVHkge
 def VV864t(self, mode, colList):
  if mode == "series":
   VVUwmk = colList[0]
   season = colList[1]
   serCode = colList[2]
   catID = colList[3]
   serId = colList[4]
   chCm = colList[7]
   VVuPzU = colList[12]
   VVUwmk = "%s (%s - %s)" % (VVUwmk, season, serCode)
   chNum = serCode
   stID = serId.replace(":", "_")
  else:
   chNum = colList[0]
   VVUwmk = colList[1]
   stID = colList[2]
   catID = colList[3]
   VVuPzU = colList[4]
   chCm = colList[5]
   serCode = ""
   serId = ""
  return VVUwmk.strip(), catID.strip(), stID.strip(), chNum.strip(), chCm.strip(), serCode.strip(), serId.strip(), VVuPzU.strip()
 @staticmethod
 def VVZTHq(SELF, install=True, cbFnc=None):
  try:
   import requests
   return True
  except:
   if install:
    title = 'Install "Requests"'
    VV9cxb = []
    VV9cxb.append((title        , "inst" ))
    VV9cxb.append(("Update Packages then %s" % title , "updInst" ))
    FFO9kU(SELF, BF(CC6V53.VVJ5pX, SELF, cbFnc=cbFnc), title='This requires Python "Requests" library', VV9cxb=VV9cxb)
   return False
 @staticmethod
 def VVJ5pX(SELF, item=None, cbFnc=None):
  if item:
   cmdUpd = FFMXCy(VVEuxp)
   if cmdUpd:
    cmdInst = FF4zTV(VVw2da, "python-requests")
    if pyVersion[0] >= 3:
     cmdInst = cmdInst.replace("python-", "python3-")
    if   item == "inst"  : cmd = cmdInst
    elif item == "updInst" : cmd = cmdUpd + " && " + cmdInst
    FF6NKJ(SELF, cmd, VVAH4n=True, title='Installing "Requests" Library', VVu7vM=cbFnc)
   else:
    FFWaiD(SELF)
 def VVg3i8(self):
  valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = self.VVjhBj(CCZv30(self.session).VVadS0)
  return mode, host, catID, stID, epNum.replace("%3a", ":"), epId.replace("%3a", ":")
 def VVWMVe(self, VVhzhr):
  curMode, curHost, curCat, curStID, curEpNum, curEpId = self.VVg3i8()
  if all((curMode, curHost, curCat)) and curHost == self.VVy9Fm:
   VVhzhr.VVhINX({"itv": 0, "vod": 1, "series": 2}.get(curMode, 0))
 def VVAlU7(self, mode, VVAIxO, title, txt, colList):
  curMode, curHost, curCat, curStID, curEpNum, curEpId = self.VVg3i8()
  if all((curMode, curHost, curCat)) and curMode == mode and curHost == self.VVy9Fm:
   VVAIxO.VV5rHa({1:curCat})
 def VVpF63(self, mode, isEp, VVAIxO, title, txt, colList):
  curMode, curHost, curCat, curStID, curEpNum, curEpId = self.VVg3i8()
  if all((curMode, curHost, curCat)) and curCat == self.curPortalCatId and curMode == mode and curHost == self.VVy9Fm:
   if mode in ("itv", "vod"):
    VVAIxO.VV5rHa({2:curStID})
   else: #series
    if isEp:
     VVAIxO.VV5rHa({2:curEpNum, 4:curEpId})
    elif mode == "series":
     ser1 = curEpId.split(":")[0]
     ser2 = "%s:%s" % (ser1, ser1)
     ok = VVAIxO.VV5rHa({2:ser2})
     if not ok: VVAIxO.VV5rHa({2:ser1})
 @staticmethod
 def VVpTiv(VVadS0):
  span = iSearch(r"(mode=.+)&chCm=.+&end=:(.+)", VVadS0, IGNORECASE)
  if span : return span.group(1), span.group(2)
  else : return "", ""
 @staticmethod
 def VVZOQd(SELF, chUrl):
  VVq9SN, VVadS0, VVjgtq, VVVmGQ, VVUwmk = FFLlAM(SELF)
  phpPart1, VVUwmk1 = CC6V53.VVpTiv(VVadS0)
  phpPart2, VVUwmk2 = CC6V53.VVpTiv(FF5ov5(chUrl))
  return None if phpPart1 and (phpPart1, VVUwmk1) == (phpPart2, VVUwmk2) else chUrl
class CCTe4w(Screen, CC6V53, CConSF, CCQyUl):
 VVYE4d    = 0
 VVWxw2    = 1
 VVeADz    = 2
 VVfkiI    = 3
 VV9249     = 4
 VVRNIa     = 5
 VVMU8e     = 6
 VVoF9l     = 7
 VVgGGC     = 8
 VVf4Lc     = 9
 VVnkFI      = 10
 VV3O2Y     = 11
 VVQ1PW     = 12
 VVMyll     = 13
 VVfYqZ     = 14
 VVdpsN      = 15
 VVdgEy      = 16
 VV0WrW      = 17
 VV4IhP      = 18
 VVQmfz      = 19
 VVEP1S    = 0
 VVqyuy   = 1
 VVdqLS   = 2
 VVeQf7   = 3
 VViW4p  = 4
 VVZ7NZ  = 5
 VV9a1K   = 6
 VVciGe   = 7
 VV2SEW  = 8
 VVXjU5  = 9
 VVy7Q5  = 10
 def __init__(self, session):
  self.skin, self.VVmNvK = FFQaOH(VVNkG2, 970, 1050, 50, 40, 30, "#0a0a0a2a", "#0a0a0a1a", 28, VVcmdl=1)
  self.session     = session
  self.VVAIxO    = None
  self.VVRWJ8     = "Local IPTV Services"
  self.VVHAto    = {}
  self.VV8ds2 = False
  self.VVRxis   = CCTe4w.VVcN0J(atLeastOne=True)
  self.VV0wMr    = True
  self.VVy6Nm      = ""
  self.VVyf0w    = None
  self.VV5UUF     = {}
  CC6V53.__init__(self)
  CConSF.__init__(self)
  VV9cxb = self.VVBcmE()
  FFNhKZ(self, title="IPTV", VV9cxb=VV9cxb)
  FFmpyO(self, {"menu" : self.VVQeZK})
  self.onShown.append(self.VVf1Ra)
  self.onClose.append(self.onExit)
  self["myMenu"].onSelectionChanged.append(self.VVowAw)
  global VViaWx
  VViaWx = True
 def VVf1Ra(self):
  self["myMenu"].setList(self.VVBcmE())
  FFNUiO(self)
  FFeo1z(self)
  if self.VV0wMr:
   self.VV0wMr = False
   FFvJ8o(self["myMenu"])
   FFtWSy(self)
   self.VVv0x0()
   FFyWkH()
 def VVv0x0(self):
  qUrl, VVadS0, VVVmGQ = CCTe4w.VVKjeQ(self)
  if qUrl or "chCode" in VVVmGQ:
   for ndx, item in enumerate(self["myMenu"].list):
    if item[0] == "IPTV Server Browser (from Current Channel)" and len(item) > 1:
     self["myMenu"].moveToIndex(ndx)
     break
 def onExit(self):
  self["myMenu"].onSelectionChanged = []
  FF0JpZ("VViaWx")
 def VVowAw(self):
  if self["myMenu"].getCurrent()[1] in ("VVQogQ", "VVLQyhPortal") : self["keyMenu"].show()
  else                      : self["keyMenu"].hide()
 def VVQeZK(self):
  if self["myMenu"].getVisible():
   title, item = self["myMenu"].getCurrent()
   if   item == "VVQogQ" : confItem = CFG.favServerPlaylist
   elif item == "VVLQyhPortal" : confItem = CFG.favServerPortal
   else         : return
   url = confItem.getValue().strip().split()[0]
   title += (" : %s" % FFKrMM(CCTe4w.VVEUPG(url)[1], VVU4M8)) if url else ""
   FF6pUe(self, BF(self.VVE2Oi, confItem), "Remove from menu ?", title=title)
 def VVE2Oi(self, confItem):
  FFBWtx(confItem, "")
  self.VVf1Ra()
 def VVBcmE(self):
  fav1, fav2 = CFG.favServerPlaylist.getValue(), CFG.favServerPortal.getValue()
  c1 = VVWJEN
  VV9cxb = []
  if fav1: VV9cxb.append((c1 +  "Favourite Playlist Server"    , "VVQogQ" ))
  if fav2: VV9cxb.append((c1 +  "Favourite Portal Server"    , "VVLQyhPortal" ))
  VV9cxb.append(("IPTV Server Browser (from Playlists)"     , "VV6dOI_fromPlayList" ))
  VV9cxb.append(("IPTV Server Browser (from Portal List)"    , "VV6dOI_fromMac"  ))
  qUrl, VVadS0, VVVmGQ = CCTe4w.VVKjeQ(self)
  fromCurCond = qUrl or "chCode" in VVVmGQ
  VV9cxb.append(FFH04v("IPTV Server Browser (from Current Channel)", "VV6dOI_fromCurrChan", fromCurCond))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Local Servers & M3U Cache"       , "browser_localServ"  ))
  VV9cxb.append(("M3U/M3U8 File Browser"        , "VV21sD"   ))
  if self.VVRxis:
   VV9cxb.append(("IPTV Services (from Local Bouquets)"    , "iptvTable_all"   ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(FFH04v("Update Current Bouquet EPG/PIcons (from IPTV Server)", "VVmmMb", fromCurCond))
  if self.VVRxis:
   VV9cxb.append(VVbM5H)
   c1, c2 = VVv8b8, VVk4x7
   t1 = FFKrMM("auto-match names", VVWJEN)
   t2 = FFKrMM("from xml file"  , VVWJEN)
   VV9cxb.append((c1 + "Count Available IPTV Channels"    , "VVqvPC"    ))
   VV9cxb.append((c1 + "Copy EPG/PIcons between Channels (%s)" % t2 , "copyEpgPicons"   ))
   VV9cxb.append(VVbM5H)
   VV9cxb.append((c2 + "Share Reference with DVB Channels (%s)" % t2 , "renumIptvRef_fromFile" ))
   VV9cxb.append((c2 + "Share Reference with DVB Channels (%s)" % t1 , "VVnlAl" ))
   VV9cxb.append((VVU4M8 + "More Reference Tools ..."  , "VVtygw"   ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Reload Channels and Bouquets"       , "VV4Z9Q"   ))
  VV9cxb.append(VVbM5H)
  if not CClaHD.VVyZwz():
   VV9cxb.append(("Download Manager"         , "dload_stat"    ))
  else:
   VV9cxb.append(("Download Manager ... No downloads"    ,       ))
  return VV9cxb
 def VV5QnJ(self, item):
  self.VVy6Nm = ""
  tTitle = "Share Reference with DVB Service"
  if item is not None:
   if   item == "VVuVAm"   : self.VVuVAm()
   elif item == "VV7fkW" : self.VV7fkW()
   elif item == "VVzlUD" : FF6pUe(self, self.VVzlUD, "Change Current List References to Unique Codes ?")
   elif item == "VVdNx8_rows" : FF6pUe(self, BF(FF7iMz, self.VVAIxO, self.VVdNx8), "Change Current List References to Identical Codes ?")
   elif item == "VVqKk8"   : self.VVqKk8(tTitle)
   elif item == "VVHY9D"   : self.VVHY9D(tTitle)
   elif item == "VVQogQ" : self.VVLQyh(False)
   elif item == "VVLQyhPortal" : self.VVLQyh(True)
   elif item == "VV6dOI_fromPlayList" : self.VVgeMs(1)
   elif item == "VV6dOI_fromMac"  : self.VV1P5c()
   elif item == "VV6dOI_fromCurrChan" : self.VVjQpR()
   elif item == "browser_localServ"  : CCGSVa(self, CCGSVa.VVg57A)
   elif item == "VV21sD"   : self.VV21sD()
   elif item == "iptvTable_all"   : self.VVgXPi(self.VVYE4d)
   elif item == "VVmmMb" : CCTe4w.VVmmMb(self)
   elif item == "VVqvPC"    : self.VVqvPC()
   elif item == "copyEpgPicons"   : self.VVWvup(False)
   elif item == "renumIptvRef_fromFile" : self.VVWvup(True)
   elif item == "VVnlAl" : FF6pUe(self, BF(FF7iMz, self, self.VVnlAl), VVqg4G="Continue ?")
   elif item == "VVtygw"    : self.VVtygw()
   elif item == "VV4Z9Q"   : CC2Ekb.VV4Z9Q(self)
   elif item == "dload_stat"    : CClaHD.VVRi6O(self)
 def VVyuDa(self):
  item = FFgo5c(self)
  self.VV5QnJ(item)
 @FFJRPn("Loading Channels ...")
 def VVgXPi(self, mode):
  VVuGUx = self.VVmwDD(mode)
  if VVuGUx:
   bg = "#1b001121"
   VVwqVu = ("Current Service", self.VVS7Q8 , [])
   VV46TD = ("Options"  , self.VVtX10   , [])
   VViMvb = ("Filter"   , self.VVqEAD   , [])
   VVj7lw  = ("Play"   , BF(self.VV57T0)  , [])
   VVmolf = (""    , self.VVCyS9    , [])
   VVDPcX = (""    , self.VVfnsz     , [])
   header   = ("Num" , "Name", "Bouquet" , "Type", "Ref.", "URL" )
   widths   = (8  , 30 , 30  , 6  , 26 , 0  )
   VV4Uoc  = (CENTER , LEFT , LEFT  , CENTER, LEFT , LEFT )
   FFCXsL(self, None, header=header, VVXpNQ=VVuGUx, VV4Uoc=VV4Uoc, VV8boH=widths, width=1750, height=1000, VVPYL1=25
     , VVj7lw=VVj7lw, VVwqVu=VVwqVu, VV46TD=VV46TD, VViMvb=VViMvb, VVmolf=VVmolf, VVDPcX=VVDPcX
     , VVfWsQ=bg, VVB5I5=bg, VVYCun=bg, VVmErq="#11004a55", VVoNmU=True, VVMBr1=1)
  else:
   if mode == self.VVf4Lc: err = "No Live IPTV channels !"
   else       : err = "No IPTV channels !"
   FFbBGq(self, err)
 def VVfnsz(self, VVAIxO, title, txt, colList):
  self.VVAIxO = VVAIxO
 def VVtX10(self, VVAIxO, title, txt, colList):
  VV9cxb = []
  VV9cxb.append(("Add Current List to a New Bouquet"     , "VVuVAm"  ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(FFH04v("Delete Current List (from all Bouquets)" , "VV7fkW" , VVAIxO.VVAjLb().startswith("Filter:"), VVdLWL))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Change Current List References to Unique Codes" , "VVzlUD"))
  VV9cxb.append(("Change Current List References to Identical Codes", "VVdNx8_rows" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Share Reference with DVB Service (manual entry)" , "VVqKk8"   ))
  VV9cxb.append(("Share Reference with DVB Service (auto-find)"  , "VVHY9D"   ))
  FFO9kU(self, self.VV5QnJ, title="IPTV Tools", VV9cxb=VV9cxb)
 def VVqEAD(self, VVAIxO, title, txt, colList):
  FF7iMz(VVAIxO, BF(self.VVdX58, VVAIxO))
 def VVdX58(self, VVAIxO):
  VV9cxb = []
  VV9cxb.append(("All"         , "all"   ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Prefix of Selected Channel"   , "sameName" ))
  VV9cxb.append(("Suggest Words from Selected Channel" , "partName" ))
  VV9cxb.append(("Names with Non-English Characters" , "nonEnglish" ))
  VV9cxb.append(("Duplicate References"     , "depRef"  ))
  VV9cxb.append(("Reference x:x:x:x:0:0:0:0:0:0:"  , "ref00"  ))
  VV9cxb.append(("Stream Relay"       , "SRelay"  ))
  VV9cxb.append(FFT7cF("Category"))
  VV9cxb.append(("Live"         , "live"  ))
  VV9cxb.append(("VOD"         , "vod"   ))
  VV9cxb.append(("Series"        , "series"  ))
  VV9cxb.append(("Uncategorised"      , "uncat"  ))
  VV9cxb.append(FFT7cF("Media"))
  VV9cxb.append(("Video"        , "video"  ))
  VV9cxb.append(("Audio"        , "audio"  ))
  VV9cxb.append(FFT7cF("File Type"))
  VV9cxb.append(("MKV"         , "MKV"   ))
  VV9cxb.append(("MP4"         , "MP4"   ))
  VV9cxb.append(("MP3"         , "MP3"   ))
  VV9cxb.append(("AVI"         , "AVI"   ))
  VV9cxb.append(("FLV"         , "FLV"   ))
  VV9cxb.extend(CC8i1k.VVtTm6(prefix="__b__", onlyIptv=True))
  inFilterFnc = BF(self.VVHdSm, VVAIxO) if VVAIxO.VVAjLb().startswith("Filter:") else None
  filterObj = CCuHRT(self)
  filterObj.VVMz7Q(VV9cxb, VV9cxb, BF(self.VVAbg0, VVAIxO, False), inFilterFnc=inFilterFnc)
 def VVHdSm(self, VVAIxO, VVhzhr, item):
  self.VVAbg0(VVAIxO, True, item)
 def VVAbg0(self, VVAIxO, inFilter, item=None):
  self.VV8ds2 = inFilter
  prefix = VVAIxO.VVYmuZ(1).split(" ")[0]
  if item is not None:
   if   item == "all"    : mode, words, title = self.VVYE4d , ""  , self.VVRWJ8
   elif item == "sameName"   : mode, words, title = self.VVWxw2 , prefix , prefix + " ..."
   elif item == "partName"   : mode, words, title = self.VVeADz , ""  , ""
   elif item == "nonEnglish"  : mode, words, title = self.VVfkiI , ""  , "Names with Non-English Characters"
   elif item == "depRef"   : mode, words, title = self.VVMU8e  , ""  , "Duplicate References"
   elif item == "ref00"   : mode, words, title = self.VVoF9l  , ""  , "Reference x:x:x:x:0:0:0:0:0:0:"
   elif item == "SRelay"   : mode, words, title = self.VVgGGC  , ""  , "Stream Relay"
   elif item == "live"    : mode, words, title = self.VVf4Lc  , ""  , "Live"
   elif item == "vod"    : mode, words, title = self.VVnkFI   , ""  , "VOD"
   elif item == "series"   : mode, words, title = self.VV3O2Y  , ""  , "Series"
   elif item == "uncat"   : mode, words, title = self.VVQ1PW  , ""  , "Uncategorised"
   elif item == "video"   : mode, words, title = self.VVMyll  , ""  , "Video"
   elif item == "audio"   : mode, words, title = self.VVfYqZ  , ""  , "Audio"
   elif item == "MKV"    : mode, words, title = self.VVdpsN   , ""  , "MKV"
   elif item == "MP4"    : mode, words, title = self.VVdgEy   , ""  , "MP4"
   elif item == "MP3"    : mode, words, title = self.VV0WrW   , ""  , "MP3"
   elif item == "AVI"    : mode, words, title = self.VV4IhP   , ""  , "AVI"
   elif item == "FLV"    : mode, words, title = self.VVQmfz   , ""  , "FLV"
   elif item.startswith("__b__") : mode, words, title = self.VV9249  , item[5:] , item[5:]
   elif item.startswith("__w__") : mode, words, title = self.VVRNIa  , item[5:] , item[5:]
   else       : return
  if mode != self.VVYE4d:
   tTitle = "Filter: "
   if mode == self.VV9249:
    tTitle += " Bouquet = "
   title = tTitle + FFKrMM(title, VVWH8U)
  if len(title) > 85:
   title = title[:85] + ".."
  if mode == self.VVeADz:
   VV9cxb = []
   VVUwmk = VVAIxO.VVYmuZ(1)
   if VVUwmk:
    list = set()
    for match in iFinditer(r"((?:[^\x00-\x7F]+\s*)+)", VVUwmk, IGNORECASE):
     list.add(match.group(1).strip())
    if list:
     for match in iFinditer(r"(\w+)", VVUwmk, IGNORECASE):
      list.add(match.group(1).strip())
    words = VVUwmk.split(" ")
    tWord = ""
    for word in words:
     tWord += " " + word
     list.add(word.strip())
     list.add(tWord.strip())
    for item in sorted(list):
     if item:
      VV9cxb.append((item, item))
    if not VV9cxb and VVUwmk:
     VV9cxb.append((VVUwmk, VVUwmk))
    FFO9kU(self, self.VVW1IU, VV9cxb=VV9cxb)
   else:
    VVAIxO.VV2t5o("Invalid Channel Name")
  else:
   words, asPrefix = CCuHRT.VVzdEZ(words)
   if not words and mode in (self.VV9249, self.VVRNIa):
    FFoTZI(self.VVAIxO, "Incorrect filter", 2000)
   else:
    self.VVyf0w = BF(FF7iMz, self.VVAIxO, BF(self.VVbgpP, mode, words, asPrefix, title), clearMsg=False, title="Filtering ...")
    self.VVyf0w()
 def VVW1IU(self, word=None):
  if word:
   title = "Filter: %s" % FFKrMM(word, VVWH8U)
   self.VVyf0w = BF(FF7iMz, self.VVAIxO, BF(self.VVbgpP, self.VVeADz, [word.lower()], False, title), clearMsg=False, title="Filtering ...")
   self.VVyf0w()
 @staticmethod
 def VV6Gyk(txt):
  return "#f#11ffff00#" + txt
 def VVbgpP(self, mode, words, asPrefix, title):
  if self.VV8ds2 : VVuGUx = self.VVIYPG(mode=mode, words=words, asPrefix=asPrefix)
  else       : VVuGUx = self.VVmwDD(mode=mode, words=words, asPrefix=asPrefix)
  if VVuGUx:
   self.VVAIxO.VVEEBV(VVuGUx, title)
   return True
  else:
   self.VVAIxO.VV2t5o("Not found")
   return False
 def VVIYPG(self, mode=0, words=None, asPrefix=False):
  VVuGUx = []
  for row in self.VVAIxO.VVGpBN():
   row = list(map(str.strip, row))
   chNum, VVUwmk, VVsvsL, chType, VVq9SN, url = row
   if self.VVG5R3(mode, VVq9SN, FF5ov5(url).lower(), VVUwmk, words, VVsvsL.lower(), asPrefix):
    VVuGUx.append(row)
  VVuGUx = self.VVQYSV(mode, VVuGUx)
  return VVuGUx
 def VVmwDD(self, mode=0, words=None, asPrefix=False, isStripChan=False):
  patt = r"#SERVICE\s+([A-Fa-f0-9]+:0:(?:[A-Fa-f0-9]+[:]){8})(http.+)\n#DESCRIPTION\s+"
  if isStripChan: patt += r"[^\x00-\x7F]*(.+)[^\x00-\x7F]*"
  else    : patt += r"(.+)"
  VVuGUx = []
  files = CCTe4w.VVcN0J()
  if files:
   chNum = 1
   for path in files:
    if path.endswith("radio"): chType = "Radio"
    else      : chType = "TV"
    txt = FFmx8y(path)
    span = iSearch(r"#NAME\s(.+)", txt, IGNORECASE)
    if span : VVsvsL = span.group(1)
    else : VVsvsL = ""
    VVsvsL_lCase = VVsvsL.lower()
    for match in iFinditer(patt, txt, IGNORECASE):
     VVq9SN = match.group(1).upper()
     url  = match.group(2).strip()
     VVUwmk = match.group(3).strip()
     if self.VVs8ai(VVUwmk): VVawls = self.VV6Gyk(VVUwmk)
     else        : VVawls = VVUwmk
     row = (str(chNum), VVawls, VVsvsL, chType + (" SRel" if FFKeSw(url) else ""), VVq9SN, url)
     if self.VVG5R3(mode, VVq9SN, FF5ov5(url).lower(), VVUwmk, words, VVsvsL_lCase, asPrefix):
      VVuGUx.append(row)
      chNum += 1
  VVuGUx = self.VVQYSV(mode, VVuGUx)
  return VVuGUx
 def VVQYSV(self, mode, VVuGUx):
  newRows = []
  if VVuGUx and mode == self.VVMU8e:
   counted  = iCounter(elem[4] for elem in VVuGUx)
   for item in VVuGUx:
    tot = counted.get(item[4], 0)
    if tot > 1:
     newRows.append(item)
   return newRows
  else:
   return VVuGUx
 def VVG5R3(self, mode, VVq9SN, tUrl, VVUwmk, words, VVsvsL_lCase, asPrefix):
  if   mode == self.VVYE4d : return True
  elif mode == self.VVMU8e : return True
  elif mode == self.VVoF9l  : return ":0:0:0:0:0:0:" in VVq9SN
  elif mode == self.VVgGGC : return FFKeSw(tUrl)
  elif mode == self.VVMyll  : return CCTe4w.VVqy70(tUrl, getAudVid=True) == "vid"
  elif mode == self.VVfYqZ  : return CCTe4w.VVqy70(tUrl, getAudVid=True) == "aud"
  elif mode == self.VVf4Lc  : return CCTe4w.VVqy70(tUrl, compareType="live")
  elif mode == self.VVnkFI  : return CCTe4w.VVqy70(tUrl, compareType="vod")
  elif mode == self.VV3O2Y : return CCTe4w.VVqy70(tUrl, compareType="series")
  elif mode == self.VVQ1PW  : return CCTe4w.VVqy70(tUrl, compareType="")
  elif mode == self.VVdpsN  : return CCTe4w.VVqy70(tUrl, compareExt="mkv")
  elif mode == self.VVdgEy  : return CCTe4w.VVqy70(tUrl, compareExt="mp4")
  elif mode == self.VV0WrW  : return CCTe4w.VVqy70(tUrl, compareExt="mp3")
  elif mode == self.VV4IhP  : return CCTe4w.VVqy70(tUrl, compareExt="avi")
  elif mode == self.VVQmfz  : return CCTe4w.VVqy70(tUrl, compareExt="flv")
  elif mode == self.VVWxw2: return VVUwmk.lower().startswith(words[0])
  elif mode == self.VVeADz: return words[0] in VVUwmk.lower()
  elif mode == self.VVfkiI: return bool(iSearch(r"[^\x00-\x7F]", VVUwmk))
  elif mode == self.VV9249 : return words[0] == VVsvsL_lCase
  elif mode == self.VVRNIa :
   name = VVUwmk.lower()
   for word in words:
    if asPrefix:
     if name.startswith(word) : return True
    elif word in name    : return True
  return False
 def VVuVAm(self):
  picker = CC8i1k(self, self.VVAIxO, "Add to Bouquet", self.VVlhDc)
 def VVlhDc(self):
  chUrlLst = []
  for row in self.VVAIxO.VVGpBN():
   chUrlLst.append(row[4] + row[5])
  return chUrlLst
 def VV7fkW(self):
  tot = self.VVAIxO.VVM62I()
  FF6pUe(self, self.VVlmo0, "Delete %s IPTV Channel%s ?" % (tot, FFaRsj(tot)))
 def VVlmo0(self):
  bFiles = CCTe4w.VVcN0J()
  if not bFiles:
   FFoTZI(self.VVAIxO, "No bouquets files !", 1500)
   return
  totRows = self.VVAIxO.VVM62I()
  if not totRows:
   FFoTZI(self.VVAIxO, "Cannot read list", 1500)
   return
  CCV3Gw.VVgWD3(self, VVN6I4="Renumbering References", VV32kU=CCV3Gw.VVQFxC, totBars=2
      , VVuSHu  = BF(self.VVSjDt, totRows, bFiles)
      , VVhK3C = self.VVpVQ6 )
 def VVSjDt(self, totRows, bFiles, VVqeT6):
  totDel = totBouq = 0
  VVqeT6.VVfT17(len(bFiles))
  VVqeT6.VVH2AI(totRows)
  VVqeT6.VVL8uX = (totRows, totDel, totBouq)
  for path in bFiles:
   if not VVqeT6 or VVqeT6.isCancelled:
    return
   if FFKbVo(path):
    toSave = False
    txt  = FFmx8y(path)
    span = iSearch(r"#NAME\s+(.+)", txt, IGNORECASE)
    if span : bName = span.group(1)
    else : bName = os.path.splitext(os.path.basename(path))[0]
    VVqeT6.VVX5nT("%s   %s" % (totDel, bName))
    VVqeT6.VVqE9L(1)
    VVqeT6.VVuDjj(0)
    for row in self.VVAIxO.VVGpBN():
     if not VVqeT6 or VVqeT6.isCancelled:
      return
     VVqeT6.VVpqYW(1)
     ref = row[4] + row[5]
     if ref in txt:
      txt, tot = iSubn(r"(#SERVICE\s+%s\n#DESCRIPTION.+\n?)" % iEscape(ref), "", txt)
      if tot > 0:
       totDel += tot
       VVqeT6.VVL8uX = (totRows, totDel, totBouq)
       toSave = True
    if toSave:
     totBouq += 1
     VVqeT6.VVL8uX = (totRows, totDel, totBouq)
     with open(path, "w") as f:
      f.write(txt)
 def VVpVQ6(self, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  totRows, totDel, totBouq = VVL8uX
  if totBouq:
   FFANYL()
   txt  = "Channels\t: %s\n" % totRows
   txt += "Deleted\t: %s   (from %s bouquet%s)" % (totDel, totBouq, FFaRsj(totBouq))
   FFSMJz(self, txt, VVhK3C=BF(FF7iMz, self.VVAIxO or self, self.VVWPc7, clearMsg=False))
  else:
   FF0onH(self, "No changes.")
 def VVWPc7(self):
  if self.VVAIxO:
   if not self.VVyf0w():
    if not self.VVbgpP(self.VVYE4d, "", False, "Local IPTV Services"):
     self.VVAIxO.cancel()
 def VVtygw(self):
  t1 = FFKrMM("Bouquet" , VVk4x7)
  t2 = FFKrMM("ALL"  , VVU4M8)
  t3 = FFKrMM("Unique"  , VVv8b8)
  t4 = FFKrMM("Identical" , VVWJEN)
  VV9cxb = []
  VV9cxb.append((VVWH8U + "Check System Acceptable Reference Types", "VV3dN2"))
  VV9cxb.append(FFH04v("Check Reference Codes Format", "VVMf6Y", self.VVRxis, VVWH8U))
  VV9cxb.append(VVbM5H)
  txt = "Change %s Ref. Types to (1/4097/5001/5002/8192/8193/8793) .."
  VV9cxb.append((txt % t1, "VVrzwz" ))
  VV9cxb.append((txt % t2, "VVo1h3_all"  ))
  VV9cxb.append(VVbM5H)
  txt = "Change %s References to %s Codes .."
  VV9cxb.append((txt % (t1, t3), "VVLhC9" ))
  VV9cxb.append((txt % (t2, t3), "VVsUHr"  ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Change %s References to %s Codes" % (t2, t4) , "VVdNx8_all"))
  VVQ4hk = self.VVy7Yh
  FFO9kU(self, None, width=1220, title="IPTV Reference Tools", VV9cxb=VV9cxb, VVQ4hk=VVQ4hk, VVfWsQ="#22002233", VVB5I5="#22001122")
 def VVy7Yh(self, item=None):
  if item:
   ques = "Continue ?"
   VVhzhr, txt, item, ndx = item
   if   item == "VV3dN2"    : FF7iMz(VVhzhr, self.VV3dN2)
   elif item == "VVMf6Y"     : FF7iMz(VVhzhr, self.VVMf6Y)
   elif item == "VVrzwz" : self.VVkkO3(VVhzhr, self.VVl8B3)
   elif item == "VVo1h3_all"  : self.VVl8B3(VVhzhr, None, None)
   elif item == "VVLhC9" : self.VVLhC9(VVhzhr, txt)
   elif item == "VVsUHr"  : FF6pUe(self, BF(self.VVsUHr , VVhzhr, txt), title=txt, VVqg4G=ques)
   elif item == "VVdNx8_all"  : FF6pUe(self, BF(FF7iMz, VVhzhr, self.VVdNx8), title=txt, VVqg4G=ques)
 def VVl8B3(self, VVhzhr, bName, bPath):
  VV9cxb = []
  for rt in CCTe4w.VVnWJ1():
   VV9cxb.append(("%s\t ... %s" % (rt, CCTe4w.VV4iUL(rt)), rt))
  FFO9kU(self, BF(self.VV76jJ, VVhzhr, bName, bPath), VV9cxb=VV9cxb, width=800, title="Change Reference Types to:")
 def VV76jJ(self, VVhzhr, bName, bPath, rType=None):
  if rType:
   self.VVkJZ7(VVhzhr, bName, bPath, rType)
 def VVkkO3(self, VVhzhr, fnc):
  VV9cxb = CC8i1k.VVtTm6()
  if VV9cxb:
   FFO9kU(self, BF(self.VVkkcA, VVhzhr, fnc), VV9cxb=VV9cxb, title="IPTV Bouquets", VVDkqE=True)
  else:
   FFoTZI(VVhzhr, "No bouquets Found !", 1500)
 def VVkkcA(self, VVhzhr, fnc, item=None):
  if item:
   bName, bRef, ndx = item
   span = iSearch(r'BOUQUET "(.+)" ORDER', bRef, IGNORECASE)
   if span:
    bPath = VVgVTn + span.group(1)
    if FFKbVo(bPath): fnc(VVhzhr, bName, bPath)
    else    : FFoTZI(VVhzhr, "Bouquet file not found!", 2000)
   else:
    FFoTZI(VVhzhr, "Cannot process bouquet !", 2000)
 def VVkJZ7(self, VVhzhr, bName, bPath, rType):
  if bPath: title = "Change for Bouquet : %s" % FFKrMM(bName, VVjojy)
  else : title = "Change for %s" % FFKrMM("All IPTV Services", VVjojy)
  FF6pUe(self, BF(FF7iMz, VVhzhr, BF(self.VVfbY5, VVhzhr, bName, bPath, rType), title="Changing Type ...")
    , "Change to : %s ?" % FFKrMM(rType, VVjojy), title=title)
 def VVfbY5(self, VVhzhr, bName, bPath, rType):
  totChange = 0
  if bPath: files = [bPath]
  else : files = CCTe4w.VVcN0J()
  if files:
   newRType = rType + ":"
   piconPath = CCRGqC.VV5G3P()
   for path in files:
    if   not FFKbVo(path)      : err = "Cannot read the file:\n\n%s" % path
    elif not CC17eA.VV9kj1(self, path) : err = "File is not in 'UTF-8' Encoding:\n\n%s" % path
    else           : err = ""
    if err:
     FFbBGq(self, err)
     return
    newpFile = path + ".tmp"
    totMod = 0
    with open(newpFile, "w") as tFile:
     with ioOpen(path, "r", encoding="utf-8") as f:
      for line in f:
       span = iSearch(r"#SERVICE\s+([A-Fa-f0-9]+[:]).+http.+", line)
       if span:
        oldRType = span.group(1)
        if not oldRType == newRType:
         totMod += 1
         totChange += 1
         span = iSearch(r"((?:[A-Fa-f0-9]+[:]){10})", line)
         if span : oldPicon = piconPath + span.group(1).strip(":").replace(":", "_") + ".png"
         else : oldPicon = ""
         line = iSub(r"(#SERVICE)\s+[A-Fa-f0-9]+[:](.+http.+)", r"\1 %s\2" % newRType, line)
         if FFKbVo(oldPicon):
          span = iSearch(r"((?:[A-Fa-f0-9]+[:]){10})", line)
          if span:
           FFlonU("mv -f '%s' '%s'" % (oldPicon, piconPath + span.group(1).strip(":").replace(":", "_") + ".png"))
       tFile.write(line)
    if totMod: cmd = "mv -f '%s' '%s'" % (newpFile, path)
    else  : cmd = "rm -f '%s'" % newpFile
    FFlonU(cmd)
  self.VVzCNj(totChange > 0, 'Change Ref. Codes to "%s"' % rType, "Changes = %d" % totChange)
 @FFJRPn()
 def VVqvPC(self):
  totFiles = 0
  files  = CCTe4w.VVcN0J()
  if files:
   totFiles = len(files)
  totChans = 0
  VVuGUx = self.VVmwDD()
  if VVuGUx:
   totChans = len(VVuGUx)
  FFSMJz(self, "Total Files\t: %d\nTotal Channels\t: %d" % (totFiles, totChans))
 def VVMf6Y(self):
  files = CCTe4w.VVcN0J()
  if files:
   totInvalid = 0
   invTxt  = ""
   for path in files:
    txt = FFmx8y(path)
    for match in iFinditer(r"#SERVICE\s+(?!(?:(?:[A-Fa-f0-9]+[:]){10})).+\n#DESCRIPTION\s+(.+)", txt, IGNORECASE):
     totInvalid += 1
     invTxt += "%s\t: %s\n" % (os.path.basename(path), match.group(1))
   if totInvalid == 0 : color = VVOQkl
   else    : color = VVdLWL
   totInvalid = FFKrMM(totInvalid, color)
   txt  = "Processed Files\t\t: %d\n" % len(files)
   txt += "Invalid References\t: %s\n" % totInvalid
   if invTxt:
    txt += FFKrMM("\nInvalid Refrences (File & Chan. Name):\n", color)
    txt += invTxt
  else:
   txt = "No IPTV Files processed."
  FFSMJz(self, txt, title="Check IPTV References")
 def VV3dN2(self):
  bName  = "%s_IPTV_TMP_BOUQUET_DEL" % PLUGIN_NAME
  userBName = "userbouquet.%s.tv"  % bName
  chPrefix = "Testing RType "
  rTypeList = CCTe4w.VVnWJ1()
  chUrlLst = []
  for rType in (rTypeList):
   ref = "%s:0:1:DDD:DDD:DDD:DDD:0:0:0:http%%3a//testUrl.com/aa/bb.m3u8:Testing RType %s" % (rType, rType)
   chUrlLst.append(ref)
  CC8i1k.VVWTLg(self, "", bName, "", chUrlLst, showRes=False)
  acceptedList = []
  VVbPr6 = eServiceReference('1:7:1:0:0:0:0:0:0:0:FROM BOUQUET "%s" ORDER BY bouquet' % userBName)
  if VVbPr6:
   VV50QG = FFM85b(VVbPr6)
   if VV50QG:
    for service in VV50QG:
     VVUwmk = service[1]
     acceptedList.append(VVUwmk.replace(chPrefix, ""))
  path = VVgVTn + userBName
  bFile = VVgVTn + "bouquets.tv"
  tmpF = bFile + ".tmp"
  cmd = FFQWwc("grep -v '%s' '%s' > '%s'; mv '%s' '%s'" % (userBName, bFile, tmpF, tmpF, bFile))
  cmd += FFQWwc("rm -f '%s'" % path)
  FFlonU(cmd)
  FFANYL()
  title = "System Acceptable Reference Types"
  if acceptedList:
   txt = ""
   for item in rTypeList:
    if item in acceptedList : res, color = "Yes", VVOQkl
    else     : res, color = "No" , VVdLWL
    pl = CCTe4w.VV4iUL(item)
    txt += "    %s\t: %s%s\n" % (item, FFKrMM(res, color), FFKrMM("\t... %s" % pl, VV0p9P) if pl else "")
   FFSMJz(self, txt, title=title)
  else:
   txt = FFbBGq(self, "Could not complete the test on your system!", title=title)
 def VVnlAl(self):
  VVNFGd, err = CC2Ekb.VVTefV(self, CC2Ekb.VVPiun)
  if VVNFGd:
   totChannels = 0
   totChange = 0
   for path in CCTe4w.VVcN0J():
    toSave = False
    txt = FFmx8y(path)
    for match in iFinditer(r"(#SERVICE\s+[A-Fa-f0-9]+:)0:(?:[A-Fa-f0-9]+[:]){8}(.+\n#DESCRIPTION\s+(?:.+[:()|\]\[])*(.+))", txt, IGNORECASE):
     totChannels += 1
     VVUwmk = match.group(3).strip(" !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~")
     VVq9SN = VVNFGd.get(VVUwmk, "")
     if VVq9SN:
      VVq9SN  = VVq9SN[VVq9SN.index(":") + 1:]
      toSave  = True
      totChange += 1
      txt = txt.replace(match.group(0), match.group(1) + VVq9SN + ":" + match.group(2))
    if toSave:
     with open(path, "w") as f:
      f.write(txt)
   txt  = "Channels\t: %d\n" % totChannels
   txt += "Changed\t: %d\n" % totChange
   self.VVzCNj(totChange > 0, "Copy Ref. from existing Channels", txt)
  else:
   FFbBGq(self, 'No channels in "lamedb" !')
 def VVsUHr(self, VVhzhr, title):
  bFiles = CCTe4w.VVcN0J()
  if bFiles: self.VVVVl4(bFiles, title)
  else  : FFoTZI(VVhzhr, "No bouquets files !", 1500)
 def VVLhC9(self, VVhzhr, title):
  self.VVkkO3(VVhzhr, BF(self.VVxJB7, title))
 def VVxJB7(self, title, VVhzhr, bName, bPath):
  self.VVVVl4([bPath], title)
 def VVVVl4(self, bFiles, title):
  CCV3Gw.VVgWD3(self, VVN6I4="Renumbering References"
      , VVuSHu  = BF(self.VVeFxS, bFiles)
      , VVhK3C = BF(self.VV1vbC, title))
 def VVeFxS(self, bFiles, VVqeT6):
  VVqeT6.VVL8uX = ""
  VVqeT6.VVX5nT("Calculating Reference ...")
  totLines = 0
  patt = r"#SERVICE\s+(?:[A-Fa-f0-9]+[:]){10}(.+\/\/.+)"
  for path in bFiles:
   if FFKbVo(path):
    lines = FF2kXa(path)
    for line in lines:
     span = iSearch(patt, line)
     if span:
      totLines += 1
  if not VVqeT6 or VVqeT6.isCancelled:
   return
  elif not totLines:
   VVqeT6.VVL8uX = "No IPTV Services !"
   return
  else:
   VVqeT6.VVfT17(totLines)
  rType = CFG.iptvAddToBouquetRefType.getValue()
  startId = startNS = 0
  for path in bFiles:
   if not VVqeT6 or VVqeT6.isCancelled:
    return
   if FFKbVo(path):
    toSave = False
    bName  = os.path.basename(path)
    lines  = FF2kXa(path)
    for ndx, line in enumerate(lines):
     if not VVqeT6 or VVqeT6.isCancelled:
      return
     if ndx == 0:
      span = iSearch(r"#NAME\s+(.+)", line, IGNORECASE)
      if span:
       bName = span.group(1)
      if VVqeT6:
       VVqeT6.VVX5nT("Processing : %s " % bName)
     span = iSearch(patt, line)
     if span:
      if VVqeT6:
       VVqeT6.VVqE9L(1)
      VVq9SN, startId, startNS = CC8i1k.VV3nfz(rType, CC8i1k.VVVr1v, [], startId, startNS)
      if VVq9SN:
       lines[ndx] = "#SERVICE %s" % (VVq9SN + span.group(1))
       toSave = True
      else:
       if VVqeT6:
        VVqeT6.VVL8uX = "Out of Free References while processing the file:\n%s" % path
       return
    if toSave:
     with open(path, "w") as f:
      f.write("\n".join(lines) + "\n")
 def VV1vbC(self, title, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  txt  = "Found\t: %d\n"  % threadTotal
  txt += "Changed\t: %d\n" % threadCounter
  if VVL8uX:
   txt += "\n\n%s\n%s" % (FFKrMM("Ended with Error:", VVdLWL), VVL8uX)
  self.VVzCNj(True, title, txt)
 def VVzlUD(self):
  bFiles = CCTe4w.VVcN0J()
  if not bFiles:
   FFoTZI(self.VVAIxO, "No bouquets files !", 1500)
   return
  tableRefList = []
  for row in self.VVAIxO.VVGpBN():
   tableRefList.append((row[4], row[5]))
  if not tableRefList:
   FFoTZI(self.VVAIxO, "Cannot read list", 1500)
   return
  CCV3Gw.VVgWD3(self, VVN6I4="Renumbering References"
      , VVuSHu  = BF(self.VVIoL1, bFiles, tableRefList)
      , VVhK3C = BF(self.VV1vbC, "Change Current List References to Unique Codes"))
 def VVIoL1(self, bFiles, tableRefList, VVqeT6):
  VVqeT6.VVL8uX = ""
  VVqeT6.VVX5nT("Reading System References ...")
  refLst = CC8i1k.VVXaQN(CC8i1k.VVVr1v, stripRType=True)
  if not VVqeT6 or VVqeT6.isCancelled:
   return
  VVqeT6.VVfT17(len(tableRefList))
  rType = CFG.iptvAddToBouquetRefType.getValue()
  startId = startNS = 0
  for path in bFiles:
   if not VVqeT6 or VVqeT6.isCancelled:
    return
   if FFKbVo(path):
    toSave = False
    bName = os.path.basename(path)
    txt  = FFmx8y(path)
    span = iSearch(r"#NAME\s+(.+)", txt, IGNORECASE)
    if span:
     bName = span.group(1)
    if not VVqeT6 or VVqeT6.isCancelled:
     return
    VVqeT6.VVX5nT("Processing : %s " % bName)
    for ref, url in tableRefList:
     if not VVqeT6 or VVqeT6.isCancelled:
      return
     VVZWTf = ref + url
     if VVZWTf in txt:
      VVqeT6.VVqE9L(1)
      VVq9SN, startId, startNS = CC8i1k.VV3nfz(rType, CC8i1k.VVVr1v, refLst, startId, startNS)
      if VVq9SN:
       tot = txt.count(VVZWTf)
       if tot > 0:
        txt = txt.replace(VVZWTf, VVq9SN + url)
        toSave = True
      else:
       if VVqeT6:
        VVqeT6.VVL8uX = "Out of Free References while processing the file:\n%s" % path
       return
    if toSave:
     with open(path, "w") as f:
      f.write(txt)
 def VVdNx8(self):
  list = None
  if self.VVAIxO:
   list = []
   for row in self.VVAIxO.VVGpBN():
    list.append(row[4] + row[5])
  files = CCTe4w.VVcN0J()
  totChange = 0
  if files:
   for path in files:
    lines = FF2kXa(path)
    toSave = False
    for ndx, line in enumerate(lines):
     span = iSearch(r"#SERVICE\s+(.+\/\/.+)", line, IGNORECASE)
     if span:
      if not list or span.group(1) in list:
       txt, tot = iSubn(r"(#SERVICE\s+(?:[A-Fa-f0-9]+[:]){3})(?:[A-Fa-f0-9]+[:]){7}(.+\/\/.+)", r"\g<1>%s\2" % ("0:" * 7), line, IGNORECASE)
       if tot > 0:
        lines[ndx] = txt
        toSave  = True
        totChange += 1
    if toSave:
     with open(path, "w") as f:
      f.write("\n".join(lines) + "\n")
  self.VVzCNj(totChange > 0, "Change to Identical Ref. Codes", "Changes = %d" % totChange)
 def VVzCNj(self, isChanged, title, txt, refreshTable=True):
  if isChanged:
   FFANYL()
   if refreshTable and self.VVAIxO:
    VVuGUx = self.VVmwDD()
    if VVuGUx and self.VVAIxO:
     self.VVAIxO.VVEEBV(VVuGUx, self.VVRWJ8)
     self.VVAIxO.VV2t5o(txt)
   FFSMJz(self, txt, title=title)
  else:
   FF0onH(self, "No changes.")
 @staticmethod
 def VVcN0J(atLeastOne=False, onlyFileName=False):
  types = ('*.tv', '*.radio')
  files = []
  for f in types:
   files.extend(iGlob(VVgVTn + f))
  if files:
   iptvFiles = []
   for path in files:
    if FFKbVo(path):
     txt = FFmx8y(path)
     span = iSearch(r"#SERVICE.+\/\/.+\n#DESCRIPTION.+", txt, IGNORECASE)
     if span:
      iptvFiles.append(os.path.basename(path) if onlyFileName else path)
      if atLeastOne:
       return iptvFiles
   return iptvFiles
  else:
   return None
 def VVCyS9(self, VVAIxO, title, txt, colList):
  Num, Name, Bouquet, Type, Ref, URL = VVAIxO.VVQDwi()
  VVadS0 = FF5ov5(URL)
  VVVmGQ = "%s:%s" % (Ref.rstrip(":"), URL.rstrip(":"))
  if not VVVmGQ.endswith(":" + Name):
   VVVmGQ += ":" + Name
  txt  = "%s\n\n" % title
  txt += "Name\t: %s\n" % FFKrMM(Name, VVk4x7)
  txt += "Bouquet\t: %s\n" % Bouquet
  txt += CCpebE.VVLKHh(FF5ov5(VVVmGQ), showUrl=False)
  CCpebE.VV1v7b(self, VV6tGM=CCpebE.VVHHG8, params=(Ref, Name, txt, VVadS0, VVVmGQ))
 def VV6W8V(self, VVAIxO, colList):
  VVUwmk = colList[1]
  VVq9SN = colList[4]
  url  = colList[5]
  chUrl = VVq9SN + url
  return VVUwmk, chUrl
 def VV57T0(self, VVAIxO, title, txt, colList):
  VVUwmk, chUrl = self.VV6W8V(VVAIxO, colList)
  self.VV6H8p(VVAIxO, VVUwmk, chUrl, "localIptv")
 def VVpxAq(self, mode, VVAIxO, colList):
  VVUwmk, chUrl, VVuPzU, VVq9SN = self.VV9MVv(mode, colList)
  VVHkge = os.path.join(self.VVR5UG(mode), os.path.basename(VVuPzU)) if VVuPzU else ""
  return VVUwmk, chUrl, VVHkge
 def VVUeht(self, mode, VVAIxO, title, txt, colList):
  VVUwmk, chUrl, VVuPzU, VVq9SN = self.VV9MVv(mode, colList)
  VVHkge = os.path.join(self.VVR5UG(mode), os.path.basename(VVuPzU)) if VVuPzU else ""
  self.VV6H8p(VVAIxO, VVUwmk, chUrl, mode, VVHkge)
 def VV6H8p(self, VVAIxO, VVUwmk, chUrl, mode, VVHkge=""):
  VVUwmk = FFkEjh(VVUwmk)
  if self.VVs8ai(VVUwmk):
   FFoTZI(VVAIxO, "This is a marker!", 300)
  else:
   CCsmqb.VVlIAT(self.session, VVu1kk=(self, VVAIxO, mode), VVdxJv=chUrl, VVHkge=VVHkge, VV9m2C=mode == self.VVXjU5)
 @staticmethod
 def VVs8ai(VVUwmk):
  mark = ("--", "__", "==", "##",  "**", "_*", "*_", str(u"\u2605" * 2))
  if VVUwmk.startswith(mark) and VVUwmk.endswith(mark):
   return True
  return False
 def VVS7Q8(self, VVAIxO, title, txt, colList):
  VVq9SN, VVadS0, VVjgtq, VVVmGQ, VVUwmk = FFLlAM(self)
  if VVq9SN:
   url1 = FF5ov5(VVjgtq.strip())
   for ndx, row in enumerate(VVAIxO.VVGpBN()):
    if VVq9SN in row[4]:
     tableRow = FF5ov5(row[5].strip())
     if url1 in tableRow or tableRow in url1:
      VVAIxO.VVt5t9(ndx)
      break
   else:
    FFoTZI(VVAIxO, "Not found", 1000)
 def VV21sD(self):
  if CC6V53.VVZTHq(self):
   self.VVdC2G()
 @FFJRPn("Searching ...")
 def VVdC2G(self):
  lines = self.VV9dOm(3)
  if lines:
   lst = []
   for f in lines:
    if os.path.isfile(f):
     m3File, m3Dir, VV0Dqv, zPath, zFound = CCGSVa.VV4vqh(f)
     sz = FFLjtI(f)
     (m3SzT, m3Sz) = (CC17eA.VVxNgx(sz, mode=4), str(sz)) if sz > -1 else ("", "")
     m3Tm = zSz = ""
     if zFound:
      sz = FFLjtI(zPath)
      zSz = CC17eA.VVxNgx(sz, mode=4) if sz > -1 else ""
      if zSz: m3SzT = "#f#0066ff66#" + m3SzT
      m3Tm = CCGSVa.VVuhBT(zPath).srcMod
     lst.append((m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm))
   title = "M3U/M3U8 File Browser"
   if lst:
    lst.sort(key=lambda x: x[0].lower())
    bTitle = "Playlist Options"
    bg = "#11221122"
    VVpz29  = {3:2}
    VVj7lw  = ("Select"    , self.VV9jn5       , [])
    VVwqVu = ("Refresh File Cache" , self.VV4EEO    , [])
    VV46TD = ("File Options"  , self.VVfBV5       , [])
    VViMvb = (bTitle    , BF(self.VVSOMA, bTitle) , [])
    header   = ("File" , "Path", "Size","Size" , "zPath" , "Cached Size" , "m3Tm" )
    widths   = (50  , 38 , 0.02 , 12 , 0   , 0.01   , 0   )
    VV4Uoc  = (LEFT  , LEFT , CENTER, CENTER, CENTER , CENTER  , CENTER )
    tbl = FFCXsL(self, None, title=title, header=header, VVXpNQ=lst, VV4Uoc=VV4Uoc, VV8boH=widths, VVPYL1=26, VVpz29=VVpz29, VVj7lw=VVj7lw, VViMvb=VViMvb, VVwqVu=VVwqVu, VV46TD=VV46TD, VVfWsQ="#11221122", VVB5I5=bg, VVYCun=bg, VVmErq="#11004a55", VVK8UQ="#0a333333", VVgSJJ="#06333333")
    tbl.VVQ4nk(BF(self.VVv4ZZ, tbl))
   else:
    FFbBGq(self,"No files found." , title=title)
 def VV9jn5(self, VVAIxO, title, txt, colList):
  m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm = colList
  CCGSVa(VVAIxO, CCGSVa.VV0wZ1, m3uF=m3Dir+m3File, VVS4vP=BF(self.VVrLMW, VVAIxO))
 def VV4EEO(self, VVAIxO, title, txt, colList):
  m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm = colList
  if VVAIxO["keyGreen"].getVisible():
   CCGSVa(self, CCGSVa.VVauyS, m3uF=m3Dir+m3File, VVS4vP=BF(self.VVrLMW, VVAIxO))
 def VVfBV5(self, VVAIxO, title, txt, colList):
  m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm = colList
  VV9cxb = []
  VV9cxb.append(("Delete Selected File"   , "delm3u"))
  if zSz: VV9cxb.append(("Delete Local Cache" , "delZip"))
  FFO9kU(self, BF(self.VVgykD, VVAIxO, colList), title="File Options", VV9cxb=VV9cxb, width=700, VVDkqE=True)
 def VVgykD(self, VVAIxO, colList, item):
  if item:
   title, ref, ndx = item
   m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm = colList
   if  ref == "delm3u": path = m3Dir + m3File
   elif ref == "delZip": path = zPath
   FF6pUe(self, BF(self.VVJIiZ, VVAIxO, path, ref), "Delete ?\n\n%s" % path, title=title)
 def VVJIiZ(self, VVAIxO, path, ref):
  FFnE7j(path)
  if ref == "delm3u":
   if FFKbVo(path) : FFoTZI(VVAIxO, "No deleted", 1000)
   else    : VVAIxO.VVIB2X()
  elif ref == "delZip":
   self.VVrLMW(VVAIxO)
 def VVSOMA(self, Title, VVAIxO, title, txt, colList):
  m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm = colList
  VV9cxb = []
  VV9cxb.append(("Browse Selected Server Online"  , "br"))
  VV9cxb.append(("Filter Playlist URLs (from all Files)", "fl"))
  FFO9kU(self, BF(self.VVYFVl, VVAIxO, m3Dir+m3File), title=Title, VV9cxb=VV9cxb, width=700, VVDkqE=True)
 def VVYFVl(self, VVAIxO, path, item):
  if item:
   title, ref, ndx = item
   if  ref == "br": self.VVMSum(VVAIxO, title, path)
   elif ref == "fl": self.VVCtAV(VVAIxO)
 def VVrLMW(self, VVAIxO, *arg):
  m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm = VVAIxO.VVQDwi()
  sz = FFLjtI(zPath)
  zSz = CC17eA.VVxNgx(sz, mode=4) if sz > -1 else ""
  try: m3Tm = str(int(os.path.getmtime(m3Dir + m3File)))
  except: m3Tm = ""
  VVAIxO.VVsu0I((m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm))
  if zSz:
   fg = FFcUfR("#0066ff66")
   ndx = VVAIxO.VVoxea()
   VVAIxO.VVvqdM(ndx, 3, 8, fg)
   VVAIxO.VVvqdM(ndx, 3, 9, fg)
  self.VVv4ZZ(VVAIxO)
 def VVv4ZZ(self, VVAIxO):
  m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm = VVAIxO.VVQDwi()
  VVAIxO["keyGreen"].hide()
  if zSz and m3Tm:
   try: curTm = int(os.path.getmtime(m3Dir + m3File))
   except: curTm = ""
   if curTm and m3Tm != str(curTm):
    VVAIxO["keyGreen"].show()
 def VVCtAV(self, VVAIxO):
  CCV3Gw.VVgWD3(self, titleBg="#22003344", bodyBg="#22001122"
      , VVuSHu  = BF(self.VVDyZ4, VVAIxO)
      , VVhK3C = self.VV84ZT)
 def VVDyZ4(self, VVAIxO, VVqeT6):
  lst = []
  dupl = 0
  totF = VVAIxO.VVM62I()
  VVqeT6.VVfT17(totF)
  VVqeT6.VVL8uX = (totF, dupl, lst)
  for ndx, (m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm) in enumerate(VVAIxO.VVGpBN()):
   path = m3Dir + m3File
   if not VVqeT6 or VVqeT6.isCancelled: return
   VVqeT6.VVX5nT(os.path.basename(path))
   VVqeT6.VVqE9L(1)
   if FFKbVo(path):
    enc = CC6ntZ.VVC1NW(path)
    if not enc == -1:
     with ioOpen(path, "r", encoding=enc) as f:
      for line in f:
       if not VVqeT6 or VVqeT6.isCancelled: return
       line = str(line).strip()
       line, _, _ = line.partition("?")
       line, _, _ = line.partition("&")
       if len(line) < 500:
        url = CCTe4w.VVb6iw(line)
        if url:
         if not url in lst: lst.append(url)
         else    : dupl += 1
         VVqeT6.VVL8uX = (totF, dupl, lst)
         break
 def VV84ZT(self, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  title = "Create Playlist from m3u Files"
  totF, dupl, lst = VVL8uX
  if not lst:
   FFbBGq(self, "Could not obtain URLs from this file list !", title=title)
   return
  lst.sort()
  pListF = "%sPlaylist_%s.txt" % (FF5KK0(), FFRIlf())
  with open(pListF, "w") as f:
   for url in lst:
    f.write(url + "\n")
  txt = ""
  txt += "Total Files\t: %d\n" % totF
  txt += "Prcessed Files\t: %d\n" % threadCounter
  if dupl > 0: txt += "Duplicates\t: %d  (removed)\n" % dupl
  txt += "Created Lines\t: %d\n" % len(lst)
  txt += "Playlist File\t: %s" % pListF
  FFSMJz(self, txt, title=title)
 @FFJRPn("Searching ...")
 def VVgeMs(self, mode):
  if   mode == 1: title, okFnc = "Select Playlist File", self.VVramy
  elif mode == 2: title, okFnc = "Select Portal File"  , self.VVM9NN
  lines = self.VV9dOm(mode)
  if lines:
   lines.sort()
   VV9cxb = []
   for line in lines:
    VV9cxb.append((FFKrMM(line, VVk4x7) if "Bookmarks" in line else line, line))
   t = CCM6jS.VVy3nL(901 if mode==1 else 902) if mode in (1, 2) and VVSm4H else None
   VVF79M = self.VV67Ct
   VVWt1H = (VVk4x7 + t, BF(self.VVuSCc, mode, t)) if t else None
   VVGbyT = ("Merge All Files", BF(self.VVxXJX, mode)) if len(VV9cxb) > 1 else None
   FFO9kU(self, None, title=title, VV9cxb=VV9cxb, width=1700, height=900, VVQ4hk=okFnc, VVF79M=VVF79M, VVWt1H=VVWt1H, VVGbyT=VVGbyT, VV1NnQ="")
 def VV9dOm(self, mode):
  err = excl = ""
  dirs = []
  path = "/"
  if CFG.iptvHostsMode.getValue() == VV6RVR:
   excl = FFbt47(1)
  else:
   lst = list(set(list(map(str.strip, CFG.iptvHostsDirs.getValue().split(",")))))
   tList = []
   for Dir in lst:
    if VVkY7E(Dir):
     tList.append(Dir)
   lst = sorted(tList, key=len)
   for Dir in lst:
    for dir1 in dirs:
     if len(Dir) > len(dir1) and Dir.startswith(dir1):
      break
    else:
     dirs.append(Dir)
   if   len(dirs) == 1 : path = dirs[0]
   elif len(dirs) > 1 : path = "{%s}" % ",".join(dirs)
   if not dirs:
    FFbBGq(self, 'Directory not found !\n\nCheck your settings option:\n\n"IPTV Hosts Files Path (Playlist, Portal, M3U)"')
    return []
  if   mode == 1: par = r'\( -iname "*playlist*" -o -iname "*stalker*" -o -iname "*urlscan.io*" \) | grep -i "\.txt\|\.json"'
  elif mode == 2: par = r'\( -iname "*portal*" -o -iname "*stalker*" -o -iname "*urlscan.io*"  \) | grep -i "\.txt\|\.conf\|\.json"'
  elif mode == 3: par = r'-iname "*.m3u" -o -iname "*.m3u8" | grep -i "\.m3u\|\.m3u8"'
  files = FFQ1wB("find %s %s %s 2> /dev/null" % (path, excl, par))
  if files:
   err = CC17eA.VVUDvl(files)
   if err : FFbBGq(self, err + FFKrMM('\n\n( Change "IPTV Hosts Files Path" to "Custom" and try again )', VVk4x7))
   else : return files
  else:
   if   path == "/": txt = "!"
   elif dirs  : txt = "in directories listed in settings !"
   else   : txt = "in :\n%s" % path
   if   mode == 1: err = 'No Playlist files found %s\n\n Expecting ".txt" files\n(names must include the word "playlist")' % txt
   elif mode == 2: err = 'No portal files found %s\n\n Expecting ".txt" or ".conf" files\n(name must include the word "portal" or "stalker")' % txt
   elif mode == 3: err = 'No ".m3u" files found %s' % txt
   t = CCM6jS.VVy3nL(901 if mode==1 else 902) if mode in (1, 2) and VVSm4H else None
   if t: FF6pUe(self, BF(self.VVuSCc, mode, t), "%s ?" % t)
   else: FFbBGq(self, err)
  return []
 def VVxXJX(self, mode, VVhzhr, item):
  lst = VVhzhr.VVYjmx()
  title = "Merge %s files" % len(lst)
  w1 = w2 = ""
  for nm in lst:
   nm = nm.lower()
   if "playlist" in nm: w1 = "Playlist_"
   if "portal" in nm or "stalker" in nm: w2 = "Portal_"
  path = "%sMerged_%s%s%s.txt" % (FFJv8S(), w1, w2, FFRIlf())
  err = ""
  with open(path, "w") as outF:
   sep = "=" * 100
   c = 0
   try:
    for fil in lst:
     c += 1
     outF.write("#%s\nFile-%s: %s\n#%s\n" % (sep, c, fil, sep))
     outF.write("%s\n\n" % FFmx8y(fil).strip())
   except Exception as e:
    err = str(e)
  if err:
   FFnE7j(path)
   FFbBGq(self, "Error in:\n%s\n\n%s" % (fil, err), title=title)
  else:
   FF0onH(self, "Saved to:\n\n%s" % path, title=title)
   VVhzhr.VVisOz((path, path), isSort=True)
   VVhzhr.VVY6ij(path)
 def VVuSCc(self, mode, t, VVhzhr=None, item=None):
  if   mode == 1: fnc = self.VVeGos(t, VVhzhr)
  elif mode == 2: fnc = self.VVSyoR(t, VVhzhr)
 @FFJRPn(par=2)
 def VVeGos(self, title, VVhzhr):
  lst = []
  for i in range(100, 118): lst.append(CCM6jS.VVy3nL(i))
  try: l1, l2, l3, r, t, u, p, U, P, H, J, L, x1, x2, x3, x4, x5, x6 = lst
  except: return
  if not all(lst): return
  exp = iCompile(r".*(%s.+)\/.*%s=(.+)&%s=([^&]+)" % (H, U, P), IGNORECASE)
  lst, eLst, mT = set(), [], ""
  fTm = FFRIlf()
  for ndx, l in enumerate((l1, l2, l3), start=1):
   resp, txt, err = CCr0nV.VVyFjr(l, verify=True)
   if err:
    eLst.append(err)
   else:
    try: d = jLoads(txt)[r]
    except: d = {}
    for par in d:
     span = exp.search(str(par[t][u]))
     if span and all(span.groups()):
      lst.add(L % tuple([FF5ov5(x).strip() for x in span.groups()]))
   if VVSm4H > 1:
    mT += ("%s\n%s\n%s\n\n" % (l, resp.headers, "\n".join([("%s\t: %s" % (x.ljust(30), resp.headers.get(x, ""))) for x in (x1, x2, x3, x4, x5, x6)]))) if resp else ""
    with open("%s%s_%s_%s.%s" % (FFJv8S(), p, fTm, ndx, J), "w") as f: f.write(txt)
  if VVSm4H > 1:
   with open("%s%s_%s_0" % (FFJv8S(), p, fTm), "w") as f: f.write(mT)
  if lst  : self.VV4UuY(VVhzhr, None, "%s%s_%s.txt" % (FFJv8S(), p, fTm), [(u, "") for u in lst], False)
  elif eLst: FFbBGq(self, "\n\n".join(eLst), title=title)
  else  : FFbBGq(self, "Not found", title=title)
 @FFJRPn(par=2)
 def VVSyoR(self, title, VVhzhr):
  u, p = CCM6jS.VVy3nL(200), CCM6jS.VVy3nL(201)
  if not all(u and p): return
  resp, txt, err = CCr0nV.VVyFjr(u, verify=True)
  U = iFindall(r'"@id": "(.+\.html)"', txt, IGNORECASE) if resp else None
  lst = set()
  for u in U:
   resp, txt, err = CCr0nV.VVyFjr(u, verify=True)
   if not txt: continue
   txt = txt.replace("http", "\nhttp")
   for line in txt.split("\n"):
    span = iSearch(r"(http[^< ]+).+(?:[a-fA-F0-9]{2}:){5}[a-fA-F0-9]{2}", line)
    if span:
     u = span.group(1).partition("&")[0].partition("#")[0]
     for m in iFindall(r"((?:[a-fA-F0-9]{2}:){5}[a-fA-F0-9]{2})", line):
      lst.add(("0", "0", "-", u, m.upper(), "-"))
  if lst:
   lst = sorted(lst)
   outF = "%s%s_%s.txt" % (FFJv8S(), p, FFRIlf())
   if VVSm4H > 1:
    self.VV1QcC(None, None, outF, True, lst, len(lst))
   else:
    with open(outF, "w") as f:
     for _, _, _, h, m, _ in lst: f.write("%s\t%s\n" % (h, m))
    VVhzhr.VVisOz((outF, outF), isSort=True)
  else:
   FFbBGq(self, "Not found")
 def VV67Ct(self, VVhzhr, txt, ref, ndx):
  txt = ref
  sz = FFLjtI(ref)
  if sz > 0:
   txt += "\n\nSize: %s" % CC17eA.VVxNgx(sz)
  FFSMJz(self, txt, title="File Path")
 def VVramy(self, item=None):
  if item:
   VVhzhr, txt, path, ndx = item
   self.VVcTK1(VVhzhr, path)
 @FFJRPn(par=1)
 def VVcTK1(self, VVhzhr, path):
  enc = CC6ntZ.VVC1NW(path, self)
  if enc == -1:
   return
  num, lineNum, VVuGUx = 1, 0, []
  datePatt = iCompile(r"(?:(?:ends?|exp)(?:[\w]+))[: ]*(\d{4})[-_](\d{2})[-_](\d{2})(?:\s+(\d{2}):(\d{2}):(\d{2}))?", IGNORECASE)
  def VVkgSl(url, rem=""):
   if url:
    modified, uURL, uProtoc, uHost, uPort, uQuery, uUser, uPass, uQueryParam = CCTe4w.VVEUPG(url)
    uURL = uURL.rstrip("/")
    for item in VVuGUx:
     if item[2] == uURL and item[3] == uUser and item[4] == uPass:
      return 0
    span = datePatt.search(rem)
    c1 = ""
    if span:
     y, m, d, H, M, S = span.groups()
     H = int(H) if str(H).isdigit() else 0
     M = int(M) if str(M).isdigit() else 0
     S = int(S) if str(S).isdigit() else 0
     try:
      end = mktime(datetime(int(y), int(m), int(d), H, M, S).timetuple())
      c1 = "#f#00ff5555#" if iTime() > end else "#f#0055ff55#"
     except:
      c1 = "#f#00888888#"
    VVuGUx.append((str(len(VVuGUx)+1), str(lineNum), str(uURL), str(uUser), str(uPass), c1 + rem, url))
    return 1
   return 0
  title = "Get Play list URLs"
  with ioOpen(path, "r", encoding=enc) as f:
   if path.endswith(".json"):
    fTxt = f.read()
    try:
     data = jLoads(fTxt)
     for d in data:
      uURL, uUser, uPass, end = d.get("host", ""), d.get("username", ""), d.get("password", ""), d.get("end_date", "")
      rem = ("Ends: %s" % FFG6of(float(end))) if str(end).isdigit() else ""
      url = "%s/get.php?username=%s&password=%s&type=m3u" % (uURL, uUser, uPass) if all((uURL, uUser, uPass)) else ""
      num += VVkgSl(url, rem)
    except:
     try:
      exp = iCompile(r".*(http.+)\/.*username=(.+)&password=([^&]+)", IGNORECASE)
      for d in jLoads(fTxt)["results"]:
       span = exp.search(str(d["task"]["url"]))
       if span and all(span.groups()):
        uURL, uUser, uPass = [FF5ov5(x.strip()) for x in span.groups()]
        url = "%s/get.php?username=%s&password=%s&type=m3u" % (uURL, uUser, uPass) if all((uURL, uUser, uPass)) else ""
        num += VVkgSl(url)
     except Exception as e:
      FFbBGq(self, str(e), title=title)
      return
   else:
    l3 = []
    hstPatt = iCompile(r"(http?:\/\/[^\/]+)[^\s]+(?:\s+#(.+))?", IGNORECASE)
    usrPatt = iCompile(r"username\s*[=:]\s*(\S+)", IGNORECASE)
    pasPatt = iCompile(r"password\s*[=:]\s*(\S+)", IGNORECASE)
    for line in f:
     lineNum += 1
     line = str(line).strip()
     if not line or len(line) > 500:
      continue
     span = iSearch(r"(http.+php.+username=.+password=[^\s]+)(?:\s+#(.+))?", line, IGNORECASE)
     url = rem = ""
     if span:
      url = span.group(1)
      rem = span.group(2).strip() if span.group(2) else ""
     else:
      span = iSearch(r"(http.+)\s+username(.+)\s+password\s+([^\s]+)(?:\s+#(.+))?", line, IGNORECASE)
      if span:
       host = FF9Uvy(span.group(1).strip())
       user1 = span.group(2).strip()
       pass1 = span.group(3).strip()
       rem  = span.group(4).strip() if span.group(4) else ""
       url  = "%sget.php?username=%s&password=%s&type=m3u" % (host, user1, pass1)
     if url:
      l3 = []
     else:
      l3.append(line)
      if len(l3) > 3: l3.pop(0)
      if len(l3) == 3:
       spanH = hstPatt.search(l3[0])
       spanU = usrPatt.search(l3[1]) or usrPatt.search(l3[2])
       spanP = pasPatt.search(l3[2]) or pasPatt.search(l3[1])
       if spanH and spanU and spanP:
        host, user1, pass1 = spanH.group(1), spanU.group(1), spanP.group(1)
        rem = spanH.group(2).strip() if spanH.group(2) else ""
        if all((host, user1, pass1)): url = "%s/get.php?username=%s&password=%s&type=m3u" % (host, user1, pass1)
        l3 = []
     num += VVkgSl(url, rem)
  if VVuGUx:
   title = "Playlist File : %s" % os.path.basename(path)
   VVj7lw  = ("Start"    , BF(self.VVGqJv, "Playlist File")      , [])
   VVjW3s = ("Home Menu"   , FF5vVS             , [])
   VVwqVu = ("Server Resources" , self.VVG1tt     , [])
   VV46TD = ("Edit File"   , BF(self.VVfeEa, path)        , [])
   VViMvb = ("Check & Filter"  , BF(self.VVFE1O, VVhzhr, path) , [])
   header   = ("Num" , "LineNum" , "Address" , "User" , "Password" , "Remarks" , "URL" )
   widths   = (7  , 0   , 33  , 17  , 17   , 26  , 0.03 )
   VV4Uoc  = (CENTER , CENTER , LEFT  , LEFT   , LEFT   , LEFT  , LEFT  )
   FFCXsL(self, None, title=title, header=header, VVXpNQ=VVuGUx, VV4Uoc=VV4Uoc, VV8boH=widths, width=1800, height=1000, VVPYL1=26, VVj7lw=VVj7lw, VVjW3s=VVjW3s, VViMvb=VViMvb, VVwqVu=VVwqVu, VV46TD=VV46TD, VVfWsQ="#11001116", VVB5I5="#11001116", VVYCun="#11001116", VVmErq="#00003635", VVK8UQ="#0a333333", VVgSJJ="#11331100", VVoNmU=True, VVMBr1=2, VVAGe1=CFG.lastFindServers)
  else:
   FFbBGq(self, "No valid URLs line in this file:\n\n%s" % path, title=title)
 def VVG1tt(self, VVAIxO, title, txt, colList):
  CCGSVa(self, CCGSVa.VVl6rL, url=colList[6])
 def VVFlmD(self, VVhzhr, item):
  CCGSVa(self, CCGSVa.VVpilh, url=self.VVHAto["playListURL"])
 def VVGqJv(self, Title, VVAIxO, title, txt, colList):
  url = colList[6]
  self.VVI7E9(VVAIxO, Title, url)
 def VVfeEa(self, path, VVAIxO, title, txt, colList):
  rowNum = int(colList[1].strip()) - 1
  if FFKbVo(path) : CCNb3y(self, path, VVhK3C=BF(self.VVPVcC, VVAIxO), VVmB4A=rowNum)
  else    : FFWfGZ(self, path)
 def VVPVcC(self, VVAIxO, fileChanged):
  if fileChanged:
   VVAIxO.cancel()
 def VVqKk8(self, title):
  curChName = self.VVAIxO.VVYmuZ(1)
  FFANcN(self, BF(self.VVecf6, title), defaultText=curChName, title=title, message="Enter Name:")
 def VVecf6(self, title, name):
  if name:
   VVNFGd, err = CC2Ekb.VVTefV(self, CC2Ekb.VV6xi4, VVf6Ho=False, VVFiGB=False)
   list = []
   if VVNFGd:
    name = self.VVPjh3(name)
    ratio = "1"
    for item in VVNFGd:
     if name in item[0].lower():
      list.append((item[0], FFfCll(item[2]), item[3], ratio))
   if list : self.VVOBhh(list, title)
   else : FFbBGq(self, "Not found:\n\n%s" % name, title=title)
 def VVHY9D(self, title):
  curChName = self.VVAIxO.VVYmuZ(1)
  CCV3Gw.VVgWD3(self, VVN6I4="Find similar names"
      , VVuSHu  = self.VVT3ni
      , VVhK3C = BF(self.VVsiz0, title, curChName))
 def VVT3ni(self, VVqeT6):
  curChName = self.VVAIxO.VVYmuZ(1)
  VVNFGd, err = CC2Ekb.VVTefV(self, CC2Ekb.VVdKU3, VVf6Ho=False, VVFiGB=False)
  if not VVNFGd or not VVqeT6 or VVqeT6.isCancelled:
   return
  VVqeT6.VVL8uX = []
  VVqeT6.VVfT17(len(VVNFGd))
  curCh = self.VVPjh3(curChName)
  for VVq9SN in VVNFGd:
   VVUwmk, sat, inDB = VVNFGd.get(VVq9SN, ("", "", 0))
   ratio = CCRGqC.VV0v8f(VVUwmk.lower(), curCh)
   if not VVqeT6 or VVqeT6.isCancelled:
    return
   VVqeT6.VVqE9L(1, True)
   if VVqeT6 and ratio > 50:
    VVqeT6.VVL8uX.append((VVUwmk, FFfCll(sat), VVq9SN.replace("_", ":"), str(ratio)))
 def VVsiz0(self, title, curChName, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  if VVL8uX: self.VVOBhh(VVL8uX, title)
  elif VV6ZvL: FFbBGq(self, "No similar names found for:\n\n%s" % curChName, title)
 def VVOBhh(self, VVuGUx, title):
  curChName = self.VVAIxO.VVYmuZ(1)
  VVtGUP = self.VVAIxO.VVYmuZ(4)
  VVy6Nm  = self.VVAIxO.VVYmuZ(5)
  VVuGUx.sort(key=lambda x: (100-int(x[3]), x[0].lower()))
  VVj7lw  = ("Share Sat/C/T Ref.", BF(self.VV1CXt, title, curChName, VVtGUP, VVy6Nm), [])
  header   = ("Name" , "Sat"  , "Reference" , "Ratio" )
  widths   = (34  , 33  , 33   , 0   )
  FFCXsL(self, None, title=title, header=header, VVXpNQ=VVuGUx, VV8boH=widths, VVPYL1=26, VVj7lw=VVj7lw, VVfWsQ="#0a00112B", VVB5I5="#0a001126", VVYCun="#0a001126", VVmErq="#00000000")
 def VV1CXt(self, newtitle, curChName, VVtGUP, VVy6Nm, VVAIxO, title, txt, colList):
  newChName = colList[0]
  newRefCode = colList[2]
  data  = newtitle, curChName, VVtGUP, VVy6Nm, newChName, newRefCode
  ques  = "IPTV Channel\t: %s\n\nSat/C/T Chan. \t: %s\n" % (curChName, newChName)
  FF6pUe(self.VVAIxO, BF(FF7iMz, self.VVAIxO, BF(self.VV3YL7, VVAIxO, data)), ques, title=newtitle, VVv5tA=True)
 def VV3YL7(self, VVAIxO, data):
  VVAIxO.cancel()
  title, curChName, VVtGUP, VVy6Nm, newChName, newRefCode = data
  VVy6Nm  = VVy6Nm.strip()
  VVtGUP = VVtGUP.strip()
  newRefCode = newRefCode.strip()
  if not VVtGUP.endswith(":") : VVtGUP += ":"
  if not newRefCode.endswith(":") : newRefCode += ":"
  curFullUrl = newFullUrl = ""
  span = iSearch(r"([A-Fa-f0-9]+:).+", VVtGUP, IGNORECASE)
  if span:
   curRType = span.group(1)
   span = iSearch(r"[A-Fa-f0-9]+:(.+)", newRefCode, IGNORECASE)
   if span:
    newRefCode = curRType + span.group(1)
    curFullUrl = VVtGUP + VVy6Nm
    newFullUrl = newRefCode + VVy6Nm
  totChanges = 0
  resTxt = resErr = ""
  if curFullUrl and newFullUrl:
   for path in CCTe4w.VVcN0J():
    txt = FFmx8y(path)
    if curFullUrl in txt:
     totChanges += 1
     txt = txt.replace(curFullUrl, newFullUrl)
     with open(path, "w") as f:
      f.write(txt)
   if totChanges > 0:
    FFANYL()
    newRow = []
    for i in range(6):
     newRow.append(self.VVAIxO.VVYmuZ(i))
    newRow[4] = newRefCode
    done = self.VVAIxO.VVsu0I(newRow)
    resTxt = "Done"
   else:
    resErr = "Not found in IPTV files"
  else:
   resErr = "Cannot read Chan. Info."
  if   resTxt: FFvfpL(BF(FF0onH , self, resTxt, title=title))
  elif resErr: FFvfpL(BF(FFbBGq, self, resErr, title=title))
 def VVFE1O(self, VVTsOy, path, VVAIxO, title, txt, colList):
  outF = "%s_OK_%s.txt" % (path, FFRIlf())
  lst = [(url, remarks) for num, lineNum, hst, usr, pas, remarks, url in VVAIxO.VVGpBN()]
  self.VV4UuY(VVTsOy, VVAIxO, outF, lst, True)
 def VV4UuY(self, VVTsOy, VVAIxO, outF, lst, hasFile):
  CCV3Gw.VVgWD3(self, VVN6I4="Checking Authorized Servers"
      , VVuSHu  = BF(self.VV5nsc, VVAIxO, lst)
      , VVhK3C = BF(self.VVq73p, VVTsOy, VVAIxO, outF, len(lst), hasFile))
 def VV5nsc(self, VVAIxO, lst, VVqeT6):
  VVqeT6.VVfT17(len(lst))
  VVqeT6.VVL8uX = []
  datePatt = iCompile(r"(?:ends?|exp)[\w]+[: ]*\d{4}[-_]\d{2}[-_]\d{2}(?:\s+\d{2}:\d{2}:\d{2})?(.*)", IGNORECASE)
  for url, remarks in lst:
   if not VVqeT6 or VVqeT6.isCancelled: return
   VVqeT6.VVqE9L(1, True)
   qUrl = self.VVmrO3(self.VVEP1S, url)
   txt, err = self.VVwngR(qUrl, timeout=1)
   if not err:
    try:
     tDict = jLoads(txt)
     if tDict and not err and "server_info" in tDict:
      item = tDict["user_info"]
      if not FFSlBO(item, "auth") == "0":
       end = item.get("exp_date", "")
       rem = ("Ends: %s" % FFG6of(float(end))) if str(end).isdigit() else ""
       if remarks:
        span = datePatt.search(remarks)
        if span : rem += (" ... %s" % span.group(1)) if span.group(1) else ""
        else : rem += " ... %s" % remarks
       if not VVqeT6 or VVqeT6.isCancelled: return
       VVqeT6.VVL8uX.append("%s%s" % (qUrl, ("\t#" + " " + rem) if rem else ""))
    except:
     pass
 def VVq73p(self, VVTsOy, VVAIxO, outF, totChk, hasFile, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  title = "Authorized Servers"
  if VVL8uX:
   totAuth = len(VVL8uX)
   if hasFile and totAuth == totChk:
    FF0onH(self, "All URLs are authorized.", title=title)
   else:
    with open(outF, "w") as f:
     for item in VVL8uX:
      f.write("%s\n" % item)
    if VVTsOy : VVTsOy.VVisOz((outF, outF), isSort=True)
    else   : self.VVgeMs(1)
    txt = FFKrMM("Process Stopped\n\n", VVPI2q) if not VV6ZvL else ""
    txt += "Checked\t: %d/%d\n"  %  (threadCounter, totChk)
    txt += "Authorized\t: %s\n\n" %  FFKrMM(totAuth, VVOQkl)
    txt += "%s\n%s"    %  (FFKrMM("Result File:", VVk4x7), outF)
    FFSMJz(self, txt, title=title)
    if VVAIxO: VVAIxO.close()
  else:
   FFbBGq(self, "No authorized URL found !", title=title)
 @staticmethod
 def VVwngR(url, timeout=3, allowDocType=False):
  if not iRequest:
   return "" , "Cannot import URLLIB/URLLIB2 !"
  try:
   req = iRequest(url)
   req.add_header("User-Agent", CCTe4w.VVNsFc())
   res = iUrlopen(req, timeout=timeout)
   resCode = res.code
   if resCode == 200 :
    cont = res.headers.get("Content-Type")
    if cont:
     if not any(x in cont for x in ("/json", "/ld+json", "text/html", "text/plain")):
      return "", "Unexpected server data type ( %s )" % cont
     res = res.read().decode("UTF-8", "replace")
     if res:
      if not allowDocType and ("<!DOCTYPE html" in res or "<html" in res):
       sErr = "Username or password is invalid."
       if sErr in res : return "", sErr
       else   : return "", "Incorrect data format from server (html)."
      else:
       return res, ""
     else:
      return "", "No data from server."
    else:
     return "", "No data received from server"
   elif resCode == 401 : err = "Unauthorized"
   elif resCode == 402 : err = "Payment Required"
   elif resCode == 408 : err = "Request Timeout"
   else    : err = "err=%d" % resCode
   return "", err
  except Exception as e:
   return "", str(e)
 @staticmethod
 def VVEUPG(url):
  uURL = uProtoc = uHost = uPort = uQuery = uUser = uPass = ""
  modified = False
  uQueryParam = {}
  span  = iSearch(r"\s*(?:(.+):\/\/)*([^:^\/]*)(?::(\d*)\/)*\/*([^\?]*)\?*(.+)", url, IGNORECASE)
  if span:
   modified = True
   uProtoc = span.group(1) or ""
   uHost = span.group(2) or ""
   uPort = span.group(3) or ""
   uQuery = span.group(4) or ""
   param = span.group(5) or ""
   for part in param.split("&"):
    if "=" in part:
     if   part.lower().startswith("username"): uUser = part.split("=")[1]
     elif part.lower().startswith("password"): uPass = part.split("=")[1]
     parts = part.split("=")
     key = parts[0]
     val = parts[1]
     uQueryParam[key] = val
  if uProtoc : uProtoc += "://"
  if uPort : uPort = ":" + uPort
  uURL = "%s%s%s/" % (uProtoc, uHost, uPort)
  return modified, uURL, uProtoc, uHost, uPort, uQuery, uUser, uPass, uQueryParam
 @staticmethod
 def VVqy70(url, justValidate=False, getAudVid=False, compareType=None, compareExt=None, justRetDotExt=False):
  res = scheme = netloc = path = params = query = fragment = username = password = hostname = port = ""
  try:
   if not iUrlparse(url).scheme:
    url = url.lstrip("/")
    url = "http://" + url
   res   = iUrlparse(url)
   scheme  = res.scheme
   netloc  = res.netloc
   path  = res.path
   params  = res.params
   query  = res.query
   fragment = res.fragment
   username = res.username or ""
   password = res.password or ""
   hostname = res.hostname or ""
   port  = res.port  or ""
  except:
   pass
  if justValidate:
   return all([scheme, netloc, path])
  tmpPath = path.strip("/")
  if   path.startswith("/live/") : chType, tmpPath = "live" , path[6:]
  elif path.startswith("/movie/") : chType, tmpPath = "vod" , path[7:]
  elif path.startswith("/series/"): chType, tmpPath = "series", path[8:]
  elif any(x in url for x in ("mode=itv", "/stream.", "/live."))     : chType = "live"
  elif any(x in url for x in ("mode=vod", "/movie/", "/vod/", "/video/", ".m3u8")): chType = "vod"
  elif "mode=series" in url  : chType = "series"
  else       : chType = ""
  parts = tmpPath.split("/")
  if len(parts) >= 2:
   username = parts[0]
   password = parts[1]
   if len(parts) > 2:
    tmpPath  = "/".join(parts[2:])
  parts  = tmpPath.split(":")
  fileName = parts[0]
  if len(parts) > 1: VVUwmk = ":".join(parts[1:])
  elif ":" in query: VVUwmk = query.split(":")[1]
  else    : VVUwmk = ""
  streamId, dotExt = os.path.splitext(fileName)
  ext = dotExt[1:]
  if justRetDotExt:
   return dotExt
  if compareExt:
   if compareExt == ext: return True
   else    : return False
  if getAudVid:
   if ext:
    tDict = CC00KO.VVgJJJ()
    if   ext in list(tDict["mov"]): return "vid"
    elif ext in list(tDict["mus"]): return "aud"
   return ""
  if streamId.isdigit():
   if not chType :
    if not ext              : chType = "live"
    elif iSearch(r"(s\d\d.*e\d\d|e\d\d.*s\d\d)", VVUwmk, IGNORECASE): chType = "series"
    else               : chType = "movie:"
  else:
   streamId = ""
  if compareType is not None:
   if compareType == chType: return True
   else     : return False
  else:
   if scheme:
    scheme += "://"
   host = scheme + netloc
   return chType, host, username, password, streamId, VVUwmk
 @staticmethod
 def VVhriR(VVadS0):
  return CCTe4w.VVqy70(VVadS0, justRetDotExt=True)
 def VVmrO3(self, mode, url, Id="0"):
  Id = str(Id).strip()
  modified, uURL, uProtoc, uHost, uPort, uQuery, uUser, uPass, uQueryParam = self.VVEUPG(url)
  url = "%splayer_api.php?username=%s&password=%s" % (uURL, uUser, uPass)
  if   mode == self.VVEP1S   : return "%s"            % url
  elif mode == self.VVqyuy   : return "%s&action=get_live_categories"     % url
  elif mode == self.VVdqLS   : return "%s&action=get_vod_categories"      % url
  elif mode == self.VVeQf7  : return "%s&action=get_series_categories"     % url
  elif mode == self.VViW4p  : return "%s&action=get_live_categories"     % url
  elif mode == self.VVZ7NZ : return "%s&action=get_series_info&series_id=%s"   % (url, Id)
  elif mode == self.VV9a1K   : return "%s&action=get_live_streams&category_id=%s"  % (url, Id)
  elif mode == self.VVciGe    : return "%s&action=get_vod_streams&category_id=%s"   % (url, Id)
  elif mode == self.VV2SEW  : return "%s&action=get_series&category_id=%s"    % (url, Id)
  elif mode == self.VVy7Q5 : return "%s&action=get_live_streams"      % url
  elif mode == self.VVXjU5  : return "%s&action=get_live_streams&category_id=%s"  % (url, Id)
 @FFJRPn(par=1, clearMsg=False)
 def VVMSum(self, VVAIxO, title, path):
  if FFKbVo(path):
   enc = CC6ntZ.VVC1NW(path, self)
   if enc == -1: return
   qUrl = ""
   with ioOpen(path, "r", encoding=enc) as f:
    for line in f:
     line = str(line).strip()
     if not line or len(line) > 500: continue
     qUrl = CCTe4w.VVb6iw(line)
     if qUrl:
      break
   VVAIxO.VVEL2E()
   if qUrl : self.VVI7E9(VVAIxO, title, qUrl)
   else : FFbBGq(self, "Invalid M3U line format in:\n\n%s" % path, title=title)
  else:
   FFbBGq(self, "Cannot open file :\n\n%s" % path, title=title)
 def VVjQpR(self):
  title = "Current Channel Server"
  qUrl, VVadS0, VVVmGQ = CCTe4w.VVKjeQ(self)
  if qUrl or "chCode" in VVVmGQ:
   p = CCr0nV()
   valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVjhBj(VVadS0)
   if valid:
    self.VVX5v3(self, host, mac)
    return
   elif qUrl:
    self.VVI7E9(self, title, qUrl)
    return
  FFbBGq(self, "Error in current channel URL !", title=title)
 @staticmethod
 def VVKjeQ(SELF):
  VVq9SN, VVadS0, VVjgtq, VVVmGQ, VVUwmk = FFLlAM(SELF)
  qUrl = CCTe4w.VVb6iw(VVadS0)
  return qUrl, VVadS0, VVVmGQ
 @staticmethod
 def VVb6iw(url):
  if url.startswith("#"):
   return ""
  url = url.strip(" /")
  try: res = iUrlparse(url)
  except: return ""
  scheme = res.scheme
  netloc = res.netloc
  if not scheme or not netloc:
   return ""
  host = scheme + "://" +  netloc
  path = res.path.strip("/")
  if   path.startswith("live/") : path = path[5:]
  elif path.startswith("movie/") : path = path[6:]
  elif path.startswith("series/") : path = path[7:]
  parts = path.split("/")
  part = "%s/get.php?username=%s&password=%s&type=m3u"
  if len(parts) == 3 and len(parts[0]) > 1:
   return part % (host, parts[0], parts[1])
  else:
   data = CCTe4w.VV6qyz(url)
   if data : return part % (data[0], data[1], data[2])
   else : return ""
 @FFJRPn("Checking Server ...", par=1)
 def VVI7E9(self, SELF, title, url):
  self.VVy6Nm = url
  self.VVHAto = {}
  qUrl = self.VVmrO3(self.VVEP1S, url)
  txt, err = self.VVwngR(qUrl)
  if err:
   err = "Server Error:\n\n%s" % err
  tDict = {}
  if not err:
   try: tDict = jLoads(txt)
   except: pass
   if not tDict:
    err = "Could not parse server data !"
  if tDict and not err:
   self.VVHAto = {"playListURL": url}
   if "user_info" in tDict and "server_info" in tDict:
    item = tDict["user_info"]
    self.VVHAto["username"    ] = FFSlBO(item, "username" )
    self.VVHAto["password"    ] = FFSlBO(item, "password" )
    self.VVHAto["message"    ] = FFSlBO(item, "message" )
    self.VVHAto["auth"     ] = FFSlBO(item, "auth"  )
    self.VVHAto["status"    ] = FFSlBO(item, "status"  )
    self.VVHAto["exp_date"    ] = FFSlBO(item, "exp_date" , isDate=True)
    self.VVHAto["is_trial"    ] = FFSlBO(item, "is_trial" )
    self.VVHAto["active_cons"   ] = FFSlBO(item, "active_cons")
    self.VVHAto["created_at"   ] = FFSlBO(item, "created_at" , isDate=True)
    self.VVHAto["max_connections"  ] = FFSlBO(item, "max_connections")
    self.VVHAto["allowed_output_formats"] = FFSlBO(item, "allowed_output_formats")
    key = "allowed_output_formats"
    val = item.get(key, None)
    if isinstance(val, list):
     self.VVHAto[key] = " , ".join(val)
    item = tDict["server_info"]
    self.VVHAto["url"    ] = FFSlBO(item, "url"   )
    self.VVHAto["port"    ] = FFSlBO(item, "port"   )
    self.VVHAto["https_port"  ] = FFSlBO(item, "https_port"  )
    self.VVHAto["server_protocol" ] = FFSlBO(item, "server_protocol")
    self.VVHAto["rtmp_port"   ] = FFSlBO(item, "rtmp_port"  )
    self.VVHAto["timezone"   ] = FFSlBO(item, "timezone"  )
    self.VVHAto["timestamp_now"  ] = FFSlBO(item, "timestamp_now" , isDate=True)
    self.VVHAto["time_now"   ] = FFSlBO(item, "time_now"  )
    VV9cxb  = self.VVHwpV(True)
    VVQ4hk = self.VVRifU
    VVF79M = BF(self.VVTcrP, 0)
    VVXpo8 = ("Home Menu" , FF5vVS)
    VVWt1H = ("Resources" , self.VVFlmD)
    VVqj6y= ("Add to Menu", BF(CCTe4w.VVbEgw, self, False, self.VVHAto["playListURL"]))
    VVGbyT = ("Bookmark" , BF(CCTe4w.VVnCDW, self, False, self.VVHAto["playListURL"]))
    VVhzhr = FFO9kU(self, None, title="IPTV Server Resources", VV9cxb=VV9cxb, VVQ4hk=VVQ4hk, VVF79M=VVF79M, VVXpo8=VVXpo8, VVWt1H=VVWt1H, VVqj6y=VVqj6y, VVGbyT=VVGbyT)
    self.VV40TK(VVhzhr)
   else:
    err = "Cannot get User-Data from server !"
  if err:
   FFbBGq(self, err, title=title)
  FFoTZI(self)
 def VVRifU(self, item=None):
  if item:
   VVhzhr, title, ref, ndx = item
   wTxt = "Downloading ..."
   if   ref == "live"   : FF7iMz(VVhzhr, BF(self.VVLQW5, self.VVqyuy  , title=title), title=wTxt)
   elif ref == "vod"   : FF7iMz(VVhzhr, BF(self.VVLQW5, self.VVdqLS  , title=title), title=wTxt)
   elif ref == "series"  : FF7iMz(VVhzhr, BF(self.VVLQW5, self.VVeQf7 , title=title), title=wTxt)
   elif ref == "catchup"  : FF7iMz(VVhzhr, BF(self.VVLQW5, self.VViW4p , title=title), title=wTxt)
   elif ref == "accountInfo" : FF7iMz(VVhzhr, BF(self.VV8dk7           , title=title), title=wTxt)
 def VV40TK(self, VVhzhr):
  dUrl = CCZv30(self.session).VVadS0
  if   FFgcYJ(dUrl): VVhzhr.VVhINX(2)
  elif FFgAmw(dUrl) : VVhzhr.VVhINX(1)
 def VVTcrP(self, isPortal, VVhzhr, txt, ref, ndx):
  FF7iMz(VVhzhr, BF(self.VVo6xo, isPortal))
 def VVo6xo(self, isPortal):
  txt  = "%s\n\n" % self.VVy6Nm
  if isPortal:
   tab  = lambda x, y: "%s\t: %s\n" % (x, y)
   wServ = self.VV1phT()
   if wServ:
    txt += tab("Web Server", wServ)
   if VVSm4H:
    ver, err = self.VV0qqk(self.VVi62k())
    txt += tab("Original", self.VVy6Nm)
    txt += tab("Modified", self.VVy9Fm)
    txt += tab("PHP"  , self.VVyNVX)
    txt += tab("Extra"  , {2:"Big", 3:"Sml"}.get(self.VV875P, "-"))
    txt += tab("Version" , (ver or err))
    txt += "\n%s\n..\tBig\n...\tSml\nBlank\t/s/l.p\n+\t/p.p\n++\t/p1.p\n*\tModed" % SEP
  FFSMJz(self, txt, title="Current Server")
 def VV8dk7(self, title):
  rows = []
  for key, val in self.VVHAto.items():
   if isinstance(val, list): val = str(" , ".join(val))
   else     : val = str(val)
   if any(x in key for x in ("url", "port", "https_port", "server_protocol", "rtmp_port", "timezone", "timestamp_now", "time_now")):
    num, part = "2", self.VV12Wl
   else:
    num, part = "1", self.VVTuxb
   rows.append((num, part, str(key).replace("_", " ").title(), str(val)))
  rows.sort(key=lambda x: (x[0], x[2]))
  VVjW3s  = ("Home Menu", FF5vVS, [])
  VVwqVu  = None
  if VVSm4H:
   VVwqVu = ("Get JS" , BF(self.VVAZuB, "/".join(self.VVHAto["playListURL"].split("/")[:-1])), [])
  header    = ("Num", "User/Server" , "Subject" , "Value" )
  widths    = (0 , 15   , 35  , 50  )
  FFCXsL(self, None, title=title, width=1200, header=header, VVXpNQ=rows, VV8boH=widths, VVPYL1=26, VVjW3s=VVjW3s, VVwqVu=VVwqVu, VVfWsQ="#0a00292B", VVB5I5="#0a002126", VVYCun="#0a002126", VVmErq="#00000000", VVMBr1=2)
 def VV6GmQ(self, mode, jData):
  list = []
  err  = ""
  try:
   tDict = jLoads(jData)
   if tDict:
    if mode in (self.VV9a1K, self.VVXjU5):
     for ndx, item in enumerate(tDict, start=1):
      num      = FFSlBO(item, "num"     )
      name     = FFSlBO(item, "name"     )
      stream_id    = FFSlBO(item, "stream_id"   )
      stream_icon    = FFSlBO(item, "stream_icon"   )
      epg_channel_id   = FFSlBO(item, "epg_channel_id"  )
      added     = FFSlBO(item, "added"    , isDate=True)
      is_adult    = FFSlBO(item, "is_adult"    )
      category_id    = FFSlBO(item, "category_id"   )
      tv_archive    = FFSlBO(item, "tv_archive"   )
      direct_source   = FFSlBO(item, "direct_source"  )
      archDur     = FFSlBO(item, "tv_archive_duration" )
      name = self.VVYMFT(name, censored=is_adult)
      if name:
       if mode == self.VV9a1K or mode == self.VVXjU5 and tv_archive == "1":
        hasPicon = "Yes" if stream_icon else ""
        VVdosY = "Yes" if tv_archive == "1" else ""
        if archDur:
         if archDur.isdigit():
          tot = int(archDur)
          if tot > 0: VVdosY = "%s day%s" % (tot, FFaRsj(tot))
         else:
          VVdosY = archDur
        list.append((num, name, category_id, stream_id, stream_icon, added, epg_channel_id, is_adult, hasPicon, VVdosY, direct_source))
    elif mode == self.VVciGe:
     for ndx, item in enumerate(tDict, start=1):
      num     = FFSlBO(item, "num"     )
      name    = FFSlBO(item, "name"     )
      stream_id   = FFSlBO(item, "stream_id"   )
      stream_icon   = FFSlBO(item, "stream_icon"   )
      added    = FFSlBO(item, "added"    , isDate=True)
      is_adult   = FFSlBO(item, "is_adult"    )
      category_id   = FFSlBO(item, "category_id"   )
      container_extension = FFSlBO(item, "container_extension" ) or "mp4"
      name = self.VVYMFT(name, censored=is_adult)
      if name:
       isPicon = "Yes" if stream_icon else ""
       list.append((num, name, category_id, stream_id, stream_icon, added, is_adult, container_extension, isPicon))
    elif mode == self.VV2SEW:
     for ndx, item in enumerate(tDict, start=1):
      num     = FFSlBO(item, "num"     )
      name    = FFSlBO(item, "name"     )
      series_id   = FFSlBO(item, "series_id"   )
      cover    = FFSlBO(item, "cover"    )
      genre    = FFSlBO(item, "genre"    )
      episode_run_time = FFSlBO(item, "episode_run_time"  )
      category_id   = FFSlBO(item, "category_id"   )
      container_extension = FFSlBO(item, "container_extension" ) or "mp4"
      name = self.VVYMFT(name)
      if name:
       isPicon = "Yes" if cover else ""
       list.append((num, name, category_id, series_id, genre, episode_run_time, container_extension, cover, isPicon))
  except:
   err = "Cannot parse received data !"
  return list, err
 def VVLQW5(self, mode, title):
  cList, err = self.VVGorc(mode)
  if cList and mode == self.VViW4p:
   cList = self.VVKteh(cList)
  if err:
   FFbBGq(self, err, title=title)
  elif cList:
   cList.sort(key=lambda x: x[0].lower())
   self.VV5UUF = dict([(x[1], x[0]) for x in cList])
   VVfWsQ, VVB5I5, VVYCun, VVmErq = self.VVq4P3(mode)
   mName = self.VV2bkQ(mode)
   if   mode == self.VVqyuy  : fMode = self.VV9a1K
   elif mode == self.VVdqLS  : fMode = self.VVciGe
   elif mode == self.VVeQf7 : fMode = self.VV2SEW
   elif mode == self.VViW4p : fMode = self.VVXjU5
   if mode == self.VViW4p:
    VV46TD = None
    VViMvb = None
   else:
    VV46TD = ("Find in %s" % mName , BF(self.VVDMfA, fMode, True) , [])
    VViMvb = ("Find in Selected" , BF(self.VVDMfA, fMode, False) , [])
   VVj7lw   = ("Show List"   , BF(self.VV7mHh, mode)  , [])
   VVjW3s  = ("Home Menu"   , FF5vVS         , [])
   header   = ("Category Name", "catID","Parent ID", "Server Default Sorting" )
   widths   = (100, 0, 0, 0.02)
   FFCXsL(self, None, title=title, width=1200, header=header, VVXpNQ=cList, VV8boH=widths, VVPYL1=30, VVgWi8=True, VVjW3s=VVjW3s, VV46TD=VV46TD, VViMvb=VViMvb, VVj7lw=VVj7lw, VVfWsQ=VVfWsQ, VVB5I5=VVB5I5, VVYCun=VVYCun, VVmErq=VVmErq, VVAGe1=CFG.lastFindIptv)
  else:
   FFbBGq(self, "No list from server !", title=title)
  FFoTZI(self)
 def VVGorc(self, mode):
  qUrl  = self.VVmrO3(mode, self.VVHAto["playListURL"])
  timeout = 20 if mode in (self.VVqyuy, self.VViW4p) else 3
  txt, err = self.VVwngR(qUrl, timeout=timeout)
  if err:
   return [], "Server Error:\n\n" + err
  list = []
  try:
   tDict = jLoads(txt)
   if tDict:
    c = 0
    for item in tDict:
     category_id  = FFSlBO(item, "category_id" )
     category_name = FFSlBO(item, "category_name")
     parent_id  = FFSlBO(item, "parent_id" )
     category_name = self.VVoWRq(category_name)
     if category_name:
      c += 1
      list.append((category_name, category_id, parent_id, str(c)))
  except:
   return "", "Cannot parse received data !"
  return list, ""
 def VVKteh(self, catList):
  mode = self.VVXjU5
  qUrl = self.VVmrO3(mode, self.VVHAto["playListURL"])
  txt, err= self.VVwngR(qUrl)
  chanList= []
  if err:
   return []
  chanList, err = self.VV6GmQ(mode, txt)
  newCatList = []
  for cat in catList:
   for ch in chanList:
    if cat[1] == ch[2] and not cat in newCatList:
     newCatList.append(cat)
  return newCatList
 @FFJRPn("Downloading ...", par=2)
 def VV7mHh(self, mode, VVAIxO, title, txt, colList):
  bName  = colList[0]
  catID  = colList[1]
  parentID = colList[2]
  title = self.VV2bkQ(mode) + " : "+ bName
  if   mode == self.VVqyuy  : mode = self.VV9a1K
  elif mode == self.VVdqLS  : mode = self.VVciGe
  elif mode == self.VVeQf7 : mode = self.VV2SEW
  elif mode == self.VViW4p : mode = self.VVXjU5
  qUrl  = self.VVmrO3(mode, self.VVHAto["playListURL"], catID)
  txt, err = self.VVwngR(qUrl, timeout=20)
  list  = []
  if not err and mode in (self.VV9a1K, self.VVciGe, self.VV2SEW, self.VVXjU5):
   list, err = self.VV6GmQ(mode, txt)
  if err:
   FFbBGq(self, err, title=title)
  elif list:
   VVjW3s  = ("Home Menu"   , FF5vVS            , [])
   if mode in (self.VV9a1K, self.VVXjU5):
    VVfWsQ, VVB5I5, VVYCun, VVmErq = self.VVq4P3(mode)
    VVmolf = (""     , BF(self.VVErkm, mode)      , [])
    VVwqVu = ("Download Options" , BF(self.VVTkzM, mode, "", "")   , [])
    VV46TD = ("Options"   , BF(self.VV2si0, "lv", mode, bName)   , [])
    VViMvb = ("Posters Mode"  , BF(self.VV9P8h, mode, False)     , [])
    VVj7lw  = ("Play"    , BF(self.VVUeht, mode)       , [])
   elif mode == self.VVciGe:
    VVfWsQ, VVB5I5, VVYCun, VVmErq = self.VVq4P3(mode)
    VVj7lw  = ("Play"    , BF(self.VVUeht, mode)       , [])
    VVmolf = (""     , BF(self.VVErkm, mode)      , [])
    VVwqVu = ("Download Options" , BF(self.VVTkzM, mode, "v", "")   , [])
    VV46TD = ("Options"   , BF(self.VV2si0, "v", mode, bName)   , [])
    VViMvb = ("Posters Mode"  , BF(self.VV9P8h, mode, False)     , [])
   elif mode == self.VV2SEW:
    VVfWsQ, VVB5I5, VVYCun, VVmErq = self.VVq4P3("series2")
    VVj7lw  = ("Show Seasons"  , BF(self.VVvXmj, mode)       , [])
    VVmolf = (""     , BF(self.VVtTYi, mode)     , [])
    VVwqVu = None
    VV46TD = None
    VViMvb = ("Posters Mode"  , BF(self.VV9P8h, mode, True)      , [])
   header, widths, VV4Uoc = self.VVIbra(mode)
   FFCXsL(self, None, title=title, header=header, VVXpNQ=list, VV4Uoc=VV4Uoc, VV8boH=widths, VVPYL1=26, VVj7lw=VVj7lw, VVjW3s=VVjW3s, VVwqVu=VVwqVu, VV46TD=VV46TD, VViMvb=VViMvb, VVAGe1=CFG.lastFindIptv, VVmolf=VVmolf, VVfWsQ=VVfWsQ, VVB5I5=VVB5I5, VVYCun=VVYCun, VVmErq=VVmErq, VVoNmU=True, VVMBr1=1)
  else:
   FFbBGq(self, "No Channels found !", title=title)
  FFoTZI(self)
 def VVIbra(self, mode):
  if mode in (self.VV9a1K, self.VVXjU5):
   header   = ("Num" , "Name", "catID", "ID"  , "Icon" , "Added" , "epgID" , "Is Adult", "Logo", "Catch-up", "Link")
   widths   = (8  , 55  , 0   , 0   , 0  , 22  , 0   , 0   , 6  , 9   , 0.03 )
   VV4Uoc  = (CENTER, LEFT  , CENTER , CENTER, LEFT , CENTER , CENTER , CENTER , CENTER, CENTER , CENTER)
  elif mode == self.VVciGe:
   header   = ("Num" , "Name", "catID", "ID"  , "Icon" , "Added" , "isAdult" , "Ext" , "Logo")
   widths   = (8  , 62  , 0   , 0   , 0  , 24  , 0   , 0  , 6  )
   VV4Uoc  = (CENTER, LEFT  , CENTER , CENTER, LEFT , CENTER , CENTER , CENTER, CENTER)
  elif mode == self.VV2SEW:
   header   = ("Num" , "Name", "catID", "ID"  , "Genre" , "Dur.", "Ext" , "Cover" , "Logo" )
   widths   = (8  , 56  , 0   , 0   , 30  , 0  , 0  , 0   , 6   )
   VV4Uoc  = (CENTER, LEFT  , LEFT   , CENTER , LEFT , CENTER, CENTER, LEFT  , CENTER )
  return header, widths, VV4Uoc
 def VVvXmj(self, mode, VVAIxO, title, txt, colList):
  title = colList[1]
  FF7iMz(VVAIxO, BF(self.VV6pEn, mode, VVAIxO, title, txt, colList), title="Downloading ...")
 def VV6pEn(self, mode, VVAIxO, title, txt, colList):
  list, err = self.VVTKbz(colList[3])
  if err:
   FFbBGq(self, err, title=title)
  elif list:
   VVfWsQ, VVB5I5, VVYCun, VVmErq = CCTe4w.VVq4P3("")
   VVjW3s = ("Home Menu"   , FF5vVS          , [])
   VVwqVu = ("Download Options" , BF(self.VVTkzM, mode, "s", title), [])
   VV46TD = ("Options"   , BF(self.VV2si0, "s", mode, title) , [])
   VViMvb = ("Posters Mode"  , BF(self.VV9P8h, mode, False)   , [])
   VVmolf = (""     , BF(self.VVErkm, mode)    , [])
   VVj7lw  = ("Play"    , BF(self.VVUeht, mode)     , [])
   header   = ("Season" , "Episode" , "Title" , "catID" , "stID", "Icon", "Ext" )
   widths   = (10  , 10  , 80  , 0   , 0  , 0  , 0  )
   VV4Uoc  = (CENTER , CENTER , LEFT  , CENTER , CENTER, LEFT , CENTER)
   FFCXsL(self, None, title=title, header=header, VVXpNQ=list, VV4Uoc=VV4Uoc, VV8boH=widths, VVPYL1=26, VVjW3s=VVjW3s, VVwqVu=VVwqVu, VVj7lw=VVj7lw, VVmolf=VVmolf, VV46TD=VV46TD, VViMvb=VViMvb, VVAGe1=CFG.lastFindIptv, VVfWsQ=VVfWsQ, VVB5I5=VVB5I5, VVYCun=VVYCun, VVmErq=VVmErq)
  else:
   FFbBGq(self, "No Channels found !", title=title)
  FFoTZI(self)
 def VVTKbz(self, series_id):
  qUrl  = self.VVmrO3(self.VVZ7NZ, self.VVHAto["playListURL"], series_id)
  txt, err = self.VVwngR(qUrl)
  list  = []
  if not err:
   list = []
   err  = ""
   try:
    tDict = jLoads(txt)
    if tDict:
     title  = "Seasons"
     category_id = "222"
     icon  = ""
     if "info" in tDict:
      sName  = FFSlBO(tDict["info"], "name"  )
      category_id = FFSlBO(tDict["info"], "category_id" )
      icon  = FFSlBO(tDict["info"], "cover"  )
     if "episodes" in tDict:
      seasons = tDict["episodes"]
      for season in seasons:
       item = seasons[season]
       for EP in item:
        stream_id   = FFSlBO(EP, "id"     )
        episode_num   = FFSlBO(EP, "episode_num"  )
        epTitle    = FFSlBO(EP, "title"    )
        container_extension = FFSlBO(EP, "container_extension")
        seasonNum   = FFSlBO(EP, "season"    )
        sName = self.VVYMFT(sName)
        epTitle = self.VVYMFT(epTitle)
        epTitle = self.VVbSgi(series_id, sName, epTitle, seasonNum, episode_num)
        list.append((seasonNum, episode_num, epTitle, category_id, stream_id, icon, container_extension))
   except:
    err = "Cannot parse received data !"
  return list, err
 def VVbSgi(self, catID, sName, eName, sNum, eNum):
  SeEp = ( "S%.2dE%.2d (%s)" % (int(sNum), int(eNum), catID) ) if sNum.isdigit() and eNum.isdigit() else ""
  prefix = sName + " " + SeEp
  patt = r"(S\d{1,3}\W*E\d{1,3})|(E\d{1,3}\W*S\d{1,3})"
  if eName.lower().startswith(sName.lower()):
   eName = sName + eName[len(sName):]
  if iMatch(r"^%s" % patt, eName, IGNORECASE):
   return iSub(patt, prefix, eName, flags=IGNORECASE)
  elif not eName.startswith(sName):
   return prefix + " " + eName
  elif eName.startswith(sName):
   eName, tot = iSubn(patt, SeEp, eName, flags=IGNORECASE)
   if tot : return eName
   else : return prefix + " " + eName[len(sName):].strip()
  return eName
 def VVDMfA(self, mode, isAll, VVAIxO, title, txt, colList):
  onlyCatID = None if isAll else colList[1]
  VV9cxb = []
  VV9cxb.append(("Keyboard"  , "manualEntry"))
  VV9cxb.append(("From Filter" , "fromFilter"))
  FFO9kU(self, BF(self.VVqQT3, VVAIxO, mode, onlyCatID), title="Input Type", VV9cxb=VV9cxb, width=400)
 def VVqQT3(self, VVAIxO, mode, onlyCatID, item=None):
  if item == "manualEntry":
   FFANcN(self, BF(self.VVbJzO, VVAIxO, mode, onlyCatID), defaultText=CFG.lastFindIptv.getValue(), title="Find", message="Enter Name (or names separated by a comma)")
  elif item == "fromFilter":
   filterObj = CCuHRT(self)
   filterObj.VVaNK8(BF(self.VVbJzO, VVAIxO, mode, onlyCatID))
 def VVbJzO(self, VVAIxO, mode, onlyCatID, item):
  if not item is None:
   title = "Find in names"
   words = None
   toFind = item.strip()
   FFBWtx(CFG.lastFindIptv, toFind)
   if toFind:
    words, asPrefix = CCuHRT.VVzdEZ(toFind)
    if words:
     if len(words) == 1 and len(words[0]) < 3:
      FFbBGq(self, "Enter at least 3 characters.", title=title)
      return
     else:
      for word in words:
       if len(word) < 3:
        FFbBGq(self, "All words must be at least 3 characters !", title=title)
        return
     if CFG.hideIptvServerAdultWords.getValue() and self.VVJ6GT(words):
      FFbBGq(self, self.VVhVMo(), title="Find: %s" % " , ".join(words))
      return
     else:
      CCV3Gw.VVgWD3(self, VVN6I4="Searching for:%s" % toFind[:15], totBars=2
          , VVuSHu  = BF(self.VVffYf, VVAIxO, mode, onlyCatID, title, words, toFind, asPrefix)
          , VVhK3C = BF(self.VVhLr1, mode, toFind, title))
   if not words:
    FFoTZI(VVAIxO, "Nothing to find !", 1500)
 def VVffYf(self, VVAIxO, mode, onlyCatID, title, words, toFind, asPrefix, VVqeT6):
  VVqeT6.VVfT17(VVAIxO.VVM62I() if onlyCatID is None else 1)
  VVqeT6.VVL8uX = []
  for row in VVAIxO.VVGpBN():
   catName = row[0]
   catID = row[1]
   if not onlyCatID is None and not catID == onlyCatID:
    continue
   if not VVqeT6 or VVqeT6.isCancelled: return
   VVqeT6.VVqE9L(1)
   VVqeT6.VVuDjj(0)
   VVqeT6.VVEfKX(catName)
   qUrl = self.VVmrO3(mode, self.VVHAto["playListURL"], catID)
   txt, err= self.VVwngR(qUrl, timeout=20)
   if not err:
    tList, err = self.VV6GmQ(mode, txt)
    if tList:
     if not VVqeT6 or VVqeT6.isCancelled: return
     VVqeT6.VVH2AI(len(tList))
     for item in tList:
      if not VVqeT6 or VVqeT6.isCancelled: return
      VVqeT6.VVpqYW(1)
      name = item[1].strip().lower()
      name = self.VVYMFT(name)
      if name:
       if asPrefix and not name.startswith(words) : continue
       elif any(x in name for x in words)   : pass
       else          : continue
       if not VVqeT6 or VVqeT6.isCancelled:
        return
       VVqeT6.VVL8uX.append(item)
       VVqeT6.VVEfKX(catName)
 def VVhLr1(self, mode, toFind, title, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  if VVL8uX:
   title = self.VVHNUV(mode, toFind)
   VVfWsQ, VVB5I5, VVYCun, VVmErq = self.VVq4P3(mode)
   if mode == self.VV9a1K or mode == self.VVciGe:
    if mode == self.VVciGe : typ = "v"
    else          : typ = ""
    bName   = CCTe4w.VVXxU8(toFind)
    VVj7lw  = ("Play"     , BF(self.VVUeht, mode)     , [])
    VVwqVu = ("Download Options" , BF(self.VVTkzM, mode, typ, "") , [])
    VV46TD = ("Options"   , BF(self.VV2si0, "fnd", mode, bName), [])
    VViMvb = ("Posters Mode"  , BF(self.VV9P8h, mode, False)   , [])
    VVmolf = (""     , BF(self.VVErkm, mode)    , [])
   elif mode == self.VV2SEW:
    VVfWsQ, VVB5I5, VVYCun, VVmErq = self.VVq4P3("series2")
    VVj7lw  = ("Show Seasons"  , BF(self.VVvXmj, mode)     , [])
    VV46TD = None
    VVwqVu = None
    VViMvb = ("Posters Mode"  , BF(self.VV9P8h, mode, True)    , [])
    VVmolf = (""     , BF(self.VVtTYi, mode)   , [])
   VVjW3s  = ("Home Menu"   , FF5vVS          , [])
   header, widths, VV4Uoc = self.VVIbra(mode)
   VVAIxO = FFCXsL(self, None, title=title, header=header, VVXpNQ=VVL8uX, VV4Uoc=VV4Uoc, VV8boH=widths, VVPYL1=26, VVj7lw=VVj7lw, VVjW3s=VVjW3s, VVwqVu=VVwqVu, VV46TD=VV46TD, VViMvb=VViMvb, VVmolf=VVmolf, VVfWsQ=VVfWsQ, VVB5I5=VVB5I5, VVYCun=VVYCun, VVmErq=VVmErq, VVoNmU=True, VVMBr1=1)
   if not VV6ZvL:
    FFoTZI(VVAIxO, "Stopped" , 1000)
  else:
   if VV6ZvL:
    FFbBGq(self, "Not found in names !\n\n( %s )" % toFind, title=title)
 def VV9MVv(self, mode, colList):
  colList = list(map(str.strip, colList))
  if mode in (self.VV9a1K, self.VVXjU5):
   num, name, category_id, stream_id, stream_icon, added, epg_channel_id, is_adult, hasPicon, VVdosY, direct_source = colList
   chNum, VVUwmk, catID, stID, VVuPzU, ext, uCat = num, name, category_id, stream_id, stream_icon, "", ""
  elif mode == self.VVciGe:
   num, name, category_id, stream_id, stream_icon, added, is_adult, container_extension, isPicon = colList
   chNum, VVUwmk, catID, stID, VVuPzU, ext, uCat = num, name, category_id, stream_id, stream_icon, "." + container_extension, "movie/"
  else:
   seasonNum, episode_num, epTitle, category_id, stream_id, icon, container_extension = colList
   chNum, VVUwmk, catID, stID, VVuPzU, ext, uCat = "222", epTitle, category_id, stream_id, icon, "." + container_extension, "series/"
  VVUwmk = FFT7Bj(VVUwmk)
  url = self.VVHAto["playListURL"]
  modified, uURL, uProtoc, uHost, uPort, uQuery, uUser, uPass, uQueryParam = self.VVEUPG(url)
  VVq9SN = self.VVzrYF(catID, stID, chNum)
  chUrl = "%s%s%s/%s/%s%s"  % (uURL, uCat, uUser, uPass, stID, ext)
  chUrl = chUrl.replace(":", "%3a")
  chUrl = VVq9SN + chUrl + ":" + VVUwmk
  return VVUwmk, chUrl, VVuPzU, VVq9SN
 def VVErkm(self, mode, VVAIxO, title, txt, colList):
  if mode in (self.VV9a1K, self.VVXjU5): catID = colList[2]
  elif mode == self.VVciGe          : catID = colList[2]
  else                   : catID = colList[3]
  catName = self.VV5UUF.get(catID, "")
  if catName:
   txt = txt.strip() + "\nCategory\t: %s" % catName
  FF7iMz(VVAIxO, BF(self.VVu9Fn, mode, VVAIxO, title, txt, colList))
 def VVu9Fn(self, mode, VVAIxO, title, txt, colList):
  VVUwmk, chUrl, VVuPzU, VVq9SN = self.VV9MVv(mode, colList)
  txt = "%s\n\n%s" % (title, txt)
  CCpebE.VV1v7b(self, VV6tGM=CCpebE.VVsuho, params=(VVq9SN, VVUwmk, txt, chUrl, VVuPzU))
 def VVtTYi(self, mode, VVAIxO, title, txt, colList):
  FF7iMz(VVAIxO, BF(self.VV7vax, mode, VVAIxO, title, txt, colList))
 def VV7vax(self, mode, VVAIxO, title, txt, colList):
  name = colList[1]
  Dur  = colList[5]
  Cover = colList[7]
  txt  = "%s\n\n%s" % (title, txt)
  txt  += "Duration\t: %s" % Dur
  CCpebE.VV1v7b(self, VV6tGM=CCpebE.VVF9O7, params=(name, txt, Cover))
 def VV9P8h(self, mode, isSerNames, VVAIxO, title, txt, colList):
  if mode == "m3u":
   nameCol, picCol, descCol, descTxt = 1, 4, 2, "Group"
  elif mode in ("itv", "vod", "series"):
   if isSerNames: nameCol, picCol, descCol, descTxt = 0, 12, 9, "Genre"
   else   : nameCol, picCol, descCol, descTxt = 1, 4 , 6, "Category/Genre"
  else:
   nameCol = 1
   if isSerNames         : picCol, descCol, descTxt = 7, 4, "Genre"
   elif mode == self.VV9a1K : picCol, descCol, descTxt = 4, 5, "Added"
   elif mode == self.VVXjU5 : picCol, descCol, descTxt = 4, 5, "Added"
   elif mode == self.VVciGe  : picCol, descCol, descTxt = 4, 5, "Added"
   elif mode == self.VV2SEW : picCol, descCol, descTxt = 5, 0, "Season"
  FF7iMz(VVAIxO, BF(self.session.open, CCL8u5, VVAIxO, self.VVR5UG(mode), nameCol, picCol, descCol, descTxt))
 @staticmethod
 def VVR5UG(mode):
  if   mode in ("itv", "live" , CCTe4w.VV9a1K, CCTe4w.VVXjU5): subD = "Live"
  elif mode in ("vod"   , CCTe4w.VVciGe )          : subD = "VOD"
  elif mode in ("series"  , CCTe4w.VV2SEW)          : subD = "Series"
  elif mode == "m3u"                       : subD = "M3U"
  else                          : subD = ""
  return FF9Uvy(os.path.join(FFJv8S(), "Posters", subD))
 def VVTkzM(self, mode, typ, VVGHs6, VVAIxO, title, txt, colList):
  VV9cxb = []
  isMulti = VVAIxO.VVGZGK
  tot  = VVAIxO.VVAGI8()
  if isMulti:
   if tot < 1:
    FFoTZI(VVAIxO, "Select rows first.", 1000)
    return
   else:
    name = "%d Selected" % tot
   plural = FFaRsj(tot)
  else:
   name = "ALL"
   plural = "s"
  txt = "PIcon" if mode in ("itv", CCTe4w.VV9a1K, CCTe4w.VVXjU5) else "Poster"
  VV9cxb.append(("Download %s %s%s" % (name, txt, plural)  , "dnldPicons" ))
  if typ:
   VV9cxb.append(VVbM5H)
   tName = "Movie" if typ.startswith("v") else "Episode"
   VV9cxb.append(("Download Current %s" % tName    , "dnldSel"  ))
   VV9cxb.append(("Add Current %s to Download List" % tName , "addSel"  ))
   if typ.startswith("s"):
    VV9cxb.append(("Add All Episodes to Download List" , "addAllEp" ))
   if not CClaHD.VVyZwz():
    VV9cxb.append(VVbM5H)
    VV9cxb.append(("Download Manager"      , "dload_stat" ))
  FFO9kU(self, BF(self.VV2gf8, VVAIxO, mode, typ, VVGHs6, colList), title="Download Options", VV9cxb=VV9cxb)
 def VV2gf8(self, VVAIxO, mode, typ, VVGHs6, colList, item=None):
  if item:
   if   item == "dnldPicons" : self.VVvySR(self, VVAIxO, mode)
   elif item == "dnldSel"  : self.VVxQJT(VVAIxO, mode, typ, colList, True)
   elif item == "addSel"  : self.VVxQJT(VVAIxO, mode, typ, colList, False)
   elif item == "addAllEp"  : self.VVcMOO(VVAIxO, mode, typ, VVGHs6)
   elif item == "dload_stat" : CClaHD.VVRi6O(self, VVAIxO)
 def VVxQJT(self, VVAIxO, mode, typ, colList, startDnld):
  VVUwmk, VVadS0 = self.VVnn8L(mode, typ, colList)
  if startDnld:
   CClaHD.VVuNb5(self, VVadS0)
  else:
   self.VVLr7S(VVAIxO, "Add to Download list", VVUwmk, [VVadS0], startDnld)
 def VVcMOO(self, VVAIxO, mode, typ, VVGHs6):
  VVY8fX = []
  for row in VVAIxO.VVGpBN():
   VVUwmk, VVadS0 = self.VVnn8L(mode, typ, row)
   VVY8fX.append(VVadS0)
  self.VVLr7S(VVAIxO, "Add to Download list", "%s\n\n( %d Episodes )" % (VVGHs6, len(VVY8fX)), VVY8fX, False)
 def VVLr7S(self, VVAIxO, title, VVUwmk, VVY8fX, startDnld):
  FF6pUe(self, BF(self.VVUord, VVAIxO, VVY8fX, startDnld), VVUwmk, title=title)
 def VVUord(self, VVAIxO, VVY8fX, startDnld):
  added, skipped = CClaHD.VVSjKX(VVY8fX)
  FFoTZI(VVAIxO, "Added", 1000)
 def VVnn8L(self, mode, typ, colList):
  if typ in ("v", "s"):
   VVUwmk, chUrl, VVuPzU, VVq9SN = self.VV9MVv(mode, colList)
  elif typ in ("vp", "sp"):
   VVUwmk, catID, stID, chNum, chCm, serCode, serId, VVuPzU = self.VV864t(mode, colList)
   VVq9SN, chUrl = self.VVaJI6(self.VVy9Fm, self.VVfHA5, mode, VVUwmk, catID, stID, chNum, chCm, serCode, serId)
  VVq9SN, VVadS0, VVjgtq, VVVmGQ = CCZv30.VVXF8h(chUrl)
  return VVUwmk, VVadS0
 @staticmethod
 def VVvySR(SELF, VVAIxO, mode):
  if FFW91j("ffmpeg"):
   CCV3Gw.VVgWD3(SELF, VVN6I4="Downloading PIcons"
       , VVuSHu  = BF(CCTe4w.VVt46t, SELF, VVAIxO, mode)
       , VVhK3C = BF(CCTe4w.VVTDwQ, SELF))
  else:
   FF6pUe(SELF, BF(CCTe4w.VVlNOU, SELF), '"FFmpeg" is required to resize the PIcons.\n\nInstall FFmpeg ?', title="Download all PIcons")
 @staticmethod
 def VVt46t(SELF, VVAIxO, mode, VVqeT6):
  VVqeT6.VVL8uX = {"total": 0, "threads": 0, "proces": 0, "badUrl": 0, "exist": 0, "attempt": 0, "ok": 0, "size0": 0, "fail": 0, "err": ""}
  VVE9ss = set()
  pPath = CCRGqC.VV5G3P()
  VVqeT6.VVX5nT("Collecting list ...")
  ndxLst = []
  for ndx, row in enumerate(VVAIxO.VVGpBN()):
   if not VVAIxO.VVGZGK or VVAIxO.VVDjAB(ndx):
    ndxLst.append(ndx)
  if not VVqeT6 or VVqeT6.isCancelled: return
  if ndxLst:
   VVqeT6.VVL8uX["total"] = len(ndxLst)
   VVqeT6.VVfT17(len(ndxLst))
   VVqeT6.VVZo23(0)
  else:
   VVqeT6.VVL8uX["err"] = "No valid URLs"
   return
  def VVL758(VVuPzU, picon):
   VVqeT6.VVL8uX["threads"] += 1
   VVqeT6.VVL8uX["attempt"] += 1
   path, err = FFUzwU(VVuPzU, picon, timeout=2, mustBeImage=True)
   if not VVqeT6 or VVqeT6.isCancelled:
    FFnE7j(path)
   elif err:
    VVqeT6.VVL8uX["fail"] += 1
    if any(x in err.lower() for x in ("time-out", "unauthorized")):
     VVqeT6.VVL8uX["err"] = err.title()
   elif not path:
    pass
   elif FFLjtI(path) == 0:
    VVqeT6.VVL8uX["size0"] += 1
    FFnE7j(path)
   else:
    VVqeT6.VVL8uX["ok"] += 1
    totOk = VVqeT6.VVL8uX["ok"]
    VVqeT6.VVZo23(totOk)
    cmd = CCpebE.VV4mAF(path)
    cmd += FFQWwc("mv -f '%s' '%s'" % (path, pPath))
    FFlonU(cmd)
   if VVqeT6 and not VVqeT6.isCancelled:
    VVqeT6.VVL8uX["threads"] -= 1
  while ndxLst or VVqeT6.VVL8uX["threads"] > 0:
   try:
    if not VVqeT6 or VVqeT6.isCancelled : return
    elif VVqeT6.VVL8uX["err"]   : return
    elif VVqeT6.VVL8uX["threads"] >= 8: continue
    elif not ndxLst        : continue
   except:
    return
   row = VVAIxO.VVBWxt(ndxLst[0])
   ndxLst.pop(0)
   VVqeT6.VVqE9L(1)
   VVqeT6.VVL8uX["proces"] += 1
   if mode in ("itv", "vod", "series"):
    VVUwmk, catID, stID, chNum, chCm, serCode, serId, VVuPzU = SELF.VV864t(mode, row)
    VVq9SN = CCTe4w.VVzrYF(catID, stID, chNum)
   elif mode == "m3u":
    VVq9SN, VVUwmk, chUrl, VVuPzU, VVadS0, isMark = CCGSVa.VVFYqm(SELF, row)
   else:
    VVUwmk, chUrl, VVuPzU, VVq9SN = SELF.VV9MVv(mode, row)
   if not VVuPzU:
    VVqeT6.VVL8uX["badUrl"] += 1
    continue
   picon = VVq9SN.replace(":", "_").rstrip("_") + ".png"
   if not VVqeT6 or VVqeT6.isCancelled:
    return
   if FFKbVo(pPath + picon):
    VVqeT6.VVL8uX["exist"] += 1
   elif not picon in VVE9ss:
    VVE9ss.add(picon)
    iThread(name="ajp_DnldPic", target=BF(VVL758, VVuPzU, picon)).start()
 @staticmethod
 def VVTDwQ(SELF, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  tDict = VVL8uX
  txt  = ""
  txt += "Total Processed\t\t: %d of %d\n" % (tDict["proces"], tDict["total"])
  txt += "Download Success\t: %d of %s\n"  % (tDict["ok"], tDict["attempt"])
  txt += "Skipped (PIcon exist)\t: %d\n"  % tDict["exist"]
  txt += "Skipped (Size = 0)\t: %d\n"   % tDict["size0"]
  txt += "Incorrect PIcon URL\t: %d\n"  % tDict["badUrl"]
  txt += "Download Failure\t: %d\n"   % tDict["fail"]
  txt += "PIcons Path\t\t: %s\n"    % CCRGqC.VV5G3P()
  if not VV6ZvL: color = "#11402000"
  elif tDict["err"]: color = "#11201000"
  else    : color = "#22001122"
  if tDict["err"]:
   txt = "Critical Error\t\t: %s\n\n%s"  % (tDict["err"], txt)
  title = "PIcons Download Result"
  if not VV6ZvL:
   title += "  (cancelled)"
  FFSMJz(SELF, txt, title=title, VVYCun=color)
 @staticmethod
 def VVlNOU(SELF):
  cmd = FF4zTV(VVw2da, "ffmpeg")
  if cmd : FF6NKJ(SELF, cmd, title="Installing FFmpeg")
  else : FFWaiD(SELF)
 @staticmethod
 def VVmmMb(SELF):
  CCB02H(SELF)
 @staticmethod
 def VVpUIe(chUrl, streamId, mode):
  modified, uURL, uProtoc, uHost, uPort, uQuery, uUser, uPass, uQueryParam = CCTe4w.VVEUPG(chUrl)
  qUrl = "%splayer_api.php?username=%s&password=%s&action=get_simple_data_table&stream_id=%s" % (uURL, uUser, uPass, streamId)
  txt, err = CCTe4w.VVwngR(qUrl)
  if err : return "", err
  else : return CCTe4w.VVWf3s(txt, mode=mode)
 @staticmethod
 def VVWf3s(txt, mode):
  lst = []
  evLst = []
  try:
   tDict = jLoads(txt)
   for item in tDict["epg_listings"]:
    description = FFSlBO(item, "description"  , is_base64=True).replace("\n", " .. ")
    has_archive = FFSlBO(item, "has_archive"      )
    lang  = FFSlBO(item, "lang"        ).upper()
    now_playing = FFSlBO(item, "now_playing"      )
    tTitle  = FFSlBO(item, "title"   , is_base64=True)
    startServ = FFSlBO(item, "start"       )
    startT  = FFSlBO(item, "start_timestamp" , isDate=True )
    startTs  = FFSlBO(item, "start_timestamp"     )
    stopT  = FFSlBO(item, "stop_timestamp" , isDate=True )
    stopTs  = FFSlBO(item, "stop_timestamp"     )
    if mode == 0:
     if has_archive == "1":
      return True, ""
    elif mode == 1:
     try:
      startTs, stopTs = int(startTs), int(stopTs)
      if has_archive == "1" or (startTs < iTime() and stopTs > iTime()):
       durMin = str((stopTs - startTs) // 60)
       durTm = FFrTEd(stopTs - startTs)
       row = (startT[:-3], stopT[:-3], durTm, lang, tTitle, description, startServ, now_playing, durMin)
       if not row in lst:
        lst.append(row)
     except:
      pass
    elif mode == 2:
     try:
      startTs, stopTs = int(startTs), int(stopTs)
      if stopTs > iTime():
       dur = stopTs - startTs
       shortDesc = ("Language : %s" % lang) if lang else ""
       lst.append((startTs, dur, tTitle, shortDesc, description, 1))
     except:
      pass
    elif mode == 3:
     try:
      startTs, stopTs = int(startTs), int(stopTs)
      if stopTs > iTime():
       dur = stopTs - startTs
       row = (description, has_archive, lang, now_playing, tTitle, startT, startTs, stopT, stopTs)
       if not row in lst:
        lst.append(row)
        shortDesc = ("Language : %s" % lang) if lang else ""
        evLst.append((startTs, dur, tTitle, shortDesc, description, 1))
     except:
      pass
  except:
   return "", "Cannot parse received data !"
  if   mode == 0: return False, ""
  elif mode == 1: return lst, ""
  elif mode == 2: return lst, ""
  elif mode == 3:
   sep = FFKrMM("_" * 32 + "\n", VV3Hcc)
   fg1, fg2, curTxt = VVCQUS, VVdLWL, "    (CURRENT EVENT)"
   epg = ""
   for evNum, (description, has_archive, lang, now_playing, tTitle, startT, startTs, stopT, stopTs) in enumerate(lst, start=1):
    if now_playing == "0": color, txt = fg1, ""
    else     : color, txt = fg2, curTxt
    epg += sep
    epg += FFKrMM("Event\t: %d%s\n" % (evNum, txt), color)
    epg += "Title\t: %s\n"    % FFKrMM(tTitle, VVk4x7)
    epg += "Start\t: %s\n"    % startT
    epg += "End\t: %s\n"    % stopT
    if lang   : epg += "Language\t: %s\n"  % lang
    if description : epg += "Description:\n%s\n" % FFKrMM(description, VV0p9P)
   return epg, evLst, ""
  else:
   return lst, ""
 @staticmethod
 def VVQtfm(VVadS0):
  epg, evLst, err = "", [], ""
  if "mode=itv" in VVadS0:
   p, err = CCr0nV.VVHzpJ(VVadS0)
   if p:
    valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVjhBj(VVadS0)
    if valid and stID:
     res, err = p.VVgit8(p.VVgPkn(stID))
     if res:
      epg, err = CCTe4w.VV4tee(res.text, retLst=False)
      evLst, err = CCTe4w.VV4tee(res.text, retLst=True)
      return epg, evLst, err
  else:
   data = CCTe4w.VV6qyz(VVadS0)
   if data:
    uHost, uUser, uPass, uId, VVUwmk = data
    if all((uHost, uUser, uPass, uId)):
     qUrl = "%s/player_api.php?username=%s&password=%s&action=get_short_epg&stream_id=%s" % (uHost, uUser, uPass, uId)
     txt, err = CCTe4w.VVwngR(qUrl, timeout=3)
     if txt:
      epg, evLst, err = CCTe4w.VVWf3s(txt, mode=3)
  return epg, evLst, err
 @staticmethod
 def VV4tee(txt, retLst=False):
  epg = ""
  lst = []
  now = iTime()
  try:
   tDict = jLoads(txt)
   for item in tDict["js"]:
    actor = FFSlBO(item, "actor"       )
    cat  = FFSlBO(item, "category"       )
    descr = FFSlBO(item, "descr"   , is_base64=True).replace("\n", " .. ")
    director= FFSlBO(item, "director"       )
    name = FFSlBO(item, "name"    , is_base64=True)
    startT = FFSlBO(item, "start_timestamp" , isDate=True )
    startTs = FFSlBO(item, "start_timestamp"     )
    stopT = FFSlBO(item, "stop_timestamp" , isDate=True )
    stopTs = FFSlBO(item, "stop_timestamp"     )
    try:
     startTs, stopTs = int(startTs), int(stopTs)
     if stopTs > now:
      dur = stopTs - startTs
      row = (actor, cat, descr, director, name, startT, stopT, startTs, stopTs, dur)
      if not row in lst:
       lst.append(row)
    except:
     pass
  except:
   return "", "Cannot parse received data !"
  if retLst:
   lst = [(startTs, dur, name, "", descr, 1) for (actor, cat, descr, director, name, startT, stopT, startTs, stopTs, dur) in lst]
   return lst, ""
  else:
   sep  = FFKrMM("_" * 32 + "\n", VV3Hcc)
   curTxt = FFKrMM("    (CURRENT EVENT)", VVWH8U)
   evNum = 1
   for actor, cat, descr, director, name, startT, stopT, startTs, stopTs, dur in lst:
    curEv = curTxt if (startTs < now and stopTs > now) else ""
    epg += sep
    epg += "Event\t: %d%s\n" % (evNum, curEv)
    epg += "Title\t: %s\n"  % FFKrMM(name, VVk4x7)
    epg += "Start\t: %s\n"  % startT
    epg += "End\t: %s\n"  % stopT
    epg += "Description:\n%s\n" % FFKrMM(descr , VV0p9P) if descr else "Description\t: - \n"
    epg += "Genre:\n%s\n"  % FFKrMM(cat  , VV0p9P) if cat else ""
    epg += "Actors:\n%s\n"  % FFKrMM(actor , VV0p9P) if actor else ""
    epg += "Director:\n%s\n" % FFKrMM(director, VV0p9P) if director else ""
    evNum += 1
   return epg, ""
 @staticmethod
 def VVSRji(txt):
  epg = movie_image = err = ""
  try:
   tDict = jLoads(txt)
   item = tDict["info"]
   movie_image = FFSlBO(item, "movie_image" )
   genre  = FFSlBO(item, "genre"  )
   plot  = FFSlBO(item, "plot"   )
   country  = FFSlBO(item, "country"  )
   actors  = FFSlBO(item, "actors"  )
   cast  = FFSlBO(item, "cast"   )
   rating  = FFSlBO(item, "rating"  )
   director = FFSlBO(item, "director"  )
   releasedate = FFSlBO(item, "releasedate" )
   duration = FFSlBO(item, "duration"  )
   tab = lambda x, y: ("%s\t: %s\n" % (x, y)) if y and y != "-" else ""
   try:
    lang = FFSlBO(tDict["info"]["audio"]["tags"], "language")
    if lang:
     epg += tab("Language", lang.capitalize())
   except:
    pass
   epg += tab("Genre"  , genre)
   epg += tab("Released" , releasedate)
   epg += tab("Country" , country)
   epg += tab("Duration" , duration)
   epg += tab("Director" , director)
   epg += tab("Rating"  , rating)
   if cast or actors : epg += "Cast:\n%s\n\n" % FFKrMM(cast or actors, VV0p9P)
   if plot    : epg += "Plot:\n%s"  % FFKrMM(plot, VV0p9P)
  except Exception as e:
   err = str(e)
  return epg, movie_image, err
 @staticmethod
 def VVv4A8(txt, VVadS0):
  span = iSearch(r".+\/series\/.+\/.+\/(\d+)", VVadS0)
  epId = span.group(1) if span else ""
  epg = epSeason = epTitle = cover = err = ""
  try:
   tDict = jLoads(txt)
   item = tDict["info"]
   cast  = FFSlBO(item, "cast"    )
   cover  = FFSlBO(item, "cover"   )
   director = FFSlBO(item, "director"   )
   genre  = FFSlBO(item, "genre"   )
   name  = FFSlBO(item, "name"    )
   plot  = FFSlBO(item, "plot"    )
   if epId:
    for sName, ep in tDict["episodes"].items():
     for item in ep:
      Id   = FFSlBO(item, "id"     )
      season  = FFSlBO(item, "season"    )
      Title  = FFSlBO(item, "title"    )
      if Id  == epId:
       epSeason, epTitle = season, Title
       break
     if epSeason or epTitle:
      break
   ttl = lambda x, y: "\n%s:\n%s\n\n" % (FFKrMM(x, VVk4x7), str(y)) if y else ""
   tab = lambda x, y: ("%s\t: %s\n" % (x, y)) if y else ""
   epg =  tab("Season"  , epSeason)
   epg += tab("Title"  , epTitle)
   epg += tab("Name"  , name)
   epg += tab("Genre"  , genre)
   epg += tab("Director" , director)
   epg += ttl("Cast"  , cast)
   epg += ttl("Plot"  , plot)
  except Exception as e:
   err = str(e)
  return epg, cover, err
 @staticmethod
 def VVzrYF(catID, stID, chNum):
  MAX_4b = 65535
  MAX_8b = 4294967295
  SID  = CCTe4w.VVEsMK(catID, MAX_4b)
  TSID = CCTe4w.VVEsMK(chNum, MAX_4b)
  ONID = CCTe4w.VVEsMK(chNum, MAX_4b)
  NS  = CCTe4w.VVEsMK(stID, MAX_8b)
  if len(NS) == 4:
   NS = "1" + NS
  rType = CFG.iptvAddToBouquetRefType.getValue()
  return "%s:0:1:%s:%s:%s:%s:0:0:0:" % (rType, SID, TSID, ONID, NS)
 @staticmethod
 def VVEsMK(numStr, limit):
  if numStr.isdigit():
   i = int(numStr)
   if i > limit:
    i = limit
   return (hex(i))[2:].upper()
  else:
   return "222"
 @staticmethod
 def VVXxU8(txt):
  txt = iSub(iCompile(r'\W'), "_", txt)
  txt = FFhTcV(txt, "_")
  return "Bouquet" if txt == "_" else txt
 @staticmethod
 def VVq4P3(mode):
  if   mode in ("itv"  , CCTe4w.VVqyuy)  : return "#0a21303C", "#0a21303C", "#0a21303C", "#00005566"
  elif mode in ("vod"  , CCTe4w.VVdqLS)  : return "#1a260518", "#1a260518", "#1a260518", "#04224040"
  elif mode in ("series" , CCTe4w.VVeQf7) : return "#1a36013F", "#1a26012F", "#1a26012F", "#04224040"
  elif mode in ("catchup" , CCTe4w.VViW4p) : return "#0a213044", "#0a213044", "#0a21303C", "#04224040"
  elif mode == CCTe4w.VVXjU5    : return "#0a202020", "#0a202020", "#0a202020", "#04663366"
  elif mode == "catchupEv"           : return "#0a00191B", "#0a001116", "#0a001116", "#00553344"
  elif mode == "series2"            : return "#0a462538", "#0a462538", "#0a462538", "#04224040"
  else                : return "#0a00292B", "#0a002126", "#0a002126", "#00005566"
 @staticmethod
 @FFJRPn("Reading ...")
 def VV5KNJ(SELF, hostUrl, VVUwmk, streamId, ok_fnc, rst_fnc=None):
  pList, err = CCTe4w.VVpUIe(hostUrl, streamId, mode=1)
  title = "Catch-up TV Programs"
  if err:
   FFbBGq(SELF, "Server Error:\n\n%s" % err, title=title)
   return
  elif not pList:
   FFbBGq(SELF, "No Programs from server", title=title)
   return
  pList.sort(key=lambda x: x[0], reverse=True)
  grnSTime = ""
  VVq9SN, VVadS0, VVjgtq, VVVmGQ, VVUwmk = FFLlAM(SELF)
  span = iSearch(r"(\d{4}-\d{2}-\d{2}):(\d{2})-(\d{2})", VVadS0)
  if span : sTime = span.group(1) + " " + span.group(2) + ":" + span.group(3)
  else : sTime = ""
  grn = False
  for ndx, row in enumerate(pList):
   if sTime in row[6] and row[4] in VVUwmk:
    pList[ndx] = tuple(["#f#0055ff55#" + x for x in row])
    grnSTime = row[6]
   elif row[7] == "1":
    pList[ndx] = tuple(["#f#00ffff00#" + x for x in row])
    grnSTime = row[6]
  span = iSearch(r"(.+)\/timeshift(\/.+\/.+)\/.+\/.+(\/.+)\.ts(.+)\s>>", VVq9SN + ":" + VVjgtq, IGNORECASE)
  chUrl = "".join(span.groups()) if span else ""
  def VV5Vck(VVAIxO, title, txt, colList):
   FF9SoI(SELF.session, chUrl)
   VVAIxO.cancel()
   if rst_fnc: rst_fnc()
  def VVfcbY(VVAIxO, title, txt, colList):
   VVAIxO.VVSepa(6, grnSTime, VVAdNn=True)
  title = "Programs for : " + FFKrMM(VVUwmk, VVWH8U)
  VVfWsQ, VVB5I5, VVYCun, VVmErq = CCTe4w.VVq4P3("catchupEv")
  VVwqVu = ("Current Event" , VVfcbY , []) if grnSTime else None
  VV46TD = ("Play Latest" , VV5Vck , []) if chUrl else None
  VVj7lw  = ("Play"  , ok_fnc  , [])
  header   = ("Start" , "End" , "Duration", "Lang", "Title" , "Description" , "sTime" , "Playing" , "DurMin" )
  widths   = (16  , 16 , 9   , 6  , 30  , 23   , 0   , 0   , 0   )
  VV4Uoc  = (CENTER , CENTER, CENTER , CENTER, LEFT  , LEFT   , CENTER , CENTER , CENTER )
  FFCXsL(SELF, None, title=title, header=header, VVXpNQ=pList, VV4Uoc=VV4Uoc, VV8boH=widths, width=1800, height=950, VVPYL1=24, VVj7lw=VVj7lw, VVwqVu=VVwqVu, VV46TD=VV46TD, VVfWsQ=VVfWsQ, VVB5I5=VVB5I5, VVYCun=VVYCun, VVmErq=VVmErq)
 @staticmethod
 def VVDU1U(rUrl, fPath):
  fPath = fPath.strip()
  if fPath.startswith("http://"):
   return fPath
  elif fPath.startswith("/"):
   try:
    res = iUrlparse(rUrl)
    scheme = res.scheme
    netloc = res.netloc
    if scheme and netloc:
     host = "%s://%s" % (scheme, netloc)
     return os.path.join(host, fPath.lstrip("/"))
   except:
    pass
   return ""
  else:
   baseUrl = os.path.dirname(rUrl).strip()
   fName = os.path.basename(rUrl).strip()
   return os.path.join(baseUrl, fPath)
 def VVbEgw(self, isPortal, line, selectionObj, item):
  title = "Add server to IPTV Menu (for easy access)"
  if isPortal : txt, confItem = "Portal" , CFG.favServerPortal
  else  : txt, confItem = "Playlist", CFG.favServerPlaylist
  if confItem.getValue().strip() == line.strip():
   FF6pUe(self, BF(self.VVZYLo, title, confItem), "Already in IPTV Menu !\n\nRemove ?", title=title)
  else:
   FFBWtx(confItem, line)
   FF0onH(self, 'Added to IPTV Menu.\n\nWill be shown as "Favourite %s Server"' % txt, title=title)
 def VVZYLo(self, title, confItem):
  FFBWtx(confItem, "")
  FF0onH(self, "Removed from IPTV Menu.", title=title)
 def VVLQyh(self, isPortal):
  if isPortal:
   span = iSearch(r"(.+)\s((?:[A-Fa-f0-9]+:){5}.+[A-Fa-f0-9]+)", CFG.favServerPortal.getValue(), IGNORECASE)
   if span:
    self.VVX5v3(self, span.group(1), span.group(2))
    return
  else:
   span = iSearch(r"(http.+\/\/.+\/.+username=.+&password=.+)", CFG.favServerPlaylist.getValue(), IGNORECASE)
   if span:
    self.VVI7E9(self, "Favourite Playlist Server", span.group(1))
    return
  FFbBGq(self, "Incorrect server data !")
 @staticmethod
 def VVnCDW(SELF, isPortal, line, selectionObj, item):
  path = FF5KK0()
  if isPortal : path += "Portal_Bookmarks.txt"
  else  : path += "Playlist_Bookmarks.txt"
  title = "Bookmark Current Server"
  try:
   if FFKbVo(path):
    with ioOpen(path, "r", encoding="utf-8") as f:
     for fLine in f:
      if str(line) in str(fLine):
       FFbBGq(SELF, "Already added to file:\n\n%s" % path, title=title)
       return
   with open(path, "a") as f:
    f.write(line + "\n")
   FF0onH(SELF, "Added to file:\n\n%s" % path, title=title)
  except Exception as e:
   FFbBGq(SELF, "Error:\n\n%s" % str(e), title=title)
 def VV2si0(self, source, mode, VVaSrd, VVAIxO, title, txt, colList):
  isMulti = VVAIxO.VVGZGK
  itemsOK = True
  totTxt = "ALL"
  if isMulti:
   tot = VVAIxO.VVAGI8()
   totTxt = "%d Service%s" % (tot, FFaRsj(tot))
   if tot < 1:
    itemsOK = False
  totTxt = FFKrMM(totTxt, VVk4x7)
  VVaSrd2 = ""
  if self.VVy6Nm:
   name = iUrlparse(self.VVy6Nm).netloc
   if name:
    VVaSrd2 = "%s (%s)" % (VVaSrd, name.split(":")[0])
  mSel = CC17aQ(self, VVAIxO, addSep=False, setsOk=True, setsBlue=True)
  VV9cxb, cbFncDict = [], None
  VV9cxb.append(VVbM5H)
  if itemsOK:
   title = "Add to Bouquet"
   thTxt = "Adding Services ..."
   VV9cxb.append(("Add %s to New Bouquet : %s"    % (totTxt, FFKrMM(VVaSrd , VVOQkl)), "addToCur1"))
   if VVaSrd2: VV9cxb.append(("Add %s to New Bouquet : %s" % (totTxt, FFKrMM(VVaSrd2, VV1l75)) , "addToCur2"))
   VV9cxb.append(("Add %s to Existing/New Bouquet ..."  % (totTxt)            , "addToNew" ))
   VV9cxb.append(VVbM5H)
   VV9cxb.append(("Save %s to M3U File" % (totTxt), "toM3u" ))
   cbFncDict = { "addToCur1": BF(FF7iMz, mSel.VVAIxO, BF(self.VVMEPn , source, mode, VVaSrd , VVAIxO, title), title=thTxt)
      , "addToCur2": BF(FF7iMz, mSel.VVAIxO, BF(self.VVMEPn , source, mode, VVaSrd2, VVAIxO, title), title=thTxt)
      , "toM3u"  : BF(FF7iMz, mSel.VVAIxO, BF(self.VVvTp4  , source, mode, VVaSrd2, VVAIxO, "Save to M3U File"), title=thTxt)
      , "addToNew" : BF(self.VVTOC4, source, mode, VVaSrd, VVAIxO, title)
      }
  else:
   VV9cxb.append(("Add to Bouquet (nothing selected)", ))
  mSel.VV4sFy(VV9cxb, cbFncDict, width=1400)
 def VVMEPn(self, source, mode, VVaSrd, VVAIxO, Title):
  chUrlLst = self.VV7el1(source, mode, VVAIxO)
  CC8i1k.VVWTLg(self, Title, VVaSrd, "", chUrlLst)
 def VVTOC4(self, source, mode, VVaSrd, VVAIxO, Title):
  picker = CC8i1k(self, VVAIxO, Title, BF(self.VV7el1, source, mode, VVAIxO), VVLpD7=VVaSrd)
 def VV7el1(self, source, mode, VVAIxO):
  isMulti = VVAIxO.VVGZGK
  chUrlLst = []
  rowNum = 0
  for ndx, row in enumerate(VVAIxO.VVGpBN()):
   if not isMulti or VVAIxO.VVDjAB(ndx):
    chUrl = VVUwmk = ""
    if source in ("pEp", "pCh"):
     VVUwmk, catID, stID, chNum, chCm, serCode, serId, VVuPzU = self.VV864t(mode, row)
     VVq9SN, chUrl = self.VVaJI6(self.VVy9Fm, self.VVfHA5, mode, VVUwmk, catID, stID, chNum, chCm, serCode, serId)
    elif source in ("lv", "v", "s", "fnd"):
     VVUwmk, chUrl, VVuPzU, VVq9SN = self.VV9MVv(mode, row)
    if chUrl and VVUwmk:
     chUrlLst.append(chUrl)
  return chUrlLst
 def VVvTp4(self, source, mode, VVaSrd, VVAIxO, Title):
  chUrlLst = []
  outF = "%s%s_%s.m3u" % (FFJv8S(), FFDJVB(VVaSrd), FFRIlf())
  totCh = toB = 0
  with open(outF, "w") as f:
   f.write("#EXTM3U\n")
   for ndx, row in enumerate(VVAIxO.VVGpBN()):
    if not VVAIxO.VVGZGK or VVAIxO.VVDjAB(ndx):
     chUrl = VVUwmk = ""
     if source in ("pEp", "pCh"):
      VVUwmk, catID, stID, chNum, chCm, serCode, serId, VVuPzU = self.VV864t(mode, row)
      VVq9SN, chUrl = self.VVaJI6(self.VVy9Fm, self.VVfHA5, mode, VVUwmk, catID, stID, chNum, chCm, serCode, serId)
     elif source in ("lv", "v", "s", "fnd"):
      VVUwmk, chUrl, VVuPzU, VVq9SN = self.VV9MVv(mode, row)
     if VVUwmk and chUrl:
      chR = chUrl.replace(":" + VVUwmk, "").strip()
      span = iSearch(r'^(?:[A-Fa-f0-9]+:){10}(.*)', chR, IGNORECASE)
      if span:
       totCh += 1
       pUrl = (' tvg-logo="%s"' % VVuPzU) if VVuPzU else ""
       f.write('#EXTINF:-1 group-title="%s"%s,%s\n' % (VVaSrd, pUrl, VVUwmk))
       f.write("%s\n" % FF5ov5(span.group(1)))
  if totCh:
   FF0onH(self, "Exported %s Channel%s to:\n\n%s" % (totCh, FFaRsj(totCh), outF), title=Title)
  else:
   FFbBGq(self, "Nothing to save.", title=Title)
   FFnE7j(outF)
 @staticmethod
 def VVK7lq():
  return {"1": "DVB Stream", "4097": "ServiceMp3", "5001": "GST Player", "5002": "ExtEPlayer3", "8192": "HDMI input", "8193": "eServiceUri", "8793": "ServiceUrl"}
 @staticmethod
 def VVnWJ1():
  return sorted(tuple(CCTe4w.VVK7lq()))
 @staticmethod
 def VV4iUL(rt):
  return CCTe4w.VVK7lq().get(str(rt), "")
 @staticmethod
 def VVNgqJ(VVq9SN):
  span = iSearch(r"(?:([A-Fa-f0-9]+):){1}(?:[A-Fa-f0-9]+:){8}", VVq9SN)
  return span.group(1) if span else ""
 @staticmethod
 def VVAJ06(VVq9SN):
  return CCTe4w.VV4iUL(CCTe4w.VVNgqJ(VVq9SN))
 @staticmethod
 def VV9RvZ(rt):
  if   rt == "1"  : return True
  elif rt == "4097": return True
  elif rt == "5001": return FFKbVo("/usr/bin/gstplayer") or FFKbVo("/usr/bin/gstplayer_gst-1.0")
  elif rt == "5002": return FFKbVo("/usr/bin/exteplayer3")
  elif rt == "8192": return False
  elif rt == "8193": return FFKbVo("/usr/bin/apt-get")
  elif rt == "8793": return FFKbVo("/usr/bin/apt-get")
  else    : return False
 @staticmethod
 def VVAMwI(SELF, cbFnc):
  def VVDnWZ(rt, selectionObj, item):
   FF6pUe(SELF, BF(VVUiJ7, rt, selectionObj), "Save as Default Player ?", title="Current Player : %s (%s)" % (rt, CCTe4w.VV4iUL(rt)))
  def VVUiJ7(rt, selectionObj):
   FFBWtx(CFG.iptvAddToBouquetRefType, rt)
   selectionObj.cancel()
   FFxHED(SELF, "Saved", 800)
  curRt = CCZv30(SELF.session).refType
  defRt = CFG.iptvAddToBouquetRefType.getValue()
  VV9cxb = []
  for ndx, rt in enumerate(CCTe4w.VVnWJ1()):
   if   rt == curRt: color, txt = VVk4x7, "(Current)"
   elif rt == defRt: color, txt = VVv8b8, "(Default)"
   else   : color = txt = ""
   VV9cxb.append(FFH04v("%s\t%s %s" % (CCTe4w.VV4iUL(rt), rt, txt), rt, CCTe4w.VV9RvZ(rt), color))
   if ndx < 4 and ndx % 2: VV9cxb.append(VVbM5H)
  VVqj6y = ("Save", BF(VVDnWZ, curRt)) if curRt != defRt else None
  FFO9kU(SELF, cbFnc, VV9cxb=VV9cxb, width=700, title="Select Player", VVqj6y=VVqj6y, VVfWsQ="#11220000", VVB5I5="#11220000")
 @staticmethod
 def VV9FBH(VVadS0):
  if not FFKeSw(VVadS0) and iMatch(r"(.+)(?:(?:\/live)*|\/movie|\/series)\/(.+)\/(.+)\/(.+):(.+)", VVadS0):
   return True
  else:
   return bool(CCTe4w.VV6qyz(VVadS0))
 @staticmethod
 def VV6qyz(VVadS0):
  if "/timeshift/" in VVadS0:
   span = iSearch(r"(.+)\/timeshift\/(.+)\/(.+)\/.+\/.+\/(.+)\.ts:(.+)(?:\s>>)?", VVadS0)
   if span and all(span.groups()): return span.groups()
  else:
   span = iSearch(r"(.+)\/(.+)\/(.+)\/(\d+):(.+)", VVadS0)
   if span and all(span.groups()):
    return span.groups()
   elif "chCode" in VVadS0:
    span = iSearch(r"(http.+)\/(.+)\/(.+)\/(\d+)\?play_token.+&end=:(.+)", VVadS0)
    if span and all(span.groups()):
     return span.groups()
  return None
 @staticmethod
 def VVNsFc():
  return "Mozilla/5.0 (U; Linux; C; Emulator/1.2.12) AppleWebKit/533.3 (KHTML, like Gecko) MAG200 stbapp ver: 2 rev: 250 Safari/533.3"
 @staticmethod
 def VVFbRP():
  return { 'User-Agent': CCTe4w.VVNsFc() }
class CCizWL(object):
 def __init__(self, SELF):
  SELF["mySbFrm"] = Label()
  SELF["mySbBak"] = Label()
  SELF["mySbSld"] = Label()
  self.frm, self.bak, self.sld = SELF["mySbFrm"], SELF["mySbBak"], SELF["mySbSld"]
  self.frmI = self.bakI = self.sldI = None
  self.sldX = self.sldY = self.sldW = self.sldH = 0
  for obj in (self.frm, self.bak, self.sld): obj.hide()
 def VVNW98(self, x, y, w, h, bW=1, frmColor="#11aaaaaa", bakColor="#11003344", sldColor="#11ff8000"):
  x, y, w, h = int(x), int(y), int(w), int(h)
  FFgLA9(self.frm, frmColor)
  FFgLA9(self.bak, bakColor)
  FFgLA9(self.sld, sldColor)
  self.frmI, self.bakI, self.sldI = self.frm.instance, self.bak.instance, self.sld.instance
  self.frmI.move(ePoint(x, y))
  self.frmI.resize(eSize(w, h))
  self.bakI.move(ePoint(x + bW, y + bW))
  self.bakI.resize(eSize(w - bW * 2, h - bW * 2))
  self.sldX = x + bW
  self.sldY = y + bW
  self.sldW = w - bW * 2
  self.sldH = h - bW * 2
  self.sldI.move(ePoint(self.sldX, self.sldY))
  self.sldI.resize(eSize(self.sldW, self.sldH))
 def VVFCC0(self, val, maxN):
  if maxN < 2:
   for obj in (self.frm, self.bak, self.sld): obj.hide()
  else:
   for obj in (self.frm, self.bak, self.sld): obj.show()
   visH = max(self.sldH / maxN, self.sldH * 0.05)
   self.sldI.resize(eSize(self.sldW, int(visH)))
   y = FFel7I(val, 1, maxN, 0, self.sldH - visH)
   self.sldI.move(ePoint(self.sldX, int(self.sldY + y)))
class CCanwj(CCizWL):
 def __init__(self, VVxYE5=""):
  self.VVz8of  = self.VVmNvK["VVIZ5t"]["rows"]
  self.VVatGZ  = self.VVmNvK["VVIZ5t"]["cols"]
  self.VVnMEH  = self.VVz8of * self.VVatGZ
  self.VVxYE5  = VVxYE5
  self.VVGzjN  = self.VVmNvK["VVIZ5t"].get("percBar", 0)
  self.VVEta1  = 0
  self.VVgzrd  = 0
  self.VV9iYP  = 0
  self.curRow   = 0
  self.curCol   = 0
  self.VVETIE  = 0
  self.VV6xyn  = 0
  self.VVHoLK  = 0
  self.VV8V7w  = 0
  self.VVTUxi   = False
  self.VVM65i   = {}
  self.VVCZ6v  = None
  self.VVioZx  = {}
  self.VVf0tF  = 0
  self.VVOFKh  = 0
  self.VVG7tY  = ""
  self.VVDQEB = True
  self.VVGToO = False
  CCizWL.__init__(self, self)
  self["myCursorLbl"]  = Label()
  self["myCursorPic"]  = Pixmap()
  self["myPiconF"]  = Label()
  self["myPiconBG"]  = Label()
  self["myPiconPic"]  = Pixmap()
  self["myPiconF"].hide()
  self["myPiconBG"].hide()
  self["myPiconPic"].hide()
  for row in range(self.VVz8of):
   for col in range(self.VVatGZ):
    self["myPosterBak%d%d" % (row, col)] = Pixmap()
    self["myPosterRep%d%d" % (row, col)] = Label()
    self["myPosterPic%d%d" % (row, col)] = Pixmap()
    self["myPosterPic%d%d" % (row, col)].hide()
    self["myPosterBak%d%d" % (row, col)].hide()
    self["myPosterLbl%d%d" % (row, col)] = Label()
    self["myPosterLbl%d%d" % (row, col)].hide()
    if self.VVGzjN:
     for nm in ("myPercFr", "myPercBG", "myPercFG"):
      self[nm + "%d%d" % (row, col)] = Label()
      self[nm + "%d%d" % (row, col)].hide()
  self.VVyspd()
  VVvs2f, boxT, boxW, boxH, infT, infH, totInf, bGap = self.VVmNvK["retPar"]
  for i in range(totInf):
   self["myPiconInf%d" % i] = Label()
  FFrM8n(self,
  {
   "up"  : self.VVCdU6   ,
   "down"  : self.VV41MG  ,
   "left"  : self.VVDDr1  ,
   "right"  : self.VVksC6  ,
   "next"  : self.VV4SSV ,
   "last"  : self.VVRlRL  ,
   "pageUp" : self.VVRlRL  ,
   "chanUp" : self.VVRlRL  ,
   "pageDown" : self.VV4SSV ,
   "chanDown" : self.VV4SSV ,
   "0"   : self.VV87fP
  })
 def VVax6u(self, sbDim=None, sbFrmW=1, sbFrmColor="#11aaaaaa", sbBg="#11003344", sbSldBg="#11ff8000", shade="", cursor="#00ffff55"):
  self.VV6Ol0(shade)
  if cursor == "swap" : self.VVGToO = True
  else    : self.VVOVaF(cursor)
  self.VVi6EZ()
  self["myPiconPic"].instance.setScale(1)
  for row in range(self.VVz8of):
   for col in range(self.VVatGZ):
    self["myPosterPic%d%d" % (row, col)].instance.setScale(1)
    sz = self["myPosterPic%d%d" % (row, col)].instance.size()
    pos= self["myPosterPic%d%d" % (row, col)].instance.position()
    self.VVM65i[(row, col)] = ((pos.x(), pos.y()))
    self.VVCZ6v = (sz.width(), sz.height())
  gap = int(self.VVmNvK["VVvs2f"] / 1)
  topBox = self["myPosterPic%d%d" % (0, 0)].instance
  sz = topBox.size()
  self.VVf0tF = sz.width()
  self.VVOFKh = sz.height()
  boxX, boxY, boxW, boxH, infT, infH, totInf, bGap = self.VVmNvK["retPar"]
  if sbDim:
   x, y, w, h = sbDim
  elif self.VVmNvK["VVIZ5t"].get("upSBar", False):
   x, y, w, h = self.VVmNvK["width"] - 22, self.VVmNvK["titleH"] + 8, 15, infH - 12
  else:
   w = 20
   y = infT + infH + 3
   h = self.VVmNvK["height"] - self.VVmNvK["VVSwLg"] - y - 2
   x = self.VVmNvK["width"] - w - 2
  self.VVNW98(x, y, w, h, bW=sbFrmW, frmColor=sbFrmColor, bakColor=sbBg, sldColor=sbSldBg)
  for row in range(self.VVz8of):
   for col in range(self.VVatGZ):
    FF0u5o(self["myPosterLbl%d%d" % (row, col)], "#000000", 2)
  self["myCursorLbl"].hide()
  self["myCursorPic"].hide()
 def VV6Ol0(self, val):
  self.VVG7tY = val
  if val:
   p = CCKxBC.VV0dmK(self["myPosterBak00"], val, toPng=True) or VVK8DT + "frm2.png"
   png = FF7uiV(p)
  else:
   png = None
  for row in range(self.VVz8of):
   for col in range(self.VVatGZ):
    pic = self["myPosterBak%d%d" % (row, col)]
    pic.instance.setPixmap(png)
    pic.instance.invalidate()
    if self.VVG7tY:
     pic.show()
 def VVOVaF(self, cursor):
  if not cursor or cursor.startswith("/"):
   self["myCursorLbl"].hide()
   self["myCursorPic"].show()
   FFbRME(self["myCursorPic"], cursor if FFKbVo(cursor) else VVK8DT + "frm1.png")
  else:
   self.VVDQEB = False
   self["myCursorPic"].hide()
   self["myCursorLbl"].show()
   if iMatch(r"^#[A-Fa-f0-9]{6}$|^#[A-Fa-f0-9]{8}$", cursor):
    FFgLA9(self["myCursorLbl"], cursor)
 def VV8m4C(self):
  if not self.VVCZ6v:
   return
  normC, cursC = "#00444444", "#00ffff00"
  for row in range(self.VVz8of):
   for col in range(self.VVatGZ):
    ndx = self.VVYdgF(row, col)
    picInst = self["myPosterPic%d%d" % (row, col)].instance
    cursInst = self["myCursorPic"].instance
    cPos, cSz = cursInst.position(), cursInst.size()
    if (row, col) == (self.curRow, self.curCol):
     x, y, w, h = cPos.x(), cPos.y(), cSz.width(), cSz.height()
     if ndx in self.VVioZx:
      _, y, w1, h1 = self.VVioZx[ndx]
      _, _, w, h = self.VV4c0B(w1, h1, w, h)
      x, w = x + 6, w - 12
      self["myCursorPic"].show()
      cursInst.setBorderColor(parseColor(cursC))
      cursInst.setBorderWidth(4)
     else:
      picInst.setBorderColor(parseColor(cursC))
      picInst.setBorderWidth(4)
    elif ndx in self.VVioZx:
     x, y, w, h = self.VVioZx[ndx]
    else:
     (x, y), (w, h) = self.VVM65i[(row, col)], self.VVCZ6v
     if self.VV6xyn == self.VVYdgF(row, col):
      picInst.setBorderColor(parseColor(normC))
      picInst.setBorderWidth(1)
    picInst.move(ePoint(x, y))
    picInst.resize(eSize(*(w, h)))
 def VV8ed0(self, ndx, row, col, pic, path, reset=False):
  inst = pic.instance
  if reset:
   if (row, col) == (self.curRow, self.curCol):
    curs = self["myCursorPic"].instance
    cPos, cSz = curs.position(), curs.size()
    boxX, boxY, boxW, boxH = cPos.x(), cPos.y(), cSz.width(), cSz.height()
   else:
    (boxX, boxY), (boxW, boxH) = self.VVM65i[(row, col)], self.VVCZ6v
   if ndx in self.VVioZx:
    del self.VVioZx[ndx]
  else:
   boxX, boxY = self.VVM65i[(row, col)]
   boxW, boxH = self.VVCZ6v
  png = FF7uiV(path) or FF7uiV(VVK8DT + "noPic.png")
  if png:
   inst.setBorderWidth(0)
  else:
   inst.setBorderColor(parseColor("#00ff8055"))
   inst.setBorderWidth(2)
   return False
  pngSz = png.size()
  pngW, pngH = pngSz.width(), pngSz.height()
  inst.setPixmap(png)
  if (pngW > pngH and boxH > boxW) or (pngH > pngW and boxW > boxH) or (pngW == pngH and boxW != boxH):
   x, y, w, h = CCanwj.VV4c0B(pngW, pngH, boxW, boxH)
   x += boxX
   y += boxY
   self.VVioZx[ndx] = (x, y, w, h)
  else:
   x, y, w, h = boxX, boxY, boxW, boxH
   inst.setBorderColor(parseColor("#00444444"))
   inst.setBorderWidth(1)
  inst.resize(eSize(*(w, h)))
  inst.move(ePoint(x, y))
  return True
 def VVs4nH(self, colors):
  for i, (fg, bg) in enumerate(colors):
   if fg: FFMhbx(self["myPiconInf%d" % i], fg)
   if bg: FFgLA9(self["myPiconInf%d" % i], bg)
 def VVbc3D(self, inf0, inf1):
  self["myPiconInf0"].setText("  %s  " % inf0 )
  self["myPiconInf1"].setText("   %s   " % inf1)
  self["myPiconInf2"].setText("Num. : %d / %d" % (self.VVETIE + 1, self.VVEta1))
  self["myPiconInf3"].setText("Page: %d / %d"  % (self.VV9iYP  + 1, self.VVgzrd))
 def VVibAZ(self):
  f1 = self.VV9iYP * self.VVnMEH
  f2 = f1 + self.VVnMEH
  if f1 > self.VVEta1: f1 = self.VVEta1
  if f2 > self.VVEta1: f2 = self.VVEta1
  return f1, f2
 def VVCdU6(self):
  if self.VV9iYP == self.curRow == self.curCol == 0:
   self.VVqo47()
  else:
   if self.VV9iYP == 0 and self.curRow == 0: self.curCol = 0
   else          : self.curRow -= 1
   self.VVtG39()
 def VV41MG(self):
  if self.VV9iYP == self.VVgzrd - 1 and self.curRow == self.VVHoLK and self.curCol == self.VV8V7w:
   self.VVtT2j()
  else:
   if self.VV9iYP == self.VVgzrd - 1 and self.curRow == self.VVHoLK:
    self.curCol = self.VV8V7w
   else:
    self.curRow += 1
   self.VVtG39()
 def VVDDr1(self):
  if self.VV9iYP == self.curRow == self.curCol == 0:
   self.VVqo47()
  else:
   self.curCol -= 1
   self.VVtG39()
 def VVksC6(self):
  if self.VV9iYP == self.VVgzrd - 1 and self.curRow == self.VVHoLK and self.curCol == self.VV8V7w:
   self.VVtT2j()
  else:
   self.curCol += 1
   self.VVtG39()
 def VVRlRL(self):
  oldPage = self.VV9iYP
  if self.VV9iYP == 0:
   self.curRow = 0
   self.curCol = 0
  else:
   self.VV9iYP -= 1
  self.VVtG39(oldPage != self.VV9iYP)
 def VV4SSV(self):
  oldPage = self.VV9iYP
  if self.VV9iYP == self.VVgzrd - 1:
   self.curRow = self.VVHoLK
   self.curCol = self.VV8V7w
  else:
   self.VV9iYP += 1
  self.VVtG39(oldPage != self.VV9iYP)
 def VV87fP(self):
  if self.VVETIE == 0: self.VVqo47()
  else     : self.VVtT2j()
 def VVtT2j(self):
  force = self.VV9iYP != 0
  self.curRow  = 0
  self.curCol  = 0
  self.VV9iYP = 0
  self.VVtG39(force)
 def VVqo47(self):
  force = self.VV9iYP != self.VVgzrd - 1
  self.VV9iYP = self.VVgzrd - 1
  self.curRow  = (self.VVz8of - 1)
  self.curCol  = (self.VVatGZ - 1)
  self.VVtG39(force)
 def VVtG39(self, force=False):
  if self.VVTUxi:
   return
  oldPage = self.VV9iYP
  if self.curCol > self.VVatGZ - 1:
   self.curCol = 0
   self.curRow += 1
  elif self.curCol < 0:
   self.curCol = self.VVatGZ - 1
   self.curRow -= 1
  if self.curRow > self.VVz8of - 1:
   self.curRow = 0
   self.VV9iYP += 1
  elif self.curRow < 0:
   self.curRow = self.VVz8of - 1
   self.VV9iYP -= 1
  VVyGzv = self.VVgzrd -1
  if   self.VV9iYP < 0  : self.VV9iYP = 0
  elif self.VV9iYP > VVyGzv: self.VV9iYP = VVyGzv
  if self.curRow > self.VVz8of - 1: self.curRow = self.VVz8of - 1
  if self.curCol < 0     : self.curCol = 0
  self.VVeq8f()
  self["myCursorLbl"].hide()
  self["myCursorPic"].hide()
  self.VVFCC0(self.VV9iYP + 1, self.VVgzrd)
  FFvfpL(BF(self.VV0wyu, force or not oldPage == self.VV9iYP, VVyGzv))
 def VV0wyu(self, force, VVyGzv):
  try:
   if force:
    self.VVylN0()
   if self.VV9iYP == VVyGzv:
    if self.curRow > self.VVHoLK:
     self.curRow = self.VVHoLK
    if self.curRow == self.VVHoLK and self.curCol > self.VV8V7w:
     self.curCol = self.VV8V7w
   self.VV6xyn = self.VVETIE
   self.VVETIE = self.VV9iYP * self.VVnMEH + self.curRow * self.VVatGZ + self.curCol
   self.VVeq8f()
   boxX, boxY, boxW, boxH, infT, infH, totInf, bGap = self.VVmNvK["retPar"]
   self["myCursorLbl"].instance.move(ePoint(int(boxX + (boxW + bGap) * self.curCol) + 1, int(boxY + (boxH + bGap) * self.curRow) + 1))
   self["myCursorPic"].instance.move(ePoint(int(boxX + (boxW + bGap) * self.curCol) + 1, int(boxY + (boxH + bGap) * self.curRow) + 1))
   if self.VVGToO:
    self.VV8m4C()
   else:
    if self.VVDQEB : self["myCursorPic"].show()
    else    : self["myCursorLbl"].show()
  except:
   pass
 def VVYdgF(self, row, col):
  return self.VV9iYP * self.VVnMEH + row * self.VVatGZ + col
 def VVelYj(self, ndx):
  if ndx > -1 and ndx < self.VVEta1:
   oldPage   = self.VV9iYP
   self.VV9iYP = int(ndx / self.VVnMEH)
   firstInPage  = self.VV9iYP * self.VVnMEH
   diff   = ndx - firstInPage
   self.curRow  = int(diff / self.VVatGZ)
   firstInRow  = self.curRow * self.VVatGZ
   diff   = ndx - firstInPage
   self.curCol  = diff - self.curRow * self.VVatGZ
   self.VVtG39(False if oldPage == self.VV9iYP else True)
  else:
   FFoTZI(self, "Not found", 1000)
 def VV3OEz(self):
  if self.VVxYE5:
   for row in range(self.VVz8of):
    for col in range(self.VVatGZ):
     self["myPosterRep%d%d" % (row, col)].hide()
 def VVyspd(self):
  for row in range(self.VVz8of):
   for col in range(self.VVatGZ):
    for nm in ("myPosterBak", "myPosterRep", "myPosterPic", "myPosterLbl"):
     self[nm + "%d%d" % (row, col)].hide()
    if self.VVGzjN:
     for nm in ("myPercFr", "myPercBG", "myPercFG"):
      self[nm + "%d%d" % (row, col)].hide()
 def VVHuJq(self, row, col):
  if self.VVG7tY:
   self["myPosterBak%d%d" % (row, col)].show()
  if not self.VVGToO:
   self["myPosterRep%d%d" % (row, col)].show()
  pic = self["myPosterPic%d%d" % (row, col)]
  lbl = self["myPosterLbl%d%d" % (row, col)]
  pic.show()
  lbl.show()
  return pic, lbl
 def VVzm7Z(self, row, col, perc):
  if self.VVGzjN and perc > -1:
   if perc > -1:
    bgLbl = self["myPercBG%d%d" % (row, col)]
    fgLbl = self["myPercFG%d%d" % (row, col)]
    sz = bgLbl.instance.size()
    fgLbl.instance.resize(eSize(*(min(perc, 100) * sz.width() // 100, sz.height())))
    for nm in ("myPercFr", "myPercBG", "myPercFG"):
     self[nm + "%d%d" % (row, col)].show()
 def VVkQR6(self):
  if self.VVxYE5:
   fg = bg = self.VVxYE5.getValue()
   self.session.openWithCallback(self.VVOHxs, CCybrT, defFG=fg, defBG=bg, onlyBG=True)
 def VVOHxs(self, fg, bg):
  if self.VVxYE5 and bg:
   FFBWtx(self.VVxYE5, bg)
   self.VVi6EZ()
 def VVi6EZ(self):
  if self.VVxYE5:
   for row in range(self.VVz8of):
    for col in range(self.VVatGZ):
     FFgLA9(self["myPosterRep%d%d" % (row, col)], self.VVxYE5.getValue())
 def VVCHuh(self, lbl, txt, color=""):
  CCanwj.VV9uc3(lbl, txt, color)
 @staticmethod
 def VV9uc3(lbl, txt, color=""):
  lbl.show()
  lbl.setText(txt)
  txtW = lbl.instance.calculateSize().width()
  lblW = lbl.instance.size().width() - 15
  if txtW > lblW:
   for i in range(len(txt), 5, -1):
    txt = txt[:-1]
    lbl.setText("%s.." % txt)
    txtW = lbl.instance.calculateSize().width()
    if txtW < lblW:
     break
  if color:
   lbl.setText("%s%s" % (color, txt))
 @staticmethod
 def VV4c0B(pngW, pngH, boxW, boxH):
  r_old = float(pngW) / pngH
  r_new = float(boxW) / boxH
  if (r_old > r_new):
   w = boxW
   h = int(float(w) / r_old)
   x = 0
   y = int((boxH - h) / 2.0) + 4
  else:
   h = boxH
   w = int(h * r_old)
   y = 2
   x = int((boxW - w) / 2.0)
  return x, y, w, h
class CCL8u5(Screen, CCanwj):
 CANCEL_POSTER_DOWNLOAD = False
 def __init__(self, session, VVAIxO, pPath, nameCol, picCol, descCol, descTxt):
  self.skin, self.VVmNvK = FFQaOH(VV2auk, 1870, 1030, 50, 20, 20, "#06112a33", "#06112a33", 50, VVcmdl=2, VVoZRH=20, VVIZ5t={"rows":2, "cols":6, "picR":0.90, "lblR":0.10, "w1R":0.85, "w2R":0.15, "gapX":35, "gapY":35})
  self.session   = session
  self.Title    = "Server Browser"
  self.VVAIxO  = VVAIxO
  self.pPath    = pPath
  self.nameCol   = nameCol
  self.picCol    = picCol
  self.descCol   = descCol
  self.descTxt   = descTxt
  self.timer_updPic  = eTimer()
  self.totThreads   = 0
  self.VVE9ss = set()
  self.totDownloads  = 0
  self.VVXpNQ    = []
  self.postersNdxLst  = []
  self.totPosterUrls  = 0
  self.VVEta1   = 0
  self.VV0wMr  = True
  self.isInPlayer   = False
  FFNhKZ(self, self.Title)
  CCanwj.__init__(self)
  if not VVkY7E(self.pPath):
   FFlonU("mkdir -p '%s'" % self.pPath)
   if not VVkY7E(self.pPath):
    self.pPath = "/tmp/"
  FFmpyO(self,
  {
   "ok" : self.VVyuDa    ,
   "cancel": self.close    ,
   "menu" : self.VVGRsk ,
   "info" : self.VVAnIc
  })
  self.onShown.append(self.VVf1Ra)
  self.onClose.append(self.onExit)
 def VVf1Ra(self):
  if self.VV0wMr:
   self.VV0wMr = False
   FFeo1z(self)
   FFuwGk(self)
   self.VVax6u(cursor="swap", sbSldBg="#00777777")
   for i in range(4):
    FFgLA9(self["myPiconInf%s" % i], "#0a001a22")
   self.VVs8Ey()
  elif self.isInPlayer:
   self.isInPlayer = False
   VV9iYP, curRow, curCol = self.VV9iYP, self.curRow, self.curCol
   self.VVZs7b()
   if (VV9iYP, curRow, curCol) != (self.VV9iYP, self.curRow, self.curCol):
    self.VVtG39(False if VV9iYP == self.VV9iYP else True)
 def VVZs7b(self):
  ndx = self.VVAIxO.VVoxea()
  self.VV9iYP = int(ndx / self.VVnMEH)
  ndx     -= self.VV9iYP * self.VVnMEH
  self.curRow  = int((ndx / self.VVatGZ))
  ndx     -= self.curRow * self.VVatGZ
  self.curCol  = int((ndx % self.VVatGZ))
 def onExit(self):
  CCL8u5.CANCEL_POSTER_DOWNLOAD = True
  self.timer_updPic.stop()
 def VVGRsk(self):
  VVUwmk, subj, desc, fName, VVuPzU = self.VVXpNQ[self.VVETIE]
  VV9cxb = []
  VV9cxb.append(FFH04v("Show Selected Picture"        , "VVl4Pv"  , fName))
  VV9cxb.append(FFH04v("Export Selected Picture"        , "VVA1nE" , fName))
  VV9cxb.append(FFH04v("Set Selected Picture as a Poster for a Local Media" , "VVp6H2", fName))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Cache details"       , "VVFS7U"  ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Help (Keys)"        , "help"     ))
  FFO9kU(self, self.VVRC9j, title=self.Title, VV9cxb=VV9cxb)
 def VVRC9j(self, item=None):
  if item is not None:
   if   item == "VVl4Pv"   : self.VVl4Pv()
   elif item == "VVA1nE"   : self.VVA1nE()
   elif item == "VVp6H2"  : self.VVp6H2()
   elif item == "VVFS7U"  : self.VVFS7U()
   elif item == "help"     : FFY7F5(self, "_help_servBr", "Server Browser (Keys)")
 def VVyuDa(self):
  self.VVAIxO.VVt5t9(self.VVETIE)
  self.VVAIxO.VVblf8()
  self.isInPlayer = True
 def VVAnIc(self):
  self.VVAIxO.VVt5t9(self.VVETIE)
  self.VVAIxO.VVP9DN()
 def VVvTuB(self, url):
  fName = os.path.basename(url)
  span = iSearch(r'(.+\.(?:png|jpg))', fName, IGNORECASE)
  return span.group(1) if span else fName
 def VVs8Ey(self):
  for colList in self.VVAIxO.VVGpBN():
   VVUwmk = colList[self.nameCol]
   url  = colList[self.picCol]
   desc = colList[self.descCol]
   fName = VVuPzU = ""
   if url:
    tmpFile = self.VVvTuB(url)
    if FFKbVo(self.pPath + tmpFile):
     fName = tmpFile
    else:
     VVuPzU = url
     self.totPosterUrls += 1
   self.VVXpNQ.append((VVUwmk, self.descTxt, desc, fName, VVuPzU))
  self.VVEta1 = len(self.VVXpNQ)
  self.VVgzrd = int(self.VVEta1 / self.VVnMEH) + (self.VVEta1 % self.VVnMEH > 0)
  self.VVZs7b()
  self.VVtG39(True)
  for ndx, (VVUwmk, subj, desc, fName, VVuPzU) in enumerate(self.VVXpNQ):
   if VVuPzU and not fName:
    self.postersNdxLst.append(ndx)
  CCL8u5.CANCEL_POSTER_DOWNLOAD = False
  try: self.timer_updPic_conn = self.timer_updPic.timeout.connect(self.VV2Qg6)
  except: self.timer_updPic.callback.append(self.VV2Qg6)
  self.timer_updPic.start(50, False)
 def VVN3Pv(self):
  if self.postersNdxLst and self.totThreads < 8:
   iThread(name="ajp_DnldPic", target=self.VVLCI0).start()
 def VVLCI0(self):
  try:
   if CCL8u5.CANCEL_POSTER_DOWNLOAD: return
   self.totThreads += 1
   ndx = self.postersNdxLst[0]
   self.postersNdxLst.pop(0)
   VVUwmk, subj, desc, fName, VVuPzU = self.VVXpNQ[ndx]
   if VVuPzU and not fName:
    if CCL8u5.CANCEL_POSTER_DOWNLOAD: return
    VVUwmk, subj, desc, fName, VVuPzU = self.VVXpNQ[ndx]
    fName = self.VVvTuB(VVuPzU)
    if not fName in self.VVE9ss:
     self.VVE9ss.add(fName)
     path, err = FFUzwU(VVuPzU, fName, timeout=2, mustBeImage=True)
     if path:
      if CCL8u5.CANCEL_POSTER_DOWNLOAD:
       FFnE7j(path)
       return
      fName = fName.replace("jpeg", "jpg")
      cmd = CCpebE.VV4mAF(path, 500)
      cmd += FFQWwc("mv -f '%s' '%s'" % (path, self.pPath + fName))
      FFlonU(cmd)
    if CCL8u5.CANCEL_POSTER_DOWNLOAD: return
    self.totDownloads += 1
    self.VVXpNQ[ndx] = (VVUwmk, subj, desc, fName, "-")
   self.totThreads -= 1
  except:
   pass
 def VV2Qg6(self):
  if self.postersNdxLst:
   if self.totThreads < 8:
    iThread(name="ajp_DnldPic", target=self.VVLCI0).start()
   txt = VVPI2q + "   >> Downloading %d/%d ..." % (self.totDownloads, self.totPosterUrls)
  else:
   txt = ""
  self["myTitle"].setText("  %s%s" % (self.Title, txt))
  last = self.VVEta1
  f1 = self.VV9iYP * self.VVnMEH
  f2 = f1 + self.VVnMEH
  if f1 > last: f1 = last
  if f2 > last: f2 = last
  row = col = remain = 0
  for ndx in range(f1, f2):
   VVUwmk, subj, desc, fName, VVuPzU = self.VVXpNQ[ndx]
   if fName and VVuPzU == "-":
    path = self.pPath + fName
    if FFKbVo(path):
     self.VVXpNQ[ndx] = (VVUwmk, subj, desc, fName, "")
     pic, lbl = self.VVHuJq(row, col)
     self.VV8ed0(ndx, row, col, pic, path, reset=True)
     if ndx == self.VVETIE and self.VVGToO:
      self.VV8m4C()
   if VVuPzU and not fName:
    remain += 1
   col += 1
   if col > (self.VVatGZ - 1):
    col = 0
    row += 1
  if not txt:
   self.VVE9ss = set()
   FFdBYP(self, 2000, self.timer_updPic.stop)
 def VVylN0(self):
  self.VVyspd()
  f1, f2 = self.VVibAZ()
  row = col = 0
  for ndx in range(f1, f2):
   VVUwmk, subj, desc, fName, VVuPzU = self.VVXpNQ[ndx]
   pic, lbl = self.VVHuJq(row, col)
   self.VVCHuh(lbl, VVUwmk)
   self.VV8ed0(ndx, row, col, pic, self.pPath + fName)
   self.VVHoLK = row
   self.VV8V7w = col
   col += 1
   if col > (self.VVatGZ - 1):
    col = 0
    row += 1
 def VVeq8f(self):
  VVUwmk, subj, desc, fName, VVuPzU = self.VVXpNQ[self.VVETIE]
  self.VVbc3D(VVUwmk, "%s : %s" % (subj, desc) if desc else "")
 def VVl4Pv(self):
  VVUwmk, subj, desc, fName, VVuPzU = self.VVXpNQ[self.VVETIE]
  if fName and FFKbVo(self.pPath + fName) : CCZQAz.VVRX4k(self, self.pPath + fName)
  else          : FFoTZI(self, "File not found", 1500)
 def VVA1nE(self):
  title = "Copy Poster/PIcon"
  VVUwmk, subj, desc, fName, VVuPzU = self.VVXpNQ[self.VVETIE]
  if fName:
   dstPath = FFNaQp()
   dstF = dstPath + (FFDJVB(VVUwmk) + os.path.splitext(fName)[1] if VVUwmk else fName)
   if FFlonU("cp -f '%s' '%s'" % (self.pPath + fName, dstF)):
    FF0onH(self, "File copied to:\n\n%s" % dstF, title=title)
   else:
    FFbBGq(self, "Cannot copy the file:\n%s\n\nTo:\n%s" % (fName, dstPath), title=title)
  else:
   FFbBGq(self, "No Poster/PIcon found", title=title)
 def VVp6H2(self):
  self.session.openWithCallback(self.VVvioN, BF(CC17eA, VV8JM3="movies", VVqNQm=CFG.MovieDownloadPath.getValue()))
 def VVvioN(self, path):
  if path:
   title = "Set Selected Picture as a Poster for a Local Media"
   VVUwmk, subj, desc, fName, VVuPzU = self.VVXpNQ[self.VVETIE]
   if fName:
    srcF = self.pPath + fName
    dstF = "%s%s" % (os.path.splitext(path)[0], os.path.splitext(srcF)[1])
    if FFlonU("cp -f '%s' '%s'" % (srcF, dstF)):
     FF0onH(self, "File copied to:\n\n%s" % dstF, title=title)
    else:
     FFbBGq(self, "Cannot copy the file:\n%s\n\nTo:\n%s" % (fName, dstF), title=title)
    CCbZVM.VVbYce(dstF)
   else:
    FFbBGq(self, "No Poster/PIcon found", title=title)
 @FFJRPn("Calculating ...")
 def VVFS7U(self):
  txt = "\n"
  totSize = 0
  for path in ("Live/", "VOD/", "Series/", "M3U/"):
   path = "%sPosters/%s" % (FFJv8S(), path)
   size = "Dir. not found !"
   if VVkY7E(path):
    size = FF2ndj("find '%s' ! -type d -print0 2> /dev/null | xargs -0 ls -lsa 2> /dev/null | awk '{sum+=$6;} END {print sum;}'" % path)
    if size.isdigit():
     size = int(size)
     totSize += size
     size = CC17eA.VVxNgx(size)
   txt += "%s\n    %s\n\n" % (FFKrMM(path, VVk4x7), size)
  mainPath = "%sPosters" % FFJv8S()
  totFiles = FF2ndj("find '%s' ! -type d | wc -l" % mainPath)
  totFTxt = " (%s file%s)" % (totFiles, FFaRsj(int(totFiles))) if totFiles.isdigit() else ""
  txt += "%s\n    %s\n\n" % (FFKrMM("Total space used by Posters/PIcons%s:" % totFTxt, VVjojy), CC17eA.VVxNgx(totSize))
  mountPath = CC17eA.VVXQIL(mainPath)
  if VVkY7E(mountPath):
   totSize  = CC17eA.VVdLTI(mountPath)
   freeSize = CC17eA.VVj8Uc(mountPath)
   usedSize = CC17eA.VVxNgx(totSize - freeSize)
   totSize  = CC17eA.VVxNgx(totSize)
   freeSize = CC17eA.VVxNgx(freeSize)
   txt += "%s\n" % SEP
   txt += FFKrMM("Media Space:\n", VVWJEN)
   txt += "    Media Path\t: %s\n" % FFKrMM(mountPath, VVv8b8)
   txt += "    Total Size\t: %s\n" % totSize
   txt += "    Used Size\t: %s\n" % usedSize
   txt += "    Free Size\t: %s\n" % freeSize
  FFSMJz(self, txt, title="Cache Used Size", height=1000)
class CCbZVM(Screen, CCanwj):
 def __init__(self, session, title, lst):
  self.skin, self.VVmNvK = FFQaOH(VV2auk, 1870, 1030, 50, 20, 20, "#06112233", "#06112233", 50, VVcmdl=2, VVoZRH=20, VVIZ5t={"rows":2, "cols":6, "picR":0.90, "lblR":0.10, "w1R":0.85, "w2R":0.15, "gapX":30, "gapY":30, "percBar":1})
  self.session   = session
  self.Title    = title
  self.VVXpNQ    = lst
  self.VVW2zZ   = -1
  FFNhKZ(self, self.Title)
  CCanwj.__init__(self)
  FFmpyO(self,
  {
   "ok" : self.VV4l3p ,
   "cancel": self.close   ,
   "menu" : self.VVb4e5,
   "info" : self.VVh6VU
  })
  self.onShown.append(self.VVf1Ra)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  FFeo1z(self)
  FFuwGk(self)
  self.VVax6u(cursor="swap", sbSldBg="#00777777")
  for i in range(4):
   FFgLA9(self["myPiconInf%s" % i], "#0a001122")
  self.VVD03X()
 def VVD03X(self):
  self.VVEta1 = len(self.VVXpNQ)
  self.VVgzrd = int(self.VVEta1 / self.VVnMEH) + (self.VVEta1 % self.VVnMEH > 0)
  self.VVtG39(True)
  self.VVpfnu(VVAdNn=False)
 def VVylN0(self):
  self.VVyspd()
  f1, f2 = self.VVibAZ()
  mPath = CFG.MovieDownloadPath.getValue()
  row = col = 0
  for ndx in range(f1, f2):
   path, movie, poster = self.VVXpNQ[ndx]
   movie = os.path.join(mPath, path, movie)
   poster = os.path.join(mPath, path, poster)
   pic, lbl = self.VVHuJq(row, col)
   self.VVCHuh(lbl, os.path.splitext(os.path.basename(movie))[0])
   self.VV8ed0(ndx, row, col, pic, poster)
   d = CCZ3EO.VV1fKj(CCZ3EO.VVC06L(FF5c8a(movie)))
   if d:
    self.VVzm7Z(row, col, int(round(100.0 * d["pos"] / d["dur"])))
   self.VVHoLK = row
   self.VV8V7w = col
   col += 1
   if col > (self.VVatGZ - 1):
    col = 0
    row += 1
 def VVIkgV(self, ndx=-1):
  if ndx == -1:
   ndx = self.VVETIE
  path, movie, poster = self.VVXpNQ[ndx]
  path = os.path.join(CFG.MovieDownloadPath.getValue(), path)
  path = os.path.join(path, movie)
  if poster:
   poster = os.path.join(os.path.dirname(path), poster)
  return path, poster
 def VVeq8f(self):
  path, poster = self.VVIkgV()
  self.VVbc3D(os.path.splitext(os.path.basename(path))[0], os.path.dirname(path))
 def VVb4e5(self):
  fPath, fDir, fName = CC17eA.VVNGSU(self)
  cur = False
  if fPath:
   for ndx, (path, movie, poster) in enumerate(self.VVXpNQ):
    if fPath == os.path.join(CFG.MovieDownloadPath.getValue(), path, movie):
     cur = True
     break
  path, poster = self.VVIkgV()
  c1, c2, c3 = VVWH8U, VVv8b8 , VVk4x7
  VV9cxb = []
  VV9cxb.append((c1 + "Find a movie ..."   , "VVfAfN"  ))
  VV9cxb.append(FFH04v("Go to Current Movie" , "VVpfnu", cur, c1 ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Add Selected Movie to Bouquet", "VVq9300"))
  VV9cxb.append(("Add All Movies to Bouquet" , "VVq9301"))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(FFH04v("Show Poster" , "VVl4Pv" , poster))
  VV9cxb.append(FFH04v("Export Poster", "VVA1nE", poster))
  VV9cxb.append(VVbM5H)
  VV9cxb.append((c3 + "Change Poster (locate manually) ...", "VVKoCK"))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Help (Keys)", "help"))
  FFO9kU(self, self.VV0zmX, width=900, title=self.Title, VV9cxb=VV9cxb)
 def VV0zmX(self, item=None):
  if item is not None:
   if   item == "VVfAfN"  : self.VVfAfN()
   elif item == "VVpfnu"    : self.VVpfnu()
   elif item == "VVq9300": self.VVq930(False)
   elif item == "VVq9301": self.VVq930(True)
   elif item == "VVA1nE"    : self.VVA1nE()
   elif item == "VVl4Pv"    : self.VVl4Pv()
   elif item == "VVKoCK"  : self.VVKoCK()
   elif item == "help"      : FFY7F5(self, "_help_movBr", "Movies Browser (Keys)")
 def VVfAfN(self):
  VVuGUx = []
  for ndx, (path, movie, poster) in enumerate(self.VVXpNQ):
   path = os.path.join(CFG.MovieDownloadPath.getValue(), path)
   VVuGUx.append((os.path.splitext(movie)[0], path, str(ndx)))
  VVuGUx.sort(key=lambda x: x[0].lower())
  VVj7lw = ("Select" , self.VVHrlq, [])
  header  = ("Name" , "Path", "NDX.")
  widths  = (60  , 40 , 0  )
  FFCXsL(self, None, title="Select Movie", width=1800, height=1000, header=header, VVXpNQ=VVuGUx, VV8boH=widths, VVPYL1=26, VVj7lw=VVj7lw, VVAGe1=CFG.lastFindMovie)
 def VVHrlq(self, VVAIxO, title, txt, colList):
  self.VVelYj(int(colList[2].strip()))
  VVAIxO.cancel()
 def VVpfnu(self, VVAdNn=True):
  fPath, fDir, fName = CC17eA.VVNGSU(self)
  if fPath:
   for ndx, (path, movie, poster) in enumerate(self.VVXpNQ):
    if fPath == os.path.join(CFG.MovieDownloadPath.getValue(), path, movie):
     self.VVelYj(ndx)
     return
  if VVAdNn:
   FFoTZI(self, "Not found", 1000)
 def VV4l3p(self):
  self.VVW2zZ = self.VVETIE
  VVq9SN = self.VVwtaz()
  CCsmqb.VVlIAT(self.session, VVyhra=False, VVdxJv=VVq9SN, zapFnc=self.VVwtaz, cbFnc=self.VVt1F6)
 def VVt1F6(self):
  Len = len(self.VVXpNQ)
  mPath = CFG.MovieDownloadPath.getValue()
  self.VVXpNQ = [(path, movie, poster) for path, movie, poster in self.VVXpNQ if FFKbVo(os.path.join(mPath, path, movie))]
  if Len != len(self.VVXpNQ):
   self.VVD03X()
  else:
   self.VVelYj(self.VVW2zZ)
 def VVwtaz(self, val=0):
  ndx = self.VVW2zZ + val
  if   ndx > self.VVEta1 -1: ndx = 0
  elif ndx < 0     : ndx = self.VVEta1 - 1
  self.VVW2zZ = ndx
  path, poster = self.VVIkgV(ndx)
  VVq9SN = "%s:%s%s" % (CFG.iptvAddToBouquetRefType.getValue(), "0:" * 9, path)
  return VVq9SN
 def VVh6VU(self):
  lst = []
  path, poster = self.VVIkgV()
  size = FFLjtI(path)
  lst.append(("Media Path", path))
  if size > -1: lst.append(("Media Size", CC17eA.VVxNgx(size)))
  lst.append(("Poster Path", poster))
  size = FFLjtI(poster)
  if size > -1: lst.append(("Poster Size", CC17eA.VVxNgx(size)))
  d = CCZ3EO.VV1fKj(CCZ3EO.VVC06L(FF5c8a(path)))
  if d:
   lst.append(("Duration", FFrTEd(d["dur"] / 90000.0)))
   lst.append(("Watched", FFG6of(d["w"])))
   lst.append(("Resume Position", FFrTEd(d["pos"] / 90000.0)))
  bg="#11001122"
  FFCXsL(self, None, title="Media File Information", VVXpNQ=lst, VV8boH=(20, 80), VVPYL1=30, VVRtfk=1, VVfWsQ=bg, VVB5I5=bg, VVYCun=bg, VVypeD=0)
 def VVl4Pv(self):
  path, poster = self.VVIkgV()
  if FFKbVo(poster): CCZQAz.VVRX4k(self, poster)
  else     : FFoTZI(self, "No Poster", 1500)
 def VVA1nE(self):
  title = "Copy Poster"
  path, poster = self.VVIkgV()
  if poster:
   dstPath = FFNaQp()
   dstF = os.path.join(dstPath, os.path.basename(poster))
   if FFlonU("cp -f '%s' '%s'" % (poster, dstF)):
    FF0onH(self, "File copied to:\n\n%s" % dstF, title=title)
   else:
    FFbBGq(self, "Cannot copy the file:\n%s\n\nTo:\n%s" % (poster, dstPath), title=title)
  else:
   FFoTZI(self, "No Poster", 1500)
 def VVKoCK(self):
  path, poster = self.VVIkgV()
  sDir = FF9Uvy(os.path.dirname(path))
  self.session.openWithCallback(BF(self.VVHHXK, sDir, path), BF(CC17eA, VV8JM3="poster", VVqNQm=sDir))
 def VVK5zB(self, VVhzhr, txt, ref, ndx):
  CCZQAz.VVRX4k(self, VVezFg=ref)
 def VVHHXK(self, sDir, path, pPath=None):
  if pPath:
   newPath = sDir + os.path.splitext(os.path.basename(path))[0] + os.path.splitext(pPath)[1].lower()
   if   pPath == newPath : FFoTZI(self, "No change", 1000)
   elif FFKbVo(newPath): FF6pUe(self, BF(self.VVqqrl, pPath, newPath), "Overwrite exiting file ?\n\n%s" % os.path.basename(newPath), title="Change Poster")
   else     : self.VVqqrl(pPath, newPath)
 def VVqqrl(self, pPath, newPath):
  if FFlonU("cp -f '%s' '%s'" % (pPath, newPath)):
   self.VVXpNQ[self.VVETIE] = (self.VVXpNQ[self.VVETIE][0], self.VVXpNQ[self.VVETIE][1], os.path.basename(newPath))
   FF7iMz(self, self.VVylN0)
   CCbZVM.VVbYce(newPath)
  else:
   FFoTZI(self, "Cannot copy file.", 1000)
 def VVq930(self, isAll):
  pathLst = []
  if isAll:
   for ndx, (path, movie, poster) in enumerate(self.VVXpNQ):
    path = os.path.join(CFG.MovieDownloadPath.getValue(), path, movie)
    pathLst.append(path)
  else:
   path, poster = self.VVIkgV()
   pathLst = [path]
  picker = CC8i1k(self, self, "Add to Bouquet", BF(self.VVcCca, pathLst))
 def VVcCca(self, pathLst):
  return CC8i1k.VVoNd2(pathLst)
 @staticmethod
 def VVbYce(path):
  if path.endswith(".png"):
   fileNoExt = path[:-4]
   jpgF = fileNoExt + ".jpg"
   if FFKbVo(jpgF):
    c = 1
    newF = "%s_%d.jpg" % (fileNoExt, c)
    while FFKbVo(newF):
     c += 1
     newF = "%s_%d.jpg" % (fileNoExt, c)
    FFlonU("mv -f '%s' '%s'" % (jpgF, newF))
 @staticmethod
 @FFJRPn()
 def VV0LPB(SELF):
  eLst = CC00KO.VVgJJJ()["mov"]
  mPath = CFG.MovieDownloadPath.getValue()
  lst = []
  for (Dir, dirs, files) in os.walk(mPath):
   for f in files:
    if os.path.splitext(f)[1].lstrip(".").lower() in eLst:
     path = os.path.join(Dir, f)
     poster = ""
     for ext in ("jpg", "png"):
      pic = "%s.%s" % (os.path.splitext(path)[0], ext)
      if FFKbVo(pic):
       poster = os.path.basename(pic)
       break
     lst.append((os.path.dirname(path).replace(mPath, ""), os.path.basename(path), poster))
  title = "Movies Browser"
  lst.sort(key=lambda x: x[1].lower())
  if lst: SELF.session.open(CCbZVM, title, lst)
  else  : FFbBGq(SELF, "No movies found in:\n\n%s\n\nYou can change the path from settings." % mPath, title=title)
class CC9c0P(Screen, CCanwj):
 def __init__(self, session, bName, lst):
  self.skin, self.VVmNvK = FFQaOH(VV2auk, 1750, 1040, 50, 3, 3, "#22003344", "#22001122", 45, VVSwLg=40, VVcmdl=1, VVoZRH=20, VVIZ5t={"rows":4, "cols":6, "picR":0.75, "lblR":0.25, "w1R":0.80, "w2R":0.20, "gapX":15, "gapY":15})
  self.session   = session
  self.Title    = bName
  self.VVXpNQ    = lst
  self.pPath    = CCRGqC.VV5G3P()
  self.VVEta1   = 0
  self.VV0wMr  = True
  FFNhKZ(self, self.Title)
  FFi79B(self["keyRed"] , "OK = Zap (Review)")
  FFi79B(self["keyGreen"] , "Zap & Exit")
  FFi79B(self["keyYellow"], "Go to Current Service")
  CCanwj.__init__(self, CFG.transpColorChannels)
  FFmpyO(self,
  {
   "ok"  : BF(self.VVuMZy, False),
   "cancel" : self.VV3iIJ      ,
   "menu"  : self.VVPBrS   ,
   "red"  : self.VV3iIJ      ,
   "green"  : BF(self.VVuMZy, True) ,
   "yellow" : BF(self.VV41eV, True)
  })
  self.onShown.append(self.VVf1Ra)
 def VVf1Ra(self):
  if self.VV0wMr:
   force = True
   self.VV0wMr = False
   FFeo1z(self)
   FFuwGk(self)
   FFgLA9(self["keyRed"], "#0a333333")
   self.VVax6u()
  else:
   pName, srvLst = CC9c0P.VVuKJk()
   if srvLst and not srvLst == self.VVXpNQ:
    force = True
    self.Title = pName
    self["myTitle"].setText("  %s  " % self.Title)
    self.VVXpNQ = srvLst
   else:
    force = False
  self.VVEta1 = len(self.VVXpNQ)
  self.VVgzrd = int(self.VVEta1 / self.VVnMEH) + (self.VVEta1 % self.VVnMEH > 0)
  self.VVtG39(force)
  self.VV41eV()
 def VVPBrS(self):
  VV9cxb = []
  VV9cxb.append(("Find Name (sorted list)" , "findSrt"  ))
  VV9cxb.append(("Find Name (as listed)" , "findNoSrt"))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Change Background Color" , "VVkQR6"))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Help (Keys)", "help"))
  FFO9kU(self, self.VVXwz5, title="Options", VV9cxb=VV9cxb)
 def VVXwz5(self, item=None):
  if item:
   if   item == "findSrt"    : self.VVs8PR(True)
   elif item == "findNoSrt"   : self.VVs8PR(False)
   elif item == "VVkQR6": self.VVkQR6()
   elif item == "help"     : FFY7F5(self, "_help_srvcBr", "Services Browser (Keys)")
 def VVs8PR(self, isSort):
  VV9cxb = []
  for ndx, item in enumerate(self.VVXpNQ):
   VV9cxb.append((item[1], ndx))
  if isSort:
   VV9cxb.sort(key=lambda x: x[0].lower())
  FFO9kU(self, self.VV4VJa, title="Find Name", VV9cxb=VV9cxb, width=1300)
 def VV4VJa(self, ndx=None):
  if ndx is not None:
   self.VVelYj(ndx)
 def VV3iIJ(self):
  if self.shown: self.close()
  else   : self.show()
 def VVuMZy(self, isExit):
  try:
   if self.shown:
    chUrl = self.VVXpNQ[self.VVETIE][0]
    if isExit: self.VVk82w(chUrl)
    else  : CCsmqb.VVlIAT(self.session, VVdxJv=chUrl)
   else:
    self.show()
  except:
   pass
 @FFJRPn("Starting ...")
 def VVk82w(self, chUrl):
  FF9SoI(self.session, chUrl)
  self.close()
 def VV41eV(self, VVAdNn=False):
  serv = self.session.nav.getCurrentlyPlayingServiceReference()
  err = ""
  if serv:
   curRef = serv.toString()
   for ndx, item in enumerate(self.VVXpNQ):
    if curRef == item[0]:
     self.VVelYj(ndx)
     return ndx
   else:
    err = "Not found"
  else:
   err = "No active service"
  if VVAdNn and err:
   FFoTZI(self, err, 500)
  return -1
 def VVylN0(self):
  self.VVyspd()
  f1, f2 = self.VVibAZ()
  row = col = 0
  for ndx in range(f1, f2):
   ref, name = self.VVXpNQ[ndx]
   pic, lbl = self.VVHuJq(row, col)
   self.VVCHuh(lbl, name)
   path = CCRGqC.VVm9vg(self.pPath, ref, name)
   self.VV8ed0(ndx, row, col, pic, path)
   self.VVHoLK = row
   self.VV8V7w = col
   col += 1
   if col > (self.VVatGZ - 1):
    col = 0
    row += 1
 def VVeq8f(self):
  ref, name = self.VVXpNQ[self.VVETIE]
  span = iSearch(r"((?:[A-Fa-f0-9]+:){10})", ref)
  if span: ref = span.group(1)
  self.VVbc3D(name, ref)
 @staticmethod
 def VVqz5S():
  VVq9SN = refName = rootRef = rootName = ""
  inBouquet = False
  VV2RgF = InfoBar.instance
  if VV2RgF:
   csel = VV2RgF.servicelist
   if csel:
    currSel  = csel.getCurrentSelection()
    rootRef  = csel.getRoot().toString()
    VVq9SN  = currSel.toString()
    rootName = FFEnx2(rootRef)
    refName  = FFEnx2(VVq9SN)
    inBouquet = csel.inBouquet()
    if   inBouquet        : rootSrc = "Favourites"
    elif "(satellitePosition == " in rootRef : rootSrc = "Satellites"
    elif "name:Current transponder" in rootRef : rootSrc = "Transponder"
    elif "(provider == " in rootRef    : rootSrc = "Provider"
    else          : rootSrc = "ALL"
  return VVq9SN, refName, rootRef, rootName, inBouquet, rootSrc
 @staticmethod
 def VVuKJk(VVq9SN="", refName="", rootRef="", rootName="", inBouquet=False):
  VVq9SN, rootRef = VVq9SN.strip(), rootRef.strip()
  if not VVq9SN and not rootRef:
   VVq9SN, refName, rootRef, rootName, inBouquet, rootSrc = CC9c0P.VVqz5S()
   VVq9SN, rootRef = VVq9SN.strip(), rootRef.strip()
  pName, srvLst = "", []
  if VVq9SN and rootRef:
   if   VVq9SN.startswith("1:7:") : ref, name = VVq9SN, refName
   elif rootRef.startswith("1:7:") : ref, name = rootRef, rootName
   else       : return "", []
   srvLst = FFM85b(eServiceReference(ref))
   pName = name or "No-Name"
   if not inBouquet: srvLst.sort(key=lambda x: x[1].lower())
  else:
   srvLst = CC8i1k.VV2lFz()
   pName  = CC8i1k.VVW657() or "ALL (Group)"
  return pName, srvLst
 @staticmethod
 def VVWSgp(SELF, cbFnc=None):
  pName, srvLst = CC9c0P.VVuKJk()
  if srvLst: SELF.session.openWithCallback(cbFnc, CC9c0P, pName, srvLst)
  else  : FFbBGq(SELF, "No services found in:\n\n%s" % pName, title="Channels Browser")
class CCBj8K(Screen, CCanwj):
 def __init__(self, session, title, lst):
  self.skin, self.VVmNvK = FFQaOH(VV2auk, 1600, 1000, 50, 20, 20, "#2200202a", "#11202020", 45, VVSwLg=40, VVcmdl=2, VVoZRH=20, VVIZ5t={"rows":4, "cols":5, "picR":0.65, "lblR":0.35, "w1R":0.85, "w2R":0.15, "bGap":8, "gapX":25, "gapY":25, "mGap":8, "lblTr":1, "picBgTr":1})
  self.session   = session
  self.Title    = title
  self.VVXpNQ    = CCBj8K.VV53L2(lst)
  self.VVEta1   = 0
  self.useOrigSize  = False
  self.firstTime   = True
  FFNhKZ(self, self.Title)
  FFi79B(self["keyRed"] , "Remove Plugins")
  FFi79B(self["keyGreen"] , "Download New Plugins")
  FFi79B(self["keyYellow"], "Package Info.")
  FFi79B(self["keyBlue"] , "Plugins Group")
  CCanwj.__init__(self)
  FFmpyO(self,
  {
   "ok"  : self.VVEnUU   ,
   "cancel" : self.close    ,
   "menu"  : self.VVk59E ,
   "info"  : self.VV7qeM  ,
   "red"  : BF(self.VVHBM6, False),
   "green"  : BF(self.VVHBM6, True),
   "yellow" : self.VVoCsZ ,
   "blue"  : self.VV1xNc
  })
  self.onShown.append(self.VVf1Ra)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  FFeo1z(self)
  FFuwGk(self)
  self.VVax6u(shade="yes", cursor="")
  self.VVs4nH([("", "#22000a0b")] * 4)
  self.VVVdaz()
 def VVVdaz(self):
  self.VVEta1 = len(self.VVXpNQ)
  self.VVgzrd = int(self.VVEta1 / self.VVnMEH) + (self.VVEta1 % self.VVnMEH > 0)
  self.VVtG39(True)
 def VVk9JO(self):
  lst = CCBj8K.VV9EZ6(PluginDescriptor.WHERE_PLUGINMENU)
  if lst:
   lst = CCBj8K.VV53L2(lst)
   if lst != self.VVXpNQ:
    self.VVXpNQ = lst
    self.VVVdaz()
  else:
   self.close()
 def VVHBM6(self, isInstall):
  FFoTZI(self, "Processing ...")
  try:
   from Screens.PluginBrowser import PluginDownloadBrowser as pb
   if isInstall:
    self.session.openWithCallback(self.VVk9JO, pb, pb.DOWNLOAD, self.firstTime)
    self.firstTime = False
   else:
    self.session.openWithCallback(self.VVk9JO, pb, pb.REMOVE)
  except:
   try:
    from Screens.PluginBrowser import PluginAction as pa
    if hasattr(pa, "DOWNLOAD") and hasattr(pa, "REMOVE"):
     self.session.openWithCallback(self.VVk9JO, pa, pa.DOWNLOAD if isInstall else pa.REMOVE)
    else:
     self.session.openWithCallback(self.VVk9JO, pa, pa.MODE_INSTALL if isInstall else pa.MODE_REMOVE)
   except:
    try:
     from Plugins.SystemPlugins.SoftwareManager.plugin import PluginManager as pb
     self.session.openWithCallback(self.VVk9JO, pb)
    except Exception as e:
     FFbBGq(self, 'Cannot open "Extensions Management" !', title=self.Title)
  FFoTZI(self)
 def VVEnUU(self):
  name, desc = self.VVUc9b(self.VVETIE)
  if name == PLUGIN_NAME and "VVloQE" in globals() and VVloQE:
   FFoTZI(self, "Already running.", 500)
  else:
   try:
    p = self.VVXpNQ[self.VVETIE]
    p(session=self.session)
   except:
    FFbBGq(self, "Cannot start from here !", title="Error in : %s" % name)
 def VV7qeM(self):
  def VVqz4B(key, val):
   return key + "\t: " + str(val) + "\n"
  p = self.VVXpNQ[self.VVETIE]
  txt = ""
  try:
   txt += VVqz4B("Path"  , p.path  )
   txt += VVqz4B("Description" , p.description )
   txt += VVqz4B("Icon"  , p.iconstr  )
   txt += VVqz4B("Wakeup Fnc" , p.wakeupfnc )
   txt += VVqz4B("NeedsRestart", p.needsRestart)
   txt += VVqz4B("Internal" , p.internal )
   txt += VVqz4B("Weight"  , p.weight  )
  except:
   pass
  name, desc = self.VVUc9b(self.VVETIE)
  if txt : FFSMJz(self, txt, title=name)
  else : FFbBGq(self, "Could not read plugin info.", title=name)
 @FFJRPn()
 def VVoCsZ(self):
  p = self.VVXpNQ[self.VVETIE]
  name, desc = self.VVUc9b(self.VVETIE)
  path = p.path
  pkg, err = CCz0DD.VVRgRC(path)
  if pkg : CCz0DD.VVHbAQ(self, pkg, name)
  else : FF8bV6(self, err, 1000)
 def VVk59E(self):
  path = self.VVXpNQ[self.VVETIE].path
  VV9cxb = []
  txt = "Open Plugin Path in File Manager"
  VV9cxb.append(FFH04v("Open Plugin Path in File Manager", "inFileMan", VVkY7E(path)))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Use Original Icon Size", "setOrigSize"))
  FFO9kU(self, self.VV59LA, title="Plugins Group", VV9cxb=VV9cxb)
 def VV59LA(self, item=None):
  if item:
   if item == "inFileMan":
    self.session.open(CC17eA, mode=CC17eA.VVD8zE, VVqNQm=self.VVXpNQ[self.VVETIE].path)
   elif item == "setOrigSize":
    self.useOrigSize = True
    self.VVtG39(True)
 def VV1xNc(self):
  FFO9kU(self, self.VVEUHM, title="Plugins Group", VV9cxb=CCBj8K.VV17jv(True, True), width=700, VVDkqE=True)
 def VVEUHM(self, item=None):
  if item:
   title, where, ndx = item
   self["myTitle"].setText("  %s (%s)" % (self.Title, title))
   lst = CCBj8K.VV9EZ6(where)
   if lst:
    self.VVXpNQ = CCBj8K.VV53L2(lst)
    self.VV9iYP = self.curCol = self.curRow = self.VVETIE = 0
    self.VVEta1 = len(self.VVXpNQ)
    self.VVgzrd = int(self.VVEta1 / self.VVnMEH) + (self.VVEta1 % self.VVnMEH > 0)
    self.VVtG39(True)
   else:
    FFbBGq(self, "Not found !", title=self.Title)
 def VVylN0(self):
  self.VVyspd()
  f1, f2 = self.VVibAZ()
  row = col = 0
  for ndx in range(f1, f2):
   name, desc = self.VVUc9b(ndx)
   pic, lbl = self.VVHuJq(row, col)
   self.VVCHuh(lbl, name)
   iconOk = False
   pngSz = None
   if self.VVXpNQ[ndx].icon:
    try:
     pngSz = self.VVXpNQ[ndx].icon.size()
     pic.instance.setScale(1)
     pic.instance.setPixmap(self.VVXpNQ[ndx].icon)
     pic.show()
     iconOk = True
    except:
     pass
   if not iconOk:
    icons = []
    path = self.VVXpNQ[ndx].path
    if VVkY7E(path):
     for f in ("iconfhd.png", "iconhd.png", "icon.png"):
      icons.append(os.path.join(path, f))
    icons.append(resolveFilename(SCOPE_CURRENT_SKIN, "icons/plugin.png"))
    icons.append(VVK8DT + "plugin.png")
    for path in icons:
     pixMap = FFbRME(pic, path)
     if pixMap:
      pngSz = pixMap.size()
      break
   if self.useOrigSize and pngSz:
    try:
     boxSz = pic.instance.size()
     VVM65i = pic.instance.position()
     pngW, pngH = pngSz.width(), pngSz.height()
     boxW, boxH = boxSz.width(), boxSz.height()
     if boxW > pngW and boxH > pngH:
      pic.instance.resize(pngSz)
      pic.instance.move(ePoint(VVM65i.x() + (boxW - pngW) // 2, VVM65i.y() + (boxH - pngH) // 2))
    except:
     pass
   self.VVHoLK = row
   self.VV8V7w = col
   col += 1
   if col > (self.VVatGZ - 1):
    col = 0
    row += 1
 def VVUc9b(self, ndx):
  name = str(self.VVXpNQ[ndx].name).strip()
  desc = str(self.VVXpNQ[ndx].description).strip().replace("\n", " >> ")
  if not name or name == "Plugin":
   name = desc or FFiZj6(self.VVXpNQ[ndx].path)
  return name, desc
 def VVeq8f(self):
  name, desc = self.VVUc9b(self.VVETIE)
  self.VVbc3D(name, desc)
 @staticmethod
 def VV17jv(isMenu=False, addTot=False):
  lst =[("Plugin Menu"   , PluginDescriptor.WHERE_PLUGINMENU    )
   , ("Audio Menu"    , PluginDescriptor.WHERE_AUDIOMENU    )
   , ("Auto-Start Menu"  , PluginDescriptor.WHERE_AUTOSTART    )
   , ("Channel Context Menu" , PluginDescriptor.WHERE_CHANNEL_CONTEXT_MENU )
   , ("Event Info"    , PluginDescriptor.WHERE_EVENTINFO    )
   , ("Extensions Menu"  , PluginDescriptor.WHERE_EXTENSIONSMENU   )
   , ("File Scan"    , PluginDescriptor.WHERE_FILESCAN    )
   , ("Main Menu"    , PluginDescriptor.WHERE_MAINMENU    )
   , ("Menu"     , PluginDescriptor.WHERE_MENU     )
   , ("Movie List"    , PluginDescriptor.WHERE_MOVIELIST    )
   , ("Network Configuration" , PluginDescriptor.WHERE_NETWORKCONFIG_READ  )
   , ("Network Setup"   , PluginDescriptor.WHERE_NETWORKSETUP   )
   , ("Session Start"   , PluginDescriptor.WHERE_SESSIONSTART   )
   , ("Software Manager"  , PluginDescriptor.WHERE_SOFTWAREMANAGER  )
   , ("Teletext"    , PluginDescriptor.WHERE_TELETEXT    )
   , ("Wizard"     , PluginDescriptor.WHERE_WIZARD     )]
  if addTot:
   for ndx, item in enumerate(lst):
    tot = len(CCBj8K.VV9EZ6(item[1]))
    lst[ndx] = ("%s   %s(%d)" % (lst[ndx][0], VV0p9P, tot), lst[ndx][1])
  if isMenu: lst.insert(1, VVbM5H)
  else  : lst.sort(key=lambda x: x[0].lower())
  return lst
 @staticmethod
 def VV9EZ6(where):
  try: return iPlugins.getPlugins(where)
  except: return []
 @staticmethod
 def VV53L2(lst):
  tmp = []
  for item in lst:
   name = str(item.name).strip()
   if not name or name == "Plugin":
    name = str(item.description).strip() or FFiZj6(item.path)
   tmp.append((name, item))
  tmp.sort(key=lambda x: x[0].lower())
  lst = []
  for nm, obj in tmp:
   lst.append(obj)
  return lst
 @staticmethod
 def VVhtKh(session):
  title = "Plugins Browser"
  lst = CCBj8K.VV9EZ6(PluginDescriptor.WHERE_PLUGINMENU)
  if lst : session.open(CCBj8K, title, lst)
  else : FFvOl9(session, "No plugins found !", title=title)
class CCKxBC(Screen, CCanwj):
 VVkIsq  = "Custom Menu"
 VV9Hwa = "ajpanel_menu.xml"
 VV5kDg  = {}
 def __init__(self, session, subFile="", subName="", picpath="", startItem=0):
  self.session  = session
  self.VVq9SNPatt = r"^((?:[A-Fa-f0-9]+(?::|_)){9}(?:[A-Fa-f0-9]+))(.*)"
  self.startItem  = startItem
  self.def_cursor_fg = "#11ffccaa"
  self.def_cursor_bg = "#11442244"
  self.def_title_fg = "#00ffffaa"
  self.def_title_bg = "#0cff0011"
  self.def_body_bg = "#0c001122"
  self.moveCM_data = None
  self.moveCM_win  = None
  self.VVQ1Er = {"title": self.VVkIsq, "mode": "list", "width": -1, "height": -1, "fg": "#00ffffff", "bg": self.def_body_bg, "font_size": 30, "align_items": 0, "title_fg": self.def_title_fg, "title_font_size": 50, "cursor_fg": self.def_cursor_fg, "cursor_bg": self.def_cursor_bg, "line_gap": 0.15, "box_gap": 0, "picpath": picpath, "lst": []}
  for k in ("title_bg", "title1_fg", "title1_bg", "title2_fg", "title2_bg", "num_fg", "num_bg", "shade", "cursor"):
   self.VVQ1Er[k] = ""
  if subFile:
   self.filePath = subFile
  else:
   self.filePath = CCKxBC.VVzmRG()
   CCKxBC.VV5kDg = {}
  self.subName = subName
  self.err  = self.VVZ0Li(subName)
  self.Title  = self.VVQ1Er["title"]
  self.isGrid, self.isStretch, cols, rows = self.VVjz7X(self.VVQ1Er["mode"])
  titleBg = self.VVQ1Er["title_bg"] or self.def_title_bg
  bodyBg = self.VVQ1Er["bg"] if self.VVNkZh(self.VVQ1Er["bg"]) else self.def_body_bg
  cursC = self.VVQ1Er["cursor"] if self.VVNkZh(self.VVQ1Er["cursor"]) else ""
  bGap = self.VVQ1Er["box_gap"]
  lblFR = FFel7I(self.VVQ1Er["font_size"], 10, 50, 0.4, 0.8)
  w, h, VVAQi3, VVvs2f, VVXAYU, textFg, VVYvMU = self.VVQ1Er["width"], self.VVQ1Er["height"], self.VVQ1Er["title_font_size"], 15, 15, self.VVQ1Er["fg"], self.VVQ1Er["font_size"]
  if self.isGrid : self.skin, self.VVmNvK = FFQaOH(VV2auk, w, h, VVAQi3, VVvs2f, VVXAYU, titleBg, bodyBg, VVYvMU, VVcmdl=2, VVoZRH=20, VVIZ5t={"rows":rows, "cols":cols, "picR":0.65, "lblR":0.35, "lblFR":lblFR, "w1R":0.80, "w2R":0.20, "trC":"", "bGap":bGap, "gapX":22, "gapY":22, "mGap":15, "lblFg":textFg, "lblTr":1, "picBgTr":1, "upSBar":True})
  else   : self.skin, self.VVmNvK = FFQaOH(VVNkG2   , w, h, VVAQi3, VVvs2f, VVXAYU, titleBg, bodyBg, VVYvMU, VVcmdl=2, VVwv0z=self.VVQ1Er["line_gap"])
  self.VVXpNQ = self.VV5Sq3() if self.VVQ1Er["lst"] else []
  FFNhKZ(self, title=self.Title)
  if self.isGrid:
   CCanwj.__init__(self)
  else:
   self["myMenu"] = MenuList(self.VVXpNQ, True, eListboxPythonMultiContent)
   self["myMenu"].l.setFont(0, gFont(VV3IRX, self.VVmNvK["VVYvMU"]))
   FFrM8n(self, {})
  FFmpyO(self,
  {
   "ok" : self.VVyuDa ,
   "cancel": self.cancel ,
   "menu" : self.VVr8oo ,
   "info" : self.VVoSTG
  })
  self.onShown.append(self.VVf1Ra)
  self.onClose.append(self.onExit)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  FFeo1z(self)
  if self.err:
   CCQyUl.VVXqCi(self, os.path.basename(self.filePath), self.err, title=self.VVQ1Er["title"])
   self.close()
   return
  space = "  "
  if self.isGrid:
   self.VVax6u(shade=self.VVQ1Er["shade"], cursor=self.VVQ1Er["cursor"])
   self.VVEta1 = len(self.VVXpNQ)
   self.VVgzrd = int(self.VVEta1 / self.VVnMEH) + (self.VVEta1 % self.VVnMEH > 0)
   self.VVtG39(True)
   if self.startItem > 0:
    self.VVelYj(min(self.startItem, len(self.VVXpNQ) - 1))
  else:
   offset = {0: 20, 1: 0, 2: -20}.get(self.VVQ1Er["align_items"])
   FFNUiO(self, offset=offset)
   if self.VVQ1Er["align_items"] == 2:
    obj = self["keyInfo"].instance
    pos = obj.position()
    obj.move(ePoint(10, pos.y()))
    space = str(u"\u2007")
   self["myTitle"].instance.setHAlign(self.VVQ1Er["align_items"])
   self["myMenu"].instance.setTransparent(True)
   FFMhbx(self["myMenu"], self.VVQ1Er["fg"])
   FFvJ8o(self["myMenu"], fg=self.VVQ1Er["cursor_fg"], bg=self.VVQ1Er["cursor_bg"])
   try:
    self["myMenu"].instance.setHAlign(self.VVQ1Er["align_items"])
   except:
    pass
   if self.startItem > 0:
    self["myMenu"].moveToIndex(min(self.startItem, len(self.VVXpNQ) - 1))
  self["myTitle"].setText("%s%s%s" % (space, self.Title, space))
  self.VV2IBU()
 def onExit(self):
  self.VVhyI2()
 def VV2IBU(self):
  wp = CCKxBC.VVX9t7(self["myWP"], self.VVQ1Er["bg"])
  if wp: self["myWP"].show()
  else : self["myWP"].hide()
  if not wp:
   FFgLA9(self["myBody"], self.VVQ1Er["bg"] if self.VVNkZh(self.VVQ1Er["bg"]) else self.def_body_bg)
  self["myTitle"].instance.setTransparent(False)
  FFMhbx(self["myTitle"], self.VVQ1Er["title_fg"] or self.def_title_fg)
  if self.VVQ1Er["title_bg"]: FFgLA9(self["myTitle"], self.VVQ1Er["title_bg"])
  else      : self["myTitle"].instance.setTransparent(True)
  self["myTitle"].instance.invalidate()
  if self.isGrid:
   fg1, fg2, bg = "#0088ff88", "#00aaaaaa", "#11000a0b"
   self.VVs4nH(((self.VVQ1Er["title1_fg"] or fg1, self.VVQ1Er["title1_bg"] or bg)
         , (self.VVQ1Er["title2_fg"] or fg2, self.VVQ1Er["title2_bg"] or bg)
         , (self.VVQ1Er["num_fg"]   or fg2, self.VVQ1Er["num_bg"]  or bg)
         , (self.VVQ1Er["num_fg"]   or fg2, self.VVQ1Er["num_bg"]  or bg) ))
   if wp:
    for i, bg in enumerate((self.VVQ1Er["title1_bg"], self.VVQ1Er["title2_bg"], self.VVQ1Er["num_bg"], self.VVQ1Er["num_bg"])):
     self["myPiconInf%d" % i].instance.setTransparent(False if bg else True)
     self["myPiconInf%d" % i].instance.invalidate()
 def VVyuDa(self):
  if self.moveCM_data:
   self.VVorWw()
  else:
   txt, ref, itemDict = self.VVvnG3()
   fnc = BF(self.VVVwEc, txt, ref, itemDict)
   if "ask" in itemDict:
    FF6pUe(self, fnc, itemDict.get("ask") or "Continue ?", title=txt)
   else:
    fnc()
 def cancel(self):
  if self.moveCM_data:
   self.VVhyI2()
  else:
   FFc1M2()
   self.close()
 def VVr8oo(self, title="Options", mode=0):
  c1, c2, c3, c4, c5 = VVk4x7, VVv8b8, VVWH8U, VVdLWL, VVWJEN
  isGrid, _, _, _ = self.VVjz7X(self.VVQ1Er["mode"])
  VV9cxb = []
  if mode == 0:
   if self.moveCM_data:
    VV9cxb.append(("Move to current position"    , "movGo" ))
    VV9cxb.append(("Cancel Move"       , "movNot" ))
   else:
    VV9cxb.append((c1 + "Change Current Icon (File Path)" , "icnFil" ))
    VV9cxb.append((c1 + "Change Current Icon (Base64)" , "icnB64" ))
    VV9cxb.append((c1 + "Reset Current Icon (to Default)" , "icnDef" ))
    VV9cxb.append(VVbM5H)
    VV9cxb.append((c2 + "Main Title"      , "ttl"  ))
    if isGrid:
     VV9cxb.append((c2 + "Information Title-1"   , "ttl1" ))
     VV9cxb.append((c2 + "Information Title-2"   , "ttl2" ))
     VV9cxb.append((c2 + "Scroll Page Number"   , "pg"  ))
     VV9cxb.append(VVbM5H)
     VV9cxb.append((c3 + "Shade"      , "gShad" ))
     VV9cxb.append((c3 + "Shade Gap"     , "bGap" ))
     VV9cxb.append((c3 + "Cursor"      , "gCurs" ))
    else:
     VV9cxb.append(VVbM5H)
     VV9cxb.append((c3 + "Cursor"      , "lCurs" ))
    VV9cxb.append((c3 + "Background Color/Wallpaper"  , "wpMnu" ))
    VV9cxb.append(VVbM5H)
    VV9cxb.append((c4 + "Clear Cached Picture Files"  , "cach" ))
    VV9cxb.append(FFH04v("Delete Current Item"  , "del"  , isGrid, c4))
    VV9cxb.append(VVbM5H)
    VV9cxb.append(FFH04v("Move Selected Item"   , "movGo" , isGrid and not self.subName, c5))
    VV9cxb.append((c5 + "Change Current Menu Pictures Path", "pPath" ))
    VV9cxb.append(FFH04v("Insert Menu XML File"   , "impX" , not self.subName, c5))
   FFO9kU(self, self.VVjpyP, width=800, height=1050, title="Options", VV9cxb=VV9cxb, VVDkqE=True, VVfWsQ="#0a111111", VVB5I5="#0a111111")
  else:
   if mode == 2:
    VV9cxb.append(("Change Wallpaper (File Path)" , "wpFil" ))
    VV9cxb.append(("Change Wallpaper (Base64)" , "wpB64" ))
    VV9cxb.append(("Change to a Color"   , "wpCol" ))
    VV9cxb.append(VVbM5H)
    VV9cxb.append((c4 + "Reset Wallpaper"   , "wpRm" ))
   elif mode == 3:
    VV9cxb.append(("Change Picture (File Path)" , "shFil" ))
    VV9cxb.append(("Change Picture (Base64)"  , "shB64" ))
    VV9cxb.append(("Change Picture to default" , "shDef" ))
    VV9cxb.append(VVbM5H)
    VV9cxb.append((c4 + "Remove Shade"   , "shRm" ))
   elif mode == 4:
    VV9cxb.append(("Change Picture (File Path))" , "crsFil" ))
    VV9cxb.append(("Change Picture (Base64)"  , "crsB64" ))
    VV9cxb.append(("Change Color"     , "crsCol" ))
    VV9cxb.append(VVbM5H)
    VV9cxb.append((c4 + "Reset to Default"  , "crsRm" ))
   elif mode == 5:
    VV9cxb.append(("Change Text Color"   , "lColF" ))
    VV9cxb.append(("Change Background Color"  , "lColB" ))
    VV9cxb.append(VVbM5H)
    VV9cxb.append((c4 + "Reset to Default"  , "lRm"  ))
   elif mode == 6:
    VV9cxb.append(("Change Text Color"   , "ttlF" ))
    VV9cxb.append(("Change Background Color"  , "ttlB" ))
    VV9cxb.append(VVbM5H)
    VV9cxb.append((c4 + "Reset Text Color"  , "ttlRf" ))
    VV9cxb.append((c4 + "Reset Background Color" , "ttlRb" ))
   elif mode == 7:
    VV9cxb.append(("Change Text Color"   , "ttl1F" ))
    VV9cxb.append(("Change Background Color"  , "ttl1B" ))
    VV9cxb.append(VVbM5H)
    VV9cxb.append((c4 + "Reset Text Color"  , "ttl1Rf" ))
    VV9cxb.append((c4 + "Reset Background Color" , "ttl1Rb" ))
   elif mode == 8:
    VV9cxb.append(("Change Text Color"   , "ttl2F" ))
    VV9cxb.append(("Change Background Color"  , "ttl2B" ))
    VV9cxb.append(VVbM5H)
    VV9cxb.append((c4 + "Reset Text Color"  , "ttl2Rf" ))
    VV9cxb.append((c4 + "Reset Background Color" , "ttl2Rb" ))
   elif mode == 9:
    VV9cxb.append(("Change Text Color"   , "pgF"  ))
    VV9cxb.append(("Change Background Color"  , "pgB"  ))
    VV9cxb.append(VVbM5H)
    VV9cxb.append((c4 + "Reset Text Color"  , "pgRf" ))
    VV9cxb.append((c4 + "Reset Background Color" , "pgRb" ))
   elif mode == 100:
    for i in range(0, 110, 10):
     VV9cxb.append((str(i)      , "bGap%d" % i))
   else:
    return
   FFO9kU(self, self.VVjpyP, title=title, width=700, VV9cxb=VV9cxb, VVDkqE=True, VVfWsQ="#0a222222", VVB5I5="#0a222222")
 def VVjpyP(self, item=None):
  if item:
   title, ref, ndx = item
   if   ref == "icnFil": self.VVupuR(title, 1, False)
   elif ref == "icnB64": self.VVupuR(title, 1, True )
   elif ref == "icnDef": self.VVRXky(title, 1, False, "")
   elif ref == "wpMnu" : self.VVr8oo(title, 2)
   elif ref == "wpFil" : self.VVupuR(title, 2, False)
   elif ref == "wpB64" : self.VVupuR(title, 2, True )
   elif ref == "wpCol" : self.VVHKeA(title , 2)
   elif ref == "wpRm" : self.VVRXky(title, 2, False, "")
   elif ref == "gShad" : self.VVr8oo(title, 3)
   elif ref == "shFil" : self.VVupuR(title, 3, False)
   elif ref == "shB64" : self.VVupuR(title, 3, True )
   elif ref == "shDef" : self.VVRXky(title, 3, False, "yes")
   elif ref == "shRm" : self.VVRXky(title, 3, False, "")
   elif ref == "gCurs" : self.VVr8oo(title, 4)
   elif ref == "crsFil": self.VVupuR(title, 4, False)
   elif ref == "crsB64": self.VVupuR(title, 4, True )
   elif ref == "crsCol": self.VVHKeA(title , 4)
   elif ref == "crsRm" : self.VVRXky(title, 4, False, "")
   elif ref == "lCurs" : self.VVr8oo(title, 5)
   elif ref == "lColF" : self.VVHKeA(title , 50)
   elif ref == "lColB" : self.VVHKeA(title , 51)
   elif ref == "lRm" : self.VVRXky(title, 51, False, "")
   elif ref == "ttl" : self.VVr8oo(title, 6)
   elif ref == "ttlF" : self.VVHKeA(title , 60)
   elif ref == "ttlB" : self.VVHKeA(title , 61)
   elif ref == "ttlRf" : self.VVRXky(title, 60, False, "")
   elif ref == "ttlRb" : self.VVRXky(title, 61, False, "")
   elif ref == "ttl1" : self.VVr8oo(title, 7)
   elif ref == "ttl1F" : self.VVHKeA(title , 70)
   elif ref == "ttl1B" : self.VVHKeA(title , 71)
   elif ref == "ttl1Rf": self.VVRXky(title, 70, False, "")
   elif ref == "ttl1Rb": self.VVRXky(title, 71, False, "")
   elif ref == "ttl2" : self.VVr8oo(title, 8)
   elif ref == "ttl2F" : self.VVHKeA(title , 80)
   elif ref == "ttl2B" : self.VVHKeA(title , 81)
   elif ref == "ttl2Rf": self.VVRXky(title, 80, False, "")
   elif ref == "ttl2Rb": self.VVRXky(title, 81, False, "")
   elif ref == "pg" : self.VVr8oo(title, 9)
   elif ref == "pgF" : self.VVHKeA(title , 90)
   elif ref == "pgB" : self.VVHKeA(title , 91)
   elif ref == "pgRf" : self.VVRXky(title, 90, False, "")
   elif ref == "pgRb" : self.VVRXky(title, 91, False, "")
   elif ref == "bGap"   : self.VVr8oo(title, 100)
   elif ref.startswith("bGap") : self.VVeNv1(title, mainAttr=("box_gap", ref[4:]))
   elif ref == "cach" : FF6pUe(self, self.VVEkpW, "Continue ?", title=title)
   elif ref == "del" : FF6pUe(self, BF(self.VVeNv1, title, delItem=True), "Continue ?", title=title)
   elif ref == "movGo" : self.VVorWw()
   elif ref == "movNot": self.VVhyI2()
   elif ref == "pPath" : self.session.openWithCallback(BF(self.VVVzyl, title), BF(CC17eA, mode=CC17eA.VVAcq8, VVqNQm=self.VV59Qg(), width=1200, height=840, pickTitleBG="#11221122", pickBodyBG="#11221122", VVfINZ="#0a552255"))
   elif ref == "impX" : self.session.openWithCallback(BF(self.VVREYk, title), BF(CC17eA, VV8JM3="custMnu", VVqNQm=self.VVa5Ey()))
 def VVorWw(self):
  title = "Move Selected Item"
  curPos = self.VVc1Op()
  if not self.moveCM_data:
   self.moveCM_data = self.VVeNv1(title, getItem=True)
   pos = self.instance.position()
   x, y = pos.x(), pos.y()
   self.moveCM_win = CCJe5E.VV9IOS(self.session, "Move cursor and click OK", 35, shadW=2, bg="#00880000", x=x, y=y+20)
   FFbKGy(self.moveCM_win, 0)
  else:
   oldNdx, elem = self.moveCM_data
   newNdx, _ = self.VVeNv1(title, getItem=True)
   if oldNdx == newNdx:
    FFoTZI(self, "Try another position", 1000)
   else:
    self.VVhyI2()
    self.VVelYj(newNdx)
    self.VVeNv1(title, moveItem=(oldNdx, newNdx, elem))
 def VVhyI2(self):
  if self.moveCM_win:
   self.session.deleteDialog(self.moveCM_win)
  self.moveCM_data = self.moveCM_win = None
 def VV59Qg(self):
  picP, xmlP = CFG.lastCustMenuPicDir.getValue(), CFG.lastCustMenuXmlDir.getValue()
  if   picP: return picP
  elif xmlP: return xmlP
  else  : return CCKxBC.VVHEMl()
 def VVa5Ey(self):
  picP, xmlP = CFG.lastCustMenuPicDir.getValue(), CFG.lastCustMenuXmlDir.getValue()
  if   xmlP: return xmlP
  elif picP: return picP
  else  : return CCKxBC.VVHEMl()
 def VVREYk(self, title, path=None):
  if path:
   FFBWtx(CFG.lastCustMenuXmlDir, os.path.dirname(path))
   err = ""
   try:
    for ndx, (event, elem) in enumerate(iElem.iterparse(path, events=("start", ))):
     if ndx == 0 and elem.tag == "ajp_menu":
      mName = FFfkDl(elem, "title") or CCKxBC.VVkIsq
      icon, err = self.VV4aOI(elem, "icon", False)
      if not err:
       fName = os.path.basename(path)
       if not mName:
        err = "No menu name in:\n\n%s" % fName
       elif fName == CCKxBC.VV9Hwa or fName in CCKxBC.VV5kDg.keys():
        err = "File is already used:\n\n%s" % fName
       else:
        el = iElem.Element("item")
        el.set("name", mName)
        if icon:
         el.set("icon", icon)
        el.text = path
        el.tail = "\n\n\t"
        self.VVeNv1(title, newElem=el)
     else:
      err = "Invalid Custom Menu file.\n\nCannot get menu name."
     break
   except Exception as e:
    err = "Invalid Custom Menu file.\n\n%s" % str(e)
   if err:
    FFbBGq(self, err, title=title)
 def VV2Xmw(self, mode):
  return {  1: "icon"
    , 2: "bg"
    , 3: "shade"
    , 4: "cursor"
    , 50: "cursor_fg" , 51: "cursor_bg"
    , 60: "title_fg" , 61: "title_bg"
    , 70: "title1_fg" , 71: "title1_bg"
    , 80: "title2_fg" , 81: "title2_bg"
    , 90: "num_fg"  , 91: "num_bg"
    }.get(mode, "")
 def VVHKeA(self, title, mode):
  attr  = self.VV2Xmw(mode)
  isBg  = False if attr.endswith("fg") else True
  fg = self.VVQ1Er[attr.replace("bg", "fg")]
  bg = self.VVQ1Er[attr.replace("fg", "bg")]
  fg = fg if self.VVNkZh(fg) else "#00ffffff"
  bg = bg if self.VVNkZh(bg) else "#00000040"
  self.session.openWithCallback(BF(self.VVpuM1, title, mode), CCybrT, defFG=fg, defBG=bg, onlyBG=True, isBgMode=isBg)
 def VVpuM1(self, title, mode, fg, bg):
  if fg or bg:
   attr  = self.VV2Xmw(mode)
   self.VVRXky(title, mode, False, fg if attr.endswith("fg") else bg)
 def VVupuR(self, title, mode, isB64):
  self.session.openWithCallback(BF(self.VVAAz6, title, mode, isB64), CC17eA, VV8JM3="poster", VVqNQm=self.VV59Qg())
 def VVAAz6(self, title, mode, isB64, path=None):
  if path:
   FFBWtx(CFG.lastCustMenuPicDir, os.path.dirname(path))
   err = self.VVKCyr(path)
   if err : FFbBGq(self, err, title=title)
   else : self.VVRXky(title, mode, isB64, path)
 def VVKCyr(self, path):
  fName = os.path.basename(path)
  try:
   p = LoadPixmap(path)
   if not p:
    return "Unloadable picture file:\n\n%s" % fName
  except Exception as e:
   return "Unloadable picture file:\n\n%s\n\nError : %s" % (fName, str(e))
  return ""
 @FFJRPn()
 def VVRXky(self, title, mode, isB64, path):
  try:
   pathTxt = path
   if isB64 and path:
    ext = os.path.splitext(path)[1][1:].lower().replace("jpg", "jpeg")
    with open(path, "rb") as f:
     pathTxt = str("data:image/%s;base64,%s" % (ext, b64encode(f.read()).decode()))
   isSubmenu = self.subName and (os.path.basename(self.filePath) != os.path.basename(self.subName))
   mainAttr = childAttr = None
   elemID  = parent = ""
   if mode > 1:
    attr = self.VV2Xmw(mode)
    if isSubmenu: childAttr, elemID = (attr, pathTxt), FF5c8a(self.subName)
    else  : mainAttr = (attr, pathTxt)
   else:
    childAttr=("icon", pathTxt)
    if isSubmenu:
     elemID = self.VVcJhg()
     parent = self.subName
   self.VVeNv1(title, mainAttr=mainAttr, childAttr=childAttr, elemID=elemID, parent=parent)
  except Exception as e:
   FFbBGq(self, str(e), title=title)
 def VVVzyl(self, title, path):
  if path:
   FFBWtx(CFG.lastCustMenuPicDir, path)
   self.VVeNv1(title, picpath=path)
 def VVeNv1(self, title, newElem=None, delItem=False, getItem=False, moveItem=None, picpath="", mainAttr=None, childAttr=None, elemID="", parent=""):
  try:
   head = ""
   xTxt = FFmx8y(self.filePath, encLst="UTF-8")
   ndx = xTxt.find("<ajp_menu")
   if ndx > 0:
    head = xTxt[:ndx]
    xTxt = xTxt[ndx:]
   tree = iElem.ElementTree(iElem.fromstring(xTxt, parser=iElem.XMLParser(target=CC2Ekb.CClM2A())))
   elemID = elemID or self.VVcJhg()
   root = tree.getroot()
   parents = {c:p for p in tree.iter( ) for c in p}
   toSave = False
   if mainAttr:
    att, val = mainAttr
    if val: root.set(att, val)
    else  : root.attrib.pop(att, None)
    toSave = True
   elif picpath:
    toSave = True
    root.set("picpath", picpath)
    p = FFfkDl(root, "cursor")
    if p.startswith("/"): root.set("cursor", os.path.basename(p))
    p = FFfkDl(root, "shade")
    if p.startswith("/"): root.set("shade", os.path.basename(p))
    for ndx, elem in enumerate(tree.iter()):
     p = FFfkDl(elem, "icon")
     if p and not self.VVEf0r(p): elem.set("icon", os.path.basename(p))
     p = FFfkDl(elem, "bg")
     if p and not self.VVEf0r(p): elem.set("bg", os.path.basename(p))
   elif moveItem:
    oldNdx, newNdx, newElem = moveItem
    if oldNdx != newNdx:
     toSave = True
     for ndx, elem in enumerate(root):
      if ndx == oldNdx:
       elRoot = parents.get(elem, None)
       if elRoot is not None: elRoot.remove(elem)
       break
     root.insert(newNdx, newElem)
   else:
    if not newElem is None or getItem: iterator = root
    else        : iterator = tree.iter()
    for ndx, elem in enumerate(iterator):
     if self.VVVXG1(elem, elemID):
      toSave = True
      if not newElem is None:
       root.insert(ndx, newElem)
      elif delItem:
       elRoot = parents.get(elem, None)
       if elRoot is not None: elRoot.remove(elem)
       else      : toSave = False
      elif getItem:
       return ndx, elem
      elif childAttr:
       if parent and parent != FFfkDl(parents[elem], "title"):
        continue
       att, val = childAttr
       if val: elem.set(att, val)
       else  : elem.attrib.pop(att, None)
      else:
       toSave = False
      break
    else:
     FFbBGq(self, "Current element not found.", title=title)
     return
   if toSave:
    self.VVsDkf(root)
    with open(self.filePath, "w") as f:
     fTxt = str(iElem.tostring(root, encoding="UTF-8").decode())
     line1 = "<?xml version='1.0' encoding='UTF-8'?>\n"
     if fTxt.startswith(line1):
      fTxt = fTxt[len(line1):]
     f.write("%s%s" % (head, fTxt))
    if mainAttr or childAttr: att, val = (mainAttr or childAttr)
    else     : att = val = ""
    if picpath or delItem or not newElem is None or att == "box_gap":
     if delItem:
      txt, ref, itemDict = self.VVvnG3()
      fPath, isMain = self.VVCddU(ref)
      if fPath:
       fName = os.path.basename(fPath)
       if fName in CCKxBC.VV5kDg.keys():
        CCKxBC.VV5kDg.pop(fName)
     self.close(self.session, self.filePath, self.subName, self.VVc1Op())
    elif att:
     self.VVPoOf(att, val)
   else:
    FF8bV6(self, "No change", 800)
  except Exception as e:
   FFbBGq(self, str(e), title=title)
 def VVPoOf(self, att, val):
  if self.VVEf0r(val):
   bg, err = self.VVsXQj(val)
   if bg: val = bg
   else : return
  if att == "icon":
   self.VV6KLc(val)
   if self.isGrid : self.VVylN0()
   else   : self["myMenu"].setList(self.VVXpNQ)
  else:
   self.VVQ1Er[att] = val
   if att in ("bg", "title_fg", "title_bg", "title1_fg", "title1_bg", "title2_fg", "title2_bg", "num_fg", "num_bg"):
    self.VV2IBU()
   elif att in ("shade"):
    self.VV6Ol0(val)
   elif att in ("cursor"):
    self.VVOVaF(val)
   elif att in ("cursor_fg", "cursor_bg"):
    if   val == ""   : FFvJ8o(self["myMenu"], fg=self.def_cursor_fg, bg=val or self.def_cursor_bg)
    elif att == "cursor_fg" : FFvJ8o(self["myMenu"], fg=val or self.def_cursor_fg)
    elif att == "cursor_bg" : FFvJ8o(self["myMenu"], bg=val or self.def_cursor_bg)
    self["myMenu"].instance.invalidate()
 def VVVXG1(self, elem, compId):
  if   elem.tag == "submenu" : name = FFfkDl(elem, "title")
  elif elem.tag == "item"  : name = FFfkDl(elem, "name")
  else      : name = ""
  return name and compId == FF5c8a(name)
 def VVcJhg(self):
  txt, ref, itemDict = self.VVvnG3()
  return itemDict.get("id", "")
 def VVc1Op(self):
  if self.isGrid : txt, info, ndx, icon = self.VVXpNQ[self.VVETIE]
  else   : ndx = self["myMenu"].l.getCurrentSelectionIndex()
  return ndx
 def VVvnG3(self):
  return self.VVQ1Er["lst"][self.VVc1Op()]
 def VV6KLc(self, path):
  txt, ref, itemDict = self.VVvnG3()
  itemDict["icon"] = path
  self.VVQ1Er["lst"][self.VVc1Op()] = (txt, ref, itemDict)
  self.VVXpNQ = self.VV5Sq3()
 def VVoSTG(self):
  txt, ref, itemDict = self.VVvnG3()
  info = itemDict.get("info", "")
  ask  = itemDict.get("ask", "Continue ?") if "ask" in itemDict else ""
  icon = itemDict.get("icon", "")
  tag  = itemDict["tag"]
  fPath, isMain = self.VVCddU(ref)
  c1 = VVk4x7
  if   self.VVEf0r(ref)   : act1, act2 = "Base64 Image", ref[:60] + " ..."
  elif fPath       : act1, act2 = "External Menu File", fPath
  elif tag == "submenu"    : act1, act2 = "Submenu", ref
  elif ref.startswith("ajp_")   : act1, act2 = "AJPanel Option", ref
  elif iMatch(self.VVq9SNPatt, ref) : act1, act2 = "Play a channel", ref
  elif ref.startswith("/"):
   fExt = os.path.splitext(ref)[1]
   if fExt: fExt = fExt[1:]
   isMedia = fExt in CC00KO.VVgJJJ()["mov"] or fExt in CC00KO.VVgJJJ()["mus"]
   isPic = fExt in CC00KO.VVgJJJ()["pic"]
   span = iSearch(r"^(\/.+sh)(\s+#+.*)*$", ref, IGNORECASE)
   if span     : act1, act2 = "Execute a Script file", ref
   elif isMedia   : act1, act2 = "Play Media File", ref
   elif isPic    : act1, act2 = "View Picture File", ref
   elif os.path.isdir(ref) : act1, act2 = "Open in File Manager", ref
   elif os.path.isfile(ref): act1, act2 = "Find in File Manager", ref
   else     : act1, act2 = "", ref
  else      : act1, act2 = "Run Command%s" % ("s" if "\n" in ref else ""), ref
  ttl = lambda x, y: "%s:\n%s\n\n" % (FFKrMM(x, c1), str(y))
  act = (FFKrMM(act1, VVWH8U, c1) if act1 else FFKrMM("Path not found", VVdLWL, c1))
  s1 = ""
  if info: s1 += ttl("Description", info)
  if icon:
   if self.VVEf0r(icon): icon = icon[:60] + " ..."
   s1 += ttl("Custom Icon", icon)
  s1 += ttl("Action (%s)" % act, VV0p9P + act2)
  s1 += ttl("Source File:", self.filePath)
  FFSMJz(self, s1, title=txt)
 def VV5Sq3(self):
  menuW = self.VVmNvK["width"] - self.VVmNvK["VVvs2f"] * 2
  lineH = self.VVmNvK["bodyLineH"]
  align = {0: LEFT, 1: CENTER, 2: RIGHT}.get(self.VVQ1Er["align_items"])
  gap  = lineH // 8
  pPath = CCRGqC.VV5G3P()
  resPath = lambda icn: "%s%s.png" % (VVK8DT, icn)
  VV9cxb = []
  for ndx, (txt, ref, itemDict) in enumerate(self.VVQ1Er["lst"]):
   if itemDict["tag"] == "separator":
    if self.isGrid:
     continue
    left = 0
    txt, ref, icon = VV3Hcc + SEP, None, None
    isSep = True
   else:
    isSep = False
    icon = itemDict.get("icon", "")
    if not icon:
     fPath, isMain = self.VVCddU(ref)
     if itemDict["tag"] == "submenu":
      isGrid, isStretch, cols, rows = self.VVjz7X(itemDict.get("mode", ""))
      icon = resPath("menug" if isGrid else "menu")
     elif fPath:
      icon = resPath("menux")
     elif iMatch(self.VVq9SNPatt, ref):
      span = iSearch(self.VVq9SNPatt, ref)
      for ext in ("png", "jpg"):
       picon = "%s%s.%s" % (pPath, span.group(1).rstrip(":_").replace(":", "_").upper(), ext)
       if FFKbVo(picon):
        icon = picon
        break
      else:
       icon = resPath("tv")
     elif ref.startswith("/"):
      fExt = os.path.splitext(ref)[1]
      fExt = fExt[1:] if fExt else fExt
      extLst = CC00KO.VVgJJJ()
      span = iSearch(r"^(\/.+sh)(\s+#+.*)*$", ref, IGNORECASE)
      if span:
       icon = resPath("scr")
      elif fExt in extLst["mov"] or fExt in extLst["mus"]:
       pathNoExt = os.path.join(os.path.dirname(ref), os.path.join(os.path.dirname(ref), os.path.basename(ref)[:-(len(fExt) + 1)]))
       for ext in ("png", "jpg"):
        poster = "%s.%s" % (pathNoExt, ext)
        if FFKbVo(poster):
         icon = poster
         break
       else:
        icon = resPath("mov" if fExt in extLst["mov"] else "mus")
      elif fExt in extLst["pic"]  : icon = ref if FFKbVo(ref) else resPath("pic")
      elif os.path.isdir(ref)   : icon = resPath("dir")
      elif os.path.isfile(ref)  :
       s = txt.lower()
       if s.startswith("about") : icon = resPath("info")
       else      : icon = resPath("fil")
      else       : icon = resPath("err")
     elif ref.startswith("ajp_")   : icon = resPath("ajp2")
     elif txt.lower().startswith("about"): icon = resPath("info")
     elif "wget" in ref     : icon = resPath("wget")
     else:
      icon = resPath("teln")
   if self.isGrid:
    info = itemDict.get("info", "") or txt
    VV9cxb.append((txt, info, ndx, icon))
   else:
    if   isSep   : x = 0
    elif align == LEFT : x = gap + lineH + lineH // 3
    elif align == CENTER: x = 0
    else    : x = -lineH - gap
    tableRow = [ None if isSep else ndx ]
    tableRow.append((eListboxPythonMultiContent.TYPE_TEXT, x, 0, menuW, lineH, 0, align | RT_VALIGN_CENTER, txt))
    png = FF7uiV(icon)
    if png:
     sz = png.size()
     pngW, pngH = sz.width(), sz.height()
     w = h = lineH - 4
     if pngW == pngH: x, y = 0, 2
     else: x, y, w, h = self.VV4c0B(pngW, pngH, lineH - 4, lineH - 4)
     if align == RIGHT:
      x = menuW - w - gap
     if not self.isGrid:
      tableRow.append(CC4ngo.VVvFdD(gap+x, y, w, h, png))
    VV9cxb.append(tableRow)
  if not self.isGrid:
   FFc1M2()
  return VV9cxb
 def VVjz7X(self, mode):
  isGrid, isStretch, cols, rows = False, True, 5, 4
  span = iSearch(r"^grid(\d)?(?:_(\d)x(\d))?", mode, IGNORECASE)
  if span:
   isGrid = True
   isStretch = span.group(1) != "1"
   if span.group(2) : cols = FFbn8W(int(span.group(2)), 3, 9)
   if span.group(3) : rows = FFbn8W(int(span.group(3)), 3, 6)
  return isGrid, isStretch, cols, rows
 def VVylN0(self):
  self.VVyspd()
  f1, f2 = self.VVibAZ()
  row = col = 0
  for ndx in range(f1, f2):
   txt, _, _, icon = self.VVXpNQ[ndx]
   pic, lbl = self.VVHuJq(row, col)
   self.VVCHuh(lbl, txt)
   png = FFbRME(pic, icon)
   if png:
    boxX, boxY = self.VVM65i[(row, col)]
    pngSz = png.size()
    pngW, pngH = pngSz.width(), pngSz.height()
    if not self.isStretch and self.VVf0tF > pngW and self.VVOFKh > pngH:
     pic.instance.resize(pngSz)
     pic.instance.move(ePoint(boxX + (self.VVf0tF - pngW) // 2, boxY + (self.VVOFKh - pngH) // 2))
    else:
     x, y, w, h = self.VV4c0B(pngW, pngH, self.VVf0tF, self.VVOFKh)
     pic.instance.resize(eSize(*(w, h)))
     pic.instance.move(ePoint(boxX + (self.VVf0tF - w) // 2, boxY + (self.VVOFKh - h) // 2))
   self.VVHoLK = row
   self.VV8V7w = col
   col += 1
   if col > (self.VVatGZ - 1):
    col = 0
    row += 1
 def VVeq8f(self):
  txt, info, ndx, icon = self.VVXpNQ[self.VVETIE]
  self.VVbc3D(txt, info)
 @FFJRPn()
 def VVVwEc(self, txt, ref, itemDict):
  tag = itemDict["tag"]
  fPath, isMain = self.VVCddU(ref)
  isAbout = txt.lower().startswith("about")
  if fPath:
   if FFKbVo(fPath):
    self.session.openWithCallback(CCKxBC.VVPILo, CCKxBC, subFile=fPath, subName=ref)
   else:
    FFbBGq(self, "Custom Menu file not found:\n\n%s" % fPath, title=txt)
    return
  elif tag == "submenu":
   self.session.openWithCallback(CCKxBC.VVPILo, CCKxBC, subFile=self.filePath, subName=ref, picpath=self.VVQ1Er["picpath"])
  elif iMatch(self.VVq9SNPatt, ref):
   span = iSearch(self.VVq9SNPatt, ref)
   VVZWTf = span.group(1).replace("_", ":").upper() + span.group(2)
   CCsmqb.VVlIAT(self.session, VVdxJv=VVZWTf)
  elif ref.startswith("/"):
   path = ref
   fExt = os.path.splitext(path)[1]
   if fExt: fExt = fExt[1:]
   if not FFKbVo(path):
    FFbBGq(self, "Path Not found:\n\n%s" % path, title=txt)
    return
   span = iSearch(r"^(\/.+sh)(\s+#+.*)*$", path, IGNORECASE)
   if span:
    path = span.group(1)
    if FFKbVo(path) : self.session.open(CCu5WO, VVruJa=path, VVnFl3=True)
    else    : FFWfGZ(self, path, title=txt)
   elif fExt in CC00KO.VVgJJJ()["mov"] or fExt in CC00KO.VVgJJJ()["mus"]:
    CC17eA.VVGtUI(self, path)
   elif fExt in CC00KO.VVgJJJ()["pic"]:
    CCZQAz.VVRX4k(self, ref)
   elif os.path.isdir(path):
    self.session.open(CC17eA, mode=CC17eA.VVkDQs, VVNzrh=path)
   elif os.path.isfile(path):
    if isAbout:
     if CC17eA.VVLpYt(path) : FFbBGq(self, "Cannot view binary file:\n\n%s" % path, title=txt)
     else        : self.VVXLPX(txt, FFmx8y(path))
    else:
     self.session.open(CC17eA, mode=CC17eA.VVkDQs, VVNzrh=path)
   else:
    FFbBGq(self, "Cannot handle path:\n\n%s" % path, title=txt)
  elif ref.startswith("ajp_"):
   s = ref[4:]
   if   s == "fman" : self.session.open(CC17eA)
   elif s == "iptv" : self.session.open(CCTe4w)
   elif s == "movie" : CCbZVM.VV0LPB(self)
   elif s == "chan" : self.session.open(CC2Ekb)
   elif s == "chanBr" : CC9c0P.VVWSgp(self)
   elif s == "bouq" : self.session.open(CCM4Rv)
   elif s == "picon" : self.session.open(CCRGqC)
   elif s == "epg"  : self.session.open(CCtAi7)
   elif s == "xmltv" : CCJi7o(self)
   elif s == "term" : self.session.open(CCu5WO)
   elif s == "soft" : self.session.open(CCCusX)
   elif s == "plugin" : self.session.open(CCz0DD)
   elif s == "plugBr" : CCBj8K.VVhtKh(self.session)
   elif s == "bakup" : self.session.open(CCmWdL)
   elif s == "date" : self.session.open(CC06Cg)
   elif s == "net"  : self.session.open(CCQdT4)
   elif s == "info" : self.session.open(CCg47Y)
   elif s == "inet" : self.session.open(CCNLYy)
   else    : FFbBGq(self, "Option not found in %s" % PLUGIN_NAME, title=txt)
  elif isAbout:
   self.VVXLPX(txt, ref)
  else:
   if len(ref) > 20000 : FFbBGq(self, "The script exceeds 20,000 characters !\n\nMove the script to a script file.", title=txt)
   else    : self.session.open(CCu5WO, VVruJa=ref, VVd4C0="Running Multiple Commands ..." if "\n" in ref else "", VVnFl3=True)
 def VVXLPX(self, title, txt):
  FFSMJz(self, txt.strip()[:60000], title=title, VVPYL1=30, width=1600, height=1000, titleBg="#11331144", VVYCun="#11440044")
 def VVZ0Li(self, subName):
  try:
   tree = iElem.parse(self.filePath)
  except Exception as e:
   return str(e)
  root = newRoot = tree.getroot()
  self.tmpOtherFiles = []
  for ndx, elem in enumerate(tree.iter()):
   tag = elem.tag
   if tag in ("ajp_menu", "submenu"):
    err = self.VVO2Sp(elem)
    if err:
     return err
    if tag == "submenu" and FFfkDl(elem, "title") == subName:
     newRoot = elem
  txt = "Repeated custom menu file in : %s\nMenu File : %s"
  lst = [elem for elem, count in iCounter((f, el) for f, el in self.tmpOtherFiles).items() if count > 1]
  if lst:
   return txt % lst[0]
  else:
   curF = os.path.basename(self.filePath)
   for mnuF, mnuName in self.tmpOtherFiles:
    if mnuF in CCKxBC.VV5kDg:
     tmpF, tmpName = CCKxBC.VV5kDg[mnuF]
     if tmpF != curF:
      return txt % (mnuName, mnuF)
    else:
     CCKxBC.VV5kDg[mnuF] = (curF, mnuName)
  self.VVQ1Er["title"] = (FFfkDl(newRoot, "title") or self.VVkIsq)
  self.VVQ1Er["mode"]  = FFfkDl(newRoot, "mode").lower()
  self.VVQ1Er["picpath"] = FFfkDl(newRoot, "picpath") or self.VVQ1Er["picpath"]
  isGrid, _, _, _ = self.VVjz7X(self.VVQ1Er["mode"])
  if isGrid:
   self.VVJMiZ("width", newRoot, 600, 1920, "1600")
   self.VVJMiZ("height", newRoot, 600, 1080, "900")
  else:
   self.VVJMiZ("width", newRoot, 500, 1920, "800")
   self.VVJMiZ("height", newRoot, 400, 1080, "1000")
  self.VVJMiZ("font_size", newRoot, 10, 50)
  self.VVJMiZ("title_font_size", newRoot, 20, 50)
  val = FFfkDl(newRoot, "line_gap")
  if val.isdigit():
   val = FFbn8W(int(val), 0, 100)
   self.VVQ1Er["line_gap"] = FFel7I(val, 0, 100, 0.15, 2)
  val = FFfkDl(newRoot, "box_gap")
  if val.isdigit():
   val = FFbn8W(int(val), 0, 100)
   self.VVQ1Er["box_gap"] = FFel7I(val, 0, 100, 0, 30)
  v = newRoot.attrib.get("align_items", "left")
  if   v == "left" : self.VVQ1Er["align_items"] = 0
  elif v == "center" : self.VVQ1Er["align_items"] = 1
  elif v == "right" : self.VVQ1Er["align_items"] = 2
  bg, err = self.VV4aOI(newRoot, "bg", True)
  if   bg : self.VVQ1Er["bg"] = bg
  elif err: return err
  if isGrid:
   bg, err = self.VV4aOI(newRoot, "cursor", True)
   if   bg : self.VVQ1Er["cursor"] = bg
   elif err: return err
   if FFfkDl(newRoot, "shade").lower() == "yes":
    self.VVQ1Er["shade"] = "yes"
   else:
    bg, err = self.VV4aOI(newRoot, "shade", False)
    if   bg : self.VVQ1Er["shade"] = bg
    elif err: return err
  for attr in ("fg", "title_fg", "title_bg", "cursor_fg", "cursor_bg", "title1_fg", "title1_bg", "title2_fg", "title2_bg", "num_fg", "num_bg"):
   self.VVAQVs(attr, newRoot)
  for elem in newRoot:
   itemDict = {"tag": elem.tag}
   if "ask" in elem.attrib  : itemDict["ask"] = FFfkDl(elem, "ask")
   if "info" in elem.attrib : itemDict["info"] = FFfkDl(elem, "info")
   name = ""
   if elem.tag == "submenu":
    name = FFfkDl(elem, "title")
    itemDict["mode"] = FFfkDl(elem, "mode")
    self.VVQ1Er["lst"].append((name, name, itemDict))
   elif elem.tag == "item":
    name = FFfkDl(elem, "name")
    action = FF4jcy(elem)
    action = "\n".join(list(map(str.strip, action.split("\n"))))
    self.VVQ1Er["lst"].append((name, action, itemDict))
   elif elem.tag == "separator":
    self.VVQ1Er["lst"].append(("", "", itemDict))
   bg, err = self.VV4aOI(elem, "icon", False)
   if   bg : itemDict["icon"] = bg
   elif err: return err
   itemDict["id"] = FF5c8a(name)
 def VVO2Sp(self, elem):
  mainName = FFfkDl(elem, "title") or FFfkDl(elem, "name") or elem.tag
  curIsSep = False
  nameLst = set()
  tot = 0
  curName = ""
  for ndx, elem in enumerate(elem):
   tag = elem.tag
   if tag == "ajp_menu":
    curIsSep = False
    titl  = curName = FFfkDl(elem, "title")
    if not titl : return "No Main Title in : %s" % tag
    else  : nameLst.add(titl.lower())
   elif tag == "submenu":
    tot += 1
    curIsSep = False
    titl = curName = FFfkDl(elem, "title")
    if   not titl    : return "Found submenu with no title."
    elif titl.lower() in nameLst: return "Duplicate submenu title : %s" % titl
    else      : nameLst.add(titl.lower())
   elif tag == "item":
    tot += 1
    curIsSep = False
    name = curName = FFfkDl(elem, "name")
    action = FF4jcy(elem)
    if   not name : return "Found menu item with no name."
    elif not action : return "No action for : %s" % name
    fPath, isMain = self.VVCddU(action)
    if fPath:
     curName = FFKrMM(curName, VVv8b8)
     if   isMain : return "Do not use the main custom file in : %s\n%s" % (curName, fPath)
     else  : self.tmpOtherFiles.append((os.path.basename(fPath), curName))
   elif tag == "separator":
    tName = curName or mainName
    if   ndx == 0 : return "Cannot use Separator as first menu item in : %s" % tName
    elif curIsSep : return "Consecutive Separators are not allowed after : %s" % tName
    else   : curIsSep = True
   else:
    return "Unknown Tag : %s" % tag
  tName = curName or mainName
  if   tot == 0: return "No menu items found in : %s" % tName
  elif curIsSep: return "Cannot use Separator as last menu item after : %s" % tName
  else   : return ""
 def VVJMiZ(self, dItem, elem, Min, Max, default=""):
  if dItem in self.VVQ1Er:
   val = elem.attrib.get(dItem, default)
   if val.isdigit():
    self.VVQ1Er[dItem] =  FFbn8W(int(val), Min, Max)
 def VVAQVs(self, dItem, elem):
  if dItem in self.VVQ1Er:
   val = elem.attrib.get(dItem, "")
   if val and self.VVNkZh(val):
    self.VVQ1Er[dItem] = val
    return True
  return False
 def VV4aOI(self, elem, attr, canColor):
  bg, err = self.VV1UTu(elem, attr, canColor)
  if err:
   c1, c2, c3, c4 = VVv8b8, VVjojy, VVPI2q, VV3Hcc
   val = FFfkDl(elem, attr)
   txt  = FFKrMM(err, c3) + "\n\n"
   txt += "Check : %s\n" % FFKrMM(self.VVQ1Er["title"], c1)
   txt += '%s="%s"' % (FFKrMM(attr, c2), FFKrMM(val if len(val) < 80 else val[:80] + " ...", c4))
   return "", txt
  else:
   return bg, err
 def VV1UTu(self, elem, attr, canColor):
  c1, c2, c3 = VVv8b8, VVjojy, VVdLWL
  val = FFfkDl(elem, attr)
  if not val:
   return "", ""
  elif canColor and self.VVNkZh(val):
   self.VVAQVs(attr, elem)
   return "", ""
  elif val.endswith((".jpg", ".png")):
   if not val.startswith("/"):
    val = os.path.join(self.VVQ1Er["picpath"], val)
   fName = os.path.basename(val)
   fil, ext = os.path.splitext(fName)
   if ext == ".png" and fil in ("ajp", "dnld", "ajp2", "pic", "mov", "tv") and not FFKbVo(val):
    val = VVK8DT + fName
   return val, ""
  elif self.VVEf0r(val):
   return self.VVsXQj(val)
  else:
   if canColor : txt = "Value must be a color,"
   else  : txt = "Picture files must be a"
   return "", "%s jpg, png or Base64 format." % txt
 def VVsXQj(self, b64):
  span = iSearch(r"data:image\/(.+);base64,(.+)", b64)
  if span:
   cacheDir = CCKxBC.VV8Jb5()
   ext, b64 = span.groups()
   pFile = "%s%s.%s" % (cacheDir, FF5c8a(b64), ext.replace("jpeg", "jpg"))
   if FFKbVo(pFile):
    return pFile, ""
   else:
    if not FFlonU("mkdir -p '%s'" % cacheDir):
     return "", "Cannot create icons directory:\n%s" % FFKrMM(cacheDir, c1)
    try:
     with open(pFile, "wb") as f:
      f.write(b64decode(b64))
    except Exception as e:
     FFnE7j(pFile)
     return "", "Cannot convert Base64 picture file.\n%s" % str(e)
    try:
     png = LoadPixmap(pFile)
     if png:
      return pFile, ""
     else:
      FFnE7j(pFile)
      return "", "Unloadable picture file (or invalid jpg/png format)"
    except Exception as e:
     FFnE7j(pFile)
     return "", "Unloadable picture file.:\n%s" % str(e)
  else:
   return "",
 def VVCddU(self, path):
  fName = os.path.basename(path)
  if fName.startswith(CCKxBC.VV9Hwa[:-4]):
   isMain = fName == CCKxBC.VV9Hwa
   if path.startswith("/") : fPath = path
   else     : fPath = CCKxBC.VVHEMl() + fName
   return fPath, isMain
  else:
   return "", False
 def VVNkZh(self, c):
  return bool(iMatch(r"^#[A-Fa-f0-9]{6}$|^#[A-Fa-f0-9]{8}$", c))
 def VVEf0r(self, txt):
  return bool(iMatch(r"data:image\/.+;base64,.+", txt))
 def VVEkpW(self):
  lst = FFQ1wB(r"find '%s' -type f \( -name '*.png' -o -name '*.jpg' \)" % CCKxBC.VV8Jb5())
  tot = 0
  for f in lst:
   if iMatch(r"(.+_ajp_.+|.+[A-Fa-f0-9]{32})\.(?:png|jpg)$", f):
    tot += 1
    FFnE7j(f)
  if tot > 0 : FFxHED(self, "%s deleted" % tot, 2000)
  else  : FFoTZI(self, "No cached files", 1000)
 @staticmethod
 def VVX9t7(pixMap, path, toPng=False):
  newPath = CCKxBC.VV0dmK(pixMap, path, toPng=toPng)
  inst = pixMap.instance
  inst.setScale(1)
  if FFKbVo(newPath):
   inst.setAlphatest(0)
   FFbRME(pixMap, newPath)
   return newPath
  elif FFKbVo(path):
   inst.setAlphatest(1)
   FFbRME(pixMap, path)
   return path
  else:
   return ""
 @staticmethod
 def VV0dmK(pixMap, path, toPng=False):
  if not FFKbVo(path):
   return ""
  sz = pixMap.instance.size()
  w, h = sz.width(), sz.height()
  fil, ext = os.path.splitext(path)
  tFile = "%s_ajp_%sx%s%s" % (fil, w, h, ".png" if toPng else ext)
  if FFKbVo(tFile):
   return tFile
  else:
   try:
    from PIL import Image
    im = Image.open(path)
    im = im.resize((w, h))
    im.save(tFile)
    return tFile
   except:
    if FFW91j("ffmpeg") and FFlonU("ffmpeg -y -i '%s' -vf scale=%s:%s '%s'" % (path, w, h, tFile)):
     return tFile
    else:
     return ""
 @staticmethod
 def VVHEMl():
  return FF9Uvy(CFG.customMenuPath.getValue())
 @staticmethod
 def VVzmRG():
  return CCKxBC.VVHEMl() + CCKxBC.VV9Hwa
 @staticmethod
 def VV8Jb5():
  return CCKxBC.VVHEMl() + "ajpanel_menu/"
 @staticmethod
 def VVx2mJ():
  return str(u"\u00A4")
 @staticmethod
 def VVLYLV():
  path = CCKxBC.VVzmRG()
  cmTitle = CCKxBC.VVkIsq
  mrk = CCKxBC.VVx2mJ()
  if FFKbVo(path):
   try:
    for ndx, (event, elem) in enumerate(iElem.iterparse(path, events=("start", ))):
     if ndx == 0 and elem.tag == "ajp_menu":
      cmTitle = FFfkDl(elem, "title") or CCKxBC.VVkIsq
     break
   except:
    pass
  return "%s %s %s" % (mrk, cmTitle, mrk)
 def VVsDkf(self, tree, space="\t", level=0):
  if isinstance(tree, iElem.ElementTree): tree = tree.getroot()
  if not len(tree): return
  indents = ["\n" + level * space]
  def VVxN3u(elem, level):
   chLevel = level + 1
   try:
    chInd = indents[chLevel]
   except IndexError:
    chInd = indents[level] + space
    indents.append(chInd)
   if not elem.text or not elem.text.strip() : elem.text = chInd
   for ch in elem:
    if len(ch)        : VVxN3u(ch, chLevel)
    if not ch.tail or not ch.tail.strip() : ch.tail = chInd
    if len(ch)        : ch.tail = "\n" + chInd
   if not ch.tail.strip()      : ch.tail = indents[level]
  VVxN3u(tree, 0)
 @staticmethod
 def VVuwBy(SELF, VVYqW3=False):
  if VVYqW3: fnc, session = FF8385, SELF
  else    : fnc, session = FF7iMz , SELF.session
  path = CCKxBC.VVzmRG()
  Dir = os.path.dirname(path)
  fil = os.path.basename(path)
  if not VVkY7E(Dir) : FFvOl9(session, "%s\n\nPlease change %s path in Settings." % (Dir, FFKrMM("Custom Menu", VVk4x7)), title="Custom Menu path not found")
  elif FFKbVo(path) : fnc(SELF, BF(session.openWithCallback, CCKxBC.VVPILo, CCKxBC), title="Loading ...")
  else     : FF6pUe(session, BF(fnc, SELF, BF(CCKxBC.VVXVRl, session, Dir, fil)), "Try a sample file ?\n\n%s" % path, title="Custom Menu file not found", VVYqW3=True)
 @staticmethod
 def VVXVRl(session, Dir, fil):
  if FFlonU("cp -f '%s%s' '%s'" % (VVK8DT, fil, Dir)):
   session.openWithCallback(CCKxBC.VVPILo, CCKxBC)
  else:
   FFvOl9(session, "Cannot copy template file to backup directory.", title=CCKxBC.VVkIsq)
 @staticmethod
 def VVPILo(session=None, subFile="", subName="", startItem=0):
  if session and (subFile or subName):
   FFvfpL(BF(session.openWithCallback, CCKxBC.VVPILo, CCKxBC, subFile=subFile, subName=subName, startItem=startItem))
class CCcR1B(Screen):
 def __init__(self, session, title="", csel=None, VVq9SN="", servName="", isFind=False):
  self.skin, self.VVmNvK = FFQaOH(VVNkG2, 700, 800, 50, 40, 30, "#22000033", "#22000011", 30)
  self.session     = session
  self.csel      = csel
  self.VVq9SN     = VVq9SN
  self.servName     = servName
  self.findTxt     = servName
  self.isFindMode     = isFind
  self.VVVApC  = 0
  self.VV5LI4 = 1
  self.VVh9Ia  = 2
  VV9cxb = []
  VV9cxb.append(("Find in All Service (from filter)" , "VVrhZQ" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Find in All (Manual Entry)"   , "VViXqd"    ))
  VV9cxb.append(("Find in TV"       , "VV7mpU"    ))
  VV9cxb.append(("Find in Radio"      , "VVJfWZ"   ))
  if self.VVRBrq():
   VV9cxb.append(VVbM5H)
   VV9cxb.append(("Hide Channel: %s" % self.servName , "VVXXzX"   ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Zap History"       , "VV8ifT"    ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("IPTV Tools"       , "iptv"      ))
  VV9cxb.append(("PIcons Tools"       , "PIconsTools"     ))
  VV9cxb.append(("Services/Channels Tools"    , "ChannelsTools"    ))
  VV9cxb.append(("EPG Tools"       , "epgTools"     ))
  FFNhKZ(self, VV9cxb=VV9cxb, title=title)
  self.onShown.append(self.VVf1Ra)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  FFvJ8o(self["myMenu"])
  FFNUiO(self)
  if self.isFindMode:
   self.VV79wQ(self.VVtqup())
 def VVyuDa(self):
  item = FFgo5c(self)
  if item is not None:
   if   item == "VViXqd"    : self.VViXqd()
   elif item == "VVrhZQ" : self.VVrhZQ()
   elif item == "VV7mpU"    : self.VV7mpU()
   elif item == "VVJfWZ"   : self.VVJfWZ()
   elif item == "VVXXzX"   : self.VVXXzX()
   elif item == "VV8ifT"    : self.VV8ifT()
   elif item == "iptv"       : self.session.open(CCTe4w)
   elif item == "PIconsTools"     : self.session.open(CCRGqC)
   elif item == "ChannelsTools"    : self.session.open(CC2Ekb)
   elif item == "epgTools"      : self.session.open(CCtAi7)
   if item in ("iptv", "PIconsTools", "ChannelsTools"):
    self.close()
 def VV7mpU(self) : self.VV79wQ(self.VVVApC)
 def VVJfWZ(self) : self.VV79wQ(self.VV5LI4)
 def VViXqd(self) : self.VV79wQ(self.VVh9Ia)
 def VV79wQ(self, mode):
  title = "Find %s Service" % ("TV", "Radio", "All")[mode]
  FFANcN(self, BF(self.VVFUaB, mode), defaultText=self.findTxt, title=title, message="Enter Name:")
 def VVrhZQ(self):
  filterObj = CCuHRT(self)
  filterObj.VVaNK8(self.VVnRQ3)
 def VVnRQ3(self, item):
  self.VVFUaB(self.VVh9Ia, item)
 def VVRBrq(self):
  if self.servName.strip() == ""      : return False
  if self.VVq9SN.strip()  == ""      : return False
  if self.VVq9SN.startswith("1:7:1:0:0:0:0:0:0:0:") : return False
  if FFC4pX(self.VVq9SN)        : return False
  return True
 @FFJRPn("Searching ...")
 def VVFUaB(self, mode, VVYisd):
  if VVYisd:
   VVYisd = VVYisd.strip()
  if VVYisd:
   self.findTxt = VVYisd
   CFG.lastFindContextFind.setValue(VVYisd)
   if   mode == self.VVVApC  : titlTxt, servTypes = "TV"  , service_types_tv
   elif mode == self.VV5LI4 : titlTxt, servTypes = "Radio"  , service_types_radio
   else          : titlTxt, servTypes = "All" , "1:7:"
   title = 'Find %s : "%s"' % (titlTxt, VVYisd)
   if len(title) > 55:
    title = title[:55] + ".."
   VVuGUx = self.VVtN65(VVYisd, servTypes)
   if self.isFindMode or mode == self.VVh9Ia:
    VVuGUx += self.VVf374(VVYisd)
   if VVuGUx:
    VVuGUx.sort(key=lambda x: x[0].lower())
    VVpW7I = self.VVEnlg
    VVj7lw  = ("Zap"   , self.VVvj0D    , [])
    VVwqVu = ("Current Service", self.VVjgUY , [])
    VV46TD = ("Options"  , self.VVHti4 , [])
    VVmolf = (""    , self.VVbmZC , [])
    header   = ("Name" , "Type", "Ref.", "Sat.", "Freq." , "Pol.", "FEC" , "SR" , "Bouq")
    widths   = (38  , 17 , 0  , 10 , 10  , 7  , 8  , 10 , 0.01 )
    VV4Uoc  = (LEFT  , CENTER, LEFT  , CENTER, CENTER , CENTER, CENTER, CENTER, CENTER)
    FFCXsL(self, None, title=title, header=header, VVXpNQ=VVuGUx, VV4Uoc=VV4Uoc, VV8boH=widths, VVPYL1=26, VVj7lw=VVj7lw, VVpW7I=VVpW7I, VVwqVu=VVwqVu, VV46TD=VV46TD, VVmolf=VVmolf, VVAGe1=CFG.lastFindContextFind)
   else:
    self.VV79wQ(self.VVtqup())
    FF0onH(self, "Not found", title=title)
  elif self.isFindMode:
   self.close()
  else:
   self.findTxt = self.servName
 def VVtN65(self, VVYisd, servTypes):
  VVXpNQ = CC2Ekb.VVwkaL(servTypes)
  VVuGUx = []
  if VVXpNQ:
   VVuDJZ, VVlt7s = FFmCsn()
   tp = CCrDr0()
   words, asPrefix = CCuHRT.VVzdEZ(VVYisd)
   colorYellow  = CCEsU0.VVUvkG(VVjojy)
   colorWhite  = CCEsU0.VVUvkG(VVCQUS)
   for s in VVXpNQ:
    name = s[1]
    for word in words:
     ok = False
     tName = name.lower()
     if asPrefix:
      if tName.startswith(word):
       ok = True
     elif word in tName:
      ok = True
     if ok:
      VVq9SN = s[0]
      if VVq9SN.count(":") > 8:
       if asPrefix:
        name = iSub(r"(%s)" % iEscape(word), r"%s\1%s" % (colorYellow, colorWhite), name, count=1, flags=IGNORECASE)
       else:
        name = iSub(r"(%s)" % iEscape(word), r"%s\1%s" % (colorYellow, colorWhite), name, flags=IGNORECASE)
       sat = FFgAAw(VVq9SN, False)
       STYPE  = VVq9SN.split(":")[2]
       sTypeInt = int(STYPE, 16)
       if sTypeInt in VVuDJZ:
        STYPE = VVlt7s[sTypeInt]
       freq, pol, fec, sr, syst = tp.VV6RhP(VVq9SN)
       if not "-S" in syst:
        sat = syst
       VVuGUx.append((name, STYPE, VVq9SN, sat, freq, pol, fec, sr, ""))
  return VVuGUx
 def VVf374(self, VVYisd):
  VVYisd = VVYisd.lower()
  VVuGUx = []
  colorYellow  = CCEsU0.VVUvkG(VVjojy)
  colorWhite  = CCEsU0.VVUvkG(VVCQUS)
  for b in CC8i1k.VVLzVr():
   VVsvsL  = b[0]
   VVQ8fm  = b[1].toString()
   VVbPr6 = eServiceReference(VVQ8fm)
   VV50QG = FFM85b(VVbPr6)
   for service in VV50QG:
    VVq9SN  = service[0]
    if FFC4pX(VVq9SN):
     servName = service[1]
     if VVYisd in servName.lower():
      servName = iSub(r"(%s)" % iEscape(VVYisd), r"%s\1%s" % (colorYellow, colorWhite), servName, flags=IGNORECASE)
      VVuGUx.append((servName, "IPTV", VVq9SN, "-", "-", "-", "-", "-", VVsvsL))
  return VVuGUx
 def VVtqup(self):
  mode = CCM4Rv.VVsFRh(default=-1)
  return self.VVh9Ia if mode == -1 else mode
 def VVEnlg(self, VVAIxO):
  self.close()
  VVAIxO.cancel()
 def VVvj0D(self, VVAIxO, title, txt, colList):
  FF9SoI(VVAIxO.session, colList[2], checkParentalControl=True)
 def VVjgUY(self, VVAIxO, title, txt, colList):
  VVq9SN, VVadS0, VVjgtq, VVVmGQ, VVUwmk = FFLlAM(VVAIxO)
  if VVq9SN:
   VVAIxO.VVSepa(2, FFeWgN(VVq9SN, VVVmGQ, VVUwmk), True)
 def VVHti4(self, VVAIxO, title, txt, colList):
  servName = colList[0]
  mSel = CC17aQ(self, VVAIxO)
  VV9cxb, cbFncDict = CC2Ekb.VVxMo5(self, VVAIxO, servName, 2)
  mSel.VV4sFy(VV9cxb, cbFncDict)
 def VVbmZC(self, VVAIxO, title, txt, colList):
  Name, Type, Ref, Sat, Freq, Pol, FEC, SR, Bouq = colList
  Name = FFkEjh(Name)
  txt  = ""
  txt += "Name\t: %s\n" % Name
  txt += "Type\t: %s\n" % Type
  if Bouq: txt += "Bouquet\t: %s" % Bouq
  if Sat != "-": txt += "Tuner\t: %s" % " ".join((Sat, Freq, Pol, FEC, SR))
  CCpebE.VV1v7b(self, VV6tGM=CCpebE.VVaclA, params=(Ref, Name, txt))
 def VVXXzX(self):
  FF6pUe(self, self.VVERSo, 'Hide "%s" ?' % self.servName, title="Hide Channel")
 def VVERSo(self):
  ret = FF97G8(self.VVq9SN, True)
  if ret:
   self.VVIjWm()
   self.close()
  else:
   FFoTZI(self, "Cannot change state" , 1000)
 def VVIjWm(self):
  if self.csel:
   self.csel.servicelist.removeCurrent()
  try: self.VVhVRy()
  except: self.VVEfsa()
  if self.VVq9SN.count(":") > 8:
   servRef = self.session.nav.getCurrentlyPlayingServiceReference()
   if servRef and self.VVq9SN in servRef.toString():
    self.session.nav.stopService()
    if self.csel:
     serviceRef = self.csel.servicelist.getCurrent()
     if serviceRef:
      FFQ2Oi(self.session, serviceRef)
 def VVhVRy(self):
  if self.VVq9SN:
   servRef = eServiceReference(self.VVq9SN)
   VV2RgF = InfoBar.instance
   if VV2RgF:
    VVVnHH = VV2RgF.servicelist
    if VVVnHH:
     hList = VVVnHH.history
     newList = []
     for rec in hList:
      for servRef in rec:
       if self.VVq9SN in servRef.toString():
        break
      else:
       newList.append(rec)
     if newList:
      oldLen = len(hList)
      newLen = len(newList)
      diff = oldLen - newLen
      if not diff == 0:
       pos = VVVnHH.history_pos - diff
       if pos > newLen -1 : pos = newLen - 1
       if pos < 0   : pos = 0
       VVVnHH.history  = newList
       VVVnHH.history_pos = pos
 def VVEfsa(self):
  VV2RgF = InfoBar.instance
  if VV2RgF:
   VVVnHH = VV2RgF.servicelist
   if VVVnHH:
    VVVnHH.history  = []
    VVVnHH.history_pos = 0
 def VV8ifT(self):
  VV2RgF = InfoBar.instance
  VVuGUx = []
  if VV2RgF:
   VVVnHH = VV2RgF.servicelist
   if VVVnHH:
    VVuDJZ, VVlt7s = FFmCsn()
    for serv in VVVnHH.history:
     VVq9SN = serv[-1].toString()
     VVUwmk = FFEnx2(VVq9SN)
     path = serv[-1].getPath()
     isLocal = path and path.startswith("/")
     isIptv = FFC4pX(VVq9SN)
     isSRel = FFKeSw(VVq9SN)
     sat = "-" if isIptv and not isSRel or isLocal else FFgAAw(VVq9SN, True)
     if isIptv : STYPE = "Stream Relay" if isSRel else "IPTV"
     elif isLocal: STYPE = "Local Media"
     else:
      STYPE  = VVq9SN.split(":")[2]
      sTypeInt = int(STYPE, 16)
      if sTypeInt in VVuDJZ:
       STYPE = VVlt7s[sTypeInt]
     VVuGUx.append((VVUwmk, sat, STYPE, VVq9SN))
  title = "Zap History"
  if VVuGUx:
   VVj7lw  = ("Zap"   , self.VVf1Ev   , [])
   VV46TD = ("Clear History" , self.VV0HT3   , [])
   VVmolf = (""    , self.VVXUKt , [] )
   header   = ("Service Name", "Satellite" , "Type" , "Ref. Code" )
   widths   = (41    , 41   , 18  , 0    )
   VV4Uoc  = (LEFT    , LEFT   , CENTER , LEFT   )
   FFCXsL(self, None, title=title, header=header, VVXpNQ=VVuGUx, VV4Uoc=VV4Uoc, VV8boH=widths, VVPYL1=28, VVj7lw=VVj7lw, VV46TD=VV46TD, VVmolf=VVmolf)
  else:
   FF0onH(self, "History is empty.", title=title)
 def VVf1Ev(self, VVAIxO, title, txt, colList):
  FF9SoI(VVAIxO.session, colList[3], checkParentalControl=True)
 def VV0HT3(self, VVAIxO, title, txt, colList):
  FF6pUe(self, BF(self.VVBovl, VVAIxO), "Clear Zap History ?")
 def VVBovl(self, VVAIxO):
  self.VVEfsa()
  VVAIxO.cancel()
 def VVXUKt(self, VVAIxO, title, txt, colList):
  VVUwmk = colList[0]
  VVq9SN = colList[3]
  CCpebE.VV1v7b(self, VV6tGM=CCpebE.VVxbjT, params=(VVq9SN, VVUwmk, txt))
 @staticmethod
 def VV6RMZ():
  global VVN33a
  try:
   VVN33a      = ChannelContextMenu.__init__
   ChannelContextMenu.__init__   = CCcR1B.VVY1Pp
   ChannelContextMenu.VVQCzH = CCcR1B.VVQCzH
  except:
   pass
 @staticmethod
 def VVY1Pp(SELF, session, csel):
  from Components.ChoiceList import ChoiceEntryComponent
  VVN33a(SELF, session, csel)
  if CFG.showInChannelListMenu.getValue():
   for ndx, title in enumerate(("Channels Browser", "Find", "Bouquet Editor", "Channels Tools")):
    title = "%s - %s" % (PLUGIN_NAME, title)
    SELF["menu"].list.insert(ndx, ChoiceEntryComponent(key=" ", text=(title , BF(SELF.VVQCzH, csel, ndx, title))))
 @staticmethod
 def VVQCzH(SELF, csel, mode, title):
  try:
   currSel  = csel.getCurrentSelection()
   VVq9SN  = currSel.toString()
   refName  = FFEnx2(VVq9SN)
  except:
   VVq9SN = refName = ""
  if   mode == 0: CC9c0P.VVWSgp(SELF, SELF.close)
  elif mode == 2: SELF.session.openWithCallback(SELF.close, CCM4Rv)
  else    : SELF.session.openWithCallback(SELF.close, CCcR1B, title=title, csel=csel, VVq9SN=VVq9SN, servName=refName, isFind=True if mode == 1 else False)
class CCM4Rv(Screen):
 def __init__(self, session, VVq9SN="", servName=""):
  self.skin, self.VVmNvK = FFQaOH(VV7rcW, 10, 10, 30, 0, 0, "#ff000000", "#ff000000", 30)
  self.session = session
  self.Title  = "Bouquet Editor"
  self.pPath  = CCRGqC.VV5G3P()
  self.bTables = []
  FFNhKZ(self)
  self.onShown.append(self.VVf1Ra)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  self.VVzOGy()
 def VVYItx(self, tbl, bName, bRef):
  self.bTables.append(tbl)
  tbl.bouqName = bName
  tbl.bouqRef  = bRef
  self.VVbkR1(tbl)
 def VVzOGy(self):
  rootStr = CCM4Rv.VVcbQn()
  rows = self.VVugW8(rootStr)
  if rows :
   self.VVXpzM(self, "Main Bouquets List", rootStr, rows)
   VVq9SN, refName, rootRef, rootName, inBouquet, rootSrc = CC9c0P.VVqz5S()
   if not self.bTables[-1].VV5rHa({3:VVq9SN}):
    self.bTables[-1].VV5rHa({3:rootRef})
  else:
   FFbBGq(self, "No bouquets Found !", title=self.Title)
   self.close()
 def VVuJuR(self):
  self.bTables[-1].cancel()
  if len(self.bTables) > 0: del self.bTables[-1]
  if not len(self.bTables): self.close()
 def VVugW8(self, bRef=None):
  blkLst = CCM4Rv.VVzi45()
  rows = []
  for ndx, row in enumerate(FFM85b(eServiceReference(bRef), mode=1), start=1):
   ref, name, flags = row
   fTxt, fColor = CCM4Rv.VVhZhD(flags)
   lck = "1" if CCM4Rv.VV9qhi(ref, blkLst) > -1 else ""
   rows.append((str(ndx), "", fColor + name, ref, fTxt, str(flags), lck))
  return rows
 def VVXpzM(self, selfObj, bName, bRef, rows):
  totTbl = len(self.bTables)
  title = {0:"Main Bouquets List", 1:"%s %s" % (FFKrMM("Fav: ", VV0p9P), bName), 2:"%s %s" % (FFKrMM("Sub: ", VV0p9P), bName)}.get(totTbl, bName)
  bg  = {0:"#11002233", 1:"#0a112222"}.get(totTbl, "#0a131111")
  VVpW7I = self.VVTzpb
  VVUZ91 = self.VVsp6B
  VVmolf = (""     , self.VVfflV   , [])
  VVj7lw  = ("Enter Bouquet"  , self.VVMJzp  , [])
  VVjW3s = ("Delete"    , self.VVrcUQ  , [])
  VVwqVu = ("Bouquets Importer" , self.VVyq9v , [])
  VV46TD = ("Options"   , self.VV0pTU  , [])
  VViMvb = ("Move Here"   , self.VV2NXp  , [])
  VVUEAa  = (1, self.VVrPGJ, None)
  widths  = (12   , 7   , 81 , 0  , 0   , 0   , 0   )
  VV4Uoc = (CENTER  , CENTER , LEFT , LEFT , LEFT  , CENTER , CENTER )
  tbl = FFCXsL(self, None, title=title, VVXpNQ=rows, VV4Uoc=VV4Uoc, width=1500, height=1000, VV8boH=widths, VVPYL1=28, VVD4Fx=False, VVmolf=VVmolf, VVj7lw=VVj7lw, VVpW7I=VVpW7I, VVUZ91=VVUZ91, VVjW3s=VVjW3s, VVwqVu=VVwqVu, VV46TD=VV46TD, VViMvb=VViMvb, VVoNmU=True, VVMBr1=2, VVUEAa=VVUEAa, VVAGe1=CFG.lastFindServices
     , VVfWsQ=bg, VVB5I5=bg, VVYCun=bg, VVmErq="#0a005566", VVypeD=0, VVgSJJ="#11330000")
  tbl.VVQ4nk(BF(self.VVsp6B, tbl))
  self.VVYItx(tbl, bName, bRef)
 def VVYz2Z(self, VVAIxO, mutableList, tot, jumpDict=None):
  if tot:
   if mutableList:
    mutableList.flushChanges()
   FFANYL()
   rows = self.VVugW8(VVAIxO.bouqRef)
   if rows:
    VVAIxO.VVurYr()
    VVAIxO.VVEEBV(rows, isSort=False, VVyoYa=BF(self.VVfszH, jumpDict))
   else:
    self.VVuJuR()
    totTbl = len(self.bTables)
    FFoTZI(self.bTables[-1] if totTbl > 0 else self, "Empty List !", 1500)
  else:
   FF8bV6(VVAIxO, "No change !", 1500)
 def VVfszH(self, jumpDict, VVAIxO, title, txt, colList):
  if jumpDict:
   VVAIxO.VV5rHa(jumpDict)
 def VVsp6B(self, VVAIxO):
  VVAIxO["keyRed"].hide()
  VVAIxO["keyBlue"].hide()
  if VVAIxO.VVGZGK:
   if VVAIxO.VVAGI8() > 0:
    VVAIxO["keyRed"].show()
    VVAIxO["keyBlue"].show()
  else:
   VVAIxO["keyRed"].show()
  self.VVbkR1(VVAIxO)
 def VVbkR1(self, VVAIxO):
  if len(self.bTables) == 1 and not VVAIxO.VVMEs4():
   VVAIxO.VVdqRF()
  else:
   VVAIxO.VVQBxV()
 def VVfflV(self, VVAIxO, title, txt, colList):
  c1, c2, c3 = VVjojy, VV1l75, VVdLWL
  ttl = lambda x, y, color=c1: "%s:\n%s\n\n" % (FFKrMM(x, color), y) if y else ""
  num, picon, name, ref, rem, flags, lck = colList
  path = CCM4Rv.VVFC75(ref, mode=1)
  txt  = ttl("Name"    , name)
  txt += ttl("Bouquet File"  , path if path.startswith("/") else "")
  txt += ttl("Parent Bouquet"  , VVAIxO.bouqName, c2)
  txt += ttl("Parent Bouquet File", CCM4Rv.VVFC75(VVAIxO.bouqRef, mode=1), c2)
  txt += ttl("Ref."    , ref, c3) if VVSm4H else ""
  txt += ttl("Remarks"   , rem, c3) if VVSm4H else ""
  path = CCRGqC.VVm9vg(self.pPath, ref, name)
  CCpebE.VV1v7b(self, VV6tGM=CCpebE.VVtIil, params=(txt, path))
 def VVMJzp(self, VVAIxO, title, txt, colList):
  FF7iMz(VVAIxO, BF(self.VVr44O, VVAIxO, colList) )
 def VVr44O(self, VVAIxO, colList):
  maxLev = 2
  num, picon, name, ref, rem, flags, lck = colList
  flags = CCM4Rv.VVEV8v(ref)
  if FF0mVx(ref):
   if len(self.bTables) <= maxLev:
    rows = self.VVugW8(ref)
    if rows : self.VVXpzM(VVAIxO, name, ref, rows)
    else : FF8bV6(VVAIxO, "Empty list !", 1500)
   else:
    FFbBGq(self, "Maximum Level of Recursive Bouquets (%d) !" % maxLev, title=self.Title)
  elif flags & 64:
   FF8bV6(VVAIxO, "Cannot play markers", 500)
  else:
   FF9SoI(self.session, ref)
   FFd2In(self, "Cancel to go back to table")
 def VVTzpb(self, VVAIxO):
  self.VVuJuR()
 def VV0pTU(self, VVAIxO, title, txt, colList):
  VV9cxb = []
  iMulSel = VVAIxO.VVMEs4()
  sortItem = ("Sort", )
  if iMulSel:
   tot = VVAIxO.VVAGI8()
   if tot > 1: sortItem = ("Sort", "sort")
   isSel = tot > 0
   bTxt = "Bouquet%s" % FFaRsj(tot)
  else:
   isSel = True
   bTxt = "Bouquet"
  inMain = len(self.bTables) == 1
  okToMain = False
  if not inMain:
   for ref in self.VVMstJ(VVAIxO):
    if not FF0mVx(ref) and not ref.startswith("1:64:"): break
   else:
    okToMain = True
  totDel = len(self.VVvIcB())
  c1, c2, c3, c4 = VV1l75, VVWH8U, VVk4x7, VVdLWL
  VV9cxb.append(FFH04v("Rename"   , "renm" , not iMulSel, c1))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(FFH04v("Add Marker"  , "mrkr" , not iMulSel, c2))
  VV9cxb.append(FFH04v("Add Empty Bouquet", "addBouq" , not iMulSel and inMain, c2))
  if totDel:
   VV9cxb.append(VVbM5H)
   VV9cxb.append((c4 + 'Delete %d Unused ".del" Bouquets File%s' % (totDel, FFaRsj(totDel)), "unused"))
  if inMain:
   VV9cxb.append(VVbM5H)
   VV9cxb.append(FFH04v("Hide %s" % bTxt , "hidOn" , isSel, c3))
   VV9cxb.append(FFH04v("Unhide %s" % bTxt , "hidOff" , isSel, c3))
   VV9cxb.append(VVbM5H)
   VV9cxb.append(FFH04v("Protect %s" % bTxt , "lckOn" , isSel, c3))
   VV9cxb.append(FFH04v("Unprotect %s" % bTxt , "lckOff" , isSel, c3))
   VVfWsQ, VVB5I5 = "#22001122", "#22000a15"
   VV9cxb.append(VVbM5H)
   VV9cxb.append((c1 + "Fix Media Path (for All Bouquets)"   , "chPath"))
   VV9cxb.append(FFH04v("Save Selected %s to M3U File" % bTxt , "toM3u", isSel, c2))
  else:
   VVfWsQ, VVB5I5 = "#2200120a", "#2200120a"
  VV9cxb.append(VVbM5H)
  VV9cxb.append(sortItem)
  VV9cxb.append(FFH04v("Copy to Main Bouquets List" , "toMain", okToMain))
  VV9cxb.append(FFH04v("Copy to a Bouquet"   , "toBouq", isSel))
  cbFncDict = { "renm" : BF(self.VVr4VI  , VVAIxO)
     , "chPath" : BF(self.VVIr2w , VVAIxO)
     , "toM3u" : BF(self.VV65PA , VVAIxO)
     , "mrkr" : BF(self.VVs0Jv , VVAIxO)
     , "addBouq" : BF(self.VVhfyH, VVAIxO)
     , "unused" : BF(self.VVwRgC , VVAIxO)
     , "hidOn" : BF(self.VVOxII  , VVAIxO, True)
     , "hidOff" : BF(self.VVOxII  , VVAIxO, False)
     , "lckOn" : BF(self.VVs8BO  , VVAIxO, True)
     , "lckOff" : BF(self.VVs8BO  , VVAIxO, False)
     , "sort" : BF(self.VVAkvn  , VVAIxO)
     , "toMain" : BF(self.VVR43u , VVAIxO)
     , "toBouq" : BF(self.VVQBmI , VVAIxO) }
  mSel = CC17aQ(self, VVAIxO)
  mSel.VV4sFy(VV9cxb, cbFncDict, height=1000, VVfWsQ=VVfWsQ, VVB5I5=VVB5I5, VVwv0z=0.08)
 def VVrcUQ(self, VVAIxO, title, txt, colList):
  txt, totSel = "", 0
  if VVAIxO.VVMEs4():
   totSel = VVAIxO.VVAGI8()
   if totSel:
    txt = "Delete %s item%s" % (FFKrMM(totSel, VVjojy), FFaRsj(totSel))
  else:
   num, picon, name, ref, rem, flags, lck = colList
   txt = "Delete : %s" % FFKrMM(name, VVjojy)
  if txt:
   FF6pUe(self, BF(self.VVfcNZ, VVAIxO), "%s\n\nContinue ?" % txt, title=self.Title)
 def VVyq9v(self, VVAIxO, title, txt, colList):
  CCUyKl.VVeuTk(self, cbFnc=BF(self.VVfcti, VVAIxO))
 def VVfcti(self, VVAIxO):
  self.VVYz2Z(VVAIxO, None, 1)
 def VVfcNZ(self, VVAIxO):
  FF7iMz(VVAIxO, BF(self.VVaKaL, VVAIxO))
 def VVaKaL(self, VVAIxO):
  lst, mutableList, csel, bServ = self.VVdijn(VVAIxO)
  if mutableList is not None:
   tot = 0
   for ref in lst:
    serv = eServiceReference(ref)
    if serv.valid() and not mutableList.removeService(serv):
     tot += 1
     bFile = CC8i1k.VVRPbd(ref)
     if bFile:
      bFile = VVgVTn + bFile
      FFlonU("rm -f '%s' '%s.del'" % (bFile, bFile))
   self.VVYz2Z(VVAIxO, mutableList, tot)
 def VV2NXp(self, VVAIxO, title, txt, colList):
  FF7iMz(VVAIxO, BF(self.VVPTsl, VVAIxO))
 def VVPTsl(self, VVAIxO):
  lst, mutableList, csel, bServ = self.VVdijn(VVAIxO)
  if mutableList is not None:
   curNdx = VVAIxO.VVoxea()
   if curNdx <= VVAIxO.VVSlWK(): lst = reversed(lst)
   else             : curNdx -= 1
   tot = 0
   for ref in lst:
    serv = eServiceReference(ref)
    if serv.valid() and not mutableList.moveService(serv, curNdx):
     tot += 1
   self.VVYz2Z(VVAIxO, mutableList, tot)
 def VVAkvn(self, VVAIxO):
  FF7iMz(VVAIxO, BF(self.VV0rTh, VVAIxO))
 def VV0rTh(self, VVAIxO):
  lst, mutableList, csel, bServ = self.VVdijn(VVAIxO)
  if mutableList is not None:
   nmlst = VVAIxO.VVKa9C(2)
   lst = list(zip(nmlst, lst))
   lst.sort(key=lambda x: x[0].lower())
   curNdx = VVAIxO.VVSlWK()
   tot = 0
   for name, ref in reversed(lst):
    serv = eServiceReference(ref)
    if serv.valid() and not mutableList.moveService(serv, curNdx):
     tot += 1
   self.VVYz2Z(VVAIxO, mutableList, tot)
 def VVr4VI(self, VVAIxO, item=None):
  name = VVAIxO.VVQDwi()[2]
  FFANcN(self, BF(self.VVO6sO, VVAIxO), defaultText=name, title="Rename", message="Enter new name")
 def VVO6sO(self, VVAIxO, name):
  lst, mutableList, csel, bServ = self.VVdijn(VVAIxO)
  if name and csel and mutableList:
   name = name.strip()
   if name:
    ref = VVAIxO.VVQDwi()[3]
    if FF0mVx(ref):
     CC8i1k.VVpWeM(ref, name)
    else:
     serv = eServiceReference(ref)
     if serv.valid():
      serv.setName(name)
      mutableList.removeService(serv)
      mutableList.addService(serv)
      mutableList.moveService(serv, VVAIxO.VVoxea())
    self.VVYz2Z(VVAIxO, mutableList, 1)
 def VVIr2w(self, VVAIxO):
  title = "Fix Media Path (for All Bouquets)"
  newP = FF9Uvy(CFG.MovieDownloadPath.getValue())
  txt = FFKrMM("/media/.../movie/", VVjojy)
  FF6pUe(self, BF(FF7iMz, VVAIxO, BF(self.VVRXMJ, title, newP)), "Change Media path (%s) to:\n\n%s" % (txt, newP), title=title)
 def VVRXMJ(self, title, newP):
  totF = totRepl = 0
  for path in CC8i1k.VVvCo4():
   txt = FFmx8y(path)
   exp = iCompile(r"(\/media\/.+\/movie\/)", IGNORECASE)
   lst = set()
   for Str in exp.findall(txt):
    if Str != newP:
     lst.add(Str)
   save = False
   for Str in lst:
    txt, tot = exp.subn(newP, txt)
    totRepl += tot
    save = True
   if save:
    totF += 1
    with open(path, "w") as f:
     f.write(txt)
  if totF or totRepl:
   txt  = "Total Files\t: %s\n"  % totF
   txt += "Total Fixes\t: %s\n"  % totRepl
   FFSMJz(self, txt, title=title)
   FFANYL()
  else:
   FF0onH(self, "All OK (no changes).", title=title)
 def VV65PA(self, VVAIxO):
  FF7iMz(VVAIxO, BF(self.VVz1m1, VVAIxO))
 def VVz1m1(self, VVAIxO):
  if VVAIxO.VVGZGK : rows = VVAIxO.VVdxfP()
  else        : rows = [VVAIxO.VVQDwi()]
  bName = rows[0][2]
  outF = "%s%s_%s.m3u" % (FFJv8S(), FFDJVB(bName), FFRIlf())
  totCh = toB = 0
  with open(outF, "w") as f:
   f.write("#EXTM3U\n")
   for num, picon, name, ref, rem, flags, lck in rows:
    if ref and name and rem == "Directory":
     for chR, chNm, chFlags in FFM85b(eServiceReference(ref), mode=1):
      if chR and chNm:
       chR = chR.replace(":" + chNm, "").strip()
       span = iSearch(r'^((?:[A-Fa-f0-9]+:){10})(.*)', chR, IGNORECASE)
       if span:
        totCh += 1
        ref, url = span.groups()
        url = FF5ov5(url)
        url = url or ref
        if FFKeSw(url):
         url = ref + url
        f.write('#EXTINF:-1 group-title="%s",%s\n' % (name, chNm))
        f.write("%s\n" % url)
  title = "Save to M3U File"
  if totCh:
   totB = len(rows)
   FF0onH(self, "Exported %s Channel%s (from %s Bouquet%s) to:\n\n%s" % (totCh, FFaRsj(totCh), totB, FFaRsj(totB), outF), title=title)
  else:
   FFbBGq(self, "Nothing to save.", title=title)
   FFnE7j(outF)
 def VVs0Jv(self, VVAIxO):
  name = "%s Marker %s" % ("=" * 7, "=" * 7)
  FF7iMz(VVAIxO, BF(self.VVk62C, VVAIxO, name))
 def VVk62C(self, VVAIxO, name):
  lst, mutableList, csel, bServ = self.VVdijn(VVAIxO)
  if mutableList is not None:
   curServ = eServiceReference(VVAIxO.VVQDwi()[3])
   cnt = tot = 0
   while mutableList:
    serv = eServiceReference("1:64:%d:0:0:0:0:0:0:0::%s" % (cnt, name))
    if curServ and curServ.valid():
     if not mutableList.addService(serv, curServ):
      csel.servicelist.addService(serv, True)
      tot += 1
      break
    elif not mutableList.addService(serv):
     csel.servicelist.addService(serv, True)
     tot += 1
     break
    cnt += 1
   self.VVYz2Z(VVAIxO, mutableList, tot)
 def VVhfyH(self, VVAIxO):
  names = VVAIxO.VVEIUC(2)
  name = "Bouquet-1"
  num = 0
  while name in names:
   num += 1
   name = "Bouquet-%s" % num
  FFANcN(self, BF(self.VVpdIk, VVAIxO), defaultText=name, title="New Bouquet", message="Enter Bouquet name")
 def VVpdIk(self, VVAIxO, name=None):
  if name and name.strip():
   FF7iMz(VVAIxO, BF(self.VVr2Qi, VVAIxO, name.strip()))
 def VVr2Qi(self, VVAIxO, bName):
  CC8i1k.VVGOEc(bName)
  self.VVYz2Z(VVAIxO, None, 1, jumpDict={2:bName})
 def VVvIcB(self):
  lst = []
  for fil in os.listdir(VVgVTn):
   if fil.endswith(".tv.del") or fil.endswith(".radio.del"):
    lst.append(fil)
  return lst
 def VVwRgC(self, VVAIxO):
  lst = self.VVvIcB()
  for fil in lst:
   FFnE7j(VVgVTn + fil)
  VVAIxO.VV2t5o("Done")
 def VVMstJ(self, VVAIxO):
  if VVAIxO.VVGZGK : return VVAIxO.VVKa9C(3)
  else        : return [VVAIxO.VVQDwi()[3]]
 def VVR43u(self, VVAIxO):
  dstFile = "bouquets.%s" % ("tv" if CCM4Rv.VVsFRh() == 0 else "radio")
  FF7iMz(VVAIxO, BF(self.VVrhse, VVAIxO, "Main Bouquets List", dstFile, True))
 def VVQBmI(self, VVAIxO):
  bRows = CC8i1k.VV2aLp()
  lst = self.VVMstJ(VVAIxO)
  VV9cxb = []
  for name, ref in bRows:
   if not ref in lst:
    VV9cxb.append((name, ref))
  if VV9cxb : FFO9kU(self,  BF(self.VVi40k, VVAIxO), VV9cxb=VV9cxb, width=1100, height=900, VVfWsQ="#22220000", VVB5I5="#22110000", title="Destination Bouquet", VVDkqE=True)
  else  : FFoTZI(VVAIxO, "No bouquets left !", 1000)
 def VVi40k(self, VVAIxO, item=None):
  if item:
   bName, bRef, ndx = item
   dstFile = CC8i1k.VVRPbd(bRef)
   FF7iMz(VVAIxO, BF(self.VVrhse, VVAIxO, bName, dstFile))
 def VVrhse(self, VVAIxO, bName, dstFile, mainToo=False):
  lst = self.VVMstJ(VVAIxO)
  tot = 0
  for ref in lst:
   ok = CC8i1k.VV3qvy(ref, dstFile)
   if ok:
    tot += 1
  self.VVYz2Z(VVAIxO, None, tot)
  if mainToo:
   rootStr = CCM4Rv.VVcbQn()
   rows = self.VVugW8(rootStr)
   self.bTables[0].VVEEBV(rows)
  ttl = lambda x, y: "%s:\n%s\n\n" % (FFKrMM(x, VVk4x7), y)
  txt  = ttl("Source Bouquet"  , VVAIxO.bouqName)
  txt += ttl("Destination Bouquet", bName)
  txt += ttl("Copied Services" , tot)
  FFSMJz(VVAIxO, txt, title="Copy Services")
 def VVOxII(self, VVAIxO, isHide):
  FF7iMz(VVAIxO, BF(self.VVrjGv, VVAIxO, isHide))
 def VVrjGv(self, VVAIxO, isHide):
  lst, mutableList, csel, bServ = self.VVdijn(VVAIxO)
  mode = CCM4Rv.VVsFRh()
  path = VVgVTn + "bouquets.%s" % ("tv" if mode==0 else "radio")
  if FFKbVo(path):
   tot = 0
   lines = list(map(str.strip, FF2kXa(path)))
   for ref in lst:
    if FF0mVx(ref):
     ref = "#SERVICE " + ref
     nrm = ref.replace("1:519:", "1:7:")
     hid = ref.replace("1:7:"  , "1:519:")
     if isHide: r1, r2 = nrm, hid
     else  : r1, r2 = hid, nrm
     if r1 in lines:
      ndx = lines.index(r1)
      lines[ndx] = r2
      tot += 1
   if tot:
    with open(path, "w") as f:
     for line in lines:
      f.write("%s\n" % line)
    self.VVYz2Z(VVAIxO, None, tot)
 def VVs8BO(self, VVAIxO, isLck):
  FF7iMz(VVAIxO, BF(self.VV3rI8, VVAIxO, isLck))
 def VV3rI8(self, VVAIxO, isLck):
  lst, mutableList, csel, bServ = self.VVdijn(VVAIxO)
  blkLst = CCM4Rv.VVzi45()
  tot = 0
  for ref in lst:
   if FF0mVx(ref):
    ndx = CCM4Rv.VV9qhi(ref, blkLst)
    if isLck:
     if ndx == -1:
      ref = ref.replace("1:519:", "1:0:").replace("1:7:", "1:0:")
      blkLst.append(ref)
      tot += 1
    else:
     if ndx > -1:
      blkLst[ndx] = ""
      tot += 1
  if tot:
   with open(VVnZCL, "w") as f:
    for line in blkLst:
     if line.strip():
      f.write("%s\n" % line)
   from Components.ParentalControl import parentalControl
   parentalControl.open()
   self.VVYz2Z(VVAIxO, None, tot)
 def VVdijn(self, VVAIxO, bServ=None):
  lst = self.VVMstJ(VVAIxO)
  mutableList = csel = None
  VV2RgF = InfoBar.instance
  if VV2RgF:
   csel = VV2RgF.servicelist
   if csel:
    if not bServ:
     bServ = eServiceReference(VVAIxO.bouqRef)
    if bServ.valid():
     mutableList = csel.getMutableList(bServ)
  return lst,  mutableList, csel, bServ
 def VVrPGJ(self, colList):
  num, picon, name, ref, rem, flags, lck = colList
  png = lambda x: "%s%s.png" % (VVK8DT, x)
  if   rem == "Marker"   : return png("mrk1")
  elif rem == "Numbered Marker" : return png("mrk2")
  elif rem == "Group"    : return png("grp")
  elif FF0mVx(ref):
   if   lck == "1" and rem == "Invisible" : return png("dirLckInvis")
   elif lck == "1"       : return png("dirLck")
   elif rem == "Invisible"     : return png("dirInvis")
   else         : return png("dir1")
  else:
   return CCRGqC.VVm9vg(self.pPath, ref, name)
 @staticmethod
 def VVhZhD(flag):
  t = c = ""
  try:
   if   flag & eServiceReference.isInvisible  : t, c = "Invisible"  , "#f#00ff7722#"
   elif flag & eServiceReference.isNumberedMarker : t, c = "Numbered Marker" , "#f#00ffffaa#"
   elif flag & eServiceReference.isGroup   : t, c = "Group"   , "#f#00bbffbb#"
   elif flag & eServiceReference.isMarker   : t, c = "Marker"   , "#f#00ffffaa#"
   elif flag & eServiceReference.isDirectory  : t, c = "Directory"  , ""
  except:
   pass
  return t, c
 @staticmethod
 def VVFC75(ref, mode=0):
  path = ""
  serv = eServiceReference(ref)
  if serv.valid():
   path = serv.getPath()
   if path and not VVSm4H:
    path = iSub(r"[&?]mode=.+end=", r"", path, flags=IGNORECASE)
   if mode == 1:
    span = iSearch(r'FROM\s+BOUQUET\s+"(.+)"\s+ORDER\s+BY\s+bouquet', path, IGNORECASE)
    if span:
     path = VVgVTn + span.group(1)
  return path
 @staticmethod
 def VVEV8v(ref):
  path = ""
  serv = eServiceReference(ref)
  if serv.valid():
   return serv.flags
  return -1
 @staticmethod
 def VVsFRh(default=0):
  VV2RgF = InfoBar.instance
  if VV2RgF:
   csel = VV2RgF.servicelist
   if csel:
    return csel.mode
  return default
 @staticmethod
 def VVcbQn():
  VV2RgF = InfoBar.instance
  if VV2RgF:
   csel = VV2RgF.servicelist
   if csel:
    return csel.bouquet_rootstr
  return ""
 @staticmethod
 def VVzi45():
  return FF2kXa(VVnZCL) if FFKbVo(VVnZCL) else []
 @staticmethod
 def VV9qhi(ref, lst=None):
  if not lst:
   lst = CCM4Rv.VVzi45()
  if FF0mVx(ref):
   ref1 = ref.replace("1:7:", "1:0:")
   ref2 = ref.replace("1:519:", "1:0:")
   if   ref1 in lst: return lst.index(ref1)
   elif ref2 in lst: return lst.index(ref2)
  return -1
class CCRGqC(Screen, CCanwj, CConSF):
 VV9kr5   = 0
 VVmpNs  = 1
 VV5OuH  = 2
 VVAkrZ  = 3
 VV7Xpq  = 4
 VVaVjj  = 5
 VVgDLd  = 6
 VVoAqG  = 7
 VV5Btx = 8
 VV4D0y = 9
 VV5TCt = 10
 VVpco3 = 11
 def __init__(self, session):
  self.skin, self.VVmNvK = FFQaOH(VVmMbY, 1800, 950, 30, 0, 0, "#22201000", "#33000000", 30, VVSwLg=40, VVcmdl=2, VVoZRH=20, VVIZ5t={"rows":4, "cols":7, "picR":0.75, "lblR":0.25, "w1R":0.45, "w2R":0.55, "gapX":10, "gapY":10})
  self.session   = session
  self.Title    = "PIcons Tools"
  self.pPath    = CCRGqC.VV5G3P()
  self.curChanName  = ""
  self.curChanFile  = ""
  self.curChanIndex  = -1
  self.curChanRefCode  = 0
  self.curChanIptvRef  = ""
  self.VVXpNQ    = []
  self.nsList    = set()
  self.lastSortCol  = 0
  self.lastMode   = 0
  self.lastWords   = ['']
  self.lastAsPrefix  = False
  self.lastTimeStamp  = 0
  self.lastSTypeList  = 0
  self.lastFind   = ""
  self.filterTitle  = ""
  FFNhKZ(self, self.Title)
  FFi79B(self["keyRed"] , "OK = Zap")
  FFi79B(self["keyYellow"], "Page Options")
  FFi79B(self["keyBlue"] , "Filter")
  CCanwj.__init__(self, CFG.transpColorPicons)
  CConSF.__init__(self)
  FFmpyO(self,
  {
   "ok"  : self.VV6JIk     ,
   "green"  : self.VVt6CE    ,
   "yellow" : self.VVe23l     ,
   "blue"  : self.VVb3HM     ,
   "menu"  : self.VVKeTE     ,
   "info"  : self.VVxDLz    ,
   "cancel" : self.close
  })
  self.onShown.append(self.VVf1Ra)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  FFeo1z(self)
  FFuwGk(self)
  FFgLA9(self["keyRed"], "#0a333333")
  self.VVax6u()
  FF7iMz(self, BF(self.VVsrrP, mode=self.lastMode, words=self.lastWords, asPrefix=self.lastAsPrefix, VV0wMr=True))
 def VVKeTE(self):
  if not self.VVTUxi:
   c1, c2 = VVOQkl, VVWH8U
   VV9cxb = []
   VV9cxb.append(("Statistics"          , "VVEyCZ"    ))
   VV9cxb.append(VVbM5H)
   VV9cxb.append((c1 + "Suggest PIcons for Current Channel"   , "VVCp52"   ))
   VV9cxb.append((c2 + "Set to Current Channel (copy file)"   , "VVE6vd_file"  ))
   VV9cxb.append((c2 + "Set to Current Channel (as SymLink)"   , "VVE6vd_link"  ))
   VV9cxb.append(VVbM5H)
   VV9cxb.append(("Export Current File Names List"     , "VVv3cr" ))
   VV9cxb.append(CCRGqC.VVQxFT())
   VV9cxb.append(VVbM5H)
   c, cond = VVU4M8, self.filterTitle == "PIcons without Channels"
   VV9cxb.append(FFH04v("Move Unused PIcons to a Directory", "VVsuTa" , cond, c ))
   VV9cxb.append(FFH04v("DELETE Unused PIcons"    , "VV0dU4" , cond, c ))
   VV9cxb.append(VVbM5H)
   VV9cxb.append(("Delete Broken PIcons SymLinks (in PIcons Directory)" , "VVnLu1"  ))
   VV9cxb.append(VVbM5H)
   VV9cxb += CCRGqC.VV61gs()
   VV9cxb.append(VVbM5H)
   VV9cxb.append(("Change Poster/Picon Transparency Color"    , "VVkQR6" ))
   VV9cxb.append(("Keys Help"           , "VVu6uM"    ))
   FFO9kU(self, self.VV5QnJ, width=1100, height=1050, title=self.Title, VV9cxb=VV9cxb, VVfWsQ="#22001020", VVB5I5="#22001020")
 def VV5QnJ(self, item=None):
  if item is not None:
   if   item == "VVEyCZ"    : self.VVEyCZ()
   elif item == "VVCp52"   : self.VVCp52()
   elif item == "VVE6vd_file"  : self.VVE6vd(0)
   elif item == "VVE6vd_link"  : self.VVE6vd(1)
   elif item == "VVv3cr"  : self.VVv3cr()
   elif item == "VVS4Ez"  : CCRGqC.VVS4Ez(self)
   elif item == "VVsuTa"   : self.VVsuTa()
   elif item == "VV0dU4"  : self.VV0dU4()
   elif item == "VVnLu1"  : self.VVnLu1()
   elif item == "VVpYJB"  : CCRGqC.VVpYJB(self)
   elif item == "findPiconBrokenSymLinks" : CCRGqC.VVEu2X(self, True)
   elif item == "FindAllBrokenSymLinks" : CCRGqC.VVEu2X(self, False)
   elif item == "VVkQR6" : self.VVkQR6()
   elif item == "VVu6uM"     : FFY7F5(self, "_help_picons", "PIcons Tools (Keys Help)")
 def VVe23l(self):
  if not self.VVTUxi:
   VV9cxb = []
   VV9cxb.append(("Go to First PIcon"  , "VVtT2j"  ))
   VV9cxb.append(("Go to Last PIcon"   , "VVqo47"  ))
   VV9cxb.append(VVbM5H)
   VV9cxb.append(("Sort by Channel Name"     , "sortByChan" ))
   VV9cxb.append(("Sort by File Name"  , "sortByFile" ))
   VV9cxb.append(VVbM5H)
   VV9cxb.append(("Find from File List .." , "VVVVKB" ))
   FFO9kU(self, self.VVkft1, title=self.Title, VV9cxb=VV9cxb)
 def VVkft1(self, item=None):
  if item is not None:
   if   item == "VVtT2j"   : self.VVtT2j()
   elif item == "VVqo47"   : self.VVqo47()
   elif item == "sortByChan"  : self.VVUS0B(2)
   elif item == "sortByFile"  : self.VVUS0B(0)
   elif item == "VVVVKB"  : self.VVVVKB()
 def VVVVKB(self):
  VV9cxb = []
  for item in self.VVXpNQ:
   VV9cxb.append((item[0], item[0]))
  FFO9kU(self, self.VVVGeU, title='PIcons ".png" Files', VV9cxb=VV9cxb, VVDkqE=True)
 def VVVGeU(self, item=None):
  if item:
   txt, ref, ndx = item
   self.VVelYj(ndx)
 def VV6JIk(self):
  if not self.VVTUxi and self["keyRed"].getVisible():
   filName, VVq9SN, VVUwmk, sat, inDB = self.VV10Tb()
   if VVq9SN:
    CCsmqb.VVlIAT(self.session, VVdxJv=VVq9SN)
    self.VVAYEe()
    self.VVeq8f()
 def VVt6CE(self):
  if self["keyGreen"].getVisible():
   self.VVelYj(self.curChanIndex)
 def VVUS0B(self, col):
  reverseSort = self.lastSortCol == col
  self.lastSortCol = col
  FF7iMz(self, BF(self.VVsrrP, mode=self.lastMode, words=self.lastWords, asPrefix=self.lastAsPrefix, reverseSort=reverseSort), title="Sorting ...")
 def VVE6vd(self, mode):
  title = "Change Current Channel PIcon"
  VVq9SN, VVadS0, VVjgtq, VVVmGQ, VVUwmk = FFLlAM(self)
  curChF = "%s%s.png" % (self.pPath, VVq9SN.replace(":", "_"))
  if VVq9SN:
   filName, VVq9SN, VVUwmk, sat, inDB = self.VV10Tb()
   selPiconF = "%s%s"  % (self.pPath, filName)
   if not curChF == selPiconF:
    if FFKbVo(curChF):
     VV9cxb = []
     VV9cxb.append(("Overwrite current PIcon"    ,  "overwrite" ))
     VV9cxb.append(('Rename current PIcon to ".bak.png"' ,  "backup" ))
     FFO9kU(self, BF(self.VVvYiB, mode, curChF, selPiconF), VV9cxb=VV9cxb, title="Current Channel PIcon (already exists)")
    else:
     self.VVvYiB(mode, curChF, selPiconF, "overwrite")
   else:
    FFbBGq(self, "Cannot change PIcon to itself !", title=title)
  else:
   FFbBGq(self, "Could not read current channel info. !", title=title)
 def VVvYiB(self, mode, curChF, selPiconF, item=None):
  if item is not None:
   cmd  = ""
   if item == "backup" : cmd += "mv -f '%s' '%s';" % (curChF, curChF + ".bak.png")
   else    : cmd += "rm -f '%s';" % curChF
   if mode == 0: cmd += "cp -f '%s' '%s'" % (selPiconF, curChF)
   else  : cmd += "ln -sf '%s' '%s'" % (selPiconF, curChF)
   FFlonU(cmd)
   FF7iMz(self, BF(self.VVsrrP, goToFirst=False), title="PIcon Changed.\nRefreshing ...")
 def VVsuTa(self):
  defDir = FF9Uvy(CCRGqC.VV5G3P() + "picons_backup")
  FFlonU("mkdir '%s'" % defDir)
  self.session.openWithCallback(BF(self.VVKztG, defDir), BF(CC17eA
         , mode=CC17eA.VVAcq8, VVqNQm=CCRGqC.VV5G3P()))
 def VVKztG(self, defDir, path):
  if len(path) > 0:
   title = "Move Unused PIcons"
   if path == CCRGqC.VV5G3P():
    FFbBGq(self, "Cannot move to same directory !", title=title)
   else:
    if not FF9Uvy(path) == FF9Uvy(defDir):
     self.VVbECe(defDir)
    FF6pUe(self, BF(FF7iMz, self, BF(self.VVuQye, title, defDir, path), title="Moving Files ..."), "Move %d files to:\n\n%s" % (len(self.VVXpNQ), path), title=title)
  else:
   self.VVbECe(defDir)
 def VVuQye(self, title, defDir, toPath):
  if not iMove:
   self.VVbECe(defDir)
   FFbBGq(self, "Module not found:\n\nshutil", title=title)
   return
  toPath = FF9Uvy(toPath)
  pPath = CCRGqC.VV5G3P()
  err  = ""
  totOK = 0
  for fName, fType, VVUwmk, sat, inDB in self.VVXpNQ:
   if fName:
    fName += ".png"
    From = "%s%s" % (pPath, fName)
    try:
     iMove(From, "%s%s" % (toPath, fName))
     totOK +=1
    except Exception as e:
     err  = "\nError while moving the file:\n   %s\n\n" % From
     err += "Error:\n   %s" % str(e)
     break
  txt  = "Files\t: %d\n" % len(self.VVXpNQ)
  txt += "Moved\t: %d\n" % totOK
  txt += err
  FFSMJz(self, txt, title=title, VVYCun="#22330000" if err else "#22002020")
  if totOK > 0:
   self.VVuOGf("all")
 def VVbECe(self, defDir):
  try:
   os.rmdir(defDir)
  except:
   pass
 def VV0dU4(self):
  title = "Delete Unused PIcons"
  tot = len(self.VVXpNQ)
  FF6pUe(self, BF(FF7iMz, self, BF(self.VVU3sK, title), title="Deleting Files ..."), "Delete %s unused PIcon file%s ?" % (tot, FFaRsj(tot)), title=title)
 def VVU3sK(self, title):
  pPath = CCRGqC.VV5G3P()
  totErr = 0
  for fName, fType, VVUwmk, sat, inDB in self.VVXpNQ:
   if fName:
    fName = "%s%s.png" % (pPath, fName)
    try:
     os.remove(fName)
    except:
     totErr += 1
  tot = len(self.VVXpNQ)
  txt  = "Found\t: %d\n"  % tot
  txt += "Deleted\t: %d\n" % (tot - totErr)
  if totErr:
   txt += "Errors\t: %s" % FFKrMM(totErr, VVdLWL)
  FFSMJz(self, txt, title=title)
 def VVnLu1(self):
  lines = FFQ1wB("find -L '%s' -type l -print" % self.pPath)
  if lines:
   tot = len(lines)
   FF6pUe(self, BF(self.VVvCuQ, lines), "\n".join(lines), title="Delete %d Broken SymLink%s ?" % (tot, FFaRsj(tot)), VVv5tA=True)
  else:
   FF0onH(self, "No broken SymLinks in:\n\n%s" % self.pPath)
 def VVvCuQ(self, fList):
  FFlonU("find -L '%s' -type l -delete" % self.pPath)
  FF0onH(self, "Files deleted:\n\n%s" % "\n".join(fList), title=self.Title)
 @FFJRPn()
 def VVxDLz(self):
  if self.VVTUxi:
   return
  txt = ""
  filName, VVq9SN, VVUwmk, sat, inDB = self.VV10Tb()
  if filName:
   path = self.pPath + filName
   txt += FFKrMM("PIcon Directory:\n", VV1l75)
   txt += "  Path\t: %s\n"  % self.pPath
   target = FF0T6e(self.pPath)
   if target:
    txt += "  Target\t: %s\n" % target
   txt += "\n"
   target = FF0T6e(path)
   txt += FFKrMM("PIcon File:\n", VV1l75)
   if target:
    txt += "  SymLink\t: %s\n"   % filName
    txt += "  Target File\t: %s\n" % (os.path.dirname(target) + "/" + os.path.basename(target))
   else:
    txt += "  File\t: %s\n" % filName
   txt += "\n"
   slLst = []
   if not os.path.islink(FFsxFo(path)):
    OrigRealPath = os.path.realpath(path)
    for fName in os.listdir(self.pPath):
     fPath = os.path.join(self.pPath, fName)
     if os.path.islink(FFsxFo(fPath)):
      fRealPath = os.path.realpath(fPath)
      if fRealPath == OrigRealPath:
       slLst.append(fRealPath)
    if slLst:
     tot = len(slLst)
     txt += FFKrMM("Found %d SymLink%s to this file from:\n" % (tot, FFaRsj(tot)), VV1l75)
     for fPath in slLst:
      txt += "  %s\n" % FFKrMM(fPath, VV0p9P)
     txt += "\n"
   if VVUwmk:
    txt += FFKrMM("Channel:\n", VV1l75)
    if VVq9SN:
     txt += "  Reference\t: %s\n" % (VVq9SN)
    txt += "  Channel\t: %s\n" % FFKrMM(VVUwmk, VVOQkl)
    if sat and not sat == "IPTV":
     txt += "  Satellite\t: %s" % sat
   elif not slLst:
    txt += FFKrMM("Remarks:\n", VV1l75)
    txt += "  %s\n" % FFKrMM("Unused", VVdLWL)
  CCpebE.VV1v7b(self, VV6tGM=CCpebE.VVaj4O, title="Picon Info", params=(VVq9SN, VVUwmk, txt, self.pPath + filName))
 def VV10Tb(self):
  fName = VVq9SN = VVUwmk = sat = inDB = ""
  if self.VVETIE > -1 and self.VVETIE < self.VVEta1:
   fName, fType, VVUwmk, sat, inDB = self.VVXpNQ[self.VVETIE]
   if fName.count("_") > 8 : VVq9SN = fName.replace("_", ":").upper()
   else     : VVq9SN = ""
   fName += ".png"
   sat  = FFfCll(sat)
  return fName, VVq9SN, VVUwmk, sat, inDB
 def VVAYEe(self):
  vLst = ("myPiconF", "myPiconBG", "myPiconPic")
  for v in vLst: self[v].hide()
  self["keyGreen"].hide()
  self.curChanName = ""
  self.curChanFile = ""
  self.curChanIndex = -1
  self.curChanRefCode = ""
  self.curChanIptvRef = ""
  VVq9SN, VVadS0, VVjgtq, VVVmGQ, VVUwmk = FFLlAM(self)
  if VVq9SN:
   self.curChanRefCode = VVq9SN
   self.curChanName = VVUwmk
   self.curChanIptvRef = VVVmGQ
   path = CCRGqC.VVm9vg(self.pPath, VVq9SN, VVUwmk)
   if path:
    self.curChanFile = os.path.splitext(os.path.basename(path))[0]
    if FFbRME(self["myPiconPic"], path):
     for v in vLst: self[v].show()
    for ndx, item in enumerate(self.VVXpNQ):
     if item[0] == self.curChanFile:
      self.curChanIndex = ndx
      if self.curChanFile.startswith(os.path.splitext(VVq9SN)[0].replace(":", "_")) : txt = "Current Service"
      else                   : txt = "Current PIcon"
      self["keyGreen"].show()
      self["keyGreen"].setText(txt)
      break
 def VVeq8f(self):
  title = "  " + self.Title
  if self.filterTitle:
   title += "  ..  Filter = " + self.filterTitle
  if len(title) > 65:
   title = title[:65] + ".."
  self["myTitle"].setText(title)
  tabLft = " " * 4
  filName, VVq9SN, VVUwmk, sat, inDB = self.VV10Tb()
  fNum = "Num. : %d / %d" % (self.VVETIE + 1, self.VVEta1)
  page = "Page: %d / %d"  % (self.VV9iYP + 1, self.VVgzrd)
  self["myPiconInf0"].setText(FFKrMM("%s%s%s%s" % (tabLft, fNum, " " * 12, page), VV1l75))
  self["myPiconInf1"].setText("%sFile : %s" % (tabLft, filName))
  self["myPiconInf2"].setText("%sRef. : %s" % (tabLft, self.VV10Tb()[1]))
  if self.curChanIptvRef : typ = "Stream Relay" if FFKeSw(self.curChanIptvRef) else "IPTV"
  else     : typ = "Current Ch."
  self["myPiconInf3"].setText("%s%s : %s" % (tabLft, typ, FFKrMM(self.curChanName, VVjojy)))
  self["myPiconInf4"].setText("%sFile : %s\n" % (tabLft, (self.curChanFile + ".png")))
  self["myPiconInf5"].setText("%sRef. : %s" % (tabLft, self.curChanRefCode))
  filName, VVq9SN, VVUwmk, sat, inDB = self.VV10Tb()
  if inDB and not sat == "IPTV" : self["keyRed"].show()
  else       : self["keyRed"].hide()
 @FFJRPn()
 def VVEyCZ(self):
  VVuDJZ, VVlt7s = FFmCsn()
  sTypeNameDict = {}
  for key, val in VVlt7s.items():
   sTypeNameDict[key] = 0
  totUsedFiles = 0
  totUsedLinks = 0
  totSymLinks  = 0
  totInDB   = 0
  totNoRefCode = 0
  totNoSType  = 0
  sTypeDict  = {}
  for fName, fType, VVUwmk, sat, inDB in self.VVXpNQ:
   if VVUwmk:
    if fType == 0 : totUsedFiles += 1
    else   : totUsedLinks += 1
   if fType == 1:
    totSymLinks += 1
   if inDB == 1:
    totInDB += 1
   span = iSearch(r"(?:[A-Fa-f0-9]+_){2}([A-Fa-f0-9]+)(?:_[A-Fa-f0-9]+){7}", fName, IGNORECASE)
   if span:
    stNum = int(span.group(1), 16)
    if stNum in VVlt7s: sTypeDict[VVlt7s[stNum]] = sTypeDict.get(VVlt7s[stNum], 0) + 1
    else     : totNoSType += 1
   else:
    totNoRefCode += 1
  totBrokSL = FF2ndj("find -L '%s' -type l -print | wc -l" % self.pPath)
  VVuGUx = []
  c = "#b#11003333#"
  VVuGUx.append((c + "PIcons" , "%d\tUsed = %s" % (self.VVEta1, totUsedFiles + totUsedLinks)))
  VVuGUx.append((c + "Files" , "%d\tUsed = %s" % (self.VVEta1 - totSymLinks, totUsedFiles)))
  VVuGUx.append((c + "SymLinks" , "%d\tUsed = %s" % (totSymLinks, totUsedLinks)))
  c = "#b#11004040#"
  VVuGUx.append((c + "In Database (lamedb)"  , str(totInDB)))
  VVuGUx.append((c + "Not In Database (lamedb)" , str(self.VVEta1 - totInDB)))
  VVuGUx.append((c + "Satellites"    , str(len(self.nsList))))
  VVuGUx.append((c + "Broken SymLinks"   , str(totBrokSL)))
  if totNoRefCode : VVuGUx.append((c + "File name is not a Reference Code" , str(totNoRefCode)))
  if totNoSType : VVuGUx.append((c + "Unknown Service Type"    , str(totNoSType)))
  s = "Service Type "
  if sTypeDict:
   sTypeRows = []
   for key, val in sTypeDict.items():
    sTypeRows.append(("Service Type (%s)" % key, str(val)))
   sTypeRows.sort(key=lambda x: x[0].lower())
   VVuGUx.extend(sTypeRows)
  FFCXsL(self, None, title=self.Title, VVXpNQ=VVuGUx, VVPYL1=28, VVmErq="#00003333", VVK8UQ="#00222222")
 def VVv3cr(self):
  if self.filterTitle:
   txt = FFgYic(self.filterTitle, r"_")
   txt = "FilteredBy_%s_" % FFhTcV(txt, "_")
  else:
   txt = "All_"
  path = "%sPIconsList_%s%s.txt" % (FFeg8m(), txt, FFRIlf())
  with open(path, "w") as f:
   for fName, fType, VVUwmk, sat, inDB in self.VVXpNQ:
    f.write("%s%s.png\n" % (self.pPath, fName))
  FF0onH(self, "List exported to file:\n\n%s" % path, title=self.Title)
 def VVb3HM(self):
  if not self.VVTUxi:
   VV9cxb = []
   VV9cxb.append(("All"        , "all"  ))
   VV9cxb.append(VVbM5H)
   VV9cxb.append(("Used by Channels"     , "used" ))
   VV9cxb.append(("Unused PIcons"     , "unused" ))
   VV9cxb.append(("IPTV PIcons"      , "iptv" ))
   VV9cxb.append(VVbM5H)
   VV9cxb.append(("PIcons Files (no SymLinks)"  , "pFiles" ))
   VV9cxb.append(("SymLinks to PIcons"    , "pLinks" ))
   VV9cxb.append(("PIcons Files Targeted by SymLinks", "pTargets"))
   VV9cxb.append(("By Files Date ..."    , "pDate" ))
   VV9cxb.append(("By Service Type ..."    , "servType"))
   if self.nsList:
    VV9cxb.append(FFT7cF("Satellites (Reference in PIcon name)"))
    satsHex = list(self.nsList)
    satsHex.sort()
    for sHex in satsHex:
     val = int(sHex, 16)
     if val > 0:
      sat = FFYCut(val)
      VV9cxb.append((sat, "__s__" + sHex + "__sat__" + sat))
   filterObj = CCuHRT(self)
   filterObj.VVMz7Q(VV9cxb, self.nsList, self.VVzMuD)
 def VVzMuD(self, item=None):
  if item is not None:
   self.VVuOGf(item)
 def VVuOGf(self, item=None):
   if   item == "all"    : mode, words, self.filterTitle = self.VV9kr5   , ""  , ""
   elif item == "used"    : mode, words, self.filterTitle = self.VVmpNs   , ""  , "PIcons with Channels"
   elif item == "unused"   : mode, words, self.filterTitle = self.VV5OuH  , ""  , "PIcons without Channels"
   elif item == "iptv"    : mode, words, self.filterTitle = self.VVgDLd   , "iptv" , "IPTV PIcons"
   elif item == "pFiles"   : mode, words, self.filterTitle = self.VVAkrZ  , ""  , "PIcons Files"
   elif item == "pLinks"   : mode, words, self.filterTitle = self.VV7Xpq  , ""  , "SymLinks"
   elif item == "pTargets"   : mode, words, self.filterTitle = self.VVaVjj  , ""  , "Targets"
   elif item == "pDate"   : mode, words, self.filterTitle = self.VV5TCt , ""  , "Date"
   elif item == "servType"   : mode, words, self.filterTitle = self.VVpco3 , ""  , "Service Type"
   elif item.startswith("__s__") : mode, words, self.filterTitle = self.VVoAqG   , item[5:].split("__sat__")[0] , item[5:].split("__sat__")[1]
   elif item.startswith("__w__") : mode, words, self.filterTitle = self.VV5Btx , item[5:] , item[5:]
   else       : return
   asPrefix = self.lastAsPrefix
   if mode == self.VVaVjj:
    words = []
    pngFiles = self.pPath + "*.png"
    lines = FFQ1wB("find %s -type l | while read -r FILE; do if [ -L \"$FILE\" ] && [ -e \"$FILE\" ]; then ls -l \"$FILE\" 2> /dev/null | awk '{$1=$2=$3=$4=$5=$6=$7=$8=$9=$10=\"\";print}' | xargs; fi; done" % pngFiles)
    if lines:
     for f in lines:
      fName = FFiZj6(f)
      if fName.endswith(".png"):
       fName = fName[:-4]
       words.append(fName)
    if not words:
     FFoTZI(self, "Not found", 1000)
     return
   elif mode == self.VV5TCt:
    self.VVL7bd(mode)
    return
   elif mode == self.VVpco3:
    self.VV6sFm(mode)
    return
   elif mode == self.VV4D0y:
    return
   else:
    words, asPrefix = CCuHRT.VVzdEZ(words)
   if not words and mode in (self.VVoAqG, self.VV5Btx):
    FFoTZI(self, "Incorrect filter", 2000)
   elif not self.lastMode == mode or not self.lastWords == words or not self.lastAsPrefix == asPrefix:
    FF7iMz(self, BF(self.VVsrrP, mode=mode, words=words, asPrefix=asPrefix), title="Filtering ...", clearMsg=False)
 def VVL7bd(self, mode):
  VV9cxb = []
  VV9cxb.append(("Today"   , "today" ))
  VV9cxb.append(("Since Yesterday" , "yest" ))
  VV9cxb.append(("Since 7 days"  , "week" ))
  FFO9kU(self, BF(self.VVd4G8, mode), VV9cxb=VV9cxb, title="Filter by Added/Modified Date")
 def VVd4G8(self, mode, item=None):
  if item:
   if   item == "today": stamp, self.filterTitle = FFiMxY(0) , "Today"
   elif item == "yest" : stamp, self.filterTitle = FFiMxY(-1), "Yesterday"
   elif item == "week" : stamp, self.filterTitle = FFiMxY(-7), "Last 7 Days"
   self.filterTitle = "File Date (%s)" % self.filterTitle
   if not self.lastMode == mode or not self.lastTimeStamp == stamp:
    FF7iMz(self, BF(self.VVsrrP, mode=mode, timeStamp=stamp), title="Filtering ...", clearMsg=False)
 def VV6sFm(self, mode):
  VVuDJZ, VVlt7s = FFmCsn()
  lst = set()
  for key, val in VVlt7s.items():
   lst.add(val)
  VV9cxb = []
  for item in lst:
   VV9cxb.append((item, item))
  VV9cxb.sort(key=lambda x: x[0])
  FFO9kU(self, BF(self.VVyBUZ, mode), VV9cxb=VV9cxb, title="Filter by Service Type")
 def VVyBUZ(self, mode, item=None):
  if item:
   VVuDJZ, VVlt7s = FFmCsn()
   sTypeList = []
   for key, val in VVlt7s.items():
    if item == val:
     self.filterTitle = val
     sTypeList.append(("%01x" % key).upper())
   if not self.lastMode == mode or not self.lastSTypeList == sTypeList:
    FF7iMz(self, BF(self.VVsrrP, mode=mode, sTypeList=sTypeList), title="Filtering ...", clearMsg=False)
 def VVCp52(self):
  CCV3Gw.VVgWD3(self
      , VVuSHu  = self.VVx5XR
      , VVhK3C = self.VVIpaX)
 def VVx5XR(self, VVqeT6):
  VVNFGd, err = CC2Ekb.VVTefV(self, CC2Ekb.VVdKU3, VVf6Ho=False, VVFiGB=False)
  files = []
  words = []
  if not VVqeT6 or VVqeT6.isCancelled:
   return
  VVqeT6.VVL8uX = []
  VVqeT6.VVfT17(len(VVNFGd))
  if VVNFGd:
   curCh = self.VVPjh3(self.curChanName)
   for VVq9SN in VVNFGd:
    if not VVqeT6 or VVqeT6.isCancelled: return
    VVqeT6.VVqE9L(1, True)
    VVUwmk, sat, inDB = VVNFGd.get(VVq9SN, ("", "", 0))
    ratio = CCRGqC.VV0v8f(VVUwmk.lower(), curCh)
    if ratio > 50:
     allPath, fName, VV7ADG, pList = CCRGqC.VVyHSe(VVq9SN.replace("_", ":"), self.curChanName, addSimilar=True)
     if pList:
      for f in pList:
       f = FFiZj6(f)
       fil = f.replace(".png", "")
       if not VVqeT6 or VVqeT6.isCancelled: return
       if not fil in VVqeT6.VVL8uX:
        VVqeT6.VVL8uX.append(fil)
 def VVIpaX(self, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  if VVL8uX : FFvfpL(BF(FF7iMz, self, BF(self.VVsrrP, mode=self.VV4D0y, words=VVL8uX), title="Loading ..."))
  else   : FFoTZI(self, "Not found", 2000)
 def VVsrrP(self, mode=0, words=None, asPrefix=False, reverseSort=False, VV0wMr=False, goToFirst=True, timeStamp=None, sTypeList=None):
  if not self.VVW66h(VV0wMr):
   return
  self.VVTUxi = True
  VVFiGB = True if VV0wMr else False
  VVNFGd, err = CC2Ekb.VVTefV(self, CC2Ekb.VVdKU3, VVf6Ho=False, VVFiGB=VVFiGB)
  if err:
   self.close()
  VVffBx = self.VVwZaZ()
  tList = []
  for fName, fType in CCRGqC.VVkuaE(self.pPath):
   fName = fName[:-4]
   namSp = ""
   if fName.count("_") > 8 and VVNFGd:
    if fName in VVNFGd:
     VVUwmk, sat, inDB = VVNFGd.get(fName)
     VVUwmk = VVUwmk or "?"
     namSp = fName.split("_")[6].zfill(8)[:4]
    elif fName in VVffBx:
     VVUwmk = VVffBx.get(fName) or "?"
     sat, inDB = "IPTV", 1
    else:
     VVUwmk, sat, inDB = "", "", 0
   else:
    VVUwmk, sat, inDB = "", "", 0
   entry = (fName, fType, VVUwmk, sat, inDB)
   isAdd = False
   if mode == self.VV9kr5:
    if namSp:
     self.nsList.add(namSp)
    isAdd = True
   elif mode == self.VVmpNs  and VVUwmk         : isAdd = True
   elif mode == self.VV5OuH and not VVUwmk        : isAdd = True
   elif mode == self.VVAkrZ  and fType == 0        : isAdd = True
   elif mode == self.VV7Xpq  and fType == 1        : isAdd = True
   elif mode == self.VVaVjj  and fName in words       : isAdd = True
   elif mode == self.VV4D0y and fName in words       : isAdd = True
   elif mode == self.VVgDLd  and sat.lower() == words[0]     : isAdd = True
   elif mode == self.VVoAqG  and namSp.lower() == words[0]    : isAdd = True
   elif mode == self.VV5Btx:
    if asPrefix:
     if any(VVUwmk.lower().startswith(x) for x in words)       : isAdd = True
    elif any(x in VVUwmk.lower() for x in words)         : isAdd = True
   elif mode == self.VV5TCt:
    try:
     if os.stat("%s%s.png" % (self.pPath, fName)).st_ctime >= timeStamp   : isAdd = True
    except:
     pass
   elif mode == self.VVpco3:
    span = iSearch(r"(?:[A-Fa-f0-9]+_){2}([A-Fa-f0-9]+)(?:_[A-Fa-f0-9]+){7}", fName, IGNORECASE)
    if span and span.group(1) in sTypeList           : isAdd = True
   if isAdd:
    tList.append(entry)
  if len(tList) > 0:
   self.VVXpNQ   = list(tList)
   tList    = None
   self.lastMode  = mode
   self.lastWords  = words
   self.lastAsPrefix = asPrefix
   self.lastTimeStamp = timeStamp
   self.lastSTypeList = sTypeList
   FFoTZI(self)
  else:
   self.VVTUxi = False
   FFoTZI(self, "Not found", 1000)
   return
  self.VVXpNQ.sort(key=lambda x: x[self.lastSortCol], reverse=reverseSort)
  self.VVAYEe()
  self.VVEta1 = len(self.VVXpNQ)
  self.VVgzrd = int(self.VVEta1 / self.VVnMEH) + (self.VVEta1 % self.VVnMEH > 0)
  if goToFirst:
   self.VV9iYP = 0
   self.curRow  = 0
   self.curCol  = 0
   self.VVETIE = 0
   self.VVHoLK = 0
   self.VV8V7w = 0
  self.VVTUxi = False
  self.VVtG39(True)
 def VVW66h(self, VV0wMr):
  if FFKbVo(self.pPath):
   for fName, fType in CCRGqC.VVkuaE(self.pPath):
    if fName:
     return True
   if VV0wMr : FFbBGq(self, 'No ".png" files in path:\n\n%s' % self.pPath, title=self.Title)
   else   : FFoTZI(self, "Not found", 1000)
  else:
   FFbBGq(self, "PIcons path not found.\n\n%s" % self.pPath)
  if VV0wMr:
   self.close()
  return False
 def VVwZaZ(self):
  VVuGUx = {}
  files  = CCTe4w.VVcN0J()
  if files:
   for path in files:
    txt = FFmx8y(path)
    list = iFindall(r"#SERVICE\s+([A-Fa-f0-9]+:0:(?:[A-Fa-f0-9]+[:]){8}).+\n#DESCRIPTION\s+(.+)", txt, IGNORECASE)
    if list:
     for item in list:
      VVq9SN = item[0].upper().replace(":", "_").strip("_")
      VVuGUx[VVq9SN] = item[1]
  return VVuGUx
 def VVylN0(self):
  self.VVyspd()
  f1, f2 = self.VVibAZ()
  row = col = 0
  for ndx in range(f1, f2):
   fName, fType, VVUwmk, sat, inDB = self.VVXpNQ[ndx]
   fName = self.VVXpNQ[ndx][0]
   path  = self.pPath + fName + ".png"
   VVq9SN  = fName.replace("_", ":").upper()
   pic, lbl = self.VVHuJq(row, col)
   ok = self.VV8ed0(ndx, row, col, pic, path)
   if ok   : color = VVOQkl if inDB else ""
   elif not VVUwmk : color = ""
   else   : color = VV2jvK
   self.VVCHuh(lbl, VVUwmk or "-", color)
   self.VVHoLK = row
   self.VV8V7w = col
   col += 1
   if col > (self.VVatGZ - 1):
    col = 0
    row += 1
 @staticmethod
 def VV0v8f(s1, s2):
  row = -1
  rows, cols, dist = len(s1) + 1, len(s2) + 1, []
  for i in range(rows): dist.append([0.] * cols)
  for i in range(1, rows):
   for j in range(1,cols): dist[i][0], dist[0][j] = i, j
  for col in range(1, cols):
   for row in range(1, rows):
    cost = 0 if s1[row-1] == s2[col-1] else 2
    dist[row][col] = min(dist[row-1][col] + 1, dist[row][col-1] + 1, dist[row-1][col-1] + cost)
  return int( ( ( len(s1) + len(s2) ) - dist[row][col] ) / ( len(s1) + len(s2) ) * 100 ) if row != -1 else 0
 @staticmethod
 def VVQxFT():
  return ("Export Current Channel PIcon File", "VVS4Ez")
 @staticmethod
 def VV61gs():
  VV9cxb = []
  VV9cxb.append(("Find SymLinks (to PIcon Directory)"   , "VVpYJB"  ))
  VV9cxb.append(("Find Broken SymLinks (to PIcon Directory)" , "findPiconBrokenSymLinks" ))
  VV9cxb.append(("Find all Broken SymLinks"      , "FindAllBrokenSymLinks" ))
  return VV9cxb
 @staticmethod
 def VVS4Ez(SELF):
  png, path = CCRGqC.VVep9Y(CCZv30(SELF.session).VVF8zm)
  if path : CCRGqC.VVAI7e(SELF, png, path)
  else : FFbBGq(SELF, "No PIcon found for current channel in:\n\n%s" % CCRGqC.VV5G3P())
 @staticmethod
 def VVpYJB(SELF):
  if VVjojy:
   sed1 = FFuLAo("->", VVjojy)
   sed2 = FFuLAo("picon", VVdLWL)
   sed3 = r"| sed 's/... Broken Link/\\t\\%s&\%s/gI'" % (VV2jvK, VVCQUS)
  else:
   sed1 = sed2 = sed3 = ""
  grep = "| grep -i 'picon'"
  FF75rg(SELF, "find / %s -type l %s | while read -r FILE; do if [ -L \"$FILE\" ] && [ ! -e \"$FILE\" ]; then BROK='... Broken Link'; else BROK=''; fi; ls -l \"$FILE\" 2> /dev/null | sed \"s/$/${BROK}/\" | awk '{$1=$2=$3=$4=$5=$6=$7=$8=\"\";print}' | xargs; done %s %s %s" % (FFbt47(1), grep, sed1, sed2, sed3))
 @staticmethod
 def VVEu2X(SELF, isPIcon):
  sed1 = FFuLAo("->", VV2jvK)
  if isPIcon:
   grep = "| grep -i 'picon'"
   sed2 = FFuLAo("picon", VVdLWL)
  else:
   grep = "| grep -v /proc | grep -v /run | grep -v /etc/rcS.d"
   sed2 = ""
  FF75rg(SELF, "find / %s -type l %s | while read -r FILE; do if [ -L \"$FILE\" ] && [ ! -e \"$FILE\" ]; then ls -l \"$FILE\" 2> /dev/null | awk '{$1=$2=$3=$4=$5=$6=$7=$8=\"\";print}' | xargs; fi; done %s %s" % (FFbt47(1), grep, sed1, sed2))
 @staticmethod
 def VVAI7e(SELF, png, path):
  dest = FFNaQp()
  andTxt = "echo -e 'PIcon file copied to:\n\n%s%s' %s" % (dest, png, FFuLAo("%s%s" % (dest, png), VVOQkl))
  errTxt = "Could not copy PIcon file!"
  orTxt = "echo -e '%s' %s" % (errTxt, FFuLAo(errTxt, VVPI2q))
  cmd = "cp -f '%s' '%s' &> /dev/null && %s || %s" % (path, dest, andTxt, orTxt)
  FFClck(SELF, cmd)
 @staticmethod
 def VVkuaE(path):
  for f in os.listdir(path):
   if f.endswith(".png"):
    p = path + f
    if os.path.islink(FFsxFo(p)) and os.path.exists(p) : yield f , 1
    elif os.path.isfile(p)          : yield f , 0
 @staticmethod
 def VV5G3P():
  return FF9Uvy(CFG.PIconsPath.getValue())
 @staticmethod
 def VVep9Y(VVq9SN, VVUwmk=""):
  if FFC4pX(VVq9SN):
   VVq9SN, VVadS0, VVjgtq, VVVmGQ = CCZv30.VVXF8h(VVq9SN)
  allPath, fName, VV7ADG, pList = CCRGqC.VVyHSe(VVq9SN, VVUwmk)
  if pList:
   if VV7ADG : return fName, VV7ADG
   else   : return fName, pList[0]
  else:
   return "", ""
 @staticmethod
 def VVm9vg(pPath, VVq9SN, VVUwmk):
  span = iSearch(r"^((?:[a-f0-9]+:){9}(?:[a-f0-9]+))", VVq9SN.strip(), IGNORECASE)
  if span:
   exts = ("png", "jpg")
   VVq9SN = span.group(1).replace(":", "_")
   tPath = "%s%s." % (pPath, VVq9SN)
   for ext in exts:
    path = tPath + ext
    if FFKbVo(path):
     return path
   refParts = VVq9SN.split("_", 1)
   for rType in CCTe4w.VVnWJ1():
    if not rType == refParts[0]:
     for ext in exts:
      path = "%s%s_%s.%s" %  (pPath, rType, refParts[1], ext)
      if FFKbVo(path):
       return path
   VVUwmk = FFkEjh(VVUwmk)
   VVUwmk1 = VVUwmk.replace(" ", "")
   for name in (VVUwmk, VVUwmk.lower(), VVUwmk.upper(), VVUwmk1.lower(), VVUwmk1.upper()):
    for ext in exts:
     path = "%s%s.%s" % (pPath, name, ext)
     if FFKbVo(path):
      return path
  return ""
 @staticmethod
 def VVyHSe(VVq9SN, VVUwmk, addSimilar=False):
  allPath = fName = VV7ADG = pList = None
  if VVq9SN.count(":") > 8:
   VVq9SN = VVq9SN.rstrip(":")
   fName = VVq9SN.strip()
   fName = fName.rstrip(":")
   fName = VVq9SN.replace(":", "_") + ".png"
   allPath = CCRGqC.VV5G3P()
   pList = []
   lst = FFYvtE(allPath, "*_" + "_".join(fName.split("_")[3:]))
   if lst:
    pList += lst
   if VVUwmk:
    pList.extend(CCRGqC.VVfn1F(FFkEjh(VVUwmk), addSimilar=addSimilar))
   VV7ADG = ""
   if pList:
    for item in pList:
     if fName == FFiZj6(item):
      VV7ADG = item
    pList.sort()
  return allPath, fName, VV7ADG, pList
 @staticmethod
 def VVfn1F(VVUwmk, addSimilar=False):
  lst  = []
  pPath = CCRGqC.VV5G3P()
  if VVkY7E(pPath):
   VVUwmk = VVUwmk.lower()
   exts = ("png", "jpg")
   fLst = os.listdir(pPath)
   if addSimilar:
    for s in ("sd", "hd", "hd+", "fhd", "fhd+", "4k", "tv"):
     VVUwmk = VVUwmk.replace(s, "")
    VVUwmk = VVUwmk.strip()
    for x in fLst:
     tName = x[:-4].lower()
     if (VVUwmk in tName or tName in VVUwmk) and x[-3:] in exts:
      lst.append(x)
   else:
    lst = [x for x in fLst if VVUwmk == x[:-4].lower() and x[-3:] in exts]
  return lst
class CCKQEu():
 def __init__(self):
  self.VVBtAu()
 def VVBtAu(self):
  noService = "No data"
  self.VVwGOd = ""
  self.VVj551  = noService
  self.VVanEJ = 0
  self.VV65ac  = noService
  self.VVbdLX = 0
  self.VVIyGB  = "-"
  self.VVf2eP = 0
  self.VVTUjn  = ""
  self.serviceName = ""
  self.infoAvailable = False
  self.VVrcLG  = None
 def VVeXSX(self, service):
  self.VVBtAu()
  if service:
   feinfo = service.frontendInfo()
   if feinfo:
    self.infoAvailable = True
    frontEndStatus = feinfo.getFrontendStatus()
    if frontEndStatus:
     self.VVrcLG = frontEndStatus
     self.VVTLMc()
   info = service.info()
   if info:
    self.serviceName = info.getName()
 def VVTLMc(self):
  if self.VVrcLG:
   val = self.VVrcLG.get("tuner_signal_quality_db", 0x12345678)
   if val is not None and val != 0x12345678: self.VVwGOd = "%3.02f dB" % (val / 100.0)
   else         : self.VVwGOd = ""
   val = self.VVrcLG.get("tuner_signal_quality", 0) * 100 / 65536
   self.VVanEJ = int(val)
   self.VVj551  = "%d%%" % val
   val = self.VVrcLG.get("tuner_signal_power" , 0) * 100 / 65536
   self.VVbdLX = int(val)
   self.VV65ac  = "%d%%" % val
   val = self.VVrcLG.get("tuner_bit_error_rate", 0)
   if not val:
    val = 0
   self.VVIyGB  = "%d" % val
   val = int(val * 100 / 500)
   self.VVf2eP = min(500, val)
   val = self.VVrcLG.get("tuner_locked", 0)
   if val == 1 : self.VVTUjn = "Locked"
   else  : self.VVTUjn = "Not locked"
 def VVs9Su(self)   : return self.VVwGOd
 def VVPwO9(self)   : return self.VVj551
 def VV86et(self)  : return self.VVanEJ
 def VVnZjX(self)   : return self.VV65ac
 def VVKqPT(self)  : return self.VVbdLX
 def VVCMNB(self)   : return self.VVIyGB
 def VV6ouN(self)  : return self.VVf2eP
 def VVoDR7(self)   : return self.VVTUjn
 def VVzqeR(self) : return self.serviceName
class CCrDr0():
 def __init__(self):
  self.sat1 = self.sat2 = self.freq = self.sr = self.syst = self.inv = self.pol = self.fec    = ""
  self.mod = self.rolof = self.pil = self.plsMod = self.plsCod = self.iStId = self.t2PlId = self.t2PId = ""
  self.data  = None
  self.namespace = ""
  self.txMedia = ""
  self.D_POL  = {0:"Horizontal" , 1:"Vartical" , 2:"Left" , 3:"Right"}
  self.D_SYS_S = {0:"DVB-S", 1:"DVB-S2"}
  self.D_SYS_T = {0:"DVB-T", 1:"DVB-T2"}
  self.D_SYS_C = {0:"DVB-C", 1:"DVB-C2", 2:"DVB-C3", 3:"ATSC"}
  self.D_PIL_INV = {0:"Off" , 1:"On" , 2:"Auto"}
  self.D_PLS_MOD = {0:"Root" , 1:"Gold" , 2:"Combo" , 3:"Unknown"}
  self.D_ROLOF = {0:"35%" , 1:"25%" , 2:"20%" , 3:"Auto"}
  self.D_MOD  = {0:"Auto" , 1:"QPSK" , 2:"8PSK" , 3:"QAM16" , 4:"16APSK", 5:"32APSK"}
  self.D_FEC  = {0:"Auto" , 1:"1/2" , 2:"2/3" , 3:"3/4" , 4:"5/6" , 5:"7/8", 6:"8/9", 7:"3/5", 8:"4/5", 9:"9/10", 10:"6/7", 15:"None"}
  self.FREQ  = "frequency"
  self.SR   = "symbol_rate"
  self.POL  = "polarization"
  self.FEC  = "fec_inner"
  self.ORPOS  = "orbital_position"
  self.SYST  = "system"
  self.INV  = "inversion"
 def VVNdhh(self, VVq9SN):
  self.data = None
  if not VVq9SN: return
  self.namespace = FFikHv(VVq9SN)
  if   self.namespace.startswith("EEEE") : self.txMedia, syst = "DVB-T", self.D_SYS_T
  elif self.namespace.startswith("FFFF") : self.txMedia, syst = "DVB-C", self.D_SYS_C
  else         : self.txMedia, syst = "DVB-S", self.D_SYS_S
  servRef = eServiceReference(VVq9SN)
  if servRef:
   info = eServiceCenter.getInstance().info(servRef)
   if info:
    self.data = info.getInfoObject(servRef, iServiceInformation.sTransponderData)
    if self.data:
     self.sat1  = self.VV1LyH(self.ORPOS  , mod=1   )
     self.sat2  = self.VV1LyH(self.ORPOS  , mod=2   )
     self.freq  = self.VV1LyH(self.FREQ  , mod=3   )
     self.sr   = self.VV1LyH(self.SR   , mod=4   )
     self.inv  = self.VV1LyH(self.INV  , self.D_PIL_INV)
     self.pol  = self.VV1LyH(self.POL  , self.D_POL )
     self.fec  = self.VV1LyH(self.FEC  , self.D_FEC )
     self.syst  = self.VV1LyH(self.SYST  , syst   )
     if "S2" in self.syst:
      self.mod = self.VV1LyH("modulation" , self.D_MOD )
      self.rolof = self.VV1LyH("rolloff"  , self.D_ROLOF )
      self.pil = self.VV1LyH("pilot"   , self.D_PIL_INV)
      self.plsMod = self.VV1LyH("pls_mode"  , self.D_PLS_MOD)
      self.plsCod = self.VV1LyH("pls_code"  )
      self.iStId = self.VV1LyH("is_id"   )
      self.t2PlId = self.VV1LyH("t2mi_plp_id" )
      self.t2PId = self.VV1LyH("t2mi_pid"  )
 def VV1LyH(self, key, valDict=None, mod=0):
  val = self.data.get(key, "?")
  if   val in ("?", -1) : return ""
  elif valDict   : return valDict.get(val, str(val))
  elif mod == 1   : return FFYCut(val)
  elif mod == 2   : return FFUti6(val)
  elif mod == 3   : return str(int(val) // 1000)
  elif mod == 4   : return str(int(val) // 1000)
  else     : return str(val)
 def VVLaED(self, refLst):
  for VVq9SN in refLst:
   self.VVNdhh(VVq9SN)
   if self.data: break
  txt = ""
  if self.data:
   def VVqz4B(subj, val):
    if val : return "%s\t: %s\n" % (subj, val)
    else : return ""
   if self.txMedia == "DVB-S":
    txt += VVqz4B("System"   , self.syst)
    txt += VVqz4B("Satellite"  , self.sat2)
    txt += VVqz4B("Frequency"  , self.freq)
    txt += VVqz4B("Inversion"  , self.inv)
    txt += VVqz4B("Symbol Rate"  , self.sr)
    txt += VVqz4B("Polarization" , self.pol)
    txt += VVqz4B("FEC"    , self.fec)
    if "S2" in self.syst:
     txt += VVqz4B("Modulation" , self.mod)
     txt += VVqz4B("Roll-Off" , self.rolof)
     txt += VVqz4B("Pilot"  , self.pil)
     txt += VVqz4B("Input Stream", self.iStId)
     txt += VVqz4B("T2MI PLP ID" , self.t2PlId)
     txt += VVqz4B("T2MI PID" , self.t2PId)
     txt += VVqz4B("PLS Mode" , self.plsMod)
     txt += VVqz4B("PLS Code" , self.plsCod)
   else:
    txt += VVqz4B("System"   , self.txMedia)
    txt += VVqz4B("Frequency"  , self.freq)
  return txt, self.namespace
 def VVFuAx(self, refLst, maxLen=0, nonTxt="-"):
  for VVq9SN in refLst:
   self.VVNdhh(VVq9SN)
   if self.data: break
  if self.data:
   if self.txMedia == "DVB-S":
    txt1, txt2, txt3 = ("%s %s %s %s" % (self.freq, self.pol[:1], self.fec, self.sr)).strip(), "  ", self.sat2.strip()
    len1, len2, len3 = len(txt1), 2, len(txt3)
    if maxLen and (len1 + len2 + len3 > maxLen):
     txt3 = txt3[:maxLen - len1 - len2] + ".."
    return (txt1 + txt2 + (FFKrMM(txt3, VVv8b8) if txt3 else "")).strip()
   else:
    return "Freq = %s  (%s)" % (self.freq, FFKrMM(self.txMedia, VVv8b8))
  elif nonTxt : return FFKrMM(nonTxt, VVU4M8)
  else  : return ""
 def VVAv0x(self, VVq9SN):
  self.VVNdhh(VVq9SN)
  if self.data:
   if all((self.pol[:1], self.fec, self.sr)): return ("%s %s %s %s" % (self.freq, self.pol[:1], self.fec, self.sr)).strip()
   else          : return ("Freq=%s" % self.freq).strip()
  else           : return ""
 def VV6RhP(self, VVq9SN):
  if VVq9SN and VVq9SN.count(":") > 8: servRef = eServiceReference(VVq9SN)
  else         : servRef = None
  self.data = None
  if servRef:
   info = eServiceCenter.getInstance().info(servRef)
   if info:
    self.data = info.getInfoObject(servRef, iServiceInformation.sTransponderData)
    if self.data:
     self.namespace = FFikHv(VVq9SN)
     if   self.namespace.startswith("EEEE") : isSat, syst = False, self.VV1LyH(self.SYST, self.D_SYS_T)
     elif self.namespace.startswith("FFFF") : isSat, syst = False, self.VV1LyH(self.SYST, self.D_SYS_C)
     else         : isSat, syst = True , self.VV1LyH(self.SYST, self.D_SYS_S)
     freq = self.VV1LyH(self.FREQ , mod=3  )
     if isSat:
      pol = self.VV1LyH(self.POL , self.D_POL)
      fec = self.VV1LyH(self.FEC , self.D_FEC)
      sr = self.VV1LyH(self.SR  , mod=4  )
      return freq, pol[:1], fec, sr, syst
     else:
      return freq, "-", "-", "-", syst
  return "-", "-", "-", "-", ""
 def VVrbgC(self, VVq9SN):
  self.data = None
  self.VVNdhh(VVq9SN)
  if self.data and self.freq : return True
  else      : return False
class CCNb3y():
 def __init__(self, VVVJTB, path, VVhK3C=None, VVmB4A=-1):
  self.VVVJTB  = VVVJTB
  self.origFile   = path
  self.Title    = "File Editor: " + FFiZj6(path)
  self.VVhK3C  = VVhK3C
  self.tmpFile   = "/tmp/ajp_edit"
  self.fileChanged  = False
  self.fileSaved   = False
  self.insertMode   = 0
  self.lastLineNum  = -1
  self.editorTable  = None
  self.starterRow   = VVmB4A
  if FFlonU("cp -f '%s' '%s'" % (self.origFile, self.tmpFile)):
   FF7iMz(self.VVVJTB, self.VV5NL4, title="Loading file ...")
  else:
   FFbBGq(self.VVVJTB, "Error while preparing edit!")
 def VV5NL4(self):
  VVuGUx = self.VVsGAo()
  VVwqVu = ("Save Changes" , self.VVw9hi   , [])
  VVj7lw  = ("Edit Line"  , self.VVZ0pf    , [])
  VVmolf = (""    , self.VVwM9h   , [])
  VV46TD = ("Options"  , self.VVtmou  , [])
  VViMvb = ("Go to Line No." , self.VVVjx1   , [])
  VVDPcX = (""    , self.VVYhgb , [])
  VVpW7I = self.VVugKj
  VVMCLR  = self.VVK7Qt
  header   = ("Line No." , " Text" )
  widths   = (8   , 92  )
  VV4Uoc  = (CENTER  , LEFT  )
  bg    = "#0a001111"
  self.editorTable = FFCXsL(self.VVVJTB, None, title=self.Title, header=header, VVXpNQ=VVuGUx, VV4Uoc=VV4Uoc, VV8boH=widths, width=1600, height=1000, VVPYL1=26, VVLdgm=True, VVwqVu=VVwqVu, VVj7lw=VVj7lw, VVmolf=VVmolf, VV46TD=VV46TD, VViMvb=VViMvb, VVpW7I=VVpW7I, VVMCLR=VVMCLR, VVDPcX=VVDPcX, VVoNmU=True, VVMBr1=1, VVAGe1=CFG.lastFindEditor
        , VVfWsQ=bg, VVB5I5=bg, VVYCun=bg, VVmErq="#06334444", VVK8UQ="#00222222", VVgSJJ="#06333322")
 def VVK7Qt(self, VVAIxO):
  VVAIxO.VVQBxV()
 def VVwM9h(self, VVAIxO, title, txt, colList):
  txt = "File\t: %s\n%s" % (self.origFile, txt)
  FFSMJz(self.VVVJTB, txt, title=title)
 def VVtmou(self, VVAIxO, title, txt, colList):
  c1, c2, c3 = VVWH8U, VVk4x7, VVdLWL
  isMulti = VVAIxO.VVGZGK
  tot  = VVAIxO.VVAGI8()
  lineNum = int(colList[0])
  totRows = VVAIxO.VVCQXG()
  isPaste = not isMulti and VVi2UY and len(VVi2UY) > 0
  isSel = not isMulti or tot > 0
  selTxt =  ("Selected " if isMulti else "", FFaRsj(tot))
  VV9cxb = []
  VV9cxb.append(FFH04v("Insert Empty Line (before line-%d)" % lineNum, "ins1" , not isMulti      , c1))
  VV9cxb.append(FFH04v("Insert Empty Line (after line-%d)"  % lineNum, "ins2" , not isMulti and lineNum == totRows, c1))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(FFH04v("Copy %sLine%s to Clipboard" % selTxt , "VVPqqS" , isSel  , c2))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(FFH04v("Insert lines from clipboard"   , "paste2"   , isPaste , c2))
  VV9cxb.append(FFH04v("Paste from clipboard (overwrite line)", "paste1"   , isPaste , c2))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(FFH04v("Delete %sLine%s" % selTxt, "del", isSel, c3))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(FFH04v("Find & Replace" , "repl", not isMulti ))
  cbFncDict = { "ins1"   : BF(self.VVuiXs, "sed -i '%d i %s' '%s'" % (lineNum, "", self.tmpFile))
     , "ins2"   : BF(self.VVGsgE, lineNum)
     , "VVPqqS" : self.VVPqqS
     , "paste1"   : BF(FF7iMz, self.editorTable, BF(self.VVPaGP, lineNum, "\n".join(VVi2UY), 1))
     , "paste2"   : BF(FF7iMz, self.editorTable, BF(self.VVPaGP, lineNum, "\n".join(VVi2UY), 2))
     , "del"    : BF(FF7iMz, self.editorTable, self.VVb3Hj)
     , "repl"   : BF(self.VVmkBU, title) }
  mSel = CC17aQ(self.VVVJTB, VVAIxO, setsOk=True)
  mSel.VV4sFy(VV9cxb, cbFncDict, width=750, height=1000)
 def VVmkBU(self, title):
  fnd = CFG.lastFindRepl_fnd.getValue()
  rpl = CFG.lastFindRepl_rpl.getValue()
  lst = [(" Find", fnd, str(len(fnd))), (" Replace with", rpl, str(len(rpl)))]
  bg = "#11101010"
  VVj7lw  = ("Change" , BF(self.VVzofZ, title, lst) , [])
  VVwqVu = ("Start" , BF(self.VVlZt3, title)  , [])
  header  = (" Subject", " Text" , "Len.")
  widths  = (20   , 70  , 10 )
  VV4Uoc = (LEFT   , LEFT  , CENTER)
  FFCXsL(self.VVVJTB, None, title=title, VVXpNQ=lst, header=header, VV4Uoc=VV4Uoc, VV8boH=widths, width=1200, VVPYL1=30, VVLdgm=True, VVj7lw=VVj7lw, VVwqVu=VVwqVu, VVRtfk=2
    , VVfWsQ=bg, VVB5I5=bg, VVYCun=bg, VVmErq="#06224455", VVK8UQ="#0a303030")
 def VVzofZ(self, Title, lst, VVAIxO, title, txt, colList):
  title = VVAIxO.VVYmuZ(0)
  ndx = VVAIxO.VVoxea()
  txt = CFG.lastFindRepl_fnd.getValue() if ndx == 0 else CFG.lastFindRepl_rpl.getValue()
  FFANcN(self.VVVJTB, BF(self.VV5AVI, VVAIxO, ndx), title=title, defaultText=txt, message="New entry")
 def VV5AVI(self, VVAIxO, ndx, newTxt=None):
  if newTxt:
   if ndx == 0 : FFBWtx(CFG.lastFindRepl_fnd, newTxt)
   else  : FFBWtx(CFG.lastFindRepl_rpl, newTxt)
   VVAIxO.VVGSSq({1:newTxt, 2:len(newTxt)})
 def VVlZt3(self, Title, VVAIxO, title, txt, colList):
  fnd = CFG.lastFindRepl_fnd.getValue()
  rpl = CFG.lastFindRepl_rpl.getValue()
  if len(fnd) > 0:
   txt = FFmx8y(self.tmpFile)
   tot = txt.count(fnd)
   if tot > 0:
    FF6pUe(self.VVVJTB, BF(FF7iMz, VVAIxO, BF(self.VVpthq, VVAIxO, fnd, rpl), title="Replacing ..."), "Replace %d occurrences ?" % tot, title=Title)
   else:
    FFoTZI(VVAIxO, "Not found in file !", 1000)
    VVAIxO.VVt5t9(0)
  else:
   FFoTZI(VVAIxO, "Nothing to find", 1000)
 def VVpthq(self, VVAIxO, fnd, rpl):
  txt = FFmx8y(self.tmpFile)
  txt = txt.replace(fnd, rpl)
  with open(self.tmpFile, "w") as f:
   f.write(txt)
  VVAIxO.cancel()
  self.fileChanged = True
  self.editorTable.VVdqRF()
  VVuGUx = self.VVsGAo()
  self.editorTable.VVEEBV(VVuGUx)
 def VVVjx1(self, VVAIxO, title, txt, colList):
  totRows = self.editorTable.VVM62I()
  lineNum = self.editorTable.VVoxea() + 1 if self.lastLineNum == -1 else self.lastLineNum
  FFANcN(self.VVVJTB, BF(self.VVKXxh, lineNum, totRows), title="Go to Line Num (1 - %d)" % totRows, defaultText="%d" % lineNum, message="Enter Line Number")
 def VVKXxh(self, lineNum, totRows, VVV9Cp):
  if VVV9Cp:
   VVV9Cp = VVV9Cp.strip()
   if VVV9Cp.isdigit():
    num = FFbn8W(int(VVV9Cp) - 1, 0, totRows - 1)
    self.editorTable.VVt5t9(num)
    self.lastLineNum = num + 1
   else:
    FFoTZI(self.editorTable, "Incorrect number", 1500)
 def VVYhgb(self, VVAIxO, title, txt, colList):
  if   self.starterRow > -1: VVAIxO.VVt5t9(self.starterRow)
  elif self.insertMode == 1: VVAIxO.VVlohq()
  elif self.insertMode == 2: VVAIxO.VVbtl9()
  self.insertMode = 0
  self.starterRow = -1
 def VVGsgE(self, lineNum):
  if lineNum == self.editorTable.VVCQXG():
   self.insertMode = 1
   self.VVuiXs("echo '' >> '%s'" % self.tmpFile)
  else:
   self.insertMode = 2
   self.VVuiXs("sed -i '%d i %s' '%s'" % (lineNum + 1, "", self.tmpFile))
 def VVPqqS(self):
  global VVi2UY
  isMulti = self.editorTable.VVGZGK
  if isMulti : VVi2UY = self.editorTable.VVKa9C(1, isStrip=False)
  else  : VVi2UY = [self.editorTable.VVYmuZ(1, isStrip=False)]
  FFxHED(self.editorTable, "Copied to clipboard", 800)
 def VVw9hi(self, VVAIxO, title, txt, colList):
  if self.fileChanged:
   if FFwvAe(self.origFile):
    if FFlonU("cp -f '%s' '%s'" % (self.tmpFile, self.origFile)):
     FFxHED(VVAIxO, "Saved", 800)
     self.fileSaved   = True
     self.fileChanged = False
     VVAIxO.VVQBxV()
    else:
     FFbBGq(self.VVVJTB, "Cannot save file!")
   else:
    FFbBGq(self.VVVJTB, "Cannot create backup copy of original file!")
 def VVugKj(self, VVAIxO):
  if self.fileChanged:
   FF6pUe(self.VVVJTB, BF(self.VVaIi2, VVAIxO), "Cancel changes ?")
  else:
   FFlonU("cp -f '%s' '%s'" % (self.tmpFile, self.origFile))
   self.VVaIi2(VVAIxO)
 def VVaIi2(self, VVAIxO):
  VVAIxO.cancel()
  FFnE7j(self.tmpFile)
  if self.VVhK3C:
   self.VVhK3C(self.fileSaved)
 def VVZ0pf(self, VVAIxO, title, txt, colList):
  lineNum = int(VVAIxO.VVYmuZ(0))
  lineTxt = VVAIxO.VVYmuZ(1, isStrip=False)
  message = VVCQUS + "ORIGINAL TEXT:\n" + VV0p9P + lineTxt
  FFANcN(self.VVVJTB, BF(self.VVegDH, lineNum), title="File Line", defaultText=lineTxt, message=message)
 def VVegDH(self, lineNum, VVV9Cp):
  if not VVV9Cp is None:
   if self.editorTable.VVCQXG() <= 1:
    self.VVuiXs("echo %s > '%s'" % (VVV9Cp, self.tmpFile))
   else:
    self.VVPaGP(lineNum, VVV9Cp, 1)
 def VVPaGP(self, lineNum, newTxt, mode):
  self.editorTable.VVOoFN("Saving ...")
  lines = FF2kXa(self.tmpFile)
  with open(self.tmpFile, "w") as f:
   for ndx, line in enumerate(lines, start=1):
    if lineNum == ndx:
     if   mode == 1: line = newTxt
     elif mode == 2: f.write(newTxt + "\n")
    f.write(line + "\n")
  self.fileChanged = True
  self.editorTable.VVdqRF()
  VVuGUx = self.VVsGAo()
  self.editorTable.VVEEBV(VVuGUx)
 def VVb3Hj(self):
  isMulti = self.editorTable.VVGZGK
  if isMulti : lst = self.editorTable.VVKa9C(0)
  else  : lst = [self.editorTable.VVYmuZ(0)]
  self.editorTable.VVurYr()
  lines = FF2kXa(self.tmpFile)
  with open(self.tmpFile, "w") as f:
   for ndx, line in enumerate(lines, start=1):
    if not str(ndx) in lst:
     f.write(line + "\n")
  self.fileChanged = True
  self.editorTable.VVdqRF()
  VVuGUx = self.VVsGAo()
  self.editorTable.VVEEBV(VVuGUx)
 def VVuiXs(self, cmd):
  FFe43w(cmd, self.VV11fz)
  self.fileChanged = True
  self.editorTable.VVdqRF()
 def VV11fz(self, result, retval):
  VVuGUx = self.VVsGAo()
  self.editorTable.VVEEBV(VVuGUx)
 def VVsGAo(self):
  if FFKbVo(self.tmpFile):
   lines = FF2kXa(self.tmpFile)
   VVuGUx = []
   if lines:
    for ndx, line in enumerate(lines, start=1):
     VVuGUx.append((str(ndx), line))
   if not VVuGUx:
    VVuGUx.append((str(1), ""))
   return VVuGUx
  else:
   FFWfGZ(self.VVVJTB, self.tmpFile)
class CCuHRT():
 def __init__(self, callingSELF, VVfWsQ="#22003344", VVB5I5="#22002233"):
  self.callingSELF = callingSELF
  self.VV9cxb  = []
  self.satList  = []
  self.VVfWsQ  = VVfWsQ
  self.VVB5I5   = VVB5I5
 def VVaNK8(self, VVhK3C):
  self.VV9cxb = []
  VV9cxb, VVqIQu = CCuHRT.VVi0d4(self.callingSELF, False, True)
  if VV9cxb:
   self.VV9cxb += VV9cxb
   self.VVFxGL(VVhK3C, VVqIQu)
 def VVtKPR(self, mode, VVAIxO, satCol, VVhK3C, inFilterFnc=None):
  VVAIxO.VVOoFN("Loading Filters ...")
  self.VV9cxb = []
  self.VV9cxb.append(("All Services" , "all"))
  if mode == 1:
   self.VV9cxb.append(VVbM5H)
   self.VV9cxb.append(("Parental Control", "parentalControl" ))
   self.VV9cxb.append(("Hidden Services" , "hiddenServices" ))
   if CC2Ekb.VVEUkc():
    self.VV9cxb.append(("Stream Relay Services", "streamRelay"))
  elif mode == 2:
   self.VV9cxb.append(VVbM5H)
   self.VV9cxb.append(("Selected Transponder"  , "selectedTP" ))
   self.VV9cxb.append(("Channels with no Transponder", "emptyTP"  ))
  self.VVzXHa(VVAIxO, satCol)
  VV9cxb, VVqIQu = CCuHRT.VVi0d4(self.callingSELF, True, False)
  if VV9cxb:
   VV9cxb.insert(0, FFT7cF("Custom Words"))
   self.VV9cxb += VV9cxb
  VVAIxO.VVEL2E()
  self.VVFxGL(VVhK3C, VVqIQu, inFilterFnc)
 def VVMz7Q(self, VV9cxb, sats, VVhK3C, inFilterFnc=None):
  self.VV9cxb = VV9cxb
  VV9cxb, VVqIQu = CCuHRT.VVi0d4(self.callingSELF, True, False)
  if VV9cxb:
   self.VV9cxb.append(FFT7cF("Custom Words"))
   self.VV9cxb += VV9cxb
  self.VVFxGL(VVhK3C, VVqIQu, inFilterFnc)
 def VVFxGL(self, VVhK3C, VVqIQu, inFilterFnc=None):
  VVWt1H  = ("Filter in Filter", inFilterFnc) if inFilterFnc else None
  VVqj6y = ("Edit Filter"  , BF(self.VV0SZN, VVqIQu))
  VVGbyT  = ("Filter Help"  , BF(self.VVPoxc, VVqIQu))
  FFO9kU(self.callingSELF, BF(self.VV4P4M, VVhK3C), VV9cxb=self.VV9cxb, title="Select Filter", VVWt1H=VVWt1H, VVqj6y=VVqj6y, VVGbyT=VVGbyT, VVbdOY=True, VVfWsQ=self.VVfWsQ, VVB5I5=self.VVB5I5)
 def VV4P4M(self, VVhK3C, item):
  if item:
   VVhK3C(item)
 def VV0SZN(self, VVqIQu, selectionObj, sel):
  if FFKbVo(VVqIQu) : CCNb3y(self.callingSELF, VVqIQu, VVhK3C=None)
  else       : FFWfGZ(self.callingSELF, VVqIQu)
  selectionObj.cancel()
 def VVPoxc(self, VVqIQu, selectionObj, sel):
  FFY7F5(self.callingSELF, "_help_service_filter", "Service Filter")
 def VVzXHa(self, VVAIxO, satColNum):
  if not self.satList:
   satList = VVAIxO.VVEIUC(satColNum)
   if satList:
    satList = set(satList)
    satList = list(satList)
    if satList:
     sats = []
     for ndx, sat in enumerate(satList):
      if not sat.strip() == "":
       self.satList.append((FFfCll(sat), "__s__" + sat))
     self.satList.sort(key=lambda x: x[0])
     self.satList.insert(0, FFT7cF("Satellites"))
  if self.VV9cxb:
   self.VV9cxb += self.satList
 @staticmethod
 def VVi0d4(SELF, addTag, VVAdNn):
  FFrxHY()
  fileName  = "ajpanel_services_filter"
  VVqIQu = FFJv8S() + fileName
  VV9cxb  = []
  if not FFKbVo(VVqIQu):
   FFlonU("cp -f '%s' '%s'" % (VVK8DT + fileName, VVqIQu))
  fileFound = False
  if FFKbVo(VVqIQu):
   fileFound = True
   lines = FF2kXa(VVqIQu)
   if lines:
    for line in lines:
     line = line.strip()
     if line and not line.startswith("#"):
      if "#" in line:
       line = line.split("#")[0].strip()
      if "," in line:
       lst = list(map(str.strip, line.split(",")))
       lst = list(filter(None, lst))
       if lst: line = ",".join(lst)
       else  : line = ""
      if line:
       if addTag: VV9cxb.append((line, "__w__" + line))
       else  : VV9cxb.append((line, line))
  if VVAdNn:
   if   not fileFound : FFWfGZ(SELF, VVqIQu)
   elif not VV9cxb : FFJkFk(SELF, VVqIQu)
  return VV9cxb, VVqIQu
 @staticmethod
 def VVzdEZ(txt):
  txt = txt.strip()
  lst = []
  prefix = False
  if "," in txt:
   lst = list(map(str.strip, txt.split(",")))
   lst = list(filter(None, lst))
   if lst and len(lst) > 1 and lst[0] == "^":
    lst = lst[1:]
    prefix = True
  else:
   txt = txt.strip()
   if txt:
    if len(txt) > 1 and txt.startswith("^"):
     txt = txt[1:]
     prefix = True
    lst = [txt]
  return tuple(map(str.lower, lst)), prefix
class CC17aQ():
 def __init__(self, callingSELF, VVAIxO, addSep=True, setsOk=False, setsRed=False, setsGreen=False, setsYellow=False, setsBlue=False):
  self.callingSELF = callingSELF
  self.VVAIxO = VVAIxO
  self.VVAIxO.VVHlEM  = setsOk
  self.VVAIxO.VV2wRZ  = setsRed
  self.VVAIxO.VV7VOF = setsGreen
  self.VVAIxO.VV8LLf = setsYellow
  self.VVAIxO.VV8qXd = setsBlue
  self.VV9cxb = []
  iMulSel = self.VVAIxO.VVMEs4()
  if iMulSel : self.VV9cxb.append( ("Disable Multi-Select " , "MultSelDisab" ))
  else  : self.VV9cxb.append( ("Enable Multi-Select"  , "multSelEnab"  ))
  tot = self.VVAIxO.VVAGI8()
  self.VV9cxb.append(    ("Select all"    , "selectAll"  ))
  if iMulSel and tot > 0:
   self.VV9cxb.append(   ("Unselect all"    , "unselectAll"  ))
  if addSep:
   self.VV9cxb.append(VVbM5H)
 def VV4sFy(self, extraMenu, cbFncDict, width=1000, height=850, VVfWsQ="#22003344", VVB5I5="#22002233", VVwv0z=0.15):
  if extraMenu:
   self.VV9cxb.extend(extraMenu)
  FFO9kU(self.callingSELF, BF(self.VV4Gkq, cbFncDict), width=width, height=height, VVwv0z=VVwv0z, title="Options", VV9cxb=self.VV9cxb, VVfWsQ=VVfWsQ, VVB5I5=VVB5I5)
 def VV4Gkq(self, cbFncDict, item=None):
  if item:
   if   item == "multSelEnab" : self.VVAIxO.VVC3dh()
   elif item == "MultSelDisab" : self.VVAIxO.VVurYr()
   elif item == "selectAll" : self.VVAIxO.VVYHQP()
   elif item == "unselectAll" : self.VVAIxO.VVXK4X()
   elif cbFncDict:
    fnc = cbFncDict.get(item)
    if fnc:
     fnc()
class CC06Cg(Screen):
 def __init__(self, session, args=0):
  self.skin, self.VVmNvK = FFQaOH(VVIZbT, 900, 480, 50, 0, 0, "#22660066", "#22330033", 35, VVSwLg=40)
  self.session = session
  FFNhKZ(self, title="Date/Time -> Manual Mode")
  FFi79B(self["keyRed"]  , "Exit")
  FFi79B(self["keyGreen"]  , "Save")
  FFi79B(self["keyYellow"] , "Refresh")
  FFi79B(self["keyBlue"]  , "NTP Mode")
  self["curTime"]  = Label()
  self["yearTitle"] = Label("Year")
  self["monthTitle"] = Label("Month")
  self["dayTitle"] = Label("Day")
  self["gapTitle"] = Label()
  self["hourTitle"] = Label("Hour")
  self["minTitle"] = Label("Min")
  self["secTitle"] = Label("Sec")
  self["year"]  = Label()
  self["month"]  = Label()
  self["day"]   = Label()
  self["gap"]   = Label()
  self["hour"]  = Label()
  self["min"]   = Label()
  self["sec"]   = Label()
  self.index   = 0
  self.list   = [self["year"], self["month"], self["day"], self["hour"], self["min"], self["sec"]]
  self.timer   = eTimer()
  self["gapTitle"].hide()
  self["gap"].hide()
  FFrM8n(self,
  {
   "red" : self.VVpHqp  ,
   "green" : self.VV5ehm ,
   "yellow": self.VVgkDZ  ,
   "blue" : self.VVZX0Y   ,
   "up" : self.VVCdU6    ,
   "down" : self.VV41MG   ,
   "left" : self.VVDDr1   ,
   "right" : self.VVksC6   ,
   "cancel": self.VVpHqp
  })
  self.onShown.append(self.VVf1Ra)
  self.onClose.append(self.onExit)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  self.VVgkDZ()
  self.VVbkxF()
  FFuwGk(self)
  try: self.timer_conn = self.timer.timeout.connect(self.VVmk7e)
  except: self.timer.callback.append(self.VVmk7e)
  self.timer.start(1000, False)
  self.VVmk7e()
 def onExit(self):
  self.timer.stop()
 def VVpHqp(self) : self.close(True)
 def VV3DOx(self) : self.close(False)
 def VVZX0Y(self):
  self.session.openWithCallback(self.VV3HUN, BF(CCitrl))
 def VV3HUN(self, VVaQiZ):
  if VVaQiZ:
   self.close()
 def VVmk7e(self):
  self["curTime"].setText(str(FFG6of(iTime())))
 def VVCdU6(self):
  self.VVWedW(1)
 def VV41MG(self):
  self.VVWedW(-1)
 def VVDDr1(self):
  self.index -= 1
  if self.index < 0:
   self.index = 5
  self.VVbkxF()
 def VVksC6(self):
  self.index += 1
  if self.index > 5:
   self.index = 0
  self.VVbkxF()
 def VVWedW(self, increment):
  year = int(self["year" ].getText())
  month = int(self["month"].getText())
  if   self.index == 0: minVal, maxVal = 2000, 3000
  elif self.index == 1: minVal, maxVal = 1, 12
  elif self.index == 2: minVal, maxVal = 1, self.VVrED7(month, year)
  elif self.index == 3: minVal, maxVal = 0, 23
  elif self.index == 4: minVal, maxVal = 0, 59
  elif self.index == 5: minVal, maxVal = 0, 59
  val  = int(self.list[self.index].getText()) + increment
  if val < minVal: val = maxVal
  if val > maxVal: val = minVal
  if self.index == 0:
   val = "%04d" % val
  else:
   val = "%02d" % val
  self.list[self.index].setText(val)
  if self.index < 2:
   year = int(self["year" ].getText())
   month = int(self["month"].getText())
   day = int(self["day"].getText())
   monthDays = self.VVrED7(month, year)
   if day > monthDays:
    self["day"].setText("%02d" % monthDays)
 def VVrED7(self, month, year):
  MonthList = [31,28,31,30,31,30,31,31,30,31,30,31]
  days = MonthList[month-1]
  if (month == 2) and (self.VVRbUQ(year)):
   days += 1
  return days
 def VVRbUQ(self, year):
  if year % 4 == 0:
   if year % 100 == 0:
    if year % 400 == 0:
     return True
    else:
     return False
   else:
    return True
  else:
   return False
 def VVbkxF(self):
  for obj in self.list:
   FFgLA9(obj, "#11404040")
  FFgLA9(self.list[self.index], "#11ff8000")
 def VVgkDZ(self):
  year, month, day, hour, minute, second, weekDay, yearDay, dayLight = localtime()
  self["year" ].setText("%04d" % year)
  self["month"].setText("%02d" % month)
  self["day"  ].setText("%02d" % day)
  self["hour" ].setText("%02d" % hour)
  self["min"  ].setText("%02d" % minute)
  self["sec"  ].setText("%02d" % second)
 def VV5ehm(self):
  year = int(self["year" ].getText())
  month = self["month"].getText()
  day  = self["day"  ].getText()
  hour = self["hour" ].getText()
  minute = self["min"  ].getText()
  second = self["sec"  ].getText()
  cmd = "date -s '%s-%s-%s %s:%s:%s'" % (year, month, day, hour, minute, second)
  FFe43w("echo -e 'System Response:\n'; %s" % cmd, self.VVR9hl)
 def VVR9hl(self, result, retval):
  result = str(result.strip())
  if len(result) == 0 : FF0onH(self, "Nothing returned from the system!")
  else    : FF0onH(self, str(result))
class CCitrl(Screen):
 def __init__(self, session, args=0):
  self.skin, self.VVmNvK = FFQaOH(VV2rBO, 900, 480, 50, 40, 10, "#22660066", "#22330033", 35, VVSwLg=40)
  self.session = session
  FFNhKZ(self, title="Date/Time -> NTP Mode", addLabel=True)
  FFi79B(self["keyRed"]  , "Exit")
  FFi79B(self["keyGreen"]  , "Sync")
  FFi79B(self["keyYellow"] , "Refresh")
  FFi79B(self["keyBlue"]  , "Manual Mode")
  FFrM8n(self,
  {
   "red" : self.VVpHqp   ,
   "green" : self.VVsj03  ,
   "yellow": self.VVgzZO ,
   "blue" : self.VVV09N  ,
   "cancel": self.VVpHqp
  })
  self.VVWBXT()
  self.onShown.append(self.VVf1Ra)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  FFuwGk(self)
  FFvfpL(self.VV2pMI)
 def VV2pMI(self):
  self.VVTAms()
  self.VVGsHv(False)
 def VVpHqp(self)  : self.close(True)
 def VVV09N(self) : self.close(False)
 def VVWBXT(self):
  self["myLabel"].setText("Getting NTP time ... ")
 def VVTAms(self):
  self.VVL9Cv()
  self.VVVBGb()
  self.VVweC9()
  self.VVTtHd()
 def VVgzZO(self):
  if len(self["keyYellow"].getText()) > 0:
   self.VVWBXT()
   self.VVTAms()
   FFvfpL(self.VV2pMI)
 def VVsj03(self):
  if len(self["keyGreen"].getText()) > 0:
   FF6pUe(self, self.VVDx2w, "Synchronize with Internet Date/Time ?")
 def VVDx2w(self):
  self.VVTAms()
  FFvfpL(BF(self.VVGsHv, True))
 def VVL9Cv(self)  : self["keyRed"].show()
 def VVnzb9(self)  : self["keyGreen"].show()
 def VVdFa5(self) : self["keyYellow"].show()
 def VVlyEp(self)  : self["keyBlue"].show()
 def VVVBGb(self)  : self["keyGreen"].hide()
 def VVweC9(self) : self["keyYellow"].hide()
 def VVTtHd(self)  : self["keyBlue"].hide()
 def VVGsHv(self, sync):
  localTime = FFENz0()
  ok = False
  server_list = ['ntp.iitb.ac.in', 'time.nist.gov', 'time.windows.com', 'pool.ntp.org']
  for server in server_list:
   epoch_time = self.VVjv8i(server)
   if epoch_time is not None:
    ntpTime = FFG6of(epoch_time)
    time1 = mktime(datetime.strptime(localTime, "%Y-%m-%d %H:%M:%S").timetuple())
    time2 = mktime(datetime.strptime(ntpTime  , "%Y-%m-%d %H:%M:%S").timetuple())
    diff = time1 - time2
    if   diff == 0 : timeDiff = "None"
    elif diff == 1 : timeDiff = "%d second"  % diff
    else   : timeDiff = "%d seconds" % diff
    timeDiff = "Difference\t=  %s" % timeDiff
    if sync:
     FFe43w("echo -e '\nSystem Response:\n'; date -s '%s'" % ntpTime, BF(self.VVR9hl, True))
    else:
     txt = "Local Time\t= %s\nInternet Time\t= %s\n%s\n" % (localTime, ntpTime, timeDiff)
     self["myLabel"].setText(txt)
    ok = True
    break
   else:
    pass
  self.VVdFa5()
  self.VVlyEp()
  if ok:
   self.VVnzb9()
  else:
   self["myLabel"].setText("Local Time\t= %s\n\nCould not get NTP time !\n" % localTime)
 def VVR9hl(self, syncAgain, result, retval):
  result = str(result.strip())
  if   len(result) == 0  : result = "\n\nNothing returned from the system!"
  elif result.count("\n") < 20: result = "\n\n" + result
  try:
   self["myLabel"].setText(result)
   if syncAgain:
    self.VVGsHv(False)
  except:
   pass
 def VVjv8i(self, addr='time.nist.gov'):
  from socket import socket, AF_INET, SOCK_DGRAM
  from struct import unpack as iUnpack
  time1970 = 2208988800
  data  = '\x1b' + 47 * '\0'
  data  = data.encode()
  if CC9qM0.VVQ0uB():
   try:
    client = socket(AF_INET, SOCK_DGRAM)
    client.settimeout(1.0)
    client.sendto(data, (addr, 123))
    data, address = client.recvfrom(1024)
    if data:
     epoch_time = iUnpack('!12I', data)[10]
     epoch_time -= time1970
     return epoch_time
   except:
    pass
  return None
class CCNLYy(Screen):
 def __init__(self, session, args=0):
  self.skin, self.VVmNvK = FFQaOH(VV23Kz, 900, 300, 50, 20, 0, "#22000060", "#22000020", 35)
  self.session  = session
  FFNhKZ(self, addLabel=True, addCloser=True)
  self["myTitle"].setText("  Internet Connectivity")
  self["myLabel"].setText("Checking Connection ...")
  self.onShown.append(self.VVf1Ra)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  FFvfpL(self.VVdUZl)
 def VVdUZl(self):
  if CC9qM0.VVQ0uB() : color, txt = "#22002020", "Internet Connection = Successful."
  else     : color, txt = "#22500000", "Cannot connect (or server is down) !"
  try:
   self["myLabel"].setText("  " + txt)
   FFgLA9(self["myBody"], color)
   FFgLA9(self["myLabel"], color)
  except:
   pass
class CCHhER(Screen):
 VVjI5D = None
 def __init__(self, session):
  size = CFG.signalSize.getValue()
  screenW = FFcBkL()[0]
  ratio = size / 5.0
  self.skin, self.VVmNvK = FFQaOH(VVGkIr, 650, 320, 26, 20, 20, "#22003040", "#22001122", 25, VVDPpb=ratio)
  self.session   = session
  self["mySNRdB"]   = Label()
  self["mySNR"]   = Label()
  self["myAGC"]   = Label()
  self["myBER"]   = Label()
  self["mySliderSNR"]  = Pixmap()
  self["mySliderAGC"]  = Pixmap()
  self["mySliderBER"]  = Pixmap()
  self["mySliderCovSNR"] = Label()
  self["mySliderCovAGC"] = Label()
  self["mySliderCovBER"] = Label()
  color     = self.VVmNvK["VViaEk"]
  self.sliderSNR   = CCuNHD(self, self["mySliderSNR"], self["mySliderCovSNR"], minN=0, maxN=100, covColor=color)
  self.sliderAGC   = CCuNHD(self, self["mySliderAGC"], self["mySliderCovAGC"], minN=0, maxN=100, covColor=color)
  self.sliderBER   = CCuNHD(self, self["mySliderBER"], self["mySliderCovBER"], minN=0, maxN=100, covColor=color)
  self["myTPInfo"]  = Label()
  self.timer    = eTimer()
  self.tunerInfo   = CCKQEu()
  self.stateCounter  = 0
  self.top    = 0
  self.left    = 0
  self.curPosNum   = CFG.signalPos.getValue()
  self.curSize   = CFG.signalSize.getValue()
  self.tpData    = CCrDr0()
  FFNhKZ(self, title="Signal")
  FFrM8n(self,
  {
   "ok"  : self.close      ,
   "up"  : self.VVCdU6       ,
   "down"  : self.VV41MG      ,
   "left"  : self.VVDDr1      ,
   "right"  : self.VVksC6      ,
   "info"  : self.VVVDQu     ,
   "epg"  : self.VVVDQu     ,
   "menu"  : self.VVu6uM      ,
   "cancel" : self.close      ,
   "red"  : self.close      ,
   "last"  : BF(self.VVV6XS, -1)  ,
   "next"  : BF(self.VVV6XS, 1)  ,
   "pageUp" : BF(self.VVwtHi, True) ,
   "chanUp" : BF(self.VVwtHi, True) ,
   "pageDown" : BF(self.VVwtHi, False) ,
   "chanDown" : BF(self.VVwtHi, False) ,
   "0"   : BF(self.VVV6XS, 0)  ,
   "1"   : BF(self.VVkVAQ, pos=1) ,
   "2"   : BF(self.VVkVAQ, pos=2) ,
   "3"   : BF(self.VVkVAQ, pos=3) ,
   "4"   : BF(self.VVkVAQ, pos=4) ,
   "5"   : BF(self.VVkVAQ, pos=5) ,
   "6"   : BF(self.VVkVAQ, pos=6) ,
   "7"   : BF(self.VVkVAQ, pos=7) ,
   "8"   : BF(self.VVkVAQ, pos=8) ,
   "9"   : BF(self.VVkVAQ, pos=9) ,
  })
  self.onShown.append(self.VVf1Ra)
  self.onClose.append(self.onExit)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  if not CCHhER.VVjI5D:
   CCHhER.VVjI5D = self
  self.sliderSNR.VV8Xds()
  self.sliderAGC.VV8Xds()
  self.sliderBER.VV8Xds(isBER=True)
  pos   = self.instance.position()
  self.left = pos.x()
  self.top = pos.y()
  self.VVkVAQ()
  self.VVd97A()
  try: self.timer_conn = self.timer.timeout.connect(self.VVbJYe)
  except: self.timer.callback.append(self.VVbJYe)
  self.timer.start(500, False)
 def VVd97A(self):
  service = self.session.nav.getCurrentService()
  self.tunerInfo.VVeXSX(service)
  serviceName = self.tunerInfo.VVzqeR()
  if not serviceName   : serviceName = "Signal"
  if len(serviceName) > 25 : serviceName = serviceName[:25] + ".."
  self["myTitle"].setText("  " + serviceName)
  s = CCZv30(self.session)
  self["myTPInfo"].setText(self.tpData.VVFuAx([s.VVq9SN, s.VVHK1O], maxLen=54))
 def VVbJYe(self):
  s = CCZv30(self.session)
  self.tunerInfo.VVeXSX(s.servPtr)
  if self.tunerInfo.infoAvailable:
   self["mySNRdB"].setText(self.tunerInfo.VVs9Su())
   self["mySNR"].setText(self.tunerInfo.VVPwO9())
   self["myAGC"].setText(self.tunerInfo.VVnZjX())
   self["myBER"].setText(self.tunerInfo.VVCMNB())
   self.sliderSNR.VVYLvJ(self.tunerInfo.VV86et())
   self.sliderAGC.VVYLvJ(self.tunerInfo.VVKqPT())
   self.sliderBER.VVYLvJ(self.tunerInfo.VV6ouN())
  else:
   self["mySNRdB"].setText("")
   self["mySNR"].setText("?")
   self["myAGC"].setText("?")
   self["myBER"].setText("?")
   self.sliderSNR.VVYLvJ(0)
   self.sliderAGC.VVYLvJ(0)
   self.sliderBER.VVYLvJ(0)
  if self.stateCounter > -1:
   self.stateCounter += 1
   if self.stateCounter > 8:
    self.stateCounter = -1
   else:
    if s.state.startswith("*"):
     FFoTZI(self, s.state.replace("*", ""), 1500)
     self.stateCounter = -1
 def VVVDQu(self):
  CCpebE.VV1v7b(self, VV6tGM=CCpebE.VVbdzi)
 def VVu6uM(self):
  FFY7F5(self, "_help_signal", "Signal Monitor (Keys)")
 def VVCdU6(self)  : self.VVkVAQ(posMap={7:4, 4:1, 8:5, 5:2, 9:6, 6:3})
 def VV41MG(self) : self.VVkVAQ(posMap={1:4, 4:7, 2:5, 5:8, 3:6, 6:9})
 def VVDDr1(self) : self.VVkVAQ(posMap={3:2, 2:1, 6:5, 5:4, 9:8, 8:7})
 def VVksC6(self) : self.VVkVAQ(posMap={1:2, 2:3, 4:5, 5:6, 7:8, 8:9})
 def VVkVAQ(self, posMap=None, pos=-1):
  if pos > -1 or posMap:
   if pos > -1:
    self.curPosNum = pos
   elif posMap:
    self.curPosNum = posMap.get(self.curPosNum, self.curPosNum)
   FFBWtx(CFG.signalPos, self.curPosNum)
  scrSize = getDesktop(0).size()
  gapH = gapV = 20
  w  = self.instance.size().width()
  h  = self.instance.size().height()
  left = self.left
  top  = self.top
  bot  = scrSize.height() - h - gapV
  rigth = scrSize.width()  - w - gapH
  if   self.curPosNum == 1: left, top = gapH , gapV
  elif self.curPosNum == 2: left, top = left , gapV
  elif self.curPosNum == 3: left, top = rigth , gapV
  elif self.curPosNum == 4: left, top = gapH , top
  elif self.curPosNum == 5: left, top = left , top
  elif self.curPosNum == 6: left, top = rigth , top
  elif self.curPosNum == 7: left, top = gapH , bot
  elif self.curPosNum == 8: left, top = left , bot
  elif self.curPosNum == 9: left, top = rigth , bot
  else     : left, top = left , top
  self.instance.move(ePoint(left, top))
 def VVV6XS(self, sizeNum):
  oldSizeNum = CFG.signalSize.getValue()
  if sizeNum == 0:
   sizeNum = 5
  else:
   sizeNum += oldSizeNum
   sizeNum = FFbn8W(sizeNum, 1, 13)
  if not oldSizeNum == sizeNum:
   FFBWtx(CFG.signalSize, sizeNum)
   self.close(True)
 def onExit(self):
  self.timer.stop()
  CCHhER.VVjI5D = None
 def VVwtHi(self, isUp):
  FFoTZI(self)
  try:
   if isUp : InfoBar.instance.zapDown()
   else : InfoBar.instance.zapUp()
   self.stateCounter = 0
   self.VVd97A()
  except:
   pass
class CCuNHD(object):
 def __init__(self, SELF, barObj, covObj, minN=0, maxN=100, covColor="#00440000"):
  self.SELF   = SELF
  self.barObj   = barObj
  self.covObj   = covObj
  self.minN   = minN
  self.maxN   = maxN
  self.covColor  = covColor
  self.isColormode = False
 def VV8Xds(self, isBER=False):
  self.barWidth = self.barObj.instance.size().width()
  self.VVSwLg = self.barObj.instance.size().height()
  self.barLeft = self.barObj.getPosition()[0]
  self.barTop  = self.barObj.getPosition()[1]
  if isBER:
   FFgLA9(self.covObj, "#0aaa0000")
   self.isColormode = True
  else:
   path = VVK8DT +  "bar_sig.png"
   if FFbRME(self.barObj, path):
    FFgLA9(self.covObj, self.covColor)
   else:
    FFgLA9(self.covObj, "#00006688")
    self.isColormode = True
  self.VVYLvJ(0)
 def VVYLvJ(self, val):
  val  = FFbn8W(val, self.minN, self.maxN)
  width = int(FFel7I(val, 0, 100, 0, self.barWidth))
  height = int(self.VVSwLg)
  if self.isColormode:
   self.covObj.instance.resize(eSize(*(width, height)))
  else:
   width = int(FFbn8W(self.barWidth - width, 0, self.barWidth))
   top  = int(self.barTop)
   left = int(self.barLeft + self.barWidth - width)
   self.covObj.hide()
   self.covObj.instance.resize(eSize(*(width, height)))
   self.covObj.instance.move(ePoint(left, top))
   self.covObj.show()
class CCV3Gw(Screen):
 VVOnwn = 0
 VVQFxC  = 1
 VV3nzx = 2
 VVcSmA = 3
 def __init__(self, session, VVN6I4="Processing ...", endTitle="Finishing ...", VVuSHu=None, VV32kU=VVOnwn, totBars=1, titleBg="#0a042328", bodyBg="#0a042328", barBg="#0a995533"):
  ratio = self.VVEbfB(VV32kU)
  if totBars == 1 : h, margT = 150, 20
  else   : h, margT = 200, 15
  self.skin, self.VVmNvK = FFQaOH(VVTT4Q, 900, h, 30, 20, margT, titleBg, bodyBg, 30, VVDPpb=ratio, VVIZ5t=totBars)
  self.session  = session
  self.VV32kU  = VV32kU
  self.totBars  = totBars
  self.barBg   = barBg
  self.VVN6I4 = VVN6I4
  self.newTitle  = self.VVN6I4
  self.endTitle  = endTitle
  self.VVuSHu  = VVuSHu
  self.isCancelled = False
  self.isError  = False
  self.maxValue  = 0
  self.maxValue2  = 0
  self.barWidth  = 0
  self.VVSwLg  = 0
  self.counter  = 0
  self.counter2  = 0
  self.VVL8uX = None
  self.timer   = eTimer()
  self.myThread  = None
  FFNhKZ(self, title=self.VVN6I4)
  for i in range(1, 3):
   self["myProgFr%s"  % i] = Label()
   self["myProgBG%s"  % i] = Label()
   self["myProgFG%s"  % i] = Label()
   self["myProgVal%s" % i] = Label()
  FFrM8n(self, {"cancel" : self.cancel})
  self.onShown.append(self.VVf1Ra)
  self.onClose.append(self.onExit)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  self.VV3zJ2()
  for i in range(1, 3):
   self["myProgVal%s" % i].setText("0%")
  for i in range(1, 3):
   FFgLA9(self["myProgFG%s" % i], self.barBg)
   size = self["myProgVal%s" % i].instance.size()
   self.barWidth = int(size.width())
   self.VVSwLg = int(size.height())
   self.VVkwl8()
  try: self.timer_conn = self.timer.timeout.connect(self.VVkwl8)
  except: self.timer.callback.append(self.VVkwl8)
  self.timer.start(50, False)
  self.myThread = iThread(name="ajp_progBar", target=BF(self.VVuSHu, self))
  self.myThread.start()
 def VVfT17(self, val):
  self.maxValue = val
 def VVH2AI(self, val):
  self.maxValue2 = val
 def VVEfKX(self, catName):
  self.newTitle = "Found %d    %d/%d %s" % (len(self.VVL8uX), self.counter, self.maxValue, catName)
 def VVVMVI(self, ev, pic):
  self.newTitle = "Downloading ... Events: %s    PIcons: %s" % (ev, pic)
 def VVZo23(self, tot):
  self.newTitle = "Downloaded %d    Processed : %d of %d" % (tot, self.counter, self.maxValue)
 def VVN88H(self, tot, evName):
  self.newTitle = "Translated: %d   ... %d/%d >> %s" % (tot, self.counter, self.maxValue, evName)
 def VVLgGj(self, tot, name):
  self.newTitle = "Added: %d   ... %d/%d >> %s" % (tot, self.counter, self.maxValue, name)
 def VVX5nT(self, txt):
  self.newTitle = str(txt)
 def VVqE9L(self, addVal, showFound=False):
  try:
   self.counter += addVal
   if showFound:
    self.newTitle = "Found : %d    .. Processed : %d of %d" % (len(self.VVL8uX), self.counter, self.maxValue)
  except:
   pass
 def VVCrM6(self, addVal, totFound):
  try:
   self.counter += addVal
   self.newTitle = "Found : %d    .. Processed : %s of %s" % (totFound, self.counter, self.maxValue)
  except:
   pass
 def VVpqYW(self, addVal):
  try:
   self.counter2 += addVal
  except:
   pass
 def VVOwDF(self, val):
  try:
   self.counter = val
  except:
   pass
 def VVuDjj(self, val):
  try:
   self.counter2 = val
  except:
   pass
 def VVY97Z(self):
  self.isError = True
  self.cancel()
 def onExit(self):
  self.timer.stop()
 def cancel(self):
  self.timer.stop()
  self.isCancelled = True
  self.VV9v5t(False)
 def VV9v5t(self, isDone):
  self.close(isDone, self.VVL8uX, self.counter, self.maxValue, self.isError)
 def VVkwl8(self):
  if   self.newTitle  : self["myTitle"].setText("  %s  " % self.newTitle)
  elif self.maxValue > 0 : self["myTitle"].setText("  %s  ( %d of %d ) ..." % (self.VVN6I4, self.counter, self.maxValue))
  if self.maxValue > 0:
   val = FFbn8W(self.counter, 0, self.maxValue)
   width = int(FFel7I(val, 0, self.maxValue, 0, self.barWidth))
   self["myProgVal1"].setText(str(int(val * 100.0 / self.maxValue)) + "%")
  else:
   width = 0
  self["myProgFG1"].instance.resize(eSize(*(width, self.VVSwLg)))
  if self.maxValue2 > 0:
   val = FFbn8W(self.counter2, 0, self.maxValue2)
   width = int(FFel7I(val, 0, self.maxValue2, 0, self.barWidth))
   self["myProgVal2"].setText(str(int(val * 100.0 / self.maxValue2)) + "%")
  else:
   width = 0
  self["myProgFG2"].instance.resize(eSize(*(width, self.VVSwLg)))
  if self.myThread and not self.myThread.is_alive():
   self.timer.stop()
   self["myTitle"].setText("  %s  " % self.endTitle)
   self.VV9v5t(True)
 def VV3zJ2(self):
  if self.totBars == 1:
   self["myProgFr2"].hide()
   self["myProgFG2"].hide()
   self["myProgBG2"].hide()
   self["myProgVal2"].hide()
  scrW = getDesktop(0).size().width()
  winW = self.instance.size().width()
  gap  = 30
  if self.VV32kU in (self.VVOnwn, self.VVQFxC):
   self.instance.move(ePoint(int(scrW - winW - gap), gap))
 def VVEbfB(self, VV32kU):
  if   VV32kU == self.VVOnwn : return 0.7
  if   VV32kU == self.VVQFxC : return 0.5
  if   VV32kU == self.VV3nzx: return 0.5
  else           : return 1
 @staticmethod
 def VVgWD3(SELF, **kwargs):
  VVhK3C = kwargs.pop("VVhK3C", None)
  SELF.session.openWithCallback(VVhK3C, CCV3Gw, **kwargs)
class CCDRFn(object):
 def __init__(self):
  self.VV8Lg3 = {}
  self.VVUr6B  = {}
  self.VVpl47 = {}
  self.VVhK3C = {}
  self.VVsOl0 = False
  self.VV8uHX  = FFdufB()
 def VV70Ea(self, cmd, VVhK3C, VVpl47=None, VVpGvX=None):
  self.VVsOl0 = True
  name = cmd
  i  = 0
  while name in self.VV8Lg3:
   name = cmd + '_' + str(i)
   i += 1
  self.VVUr6B[name] = ""
  self.VVpl47[name] = VVpl47
  self.VVhK3C[name] = VVhK3C
  try:
   from enigma import eConsoleAppContainer
   self.VV8Lg3[name] = eConsoleAppContainer()
   if self.VV8uHX:
    self.VV8Lg3[name].dataAvail_conn = self.VV8Lg3[name].dataAvail.connect(BF(self.VV8nWf, name))
    self.VV8Lg3[name].appClosed_conn = self.VV8Lg3[name].appClosed.connect(BF(self.VVCxlw , name))
   else:
    self.VV8Lg3[name].dataAvail.append(BF(self.VV8nWf, name))
    self.VV8Lg3[name].appClosed.append(BF(self.VVCxlw , name))
  except:
   self.VVsOl0 = False
   return False
  if isinstance(cmd, str):
   cmd = [cmd]
  if VVpGvX:
   try:
    self.VV8Lg3[name].setCWD(VVpGvX)
   except:
    pass
  retval = self.VV8Lg3[name].execute(*cmd)
  if retval:
   self.VVCxlw(name, retval)
  return True
 def VV8nWf(self, name, data):
  try:
   data = data.decode("UTF-8")
  except:
   data = "%s%s\n" % ("" if self.VVUr6B[name].endswith("\n") else "\n", FFKrMM("[UN-DECODED STRING]", VVU4M8))
  self.VVUr6B[name] += data
  if self.VVpl47[name]:
   self.VVpl47[name](data)
 def VVCxlw(self, name, retval):
  if not self.VV8uHX:
   del self.VV8Lg3[name].dataAvail[:]
   del self.VV8Lg3[name].appClosed[:]
  del self.VV8Lg3[name]
  del self.VVpl47[name]
  self.VVsOl0 = False
  if self.VVhK3C[name]:
   self.VVhK3C[name](self.VVUr6B[name], retval)
  del self.VVhK3C[name]
 def VVMBRF(self):
  return self.VVsOl0
 def kill(self, name):
  if name in self.VV8Lg3:
   self.VV8Lg3[name].kill()
 def killAll(self):
  for name in self.VV8Lg3:
   self.kill(name)
  self.VVsOl0 = False
class CCYInC(Screen):
 def __init__(self, session, title="", VVtT2v=None, VVWRZK=False, VVGSDE=False, VVoPrg=False, VVHJZR=False, VVpqw1=False, VV2BYW=False, VV5wgt=VVfI5z, VVu7vM=None, VVELy4=None, VVAH4n=False, VVPYL1=30, consFont=True, VVImBi=True):
  self.skin, self.VVmNvK = FFQaOH(VV0v8m, 1600, 1000, 50, 40, 20, "#11003040", "#11001122", VVPYL1, VV1j0B=consFont)
  self.session   = session
  FFNhKZ(self, addScrollLabel=True)
  self.VVWRZK   = VVWRZK
  self.VVGSDE   = VVGSDE
  self.VVoPrg   = VVoPrg
  self.VVHJZR  = VVHJZR
  self.VVpqw1 = VVpqw1
  self.VV2BYW = VV2BYW
  self.VV5wgt   = VV5wgt
  self.VVu7vM = VVu7vM
  self.VVELy4  = VVELy4
  self.VVAH4n  = VVAH4n
  self.VVImBi  = VVImBi
  self.cmdNum    = 0
  self.VVOmNp  = CCDRFn()
  self.justStarted  = True
  self.dataFound   = False
  self.VVfGjS = "Processing ..."
  if len(title) == 0:
   title = FFJ4QU()
  self["myTitle"].setText("  %s" % title)
  if isinstance(VVtT2v, str):
   self.VVtT2v = [VVtT2v]
  else:
   self.VVtT2v = VVtT2v
  if self.VVoPrg or self.VVHJZR:
   restartNote = "%s\\\\nGUI WILL RESTART NOW\\\\n%s" % (SEP, SEP)
   self.VVtT2v.append("echo -e '\n%s\n' %s" % (restartNote, FFuLAo(restartNote, VVdLWL)))
   if self.VVoPrg : self.VVtT2v.append(CCYInC.VVTwB4())
   else    : self.VVtT2v.append(CCYInC.VVP33Z())
  self.onShown.append(self.VVf1Ra)
  self.onClose.append(self.onExit)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  self["myLabel"].VVesH9(outputFileToSave="console" if self.VVImBi else "", maxChars=40000)
  if self.VVpqw1:
   FFoTZI(self, self.VVfGjS)
  if self.VVAH4n:
   self.VVwFjL("Checking Internet Access ... ")
   if not CC9qM0.VVQ0uB():
    self.VVs7WR("No connection to internet !", True)
    return
  self.VVwFjL(self.VVfGjS)
  allOK = self.VVOmNp.VV70Ea(self.VVtT2v[0], self.VVGxQo, VVpl47=self.VVdwRo)
  if not allOK:
   self.VVwFjL()
   self.VVs7WR("Console Problem (in cmd-0) !", True)
 def onExit(self):
  if self.VVOmNp.VVMBRF():
   self.VVOmNp.killAll()
 def VVwFjL(self, altTxt=""):
  if self.VV2BYW or self.VVoPrg or self.VVHJZR:
   self.VVFEZs(FFFGRS("STARTED", VV0p9P))
   self.VVgBkQ(altTxt)
  else:
   self.VVFEZs(altTxt)
  if self.VVWRZK:
   self["myLabel"].VVJS7j()
 def VVs7WR(self, txt="", isErr=False):
  if txt:
   self.VVgBkQ("\n%s\n" % (FFKrMM(txt, VVdLWL) if isErr else txt))
  if not self.dataFound or self.VVsPA0():
   self.VVwFjL()
   self.VVgBkQ("Done.")
  if self.VV2BYW and not (self.VVoPrg or self.VVHJZR):
   self.VVgBkQ("\n%s" % FFFGRS("FINISHED", VV0p9P))
  if self.VVGSDE:
   self["myLabel"].VVJS7j()
  if self.VVpqw1:
   FFoTZI(self)
  if self.VVu7vM:
   self.VVu7vM()
 def VVgBkQ(self, txt) : self["myLabel"].appendText(txt, VV5wgt=self.VV5wgt)
 def VVFEZs(self, txt) : self["myLabel"].setText(txt)
 def VVI5Y2(self)  : return FFkEjh(self["myLabel"].getText())
 def VVsPA0(self, txt=""):
  consTxt = self.VVI5Y2().strip()
  return not consTxt or consTxt.strip().endswith(self.VVfGjS)
 def VVdwRo(self, txt):
  if len(txt) > 0:
   self.dataFound = True
  if self.justStarted:
   self.justStarted = False
   if self.dataFound and self.VVsPA0():
    self.VVwFjL()
  if self.VVELy4:
   colorWhite = CCEsU0.VVUvkG(VVCQUS)
   color  = CCEsU0.VVUvkG(self.VVELy4[0])
   words  = self.VVELy4[1:]
   for word in words:
    txt = iSub(r"(%s)" % iEscape(word), r"%s\1%s" % (color, colorWhite), txt, flags=IGNORECASE)
  self.VVgBkQ(txt)
  if self.VVWRZK or self.VVGSDE:
   self["myLabel"].VVJS7j()
 def VVGxQo(self, data, retval):
  self.cmdNum += 1
  if self.cmdNum < len(self.VVtT2v):
   allOK = self.VVOmNp.VV70Ea(self.VVtT2v[self.cmdNum], self.VVGxQo, VVpl47=self.VVdwRo)
   if not allOK:
    self.VVs7WR("Console Problem (in cmd-%s) !" % self.cmdNum, True)
  else:
   self.VVs7WR()
 @staticmethod
 def VValvI(isInst=False):
  txt  = "apt-get install -f -y > /dev/null 2>&1;" if isInst else ""
  return "sync; sleep 3; if which systemctl > /dev/null 2>&1; then %s systemctl restart enigma2; else killall -9 enigma2; fi" % txt
 @staticmethod
 def VVP33Z(): return CCYInC.VValvI()
 @staticmethod
 def VVTwB4(): return CCYInC.VValvI(True)
 @staticmethod
 def VViFfG(SELF):
  from Screens.Standby import TryQuitMainloop
  SELF.session.open(TryQuitMainloop, 3)
class CCu5WO(Screen):
 def __init__(self, session, VVruJa="", VVd4C0="", VVnFl3=False):
  self.skin, self.VVmNvK = FFQaOH(VV0v8m, 1700, 1000, 40, 20, 20, "#22200010", "#1a000000", 28, VVSwLg=40, VV1j0B=True, VVcmdl=2)
  self.session   = session
  self.VVruJa   = VVruJa
  self.VVd4C0   = VVd4C0.strip()
  self.VVnFl3   = VVnFl3
  self.VVYU41 = FFJv8S() + "ajpanel_terminal.history"
  self.VVIoUl = ""
  self.VV8fO4  = "ls"
  self.VVKaCE   = ">>"
  self.VVpGvX    = FF2ndj("pwd") or "/home/root"
  self.VVOmNp  = CCDRFn()
  self.VV9K5V  = []
  self.VVGBKf  = ""
  self.VV5Mqw   = None
  self.VV18nt   = (VV3Hcc, VVaWxS,VVOQkl,VVjojy,VV0MNp,VV2jvK,VV1l75,VVCQUS)
  self.VVIj5I  = 0
  FFNhKZ(self, title="Terminal", addScrollLabel=True)
  FFi79B(self["keyRed"] , "Stop Process")
  FFi79B(self["keyGreen"] , "Minimize")
  FFi79B(self["keyYellow"], "Terminal Options")
  FFi79B(self["keyBlue"] , "New Command")
  FFmpyO(self,
  {
   "ok" : self.VVUWmT ,
   "cancel": self.VVT9Sv  ,
   "menu" : self.VVE4RB ,
   "info" : self.VVGMtj  ,
   "red" : self.VVFqNn   ,
   "green" : self.VVlk3f   ,
   "yellow": self.VVsipl ,
   "blue" : self.VVvyxD  ,
   "last" : self["myLabel"].VV9VVg ,
   "next" : self["myLabel"].VVunBk ,
   "0"  : self["myLabel"].VVRi7w  ,
  })
  self.onShown.append(self.VVf1Ra)
  self.onClose.append(self.VVFqNn)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  self["myLabel"].VVesH9(isResizable=False, outputFileToSave="terminal", addNewLine=False, hideBtns=True)
  self["myLabel"].VVpi6g(CFG.terminalTextWrap.getValue())
  FFuwGk(self)
  FFeo1z(self)
  self.VVUNYp(FF2ndj("date"), 5)
  result = FF2ndj("tUSER=$(whoami) || tUSER=""; tHOST=$(hostname) || tHOST=""; echo $tUSER,$tHOST")
  if result and "," in result:
   result = result.replace(",", "@")
   if len(result) < 15:
    self.VVKaCE = "%s: " % result
  self.VVcAPj()
  if VVkY7E(FFJv8S()):
   self.VVhBAL()
   if self.VVruJa:
    self.VVVxOC(self.VVruJa, self.VVd4C0)
  else:
   FFbBGq(self, 'Cannot access the path:\n\n%s' % FFJv8S())
   self.close()
 def VVT9Sv(self):
  if   self.VV5Mqw     : self.VVlk3f()
  elif self.VVOmNp.VVMBRF()  : self.VVJECh()
  elif self.VVnFl3      : self.close()
  elif CFG.ConfirmTerminalExit.getValue() : FF6pUe(self, self.close, "Exit ?")
  else         : self.close()
 def VVlk3f(self):
  if self.VV5Mqw:
   self.session.deleteDialog(self.VV5Mqw)
   self.VV5Mqw = None
   self.show()
  else:
   self.VV5Mqw = CCJe5E.VV9IOS(self.session, self.VVGBKf, 24, shadW=0, bg="#77000000")
   self.hide()
 def VVhBAL(self):
  userFile = CFG.terminalCmdFile.getValue()
  alterFile = FFJv8S() + "ajpanel_cmd"
  templPath = VVK8DT + "ajpanel_cmd_list"
  if   FFKbVo(userFile) : self.VVIoUl = userFile
  elif FFKbVo(alterFile): self.VVIoUl = alterFile
  else:
   if not FFlonU("cp -f '%s' '%s'" % (templPath, alterFile)):
    FFZZgw("echo -e 'pwd\ncd\ncd /tmp\nls\nls -ls' > '%s'" % alterFile)
   self.VVIoUl = alterFile
 def VVFqNn(self):
  if self.VV5Mqw:
   self.VVlk3f()
  elif self.VVOmNp.VVMBRF():
   self.VVOmNp.killAll()
   self.VVoFD2("Process killed")
   self.VVcAPj()
 def VVJECh(self):
  if self.VV5Mqw:
   self.VVlk3f()
  FFoTZI(self, "Terminal is busy", 800)
 def VVoFD2(self, err):
  txt = self["myLabel"].getText()
  if   txt.endswith("\n\n"): cr = ""
  elif txt.endswith("\n")  : cr = "\n"
  else      : cr = "\n\n"
  self.VVUNYp("%s---(  %s  )---\n" % (cr, err), 4)
 def VVcAPj(self):
  txt = self["myLabel"].getText()
  self.VVIj5I = len(txt)
  if   txt.endswith("\n\n"): cr = ""
  elif txt.endswith("\n")  : cr = "\n"
  else      : cr = "\n\n"
  self.VVUNYp(cr + self.VVKaCE, 1)
  self["keyRed"].hide()
 def VVUNYp(self, txt, mode):
  if   mode == 0 : color = VVCQUS
  elif mode == 1 : color = VVjojy
  elif mode == 2 : color = VV1l75
  elif mode == 3 : color = VVCQUS
  elif mode == 4 : color = VVdLWL
  elif mode == 5 : color = VV0p9P
  elif mode == 6 : color = VV3Hcc
  else   : color = VVCQUS
  txt = iSub(r"\x1B\[0m", CCEsU0.VVUvkG(VVCQUS), txt, flags=IGNORECASE)
  for i, c in enumerate(self.VV18nt):
   txt = iSub(r"\x1B\[[\d\;]*%sm" % i, CCEsU0.VVUvkG(c), txt, flags=IGNORECASE)
  txt = iSub(r"\x1B\[(\d{,3};?){,3}m", "", txt, flags=IGNORECASE)
  if not txt.strip() or iMatch(r"^\\c.{8}.*", txt):
   color = ""
  try:
   txt = str(txt)
   oldTxt = self["myLabel"].getText()
   done = False
   if chr(13) in txt:
    pos = oldTxt.rfind(chr(13))
    if pos > self.VVIj5I:
     self["myLabel"].setText(oldTxt[:pos] + txt)
     done = True
   if not done:
    self["myLabel"].setText(oldTxt + color + txt)
   txt = txt.strip().rpartition("\n")[2]
   if txt:
    if len(txt) > 20: txt = "%s .. %s" % (txt[:10], txt[-10:])
    self.VVGBKf = color + txt
    if self.VV5Mqw:
     CCJe5E.VVQVcM(self.VV5Mqw, self.VVGBKf)
  except:
   pass
 @FFJRPn("Loading History ...")
 def VVUWmT(self):
  title = "Command History"
  if not FFKbVo(self.VVYU41) or self.VVNoPL() == "":
   self.VVPqSB("cd /tmp")
   self.VVPqSB("ls")
  VVuGUx = []
  if FFKbVo(self.VVYU41):
   lines  = FF2kXa(self.VVYU41)
   c  = 0
   lNum = len(lines) + 1
   for line in reversed(lines):
    line = line.strip()
    lNum -= 1
    if line and not line.startswith("#"):
     c += 1
     VVuGUx.append((str(c), line, str(lNum)))
   self.VVpsit(VVuGUx, title, self.VVYU41, isHistory=True)
  else:
   FFWfGZ(self, self.VVYU41, title=title)
 def VVNoPL(self):
  lastLine = FF2ndj("grep '.' '%s' | tail -1" % self.VVYU41)
  return lastLine.strip()
 def VVPqSB(self, cmd):
  try:
   with open(self.VVYU41, "a") as f:
    f.write("%s\n" % cmd)
  except Exception as e:
   FFbBGq(self, str(e))
 def VVE4RB(self, VVAIxO=None):
  FF7iMz(VVAIxO or self, BF(self.VVb725, VVAIxO), "Loading Commands ...")
 def VVb725(self, VVAIxO=None):
  if FFKbVo(self.VVIoUl):
   lines = FF2kXa(self.VVIoUl)
   VVuGUx = []
   c  = 0
   lNum = 0
   defColor = ""
   for line in lines:
    line = line.strip()
    lNum += 1
    if line:
     c += 1
     color, line = self.VVlLri(line)
     if not color.startswith("#f#") and iMatch("^[^a-zA-Z0-9_/]", line):
      color = "#f#00FF8055#" + defColor
     if color:
      if line:
       line = color + line
      else:
       defColor = color
       continue
     elif not line:
      defColor = ""
      continue
     else:
      line = defColor + line
     VVuGUx.append((str(c), line, str(lNum)))
   if VVAIxO:
    VVAIxO.VVEEBV(VVuGUx)
    VVAIxO.VVt5t9(CFG.lastTerminalCustCmdLineNum.getValue())
   else:
    self.VVpsit(VVuGUx, "File : %s" % os.path.basename(self.VVIoUl), filePath=self.VVIoUl, isHistory=False)
  else:
   FFWfGZ(self, self.VVIoUl, title="Custom Commands")
 def VVlLri(self, line):
  found = False
  span = iSearch(r"^\s*\[(.+)?\](.+?#.*)", line)
  if span:
   fgBg, line = span.groups()
   found = True
  else:
   span = iSearch(r"^([^#]+)(#)(.+)\[(.+)?\](.*)", line)
   if span:
    line, sep, txt1, fgBg, txt2 = span.groups()
    txt1 = txt1.strip(" #") if txt1 else ""
    txt2 = txt2.strip(" #") if txt2 else ""
    if   txt1 and txt2 : line += "\t%s %s ... %s" % (sep, txt1, txt2)
    elif txt1 or txt2 : line += "\t%s %s" % (sep, txt1 or txt2)
    found = True
   else:
    span = iSearch(r"^\s*\[(.+)?\](.+)?", line)
    if span:
     fgBg, line = span.groups()
     found = True
  if found:
   fg = bg = color = ""
   line = line.strip() if line else ""
   if fgBg:
    fg, _, bg = fgBg.partition(",")
    fg, bg = fg.strip(" #"), bg.strip(" #")
   c = self.VVcVoB(fg)
   if c: color = "#f#%s#" % c
   c = self.VVcVoB(bg)
   if c: color += "#b#%s#" % c
   return color, line
  return "", line
 def VVcVoB(self, txt):
  if txt:
   Dict = {"black": "000000", "red": "FF0000", "green": "00FF00", "blue": "0000FF", "yellow": "FFFF00", "cyan": "00FFFF", "purple": "FF00FF", "grey": "666666", "gray": "666666", "white": "FFFFFF"}
   tc = "22"
   Len = len(txt)
   color = Dict.get(txt.lower(), "")
   if color:
    return tc + color
   elif Len in (6,8) and iMatch("[a-fA-F0-9]", txt):
    if Len == 6 : return tc + txt
    if Len == 8 : return txt
  return ""
 def VVpsit(self, VVuGUx, title, filePath=None, isHistory=False):
  if VVuGUx:
   if isHistory: VVfWsQ = VVB5I5 = VVYCun = "#11000020"
   else  : VVfWsQ = VVB5I5 = VVYCun = "#06002020"
   VVj7lw   = ("Send"   , BF(self.VVdGTy, isHistory)  , [])
   VVwqVu  = ("Modify & Send" , self.VVTLOz     , [])
   if isHistory:
    VVPYL1  = CFG.terminalFontSizeHist.getValue()
    VV46TD = ("Clear History" , self.VViToE     , [])
    VViMvb = None
    VVmolf = None
   elif filePath:
    VVPYL1  = CFG.terminalFontSizeCmd.getValue()
    VV46TD = ("Options"  , self.VV75h7      , [])
    VViMvb = ("Edit File"  , BF(self.VVBMYs, filePath) , [])
    VVmolf = (""    , self.VVshuv     , [])
   header  = ("No." , "Commands", "LineNum" )
   widths  = (7  , 93   , 0    )
   VV4Uoc = (CENTER , LEFT   , CENTER )
   VVAIxO = FFCXsL(self, None, title=title, header=header, VVXpNQ=VVuGUx, VV4Uoc=VV4Uoc, VV8boH=widths, height=1000, VVPYL1=VVPYL1, VVj7lw=VVj7lw, VVwqVu=VVwqVu, VV46TD=VV46TD, VViMvb=VViMvb, VVmolf=VVmolf, VVAGe1=CFG.lastFindTerminal, VVoNmU=True, VVMBr1=1
         , VVfWsQ=VVfWsQ, VVB5I5=VVB5I5, VVYCun=VVYCun, VVzVW9="#00ffffff", VVmErq="#0a884400")
   if not isHistory:
    VVAIxO.VVt5t9(CFG.lastTerminalCustCmdLineNum.getValue())
  else:
   FF6pUe(self, self.VVWyPr, "File is empty:\n\n%s\n\nSelect another file ?" % self.VVIoUl, title=title)
 def VVshuv(self, VVAIxO, title, txt, colList):
  txt  = "%s\n%s\n\n" % (FFKrMM("Command:", VVk4x7), colList[1])
  txt += "%s\n%s\n\n" % (FFKrMM("Line %s in File:" % colList[2], VVk4x7), self.VVIoUl)
  FFSMJz(self, txt, title=title)
 def VV75h7(self, VVAIxO, title, txt, colList):
  if VVAIxO.VVGZGK:
   totSel = VVAIxO.VVAGI8()
   totTxt = str(totSel)
   txt = "Send %s Command%s" % (FFKrMM(totTxt, VVk4x7) if totSel else totTxt, FFaRsj(totSel))
   item = (txt, "send") if totSel else (txt,)
  else:
   txt = "Send current line"
   item = (txt, "send")
  CC17aQ(self, VVAIxO, setsOk=True, setsBlue=True, setsGreen=True).VV4sFy([item], { "send": BF(self.VVdGTy, False, VVAIxO, title, txt, colList) })
 def VVsipl(self):
  VV9cxb = []
  VV9cxb.append(("Change Custom Commands File" , "chCmdF" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("%s Text Wrapping"     % ("Disable" if self["myLabel"].wrapEnabled else "Enable"), "wrap" ))
  VV9cxb.append(("%s Terminal-Exit Confirmation" % ("Disable" if CFG.ConfirmTerminalExit.getValue() else "Enable"), "togExit"))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Commands Table Font Size" , "cmdFntSz" ))
  VV9cxb.append(("History Table Font Size" , "histFntSz" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Save Terminal Log File"  , "saveLog" ))
  FFO9kU(self, self.VVa9xt, VV9cxb=VV9cxb, title="Terminal Options", width=700)
 def VVa9xt(self, item):
  if item:
   if   item == "chCmdF" : self.VVWyPr()
   elif item == "wrap"  : self.VViCj4()
   elif item == "togExit" : FFBWtx(CFG.ConfirmTerminalExit, not CFG.ConfirmTerminalExit.getValue())
   elif item == "cmdFntSz" : self.VVO3bW(True)
   elif item == "histFntSz": self.VVO3bW(False)
   elif item == "saveLog" : self["myLabel"].VVBMaN()
 def VViCj4(self):
  self["myLabel"].VVj9Ll()
  FFBWtx(CFG.terminalTextWrap, self["myLabel"].wrapEnabled)
 def VVO3bW(self, isCmdTbl):
  if isCmdTbl : confItem, txt = CFG.terminalFontSizeCmd , "Commands"
  else  : confItem, txt = CFG.terminalFontSizeHist, "History"
  CCLbil.VVZvbO(self, confItem, "%s Table Font Size" % txt, cbFnc=BF(FFxHED, self, "Saved"), isSave=True, width=700)
 def VVWyPr(self):
  title = "Custom Commands File"
  VV9cxb = []
  bPath = FFJv8S()
  for fName in sorted(os.listdir(bPath), key=lambda x: x[0].lower()):
   path = os.path.join(bPath, fName)
   if fName.lower().startswith(("ajpanel_cmd", "linuxcommands")) and os.path.isfile(path):
    if path == self.VVIoUl:
     fName = FFKrMM(fName, VVOQkl)
    VV9cxb.append((fName, path))
  if VV9cxb : FFO9kU(self, BF(self.VV9k15, title), VV9cxb=VV9cxb, title=title, VV3an7=3, VV1NnQ="", VVfWsQ="#11220000", VVB5I5="#11220000")
  else  : FFbBGq(self, "No valid files found in:\n\n%s" % bPath, title=title)
 def VV9k15(self, title, path=None):
  if path:
   oldF = self.VVIoUl
   if CC17eA.VVLpYt(path):
    FFbBGq(self, "Incorrect file format:\n\n%s" % path, title=title)
   elif path == self.VVIoUl:
    FFoTZI(self, "No change", 1000)
   else:
    self.VVIoUl = path
    FFBWtx(CFG.terminalCmdFile, path)
    FFBWtx(CFG.lastTerminalCustCmdLineNum, 0)
    FFxHED(self, "Changed")
 def VVdGTy(self, isHistory, VVAIxO, title, txt, colList):
  if VVAIxO.VVGZGK:
   lst = VVAIxO.VVKa9C(1)
   curNdx = VVAIxO.VVSlWK()
  else:
   lst = [colList[1]]
   curNdx = VVAIxO.VVoxea()
  if not isHistory:
   FFBWtx(CFG.lastTerminalCustCmdLineNum, curNdx)
  self.VV9K5V = lst
  VVAIxO.cancel()
  FFvfpL(self.VVAshZ)
 def VVAshZ(self):
  if self.VV9K5V:
   cmd = self.VV9K5V[0]
   self.VV9K5V.pop(0)
   if not iMatch("^[a-zA-Z0-9_/]", cmd):
    self.VVUNYp("\n%s\n" % cmd, 6)
    self.VVUNYp(self.VVKaCE, 1)
    self.VVAshZ()
   else:
    self.VVVxOC(cmd)
 def VVVxOC(self, cmd, VVd4C0=""):
  if self.VVOmNp.VVMBRF():
   self.VVJECh()
   return
  self["keyRed"].show()
  if cmd.startswith("passwd"):
   self.VVUNYp(cmd, 2)
   self.VVUNYp("\nCannot change passwrod from Console this way. Try using:\n", 4)
   txt = r'echo -e "NEW_PASSWORD\#nNEW_PASSWORD" | passwd'
   for ch in txt:
    if not ch == "#":
     self.VVUNYp(ch, 0)
   self.VVUNYp("\nor\n", 4)
   self.VVUNYp("echo root:NEW_PASSWORD | chpasswd\n", 0)
   self.VVcAPj()
  else:
   cmd = cmd.strip()
   modCmd = cmd
   span = iSearch(r"^(\/.+sh)(\s+#+.*)*$", cmd, IGNORECASE)
   if span:
    modCmd = "sh '%s'" % span.group(1)
    FFlonU(FFQWwc("chmod 755 '%s'" % cmd))
    txt = "%s%s\n" % (VV2jvK, cmd)
   elif cmd.endswith((".py", ".pyo", ".pyc")) and os.path.isfile(cmd):
    FFlonU(FFQWwc("chmod 755 '%s'" % cmd))
    modCmd = "python%s '%s'" % ("3" if pyVersion[0] >= 3 else "", cmd)
    txt = "%s%s\n" % (VV2jvK, cmd)
   elif "#" in cmd and not "\n" in cmd:
    parts = cmd.split("#")
    left  = VV1l75 + parts[0].strip()
    right = VV3Hcc + "#" + parts[1].strip()
    txt = "%s    %s\n" % (left, right)
   else:
    txt = "%s\n" % cmd
   self.VVUNYp(VVd4C0 if VVd4C0 else txt, 2)
   lastLine = self.VVNoPL()
   if not lastLine or not cmd == lastLine:
    self.VV8fO4 = cmd
    self.VVPqSB(cmd)
   span = iSearch(r".*cd\s+([\/?\w\.+\~]+)", cmd + ";")
   if span:
    self.VVpGvX = span.group(1)
   allOK = self.VVOmNp.VV70Ea(modCmd, self.VVF4W6, VVpl47=self.VVT17S, VVpGvX=self.VVpGvX)
   if not allOK:
    FFbBGq(self, "Cannot connect to Console!")
   self.VV8fO4 = cmd
 def VVT17S(self, data):
  self.VVUNYp(data, 3)
 def VVF4W6(self, data, retval):
  if not retval == 0:
   self.VVoFD2("Exit Code : %d" % retval)
  self.VVcAPj()
  if self.VV9K5V:
   self.VVAshZ()
 def VVTLOz(self, VVAIxO, title, txt, colList):
  if VVAIxO.VVznjv():
   cmd = colList[1]
   self.VVpxgl(VVAIxO, cmd)
 def VViToE(self, VVAIxO, title, txt, colList):
  FF6pUe(self, BF(self.VVHpRI, VVAIxO), "Reset History File ?", title="Command History")
 def VVHpRI(self, VVAIxO):
  FFZZgw("> '%s'" % self.VVYU41)
  VVAIxO.cancel()
 def VVBMYs(self, filePath, VVAIxO, title, txt, colList):
  rowNum = int(colList[2].strip()) - 1
  if FFKbVo(filePath) : CCNb3y(self, filePath, VVhK3C=BF(self.VVqsrt, VVAIxO), VVmB4A=rowNum)
  else     : FFWfGZ(self, filePath)
 def VVqsrt(self, VVAIxO, fileChanged):
  if fileChanged:
   VVAIxO.cancel()
   FFvfpL(self.VVE4RB)
 def VVvyxD(self):
  if self.VVOmNp.VVMBRF():
   self.VVJECh()
  else:
   self.VVpxgl(None, "")
 def VVpxgl(self, VVAIxO, cmd):
  if "#" in cmd:
   cmd = cmd.split("#")[0].strip()
  FFANcN(self, BF(self.VVogV5, VVAIxO), title="Terminal", defaultText=cmd, message="Enter Command:")
 def VVogV5(self, VVAIxO, cmd):
  if cmd and len(cmd) > 0:
   self.VVVxOC(cmd)
   if VVAIxO:
    VVAIxO.cancel()
 def VVGMtj(self):
  FFY7F5(self, "_help_terminal", "Terminal Help")
class CCu7jG(Screen):
 def __init__(self, session, title="", message="", VV5wgt=VVfI5z, width=1400, height=900, VV4n1E=False, isErr=False, titleBg="#22002020", VVYCun="#22001122", VVPYL1=30, VVAQi3=50, resize=True, outputFileToSave=""):
  if isErr: titleBg, VVYCun = "#22330000", "#22200000"
  self.skin, self.VVmNvK = FFQaOH(VV0v8m, width, height, VVAQi3, 30, 20, titleBg, VVYCun, VVPYL1)
  self.session   = session
  FFNhKZ(self, title, addScrollLabel=True)
  self.VV5wgt   = VV5wgt
  self.VV4n1E   = VV4n1E
  self.resize    = resize
  self.outputFileToSave = outputFileToSave
  if isinstance(message, list):
   try:
    self.message = "\n".join(message)
   except:
    pass
  self.message = str(message)
  self.onShown.append(self.VVf1Ra)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  self["myLabel"].VVesH9(VV4n1E=self.VV4n1E, outputFileToSave=self.outputFileToSave)
  self["myLabel"].setText(self.message, self.VV5wgt)
  self.VV69k7()
 def VVOhJD(self, txt):
  self["myLabel"].appendText(txt)
  self.VV69k7()
 def VV69k7(self):
  if self.resize:
   self["myLabel"].VVJS7j()
class CCk1tY(Screen):
 def __init__(self, session, txt):
  self.skin, self.VVmNvK = FFQaOH(VVwU8r, 1800, 60, 30, 30, 20, "#55000000", "#ff000000", 30)
  self.session  = session
  self.txt   = txt
  self["myWinTitle"] = Label()
  FFNhKZ(self, " ", addCloser=True)
  self.onShown.append(self.VVf1Ra)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  CCJe5E.VVQVcM(self, self.txt)
  self.instance.move(ePoint((getDesktop(0).size().width() - self.instance.size().width()) // 2, 20))
class CCJq9D(Screen):
 def __init__(self, session, title="", message=""):
  self.skin, self.VVmNvK = FFQaOH(VVi9he, 1200, 300, 50, 20, 0, "#22330000", "#22200000", 30)
  self.session = session
  FFNhKZ(self, title, addLabel=True, addCloser=True)
  self["errPic"] = Pixmap()
  self["myLabel"].setText(message)
  self.onShown.append(self.VVf1Ra)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  FFHTca(self["errPic"], "err")
class CCmH8P(Screen):
 def __init__(self, session, fnc, title="Processing ...", fntSize=28, bg="#22331133"):
  self.skin, self.VVmNvK = FFQaOH(VVwU8r, 500, 100, 10, 10, 30, "#FF000000", "#FF000000", 30, VVNLQc=False)
  self.session = session
  self.fnc  = fnc
  self.Title  = str(title)
  self.fntSize = fntSize
  self.bg   = bg
  FFNhKZ(self, " ")
  self["myWinTitle"] = Label()
  self.onShown.append(self.VVf1Ra)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  self["myInfoFrame"].show()
  body = self["myInfoBody"]
  body.show()
  body.setText(self.Title)
  body.instance.setFont(gFont(VV3IRX, self.fntSize))
  FFgLA9(body, self.bg)
  FFe43w(":", self.VVWiDw)
 def VVWiDw(self, result, retval):
  self.fnc()
  self.close()
class CCDBE6(Screen):
 def __init__(self, session, title, timeout=1500, fntSize=28, fg="#22ffffaa", bg="#22001100", isRed=False):
  self.skin, self.VVmNvK = FFQaOH(VVwU8r, 500, 100, 10, 10, 30, "#FF000000", "#FF000000", 30, VVNLQc=False)
  self.session = session
  self.Title  = str(title)
  self.fntSize = fntSize
  self.fg   = fg
  self.bg   = "#00550000" if isRed else bg
  FFNhKZ(self, " ", addCloser=True)
  self["myWinTitle"] = Label()
  self.timer = eTimer()
  try: self.timer_conn = self.timer.timeout.connect(self.close)
  except: self.timer.callback.append(self.close)
  self.timer.start(timeout, True)
  self.onShown.append(self.VVf1Ra)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  self["myInfoFrame"].show()
  body = self["myInfoBody"]
  body.show()
  body.setText(self.Title)
  body.instance.setFont(gFont(VV3IRX, self.fntSize))
  FFPvX5(body, self.fg, self.bg)
class CCZp9O(Screen):
 def __init__(self, session, txt, fntSize, bg="#FF000000"):
  self.skin, self.VVmNvK = FFQaOH(VVwU8r, 1000, 50, 20, 30, 20, bg, bg, fntSize, VVNLQc=False)
  self.session  = session
  self["myWinTitle"] = Label()
  FFNhKZ(self, " ", addCloser=True)
class CCJe5E():
 def __init__(self, session, txt, timeout=1500, fonSize=24, x=30, y=20):
  self.session = session
  self.win  = CCJe5E.VV9IOS(session, txt, fonSize, x=x, y=y)
  self.timer = eTimer()
  try: self.timer_conn = self.timer.timeout.connect(self.VVlTAr)
  except: self.timer.callback.append(self.VVlTAr)
  self.timer.start(timeout, True)
 def VVlTAr(self):
  self.session.deleteDialog(self.win)
 @staticmethod
 def VV9IOS(session, txt, fonSize, shadW=2, shadColor="#440000", bg="#FF000000", x=30, y=20):
  win = session.instantiateDialog(CCZp9O, str(txt).strip(), fonSize, bg=bg)
  win.show()
  FF0u5o(win["myWinTitle"], shadColor, shadW)
  CCJe5E.VVQVcM(win, txt)
  if x < 0: x = (getDesktop(0).size().width() - win.instance.size().width()) // 2
  if y < 0: y = (getDesktop(0).size().height() - win.instance.size().height()) // 2
  win.instance.move(ePoint(x, y))
  return win
 @staticmethod
 def VVQVcM(win, txt):
  win["myWinTitle"].setText(str(txt).strip())
  inst = win["myWinTitle"].instance
  w = inst.calculateSize().width() + 30
  h = int(inst.size().height())
  inst.resize(eSize(*(w, h)))
  win.instance.resize(eSize(*(w, h)))
class CClaHD():
 VVq8Us    = 0
 VVmTlG  = 1
 VVJKeO   = ""
 VVXWFL   = {}
 VVcmMY    = "ajpDownload"
 def __init__(self, SELF, mode, title, startDnld, VVadS0=""):
  self.SELF     = SELF
  self.mode     = mode
  self.Title     = title
  self.VVAIxO   = None
  self.timer     = eTimer()
  self.VVsEYx   = 0
  self.VVeIap  = 1
  self.VVBBzn  = 2
  self.VV0Two   = 3
  self.VVH142   = 4
  VVuGUx = self.VVgBLg()
  if VVuGUx:
   self.VVAIxO = self.VVOQSR(VVuGUx)
  if not VVuGUx and mode == self.VVq8Us:
   self.VVJf3H("Download list is empty !")
   self.cancel()
  if mode == self.VVmTlG:
   FF7iMz(self.VVAIxO or self.SELF, BF(self.VVOKly, startDnld, VVadS0), title="Checking Server ...")
  self.VVhdXL(force=True)
  try: self.timer_conn = self.timer.timeout.connect(self.VVhdXL)
  except: self.timer.callback.append(self.VVhdXL)
  self.timer.start(1000, False)
 def VVOQSR(self, VVuGUx):
  VVuGUx.sort(key=lambda x: int(x[0]))
  VVpW7I = self.VV0lZz
  VVj7lw  = ("Play"  , self.VVj9Sl , [])
  VVmolf = (""   , self.VVwM9h  , [])
  VVjW3s = ("Stop"  , self.VVgrm7  , [])
  VVwqVu = ("Resume"  , self.VV9srG , [])
  VV46TD = ("Options" , self.VVKeTE  , [])
  header   = ("No." , "Name" , "Type", "File Size", "Status" , "Progress", "Path", "sizeVal" , "URL" , "decoded-Url" , "oldSize" , "Speed" , "m3u8Log" )
  widths   = (5  , 39  , 8  , 13   , 13   , 11   , 0.01 , 0   , 0.01 , 0    , 0   , 11  , 0   )
  VV4Uoc  = (CENTER, LEFT  , CENTER, CENTER  , CENTER , CENTER , LEFT , CENTER , LEFT , LEFT   , CENTER , CENTER , LEFT  )
  return FFCXsL(self.SELF, None, title=self.Title, header=header, VVXpNQ=VVuGUx, VV4Uoc=VV4Uoc, VV8boH=widths, VVPYL1=26, VVj7lw=VVj7lw, VVmolf=VVmolf, VVpW7I=VVpW7I, VVjW3s=VVjW3s, VVwqVu=VVwqVu, VV46TD=VV46TD, VVAGe1=CFG.lastFindIptv, VVfWsQ="#11220022", VVB5I5="#11110011", VVYCun="#11110011", VVmErq="#00223025", VVK8UQ="#0a333333", VVgSJJ="#0a400040", VVoNmU=True, VVMBr1=1)
 def VVgBLg(self):
  lines = CClaHD.VVutI8()
  VVuGUx = []
  if lines:
   for ndx, line in enumerate(lines):
    if "," in line:
     parts  = line.split(",", 1)
     left  = parts[0].strip()
     VVadS0 = parts[1].strip()
     if left == "-1" or left.isdigit(): size, m3u8Log = int(left), ""
     else        : size, m3u8Log = -1  , left
     if VVadS0:
      fName, VVUwmk, url = self.VVOD9I(VVadS0)
      if fName:
       if   FFgAmw(VVadS0) : sType = "Movie"
       elif FFgcYJ(VVadS0) : sType = "Series"
       else      : sType = ""
       path = self.VVleTZ(VVadS0, fName)
       if size > -1: sizeTxt = CC17eA.VVxNgx(size, mode=4)
       else  : sizeTxt = ""
       status = prog = speed = oldSize = ""
       VVuGUx.append((str(len(VVuGUx) + 1), VVUwmk, sType, sizeTxt, status, prog, path, str(size), url, VVadS0, oldSize, speed, m3u8Log))
  return VVuGUx
 def VVluQ5(self):
  VVuGUx = self.VVgBLg()
  if VVuGUx:
   if self.VVAIxO : self.VVAIxO.VVEEBV(VVuGUx, VVWBXTMsg=False)
   else     : self.VVAIxO = self.VVOQSR(VVuGUx)
  else:
   self.cancel()
 def VVhdXL(self, force=False):
  if self.VVAIxO:
   thrListUrls = self.VVmDoM()
   VVuGUx = []
   changed = False
   for ndx, row in enumerate(self.VVAIxO.VVGpBN()):
    row = list(map(str.strip, row))
    num, name, typ, fSize, state, progr, path, sizeV, url, VVadS0, oldSize, speed, m3u8Log = row
    flag = self.VVsEYx
    if m3u8Log:
     percent = CClaHD.VVDowb(m3u8Log)
     if percent > -1:
      if percent < 100: flag, progr = self.VV0Two , "%.2f %%" % percent
      else   : flag, progr = self.VVH142 , "100 %"
     mPath = m3u8Log[:-9]
     curSize = FFLjtI(mPath)
     if curSize > -1:
      fSize = CC17eA.VVxNgx(curSize, mode=4)
     try:
      if not oldSize in ("", "0", "-"):
       diff = int(curSize - int(oldSize))
       if diff:
        speed = CC17eA.VVxNgx(diff, mode=4) + "/s"
     except:
      pass
    else:
     curSize = FFLjtI(path)
     if curSize > -1:
      if sizeV.isdigit():
       percent = float(curSize) / float(sizeV) * 100.0
       if percent < 100: flag, progr = self.VV0Two , "%.2f %%" % percent
       else   : flag, progr = self.VVH142 , "100 %"
       try:
        if not oldSize in ("", "0", "-"):
         diff = int(curSize - int(oldSize))
         if diff:
          speed = CC17eA.VVxNgx(diff, mode=4) + "/s"
       except:
        pass
    if VVadS0 in thrListUrls:
     flag = self.VVBBzn
     if m3u8Log :
      if not speed and not force : flag = self.VVeIap
      elif curSize == -1   : self.VVutTw(False)
    elif flag == self.VVsEYx  : speed = progr = "-"
    else        : speed = "-"
    color1 = "#f#00FF9999#" if m3u8Log else ""
    if   flag == self.VVsEYx  : color2 = "#f#00555555#"
    elif flag == self.VVeIap : color2 = "#f#0000FFFF#"
    elif flag == self.VVBBzn : color2 = "#f#0000FFFF#"
    elif flag == self.VV0Two  : color2 = "#f#00FF8000#"
    elif flag == self.VVH142  : color2 = "#f#0000FF00#"
    else        : color2 = "#f#00AAAAAA#"
    state = self.VVgEuU(flag)
    oldSize = str(curSize)
    if [num, name, typ, fSize, state, progr, path, sizeV, url, VVadS0, oldSize, speed, m3u8Log] != row:
     changed = True
    row[1]  = color1 + name
    row[2]  = color1 + typ
    row[3]  = color1 + fSize
    row[4]  = color2 + state
    row[5]  = color2 + progr
    row[10] = oldSize
    row[11] = speed if not speed.startswith("-") else "-"
    VVuGUx.append(row)
   if changed or force:
    self.VVAIxO.VVEEBV(VVuGUx, VVWBXTMsg=False)
 def VVgEuU(self, flag):
  tDict = self.VVbqMR()
  return tDict.get(flag, "?")
 def VVCoVK(self, state):
  for flag, txt in self.VVbqMR().items():
   if txt == state:
    return flag
  return -1
 def VVbqMR(self):
  return { self.VVsEYx: "Not started", self.VVeIap: "Connecting", self.VVBBzn: "Downloading", self.VV0Two: "Stopped", self.VVH142: "Completed" }
 def VVKr6F(self, title):
  colList = self.VVAIxO.VVQDwi()
  path = colList[6]
  url  = colList[8]
  if self.VV5C0S() : self.VVJf3H("Cannot delete !\n\nFile is downloading.")
  else      : FF6pUe(self.SELF, BF(self.VV9nE5, path, url), "Delete ?\n\n%s" % path, title=title)
 def VV9nE5(self, path, url):
  m3u8Log = self.VVAIxO.VVQDwi()[12]
  if m3u8Log : FFlonU("rm -f '%s' '%s' '%s'" % (m3u8Log, m3u8Log[:-4], m3u8Log[:-9]))
  else  : FFlonU("rm -rf '%s'" % path)
  self.VVLAvH(False)
  self.VVluQ5()
 def VVLAvH(self, VVAdNn=True):
  if self.VV5C0S():
   FFoTZI(self.VVAIxO, self.VVgEuU(self.VVBBzn), 500)
  else:
   colList  = self.VVAIxO.VVQDwi()
   state  = colList[4]
   VVadS0 = colList[9]
   if self.VVCoVK(state) in (self.VVsEYx, self.VVH142, self.VV0Two):
    lines = CClaHD.VVutI8()
    newLines = []
    found = False
    for line in lines:
     if CClaHD.VVWIVm(VVadS0, line): found = True
     else            : newLines.append(line)
    if found:
     self.VVjGLG(newLines)
     self.VVluQ5()
     FFoTZI(self.VVAIxO, "Removed.", 1000)
    else:
     FFoTZI(self.VVAIxO, "Not found.", 1000)
   elif VVAdNn:
    self.VVJf3H("Cannot remove partial download !\n\nYou can delete the file (from options).")
 def VV6VxC(self, flag, title):
  ques = "Only remove from table (no file deletion).\n\nContinue ?"
  FF6pUe(self.SELF, BF(self.VVjwdx, flag), ques, title=title)
 def VVjwdx(self, flag):
  list = []
  for ndx, row in enumerate(self.VVAIxO.VVGpBN()):
   state  = row[4].strip()
   VVadS0 = row[9].strip()
   flagVal  = self.VVCoVK(state)
   if   flag == flagVal == self.VVH142: list.append(VVadS0)
   elif flag == flagVal == self.VVsEYx : list.append(VVadS0)
  lines = CClaHD.VVutI8()
  totRem = 0
  newLines = []
  for line in lines:
   if any(x in line for x in list) : totRem += 1
   else       : newLines.append(line)
  if totRem > 0:
   self.VVjGLG(newLines)
   self.VVluQ5()
   FFoTZI(self.VVAIxO, "%d removed." % totRem, 1000)
  else:
   FFoTZI(self.VVAIxO, "Not found.", 1000)
 def VVp5NF(self):
  colList  = self.VVAIxO.VVQDwi()
  path  = colList[6]
  VVadS0 = colList[9]
  png   = "%s.png" % os.path.splitext(path)[0]
  if FFKbVo(png) : FFoTZI(self.VVAIxO, "Poster exists", 1500)
  else    : FF7iMz(self.VVAIxO, BF(self.VVHrwt, VVadS0, path, png), title="Checking Server ...")
 def VVHrwt(self, VVadS0, path, png):
  err = self.VVKVfj(VVadS0, path, png)
  if err:
   FFbBGq(self.SELF, err, title="Poster Download")
 def VVKVfj(self, VVadS0, path, png):
  epg, evLst, VVuPzU, err = CCpebE.VVZlns(VVadS0)
  if not VVuPzU:
   return "Cannot download poster.\n\nTry downloading it from IPTV the tables."
  ext = os.path.splitext(VVuPzU)[1] or ".png"
  tPath, err = FFUzwU(VVuPzU, "ajp_tmp%s" % ext, timeout=2, mustBeImage=True)
  if err:
   return "Cannot download poster !\n\n%s" % err
  else:
   png = "%s%s" % (os.path.splitext(path)[0], ext)
   FFlonU("mv -f '%s' '%s'" % (tPath, png))
   CCZQAz.VVRX4k(self.SELF, VVezFg=png, showGrnMsg="Saved")
   return ""
 def VVwM9h(self, VVAIxO, title, txt, colList):
  def VVPiNc(key, val) : return "%s\t: %s\n" % (key, val.strip())
  def VVqz4B(key, val) : return "\n%s:\n%s\n" % (FFKrMM(key, VVk4x7), val.strip())
  heads  = self.VVAIxO.VVjp8T()
  txt = ""
  for i in range(6):
   if i == 3:
    totSize = colList[7].strip()
    curSize = colList[10].strip()
    if totSize and totSize.isdigit(): txt += VVPiNc(heads[i]  , CC17eA.VVxNgx(int(totSize), mode=0))
    if curSize and curSize.isdigit(): txt += VVPiNc("Downloaded" , CC17eA.VVxNgx(int(curSize), mode=0))
   else:
    txt += VVPiNc(heads[i], colList[i])
  if not "j.php" in colList[9]:
   for i in (6, 8):
    txt += VVqz4B(heads[i], colList[i])
  FFSMJz(self.SELF, txt, title=title)
 def VVj9Sl(self, VVAIxO, title, txt, colList):
  path = colList[6].strip()
  m3u8Log = colList[12].strip()
  if m3u8Log:
   path = m3u8Log[:-9]
  if FFKbVo(path) : CC17eA.VVGtUI(self.SELF, path)
  else    : FFoTZI(self.VVAIxO, "File not found", 1000)
 def VV0lZz(self, VVAIxO):
  self.cancel()
 def cancel(self):
  self.timer.stop()
  if self.VVAIxO:
   self.VVAIxO.cancel()
  del self
 def VVKeTE(self, VVAIxO, title, txt, colList):
  c1, c2, c3 = VVWJEN, VVdLWL, VVk4x7
  path  = colList[6].strip()
  VVadS0 = colList[9].strip()
  resumeTxt = "Disable" if CFG.downloadAutoResume.getValue() else "Enable"
  showMonitor = "Disable" if CFG.downloadMonitor.getValue() else "Enable"
  VV9cxb = []
  VV9cxb.append((c1 + "Remove current row"       , "VVLAvH" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append((c1 + 'Remove all "Completed"'      , "remFinished"   ))
  VV9cxb.append((c1 + 'Remove all "Not started"'     , "remPending"   ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append((c2 + "Delete the file (and remove from list)"  , "VVKr6F"))
  VV9cxb.append(VVbM5H)
  VV9cxb.append((resumeTxt + " Auto Resume"       , "VVsadI" ))
  VV9cxb.append((showMonitor + " On-screen Download Monitor"  , "toggleMonitor"  ))
  VV9cxb.append(VVbM5H)
  cond = FFgAmw(VVadS0)
  VV9cxb.append(FFH04v("Download Movie Poster %s" % ("(from server)" if cond else "... Movies only"), "VVp5NF", cond, c3))
  VV9cxb.append(FFH04v("Open in File Manager", "inFileMan,%s" % path, FFKbVo(path), c3))
  FFO9kU(self.SELF, BF(self.VVIaSh, VVAIxO), VV9cxb=VV9cxb, title=self.Title, VVDkqE=True, width=800, VVbdOY=True, VVfWsQ="#1a001122", VVB5I5="#1a001122")
 def VVIaSh(self, VVAIxO, item=None):
  if item:
   txt, ref, ndx = item
   if   ref == "VVLAvH"  : self.VVLAvH()
   elif ref == "remFinished"   : self.VV6VxC(self.VVH142, txt)
   elif ref == "remPending"   : self.VV6VxC(self.VVsEYx, txt)
   elif ref == "VVKr6F" : self.VVKr6F(txt)
   elif ref == "VVp5NF"  : self.VVp5NF()
   elif ref == "VVsadI"  : FFBWtx(CFG.downloadAutoResume, not CFG.downloadAutoResume.getValue())
   elif ref == "toggleMonitor"   : FFBWtx(CFG.downloadMonitor, not CFG.downloadMonitor.getValue())
   elif ref.startswith("inFileMan,") :
    path = ref.split(",", 1)[1]
    if VVkY7E(path) : self.SELF.session.open(CC17eA, mode=CC17eA.VVkDQs, VVNzrh=path)
    else    : FFoTZI(VVAIxO, "Path not found !", 1500)
 def VVOKly(self, startDnld, VVadS0):
  refreshToken = True
  if not VVadS0:
   VVadS0 = CCZv30(self.SELF.session).VVadS0
  else:
   ndx = VVadS0.find("j.php")
   if ndx > -1:
    url = CCr0nV.VVULQ1(VVadS0)
    if url:
     span = iSearch(r"&.+=", VVadS0)
     if span : VVadS0 = url + "&" + VVadS0[ndx + 6:]
     else : VVadS0 = url + VVadS0[ndx + 5:]
     refreshToken = False
    else:
     self.VVJf3H("Could not get download link !\n\nTry again later.")
     return
  for line in CClaHD.VVutI8():
   if CClaHD.VVWIVm(VVadS0, line):
    if self.VVAIxO:
     self.VVkQ0B(VVadS0)
     FFvfpL(BF(FFoTZI, self.VVAIxO, "Already listed !", 2000))
    break
  else:
   fnc = self.cancel if self.mode == self.VVmTlG else None
   params = self.VVwT7x(VVadS0, refreshToken)
   if len(params) == 1:
    self.VVJf3H(params[0])
    if fnc:
     fnc()
   elif len(params) == 2:
    resp, VVUwmk = params
    FF6pUe(self.SELF, BF(self.VVD1ck, resp, VVadS0), "Start downloading ?\n\n%s" % VVUwmk, callBack_No=fnc, title="Download (m3u8)")
   else:
    url, fSize, path, resp, resumable = params
    title= "Download : %s" % CC17eA.VVxNgx(fSize)
    FF6pUe(self.SELF, BF(self.VVAIVn, VVadS0, url, fSize, path, resp, startDnld), "Download to\n\n%s" % path, callBack_No=fnc, title=title)
 def VVAIVn(self, VVadS0, url, fSize, path, resp, startDnld):
  with open(CClaHD.VVHuUR(), "a") as f:
   f.write("%s,%s\n" % (fSize, VVadS0))
  self.VVluQ5()
  if self.VVAIxO:
   self.VVAIxO.VVbtl9()
  if startDnld:
   threadName = "%s{%s,Sz,}%s" % (CClaHD.VVcmMY, path, VVadS0)
   self.VVF6zm(threadName, url, VVadS0, path, resp)
 def VVkQ0B(self, VVadS0):
  if self.VVAIxO:
   for ndx, row in enumerate(self.VVAIxO.VVGpBN()):
    VVadS02 = row[9].strip()
    if VVadS0 == VVadS02 and self.VVAIxO:
     self.VVAIxO.VVt5t9(ndx)
     break
 def VVwT7x(self, VVadS0, checkExist=True, resumeByte=-1, refreshToken=True):
  fName = ""
  if VVadS0:
   fName, VVUwmk, url = self.VVOD9I(VVadS0)
  if not fName:
   return ["Cannot process URL parameters !"]
  path = self.VVleTZ(VVadS0, fName)
  if checkExist and FFKbVo(path):
   return ["File already exists:\n\n%s" % path]
  if refreshToken and "chCode" in VVadS0:
   url = CCr0nV.VVULQ1(VVadS0)
   if not url:
    return ["Could not get download link from server!"]
  fSize = 0
  resumable = False
  try:
   headers = CCTe4w.VVFbRP()
   if resumeByte > -1:
    headers["Range"] = "bytes=%d-" % resumeByte
   import requests
   resp = requests.get(url, headers=headers, timeout=3, stream=True, verify=True)
   if not resp.ok:
    return ["Err-%d : %s" % (resp.status_code, resp.reason)]
   head = resp.headers
   fSize = head.get("Content-Length", "")
   cType = head.get("Content-Type", "")
   resumable = CClaHD.VVRXW0(resp)
  except:
   return ["Could not get file info from server !"]
  if not fSize or not fSize.isdigit():
   return ["Cannot get file size from server !"]
  fSize = int(fSize)
  if not "video" in cType and not "application/octet-stream" in cType:
   if ".m3u8" in resp.url:
    return [resp, VVUwmk]
   elif path and resp.url and fSize:
    pass
   else:
    return ["Cannot download this video !\n\nIncorrect download data (or not allowed by server)."]
  err = CClaHD.VVdHXH(fSize)
  if err:
   return [err]
  return [url, fSize, path, resp, resumable]
 def VVD1ck(self, resp, VVadS0):
  if not FFW91j("ffmpeg"):
   FF6pUe(self.SELF, BF(CCTe4w.VVlNOU, self.SELF), '"FFmpeg" not found !\n\nInstall FFmpeg ?', title=VVUwmk)
   return
  fName, VVUwmk, url = self.VVOD9I(VVadS0)
  dest = os.path.join(CFG.MovieDownloadPath.getValue(), fName)
  self.m3u8_params = resp, VVadS0, dest, fName, VVUwmk, url
  rTxt = str(resp.text)
  rUrl = str(resp.url)
  if "#EXT-X-STREAM-INF" in rTxt:
   self.VVsf3Q(rTxt, rUrl)
  elif "#EXTINF:" in rTxt:
   if FFKbVo(dest) : FF6pUe(self.SELF, BF(self.VVAtd5, rTxt, rUrl), "Overwrite existing file ?\n\n%s" % dest, title=VVUwmk)
   else    : self.VVAtd5(rTxt, rUrl)
  else:
   self.VVJf3H("Cannot process m3u8 file !")
 def VVsf3Q(self, rTxt, rUrl):
  lst   = iFindall(r"RESOLUTION=(\d+x\d+).*\n(.+)", rTxt, IGNORECASE)
  VV9cxb = []
  for resol, fPath in lst:
   resol = str(resol).replace("x", " x ")
   fPath = str(fPath)
   fullUrl = CCTe4w.VVDU1U(rUrl, fPath)
   VV9cxb.append((resol, fullUrl))
  if VV9cxb:
   FFO9kU(self.SELF, self.VVRrNS, VV9cxb=VV9cxb, title="Resolution", VVDkqE=True, VVbdOY=True)
  else:
   self.VVJf3H("Cannot get Resolutions list from server !")
 def VVRrNS(self, item=None):
  if item:
   txt, resolUrl, ndx = item
   resp, VVadS0, dest, fName, VVUwmk, url = self.m3u8_params
   resol = txt.replace(" ", "")
   fPath, fExt = os.path.splitext(fName)
   fName = "%s_%s%s" % (fPath, resol, fExt)
   fPath, fExt = os.path.splitext(dest)
   dest = "%s_%s%s" % (fPath, resol, fExt)
   self.m3u8_params = resp, VVadS0, dest, fName, VVUwmk, url
   if FFKbVo(dest):
    FF6pUe(self.SELF, BF(FFvfpL, BF(self.VVQBO2, resolUrl)), "Overwrite existing file ?\n\n%s" % dest, title=VVUwmk)
   else:
    FFvfpL(BF(self.VVQBO2, resolUrl))
 def VVQBO2(self, resolUrl):
  resp, txt, err = CCr0nV.VVyFjr(resolUrl)
  if err : self.VVJf3H(err)
  else : self.VVAtd5(txt, resolUrl)
 def VVpn12(self, logF, VVadS0):
  found = False
  lines = CClaHD.VVutI8()
  with open(CClaHD.VVHuUR(), "w") as f:
   for line in lines:
    if CClaHD.VVWIVm(VVadS0, line):
     line = "%s,%s" % (logF, VVadS0)
     found = True
    f.write(line + "\n")
  if not found:
   with open(CClaHD.VVHuUR(), "a") as f:
    f.write("%s,%s\n" % (logF, VVadS0))
  self.VVluQ5()
  if self.VVAIxO:
   self.VVAIxO.VVbtl9()
 def VVAtd5(self, rTxt, rUrl):
  resp, VVadS0, dest, fName, VVUwmk, url = self.m3u8_params
  fName = FFDJVB(fName)
  dest  = FFDJVB(dest)
  m3u8File = os.path.join(CFG.MovieDownloadPath.getValue(), "%s.m3u8" % fName)
  with open(m3u8File, "w") as f:
   lines = rTxt.splitlines()
   for line in lines:
    line = line.strip()
    if line.startswith(("#EXTM", "#EXT-")) and not line.startswith("#EXT-X-ENDLIST"):
     f.write(line + "\n")
  lst = iFindall(r"(#EXTINF:.+)\n(.+)", rTxt, IGNORECASE)
  if lst:
   with open(m3u8File, "a") as f:
    for extInf, fPath in lst:
     extInf = str(extInf)
     fPath = str(fPath)
     fPath = CCTe4w.VVDU1U(rUrl, fPath)
     f.write(extInf + "\n")
     f.write(fPath + "\n")
    f.write("#EXT-X-ENDLIST\n")
  else:
   self.VVJf3H("Incorrect m3u8 file from server !")
   return
  logF = "%s.log" % m3u8File
  self.VVpn12(logF, VVadS0)
  cmd  = "ffmpeg -y -hide_banner -protocol_whitelist file,http,https,tcp,tls,crypto -i '%s' -c copy '%s' > '%s' 2>&1" % (m3u8File, dest, logF)
  cmd += " && %s" % FFQWwc("rm -f '%s' '%s'" % (m3u8File, logF))
  threadName = "%s{%s,,%s}%s" % (CClaHD.VVcmMY, dest, logF, VVadS0)
  myThread = iThread(name=threadName, target=BF(os.system, cmd))
  myThread.start()
 @staticmethod
 def VVDowb(dnldLog):
  if FFKbVo(dnldLog):
   dur = CClaHD.VViLAl(dnldLog)
   if dur > -1:
    tim = CClaHD.VVzgWN(dnldLog)
    if tim > -1:
     return float(tim) / float(dur) * 100
  elif FFKbVo(dnldLog[:-9]):
   return 100
  return -1
 @staticmethod
 def VViLAl(dnldLog):
  lines = FFQ1wB("head -n 15 %s" % dnldLog)
  for line in lines:
   span = iSearch(r"Duration:\s*(\d+):(\d+):(\d+.\d+)\s*", line, IGNORECASE)
   if span:
    return int(span.group(1)) * 3600 + int(span.group(2)) * 60 + float(span.group(3))
  return -1
 @staticmethod
 def VVzgWN(dnldLog):
  lines = FFQ1wB("tail -n 15 %s" % dnldLog)
  for line in reversed(lines):
   span = iSearch(r"time=\s*(\d+):(\d+):(\d+.\d+)\s*", line, IGNORECASE)
   if span:
    return int(span.group(1)) * 3600 + int(span.group(2)) * 60 + float(span.group(3))
  return -1
 def VVleTZ(self, url, fName):
  path = CFG.MovieDownloadPath.getValue()
  if FFgcYJ(url):
   span = iSearch(r"(.+)S\d\dE\d\d|(.+)Season_\d{1,2}_\d{1,2}", fName, IGNORECASE)
   if span:
    path1 = path + (span.group(1) or span.group(2)).strip("_(")
    FFlonU("mkdir '%s'" % path1)
    if VVkY7E(path1):
     return path1 + "/" + fName
  return path + fName
 def VVF6zm(self, threadName, url, VVadS0, path, resp, isAppend=False):
  totFileSize = int(self.VVAIxO.VVQDwi()[7])
  threadName = threadName.replace(",Sz,", ",%s," % totFileSize)
  myThread = iThread(name=threadName, target=BF(self.VVN5rc, url, VVadS0, path, resp, totFileSize, isAppend))
  myThread.start()
 def VVN5rc(self, url, VVadS0, path, resp, totFileSize, isAppend):
  totBytes = 0
  try:
   with open(path, "ab" if isAppend else "wb") as f:
    for chunk in resp.iter_content(chunk_size=8192):
     if FFKbVo(path):
      if chunk:
       try:
        f.write(chunk)
        self.VVPMA9(path)
       except:
        return
      if CClaHD.VVJKeO == path:
       CClaHD.VVJKeO = ""
       return
     else:
      break
  except Exception as e:
   if not self.VVE5Bm(path, e):
    return
  if CFG.downloadAutoResume.getValue():
   curSize = FFLjtI(path)
   if curSize > -1 and not curSize == totFileSize:
    params = self.VVwT7x(VVadS0, checkExist=False, resumeByte=curSize)
    if len(params) > 1:
     url, fSize, path, resp, resumable = params
     if resumable:
      self.VVN5rc(url, VVadS0, path, resp, totFileSize, True)
 def VVE5Bm(self, path, e):
  if "IncompleteRead" in str(e):
   now = iTime()
   cnt, tm = 0, now
   if path in CClaHD.VVXWFL:
    cnt, tm = CClaHD.VVXWFL[path]
    if cnt > 2 and now > tm + 3:
     self.VVPMA9(path)
     return False
    else:
     iSleep(1)
   self.VVHvot(path, cnt + 1, tm)
  return True
 def VVHvot(self, path, cnt, tm):
  CClaHD.VVXWFL[path] = (cnt, tm)
 def VVPMA9(self, path):
  if path in CClaHD.VVXWFL: CClaHD.VVXWFL.pop(path)
 def VVgrm7(self, VVAIxO, title, txt, colList):
  m3u8Log = colList[12].strip()
  VVadS0 = colList[9].strip()
  if       self.VVI4S8() : FFoTZI(self.VVAIxO, self.VVgEuU(self.VVH142), 500)
  elif not self.VV5C0S() : FFoTZI(self.VVAIxO, self.VVgEuU(self.VV0Two), 500)
  elif m3u8Log      : FF6pUe(self.SELF, self.VVutTw, "This may stop other non-resumable files !\n\nStop anyway ?", title="Stopping non-resumable download")
  else:
   if VVadS0 in self.VVmDoM():
    CClaHD.VVJKeO = colList[6]
    FFoTZI(self.VVAIxO, "Stopping ...", 1000)
   else:
    FFoTZI(self.VVAIxO, "Stopped", 500)
 def VVutTw(self, withMsg=True):
  if withMsg:
   FFoTZI(self.VVAIxO, "Stopping ...", 1000)
  FFlonU("killall -INT ffmpeg")
 def VV9srG(self, *args):
  if   self.VVI4S8() : FFoTZI(self.VVAIxO, self.VVgEuU(self.VVH142) , 500)
  elif self.VV5C0S() : FFoTZI(self.VVAIxO, self.VVgEuU(self.VVBBzn), 500)
  else:
   resume = False
   m3u8Log = self.VVAIxO.VVQDwi()[12]
   if m3u8Log:
    if FFKbVo(m3u8Log) : FF6pUe(self.SELF, BF(self.VVpKTa, m3u8Log), "Cannot resume m3u8 type !\n\nDelete file and restart download ?", title="Resume")
    else     : resume = True
   elif self.VVbly1():
    resume = True
   if resume: FF7iMz(self.VVAIxO, BF(self.VVfr8s), title="Checking Server ...")
   else  : FFoTZI(self.VVAIxO, "Cannot resume !", 500)
 def VVpKTa(self, m3u8Log):
  FFlonU("rm -f '%s' '%s' '%s'" % (m3u8Log, m3u8Log[:-4], m3u8Log[:-9]))
  FF7iMz(self.VVAIxO, BF(self.VVfr8s), title="Checking Server ...")
 def VVfr8s(self):
  colList  = self.VVAIxO.VVQDwi()
  path  = colList[6]
  size  = colList[7]
  VVadS0 = colList[9]
  if "j.php" in VVadS0:
   url = CCr0nV.VVULQ1(VVadS0)
   if url:
    VVadS0 = self.VVDwiJ(VVadS0, url)
   else:
    self.VVJf3H("Could not get download link !\n\nTry again later.")
    return
  curSize = FFLjtI(path)
  params = self.VVwT7x(VVadS0, checkExist=False, resumeByte=curSize)
  if len(params) == 1:
   self.VVJf3H(params[0])
   return
  elif len(params) == 2:
   self.VVD1ck(params[0], VVadS0)
   return
  url, fSize, path, resp, resumable = params
  if size == "-1":
   VVadS0 = self.VVDwiJ(VVadS0, url, fSize)
  threadName = "%s{%s,Sz,}%s" % (CClaHD.VVcmMY, path, VVadS0)
  if resumable: self.VVF6zm(threadName, url, VVadS0, path, resp, isAppend=True)
  else  : self.VVJf3H("Cannot resume from server !")
 def VVOD9I(self, VVadS0):
  span = iSearch(r"\?ext=(\..{3})", VVadS0)
  fileExt = CCTe4w.VVhriR(VVadS0) or (span.group(1) if span else "") or ".mp4"
  fixName = True
  url = fName = VVUwmk = ""
  tUrl = iSub(r"[&?]mode=.+end=", r"", VVadS0, flags=IGNORECASE)
  span = iSearch(r"(https?:\/\/.+\/(?:movie|series).+\/.+\/)(.+)(:.+)", tUrl, IGNORECASE)
  if span:
   url  = span.group(1)
   fName = span.group(2)
   VVUwmk = span.group(3)
  elif "j.php" in tUrl:
   span = iSearch(r"(.+j.php)(:.+)", tUrl, IGNORECASE)
   if span:
    url  = span.group(1)
    fName = "tmp"
    VVUwmk = span.group(2)
  elif "/play/" in VVadS0:
   span = iSearch(r"(.+)&mode.+&end=(:.+)", VVadS0, IGNORECASE)
   if span:
    url = span.group(1)
    VVUwmk = span.group(2)
   span = iSearch(r".+movie.php?.+stream=(.+\..{3,4})&.+", VVadS0, IGNORECASE)
   if span     : fName = span.group(1)
   elif fileExt == ".php" : fName = ".mkv" if ".mkv" in VVadS0 else ".mp4"
   else     : fName = fileExt
  elif "get_download_link" in VVadS0:
   span = iSearch(r"(.+)&mode.+chCm=(.+)&end=(:.+)", VVadS0, IGNORECASE)
   if span:
    url  = span.group(1)
    fName = os.path.basename(span.group(2))
    VVUwmk = span.group(3).replace(":", "_").strip("_")
    fixName = False
  elif "/timeshift/" in VVadS0:
   span = iSearch(r"(http.+\/timeshift\/.+(\..+)):(.+)(?:\s>>\s(.+))", VVadS0, IGNORECASE)
   if span:
    url, ext, VVUwmk, movNm = span.groups()
    fName = movNm + (ext or ".ts")
    fixName = False
  else:
   ok = False
   span = iSearch(r"(.+\/(.+.mp4).+m3u8).+:(.+)", VVadS0, IGNORECASE)
   if span:
    url  = span.group(1)
    fName = span.group(2)
    VVUwmk = span.group(3)
    fixName = False
    ok  = True
   if not ok:
    span = iSearch(r"(.+\/.+m3u8).*:(.+)", VVadS0, IGNORECASE)
    if span:
     url  = span.group(1)
     VVUwmk = span.group(2)
     fName = VVUwmk + fileExt
     fixName = False
     ok  = True
   if not ok and FFn8GR(VVadS0):
    span = iSearch(r"(.+)\?\:(.+)", VVadS0, IGNORECASE)
    if span:
     url  = span.group(1)
     VVUwmk = span.group(2)
     fName = VVUwmk + fileExt
     fixName = False
    else:
     span = iSearch(r"(.+):(.+)", VVadS0, IGNORECASE)
     if span:
      url  = span.group(1)
      VVUwmk = span.group(2)
      fName = VVUwmk + fileExt
      fixName = False
  if url and fName and VVUwmk:
   if fixName:
    mix  = fName + VVUwmk
    parts = mix.split(":", 1)
    fName = parts[0]
    VVUwmk = parts[1]
    fName = iSub(r"[?]play_token.+", r"", fName, flags=IGNORECASE)
    url += fName
   VVUwmk1 = VVUwmk.replace(" ", "_")
   fName = VVUwmk1 + "_" + fName.lstrip("_")
   fName = FFDJVB(fName)
   return fName, VVUwmk, url
  else:
   return "", "", ""
 def VVJf3H(self, txt):
  FFbBGq(self.SELF, txt, title=self.Title)
 def VVmDoM(self):
  thrListUrls = []
  for thr in iEnumerate():
   span = iSearch(r"%s(?:{.+})*(.+)" % CClaHD.VVcmMY, thr.name, IGNORECASE)
   if span:
    thrListUrls.append(span.group(1))
  return thrListUrls
 def VV5C0S(self):
  VVadS0 = self.VVAIxO.VVQDwi()[9]
  return VVadS0 in self.VVmDoM()
 def VVI4S8(self):
  colList = self.VVAIxO.VVQDwi()
  path = colList[6]
  size = colList[7]
  m3u8Log = colList[12]
  if m3u8Log:
   return FFKbVo(m3u8Log[:-9]) and not FFKbVo(m3u8Log)
  else:
   if size == "-1" : return False
   else   : return str(FFLjtI(path)) == size
 def VVbly1(self):
  colList = self.VVAIxO.VVQDwi()
  path = colList[6]
  size = int(colList[7])
  curSize = FFLjtI(path)
  if curSize > -1:
   size -= curSize
  err = CClaHD.VVdHXH(size)
  if err:
   FFbBGq(self.SELF, err, title=self.Title)
   return False
  return True
 def VVjGLG(self, list):
  with open(CClaHD.VVHuUR(), "w") as f:
   for line in list:
    f.write(line + "\n")
 def VVDwiJ(self, VVadS0, newUrl, newSize=-1):
  found = False
  lines = CClaHD.VVutI8()
  url = VVadS0
  with open(CClaHD.VVHuUR(), "w") as f:
   for line in lines:
    if CClaHD.VVWIVm(VVadS0, line):
     parts = line.split(",", 1)
     oldUrl = parts[1].strip()
     if newSize and not newSize == -1: fSize = str(newSize)
     else       : fSize = parts[0]
     ndx = url.find("j.php")
     if ndx > -1:
      url = newUrl + url[ndx + 5:]
     line = "%s,%s" % (fSize, url)
     found = True
    f.write(line + "\n")
  if found:
   self.VVluQ5()
  return url
 @staticmethod
 def VVutI8():
  list = []
  if FFKbVo(CClaHD.VVHuUR()):
   for line in FF2kXa(CClaHD.VVHuUR()):
    line = line.strip()
    if line:
     list.append(line)
  return list
 @staticmethod
 def VVWIVm(VVadS0, line):
  span = iSearch(r"(mode=.+end=.+)", VVadS0, IGNORECASE)
  if span: VVadS0 = span.group(1)
  span = iSearch(r"(mode=.+end=.+)", line, IGNORECASE)
  if span: line = span.group(1)
  return VVadS0 in line
 @staticmethod
 def VVdHXH(size, path=""):
  dest = path or CFG.MovieDownloadPath.getValue()
  if VVkY7E(dest):
   free = CC17eA.VVj8Uc(dest)
   if free > size : return ""
   else   : return "No enough space on mount for:\n%s\n\nFile Size = %s\nFree Space = %s" % (dest, CC17eA.VVxNgx(size), CC17eA.VVxNgx(free))
  else:
   return "Path not found !\n\n%s" % dest
 @staticmethod
 def VV114F(SELF):
  tot = CClaHD.VVTYUj()
  if tot:
   FFbBGq(SELF, "Cannot change while downloading.", title="")
   return True
  else:
   return False
 @staticmethod
 def VVTYUj():
  c = 0
  for thr in iEnumerate():
   if thr.name.startswith(CClaHD.VVcmMY):
    c += 1
  return c
 @staticmethod
 def VVwIzh():
  lst = []
  for thr in iEnumerate():
   span = iSearch(r"%s(?:{(.+),(.*),(.*)}).+" % CClaHD.VVcmMY, thr.name, IGNORECASE)
   if span:
    lst.append((span.group(1), span.group(2), span.group(3)))
  return lst
 @staticmethod
 def VVyZwz():
  return len(CClaHD.VVutI8()) == 0
 @staticmethod
 def VVPfXE():
  list = []
  for p in harddiskmanager.getMountedPartitions():
   list.append(p.mountpoint)
  return list
 @staticmethod
 def VVIkTW():
  mPoints = CClaHD.VVPfXE()
  list = []
  for mPath in mPoints:
   if not mPath == "/":
    path = mPath + "/movie/"
    if VVkY7E(path) : return path
    else    : list.append(mPath)
  drives = ("/hdd", "/usb", "/sd")
  for mPath in list:
   if any(x in mPath for x in drives):
    path = mPath + "/movie/"
    FFlonU("mkdir '%s'" % path)
    if VVkY7E(path):
     return path
  return "/tmp/"
 @staticmethod
 def VVHuUR():
  return FFJv8S() + "ajpanel_downloads"
 @staticmethod
 def VVRi6O(SELF, waitMsgObj=None):
  FF7iMz(waitMsgObj or SELF, BF(CClaHD.VVP2eW, SELF, CClaHD.VVq8Us))
 @staticmethod
 def VVmKPJ(SELF):
  CClaHD.VVP2eW(SELF, CClaHD.VVmTlG, startDnld=True)
 @staticmethod
 def VVuNb5(SELF, url):
  CClaHD.VVP2eW(SELF, CClaHD.VVmTlG, startDnld=True, VVadS0=url)
 @staticmethod
 def VVcinb(SELF):
  added, skipped = CClaHD.VVSjKX([CCZv30(SELF.session).VVadS0])
  FFxHED(SELF, "Added", 1000)
 @staticmethod
 def VVSjKX(list):
  added = skipped = 0
  for line in CClaHD.VVutI8():
   for ndx, url in enumerate(list):
    if url and CClaHD.VVWIVm(url, line):
     skipped += 1
     list[ndx] = ""
     break
  with open(CClaHD.VVHuUR(), "a") as f:
   for url in list:
    if url:
     added += 1
     f.write("-1,%s\n" % url)
  return added, skipped
 @staticmethod
 def VVP2eW(SELF, mode, startDnld=False, VVadS0=""):
  title = "Download Manager"
  if not CC6V53.VVZTHq(SELF):
   return
  if mode == CClaHD.VVq8Us and CClaHD.VVyZwz():
   FFbBGq(SELF, "Download list is empty !", title=title)
  else:
   inst = CClaHD(SELF, mode, title, startDnld=startDnld, VVadS0=VVadS0)
 @staticmethod
 def VVRXW0(res):
  if res.status_code == 206:
   return True
  else:
   hResume = res.headers.get("Accept-Ranges" , "")
   if hResume and not hResume == "none":
    return True
  return False
 @staticmethod
 def VVmPDA(url, timeout=3):
  err = ""
  try:
   import requests
   res = requests.get(url, headers=CCTe4w.VVFbRP(), allow_redirects=True, timeout=timeout)
   if res.ok:
    return res, ""
   else:
    if res.status_code == 407: reason = "Proxy Authentication Required"
    if res.status_code == 423: reason = "Access Locked"
    if res.status_code == 521: reason = "Server Is Down"
    else      : reason = "Unknown"
    err = "Err-%d : %s" % (res.status_code, res.reason or reason)
  except Exception as e    : err = "Error\n" + str(e)[:120]
  return "", err
class CCfPHj():
 def __init__(self, SELF, url, path, title, pbTxt="", cbFnc=None, timeout=3, showRes=True):
  self.SELF  = SELF
  self.url  = url
  self.Path  = path
  self.Title  = title
  self.pbTxt  = pbTxt or "Checking File Size ..."
  self.cbFnc  = cbFnc
  self.timeout = timeout
  self.showRes = showRes
  self.webFile = ""
  self.webSize = ""
  self.err  = ""
  self.done  = False
  Dir = os.path.dirname(path)
  if not VVkY7E(Dir):
   FFbBGq(SELF, "Path does not exist:\n\n%s" % Dir, title)
   return
  CCV3Gw.VVgWD3(SELF, titleBg="#22110011", bodyBg="#22110011", barBg="#06117722"
      , VVuSHu  = self.VVuP4X
      , VVhK3C = self.VVWsrL)
 def VVuP4X(self, VVqeT6):
  VVqeT6.VVX5nT(self.pbTxt)
  fSize = wSize = 0
  err = ""
  try:
   import requests
   resp = requests.get(self.url, headers=CCTe4w.VVFbRP(), timeout=self.timeout, stream=True, verify=True)
   if not resp.ok:
    if resp.reason : self.err = "Err-%d : %s" % (resp.status_code, resp.reason)
    else   : self.err = "Cannot download data from server"
    return
   head  = resp.headers
   cType = head.get("Content-Type", "")
   if "stream" in cType:
    fSize = head.get("Content-Length", "")
    fSize = int(fSize) if fSize.isdigit() else 0
   if not fSize: wSize = wSize = 200 * 1000 * 1000
   cont  = head.get("content-disposition", "")
   span  = iSearch(r'filename=["*](.+)["*]', str(cont), IGNORECASE)
   self.webFile = span.group(1) if span else ""
  except requests.Timeout as e  : err = "Connection Timeout (> %s sec)" % self.timeout
  except requests.ConnectionError as e: err = "Connection Error"
  except Exception as e    : err = "Error\n" + str(e)[:120]
  if not VVqeT6 or VVqeT6.isCancelled:
   return
  if err:
   self.err = err
   return
  self.webSize = fSize or wSize
  if not self.webSize:
   self.err = "Cannot get size from server !"
   return
  err = CClaHD.VVdHXH(self.webSize)
  if err:
   self.err = err
   return
  if not VVqeT6 or VVqeT6.isCancelled: return
  VVqeT6.VVfT17(self.webSize)
  VVqeT6.VVX5nT("Downloading (%s) ..." % CC17eA.VVxNgx(self.webSize, mode=4))
  totBytes = 0
  try:
   with open(self.Path, "wb") as f:
    for chunk in resp.iter_content(chunk_size=8192):
     if not FFKbVo(self.Path):
      self.err = "Cannot access file:\n\n%s" % self.Path
      return
     if not VVqeT6 or VVqeT6.isCancelled:
      self.err = "Download Cancelled"
      return
     if chunk:
      try:
       f.write(chunk)
       VVqeT6.VVqE9L(len(chunk))
      except:
       self.err = "Cannot write to file:\n\n%s" % self.Path
       return
  except Exception as e:
   self.err = str(e)
 def VVWsrL(self, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  if self.showRes:
   perc = int(100.0 * threadCounter / threadTotal) if threadTotal else 0
   path = self.Path if FFKbVo(self.Path) else ""
   if not VV6ZvL:
    if path:
     if self.cbFnc: self.cbFnc(VV6ZvL, self.url, self.webFile, self.Path)
     else   : FFbBGq(self.SELF, "Download cancelled (at %s%%) in:\n\n%s" % (perc, path) if path else ".", self.Title)
   elif self.err:
    FFbBGq(self.SELF, self.err + (" (at %s%%) in:\n\n%s" % (perc, path) if path else ""), self.Title)
   elif self.cbFnc:
    self.cbFnc(VV6ZvL, self.url, self.webFile, self.Path)
   else:
    FF0onH(self.SELF, "Successfully downloaded to:\n\n%s" % path, self.Title)
class CCKlQq():
 def __init__(self, SELF):
  self.SELF   = SELF
  self.VV3lLb = False
  self.scrW, self.scrH = FFcBkL()
  self.X, self.Y, self.W, self.H = FFJaib(self.SELF)
 def VVnCGf(self, x, y): self.SELF.instance.move(ePoint(x, y))
 def VV5TSa(self, w, h): self.SELF.instance.resize(eSize(*(w, h)))
 def VVL1J1(self, fnc=None):
  self.VVnCGf(self.X, self.Y)
  self.VV5TSa(self.W, self.H)
  self.VV3lLb = False
 def VVSFIH(self, up):
  if self.VV3lLb: return
  self.VV3lLb = True
  origY = -(self.Y + self.H) if up else self.scrH
  self.VVnCGf(self.X, origY)
  self.SELF.show()
  self.VVeH20(up)
 def VVeH20(self, up):
  y = self.SELF.instance.position().y() + (20 if up else -20)
  if up and y < self.Y or not up and y > self.Y:
   self.VVnCGf(self.X, y)
   FFvfpL(BF(self.VVeH20, up))
  else:
   self.VVL1J1()
 def VV1PP3(self, up):
  if self.VV3lLb: return
  self.VV3lLb = True
  self.VV7Kgs(up)
 def VV7Kgs(self, up):
  y = self.SELF.instance.position().y() + (-20 if up else 20)
  if up and y > -(self.Y + self.H) or not up and y < self.scrH:
   self.VVnCGf(self.X, y)
   FFvfpL(BF(self.VV7Kgs, up))
  else:
   self.SELF.hide()
   self.VVL1J1()
 def VVBEC5(self):
  if self.VV3lLb: return
  self.VV3lLb = True
  self.VVj68u()
 def VVj68u(self):
  x, y, w, h = FFJaib(self.SELF)
  x += 70
  w -= 140
  if w > 1:
   self.VV5TSa(w, h)
   self.VVnCGf(x, y)
   FFvfpL(self.VVj68u)
  else:
   self.SELF.close()
   self.VV3lLb = False
class CCsmqb(Screen, CCzLyd):
 VVfMBZ = None
 def __init__(self, session, VVinUd=True, VVu1kk=None, VVyhra=True, VVNO3H=True, VV9m2C=False, VVdxJv="", endRef="", zapFnc=None, VVHkge="", cbFnc=None, VVYqW3=0):
  self.skin, self.VVmNvK = FFQaOH(VVLJjn, 1600, 190, 28, 10, 6, "#1100202a", "#1100202a", 24, VVcmdl=2)
  CCzLyd.__init__(self)
  self.session    = session
  self.VVinUd   = VVinUd
  self.VVu1kk  = VVu1kk
  self.VVyhra  = VVyhra
  self.VVNO3H  = VVNO3H
  self.VV9m2C  = VV9m2C
  self.VVdxJv    = VVdxJv
  self.endRef     = endRef
  self.zapFnc     = zapFnc
  self.VVHkge    = VVHkge
  self.cbFnc     = cbFnc
  self.VVYqW3   = VVYqW3
  self.Title     = ""
  self.VVdosY    = "Catch-up"
  self.resetMediaTxt   = 'You can restart media with "<" Button'
  self.VVkgv1    = eTimer()
  self.VVkHZZ    = 250
  self.VVYv49   = int(CFG.playerTimeout.getValue()) * 1000
  self.VVIpws   = 0
  self.barWidth    = 0
  self.VVSwLg    = 0
  self.VVso3m   = False
  self.VVAcEx   = 0
  self.VViohc   = 0
  self.VVC1po   = CFG.playerJumpMin.getValue()
  self.VVoraF    = 0
  self.VV2JZb    = ""
  self.VVPlaL   = 0
  self.VVbXKX  = 0
  self.VV7lpx   = None
  self.VViNvh  = False
  self.VVpX0O    = False
  self.VVzFCw  = ""
  self.VVJvnX   = False
  self.tpData     = CCrDr0()
  self.tunerInfo    = CCKQEu()
  self.VV9BAq   = None
  self.VVyKkC   = ("", "", 0)
  self.lastPIconPath   = None
  self.animate    = None
  FFNhKZ(self, "")
  self["myPlayBarF"] = Label()
  self["myPlayBarBG"] = Label()
  self["myPlayBar"] = Label()
  self["myPlayMov"] = Label()
  self["myPlayVal"] = Label()
  self["myPlayPos"] = Label()
  self["myPlaySkp"] = Label()
  self["myPlayMsg"] = Label()
  self["myPlayRem"] = Label()
  self["myPlayDur"] = Label()
  self["myPlaySep"] = Label()
  self["myPlayGrn"] = Label("Refresh")
  self["myPlayJmp"] = Label(self.VVHtpR())
  self["myPlayDat"] = Label("")
  self["myPlayTim"] = Label("")
  self["myPlayRes"] = Label("")
  self["myPlayFps"] = Label()
  self["myPlayAsp"] = Label()
  self["myPlayYel"] = Label("")
  self["myPlayBlu"] = Label("Cut-List")
  self["myPlayTyp"] = Label()
  self["myPlayPic"] = Pixmap()
  for nm in ( "myPlayCc", "myPlayAud", "myPlayDnld", "myPlayRpt"):
   self[nm] = Pixmap()
   self[nm].hide()
  color = self.VVmNvK["VViaEk"]
  nms = ("SNR", "AGC", "BER")
  for nm in nms: self["mySliderTxt%s" % nm] = Label(nm)
  for nm in nms: self["mySliderFrm%s" % nm] = Label()
  for nm in nms: self["mySliderBak%s" % nm] = Label()
  for nm in nms: self["mySliderCov%s" % nm] = Label()
  for nm in nms: self["mySliderPic%s" % nm] = Pixmap()
  self.sliderSNR = CCuNHD(self, self["mySliderPicSNR"], self["mySliderCovSNR"], minN=0, maxN=100, covColor=color)
  self.sliderAGC = CCuNHD(self, self["mySliderPicAGC"], self["mySliderCovAGC"], minN=0, maxN=100, covColor=color)
  self.sliderBER = CCuNHD(self, self["mySliderPicBER"], self["mySliderCovBER"], minN=0, maxN=100, covColor=color)
  FFrM8n(self,
  {
   "ok"  : self.VVyuDa       ,
   "info"  : self.VVVDQu      ,
   "epg"  : self.VVVDQu      ,
   "pvr"  : self.VVbZfo     ,
   "menu"  : self.VVEDpa     ,
   "cancel" : self.cancel       ,
   "red"  : self.VVW3gz   ,
   "green"  : self.VV1Pzu  ,
   "blue"  : self.VVBspP      ,
   "yellow" : self.VV9Jbl ,
   "left"  : BF(self.VVD4P1, -1)    ,
   "right"  : BF(self.VVD4P1,  1)    ,
   "longPlay" : self.VVwFS6    ,
   "play"  : self.VVntNj      ,
   "pause"  : self.VVntNj      ,
   "playPause" : self.VVntNj      ,
   "stop"  : self.VVntNj      ,
   "stopLong" : self.VVxgET     ,
   "powerLong" : self.VVxgET     ,
   "rewind" : self.VVXrpH      ,
   "forward" : self.VVwtWY      ,
   "rewindDm" : self.VVXrpH      ,
   "forwardDm" : self.VVwtWY      ,
   "last"  : self.VVHmjO      ,
   "next"  : self.VV3Bp5      ,
   "pageUp" : BF(self.VVlWRP, True)  ,
   "pageDown" : BF(self.VVlWRP, False)  ,
   "chanUp" : BF(self.VVlWRP, True)  ,
   "chanDown" : BF(self.VVlWRP, False)  ,
   "up"  : BF(self.VVlWRP, True)  ,
   "down"  : BF(self.VVlWRP, False)  ,
   "audio"  : BF(self.VVNXrm, True)  ,
   "subtitle" : BF(self.VVNXrm, False)  ,
   "text"  : self.VVVe7W  ,
   "0"   : BF(self.VVRgyC , 10)   ,
   "1"   : BF(self.VVRgyC , 1)   ,
   "2"   : BF(self.VVRgyC , 2)   ,
   "3"   : BF(self.VVRgyC , 3)   ,
   "4"   : BF(self.VVRgyC , 4)   ,
   "5"   : BF(self.VVRgyC , 5)   ,
   "6"   : BF(self.VVRgyC , 6)   ,
   "7"   : BF(self.VVRgyC , 7)   ,
   "8"   : BF(self.VVRgyC , 8)   ,
   "9"   : BF(self.VVRgyC , 9)
  })
  self.onShown.append(self.VVf1Ra)
  self.onClose.append(self.onExit)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  FFeo1z(self)
  for b in ("myPlayGrn", "myPlayYel", "myPlayBlu"):
   FF0u5o(self[b], "#000000", 3)
  if not CCsmqb.VVfMBZ:
   CCsmqb.VVfMBZ = self
  for k, v in {"myPlayCc": "cc1", "myPlayAud": "aud", "myPlayDnld": "dnld", "myPlayRpt": "rpt"}.items():
   FFHTca(self[k], v)
  self.sliderSNR.VV8Xds()
  self.sliderAGC.VV8Xds()
  self.sliderBER.VV8Xds(isBER=True)
  self.VV6APK()
  self.instance.move(ePoint(40, 40))
  self.VV9gZO(CFG.playerPos.getValue())
  self["myPlayMov"].hide()
  self["myPlaySkp"].hide()
  size = self["myPlayBar"].instance.size()
  self.barWidth = int(size.width())
  self.VVSwLg = int(size.height())
  self["myPlayBar"].instance.resize(eSize(*(1, self.VVSwLg)))
  try: self.VVkgv1_conn = self.VVkgv1.timeout.connect(self.VVWgjO)
  except: self.VVkgv1.callback.append(self.VVWgjO)
  self.VVkgv1.start(self.VVkHZZ, False)
  seekSt, chSt, chStTxt = self.VVInEX()
  self.VVWgjO("" if seekSt == "Playing" else "Checking ...")
  if self.VVdxJv:
   VVq9SN, VVadS0, VVjgtq, VVVmGQ, VVUwmk = FFLlAM(self)
   if self.VVdxJv != VVq9SN + ":" + VVjgtq:
    self.VVQAoA(self.VVdxJv, "Starting Service ...")
    return
  if not self.VVu1kk:
   self.VVrDmD()
 def VV1Pzu(self):
  if not self["myPlayGrn"].getVisible():
   return
  VVq9SN, VVadS0, VVjgtq, VVVmGQ, VVUwmk = FFLlAM(self)
  self.VV7lpx = CCSLfI.VVhC0D()
  p = CCr0nV()
  valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVjhBj(VVadS0)
  if "chCode" in VVVmGQ and not "deviceMac=" in chCm:
   if CC6V53.VVZTHq(self):
    self.VVrDmD(True)
  else:
   self.VVWgjO("Refreshing ...")
   self.VViNvh = True
   FFvfpL(BF(CC2Ekb.VVIMKA, self.session))
  FFvfpL(self.VV6APK)
 def VV8nrA(self, VVadS0):
  data = CCTe4w.VV6qyz(VVadS0)
  if data and (not self.VVzFCw or data != self.VVzFCw):
   iThread(name="ajp_catchup", target=BF(self.VVNTrF, data)).start()
 def VVNTrF(self, data):
  uHost, uUser, uPass, uId, VVUwmk = data
  if all([uHost, uUser, uPass, uId]) and CC9qM0.VVQ0uB():
   pList, err = CCTe4w.VVpUIe("%s/player_api.php?username=%s&password=%s" % (uHost, uUser, uPass), uId, mode=0)
   if pList:
    self.VVzFCw = data
    self.VVJvnX = True
 def VV6APK(self):
  self.VV2JZb = ""
  self.VVzFCw = None
  self.VVJvnX  = False
  self.VVuDK2()
  s = self.VVvNzw()
  if self.VV9m2C:
   self.VVJvnX = True
  elif s._prov in ("Playlist", "Portal") and not FFn8GR(s.VVadS0):
   FFdBYP(self, 1500, BF(self.VV8nrA, s.VVadS0))
  s.VVUwmk = FFkEjh(s.VVUwmk)
  if s.VVq9SN or s.VVUwmk: self.Title = s.VVUwmk.replace("\n", " > ")
  else     : self.Title = VVU4M8 + "No Service !"
  self["myTitle"].setText("  " + self.Title + "  ")
  FFgLA9(self["myTitle"], s._tColor)
  FFgLA9(self["myBody"], s._tColor)
  for item in ("Pos", "Skp", "Msg", "Rem", "Dur", "Jmp", "Dat", "Tim", "Res", "Fps", "Asp", "Pic", "Typ", "Yel"):
   FFgLA9(self["myPlay%s" % item], s._tColor)
  FFMhbx(self["myPlayYel"], "#0080dddd" if s.isDvb else "#00cccccc")
  for nm in ("SNR", "AGC", "BER"):
   FFgLA9(self["mySliderTxt%s" % nm], s._tColor)
  if s._prov == "Others" : self["myPlayGrn"].hide()
  else     : self["myPlayGrn"].show()
  picFile = self.VVHkge
  if not FFKbVo(picFile):
   if not iMatch(r"^\d*:(0:){9}\/.+", s.VVq9SN):
    picFile = CCpebE.VVQUv3(s.VVq9SN)
    if not FFKbVo(picFile):
     picFile = CCpebE.VVQUv3(s.VVHK1O)
  if not FFKbVo(picFile):
   fPath, fDir, fName, picFile = CCpebE.VVTeST(self)
  if not FFKbVo(picFile):
   pPath = CCRGqC.VV5G3P()
   picFile = CCRGqC.VVm9vg(pPath, s.VVq9SN, s.VVUwmk)
  if picFile != self.lastPIconPath:
   self["myPlayTyp"].setText(s.streamType)
   self.lastPIconPath = picFile
   self["myPlayPic"].hide()
   self["myPlayTyp"].show()
   if os.path.isfile(picFile) and FFZ27n(self["myPlayPic"], picFile, VVYCun=s._tColor):
    self["myPlayPic"].show()
    self["myPlayTyp"].hide()
 def VVWgjO(self, stateTxt="", highlight=False):
  if self.VVYv49:
   if self.shown:
    self.VVIpws += self.VVkHZZ
    if self.VVIpws >= self.VVYv49:
     self.VVMoD3()
   else:
    self.VVIpws = 0
  now = datetime.now()
  self["myPlayDat"].setText(now.strftime("%Y-%m-%d"))
  self["myPlayTim"].setText(now.strftime("%H:%M:%S"))
  if CClaHD.VVTYUj() : self["myPlayDnld"].show()
  else         : self["myPlayDnld"].hide()
  s = self.VVvNzw()
  tTitle = self.Title
  if s._prov == self.VVdosY and " >> " in s.VVUwmk:
   ch, _, ev = s.VVUwmk.partition(" >> ")
   ch, ev = ch.strip(), ev.strip()
   if ch and ev:
    tTitle, s._evName = ch, ev
  if s._evName:
   s._evName = "    %s    " % FFKrMM(s._evName, VV0p9P)
  self["myTitle"].setText("  %s%s  " % (tTitle, s._evName))
  self["myPlayYel"].setText(s._prov)
  if s._prov == self.VVdosY or self.VVJvnX:
   FFPvX5(self["myPlayYel"], "#00ffffff", "#11a08000", inv=False)
  if s._seekable and s._durVal > 60:
   self["myPlayBlu"].show()
   self["myPlayJmp"].show()
  else:
   self["myPlayBlu"].hide()
   self["myPlayJmp"].hide()
  if s.isDvb or s.VVHK1O:
   self.tunerInfo.VVeXSX(s.servPtr)
   if self.tunerInfo.infoAvailable:
    self.sliderSNR.VVYLvJ(self.tunerInfo.VV86et())
    self.sliderAGC.VVYLvJ(self.tunerInfo.VVKqPT())
    self.sliderBER.VVYLvJ(self.tunerInfo.VV6ouN())
  if not self.VVso3m:
   player = CCTe4w.VVAJ06(s.VVq9SN)
   if player:
    self["myPlaySkp"].show()
    self["myPlaySkp"].setText(VV3Hcc + player)
   else:
    self["myPlaySkp"].hide()
  self["myPlayRes"].setText(s._res)
  self["myPlayFps"].setText(s._fr)
  self["myPlayAsp"].setText(s._ratio)
  self["myPlayPos"].setText(s._posTxt if s._posTxt else "")
  self["myPlayVal"].setText(s._percTxt if s._percTxt else "")
  self["myPlayRem"].setText("-%s" % s._remTxt if s._remTxt else "")
  self["myPlayDur"].setText(s._durTxt if s._durTxt else "")
  if s._durTxt:
   FFgLA9(self["myPlayBarBG"], "#11000000")
   self["myPlayBarBG"].show()
   self["myPlayBarF"].show()
   self["myPlayBar"].show()
   width = 0
   percent = FFbn8W(s._percVal, 0, 100)
   width = int(FFel7I(percent, 0, 100, 0, self.barWidth))
   self["myPlayBar"].instance.resize(eSize(*(width, self.VVSwLg)))
  else:
   self["myPlayBarBG"].hide()
   self["myPlayBarF"].hide()
   self["myPlayBar"].hide()
   self["myPlayVal"].setText(">>>>")
   FFgLA9(self["myPlayBarBG"], s._tColor)
  self.VVROcd()
  if stateTxt:
   if highlight: FFMhbx(self["myPlayMsg"], "#0000ffff")
   else  : FFMhbx(self["myPlayMsg"], "#00ffaa00")
   self["myPlayMsg"].setText(stateTxt)
   self.VVoraF = iTime()
  if self.VVoraF and iTime() - self.VVoraF < 1:
   return
  else:
   self.VVoraF = 0
   FFMhbx(self["myPlayMsg"], "#00ffaa00")
   self["myPlayMsg"].setText(s._state)
  if s.VVlAIM or s.VVHK1O:
   FFMhbx(self["myPlayMsg"], "#00ffaaff")
   txt = "Stream Relay"
   if len(self.VV2JZb) > 1: txt = "%s - %s%s" % (txt, VVCQUS, self.VV2JZb)
   self["myPlayMsg"].setText(txt)
  elif s.isDvb:
   FFMhbx(self["myPlayMsg"], "#00aaaaaa")
   self["myPlayMsg"].setText(self.VV2JZb)
  stateTxt = ""
  chkResume = False
  seekSt, chSt, chStTxt = self.VVInEX()
  if seekSt:
   stateTxt = seekSt
   if s._percVal == 100:
    stateTxt = "End"
    self.VVuDK2()
    if self.VVpX0O:
     self.VVHmjO()
   elif seekSt == "Playing":
    if s._posTxt:
     chkResume = True
    elif chSt == CCsyJ5.VVoJfl and s.isIptv and s.VVq9SN.startswith("1:"):
     stateTxt = seekSt
    else:
     stateTxt = "%sWaiting for state change ..." % (("State: %s - " % chStTxt) if chStTxt else "")
  if chSt == CCsyJ5.VVoJfl:
   Id, rt, sIcon = self.VVyKkC
   if (s.uniqueId, s.refType) != (Id, rt):
    sIcon = CCpebE.VVRgsO()
    self.VVyKkC = (s.uniqueId, s.refType, sIcon)
    if sIcon > 0:
     FFHTca(self["myPlayCc"], "cc%s" % sIcon)
     self["myPlayCc"].show()
    else:
     self["myPlayCc"].hide()
    if CCpebE.VVJKB2(self.session) > 1 : self["myPlayAud"].show()
    else             : self["myPlayAud"].hide()
  if not s._seekable and not s.isIptv:
   return
  if chkResume:
   if not self.VViNvh:
    self.VVPlaL = s._posVal
   elif not s._durVal:
    self.VViNvh = False
   else:
    if self.VVPlaL > 0:
     move = end = False
     s1 = "." * self.VVbXKX
     stateTxt = ("%s Restoring Posistion %s" % (s1, s1)).strip()
     self.VVbXKX += 1
     diff = abs(s._posVal - self.VVPlaL)
     if   diff < 10     : end = True
     elif self.VVbXKX == 1: move = True
     elif self.VVbXKX >= 10:
      if diff > 10:
       move = True
      end = True
     if move and CFG.resumeMovies.getValue() == "off":
      self.VVu9HH(self.VVPlaL * 90000.0)
     if end:
      self.VVbXKX = 0
      self.VViNvh = False
      CCSLfI.VVV5ny(self.VV7lpx)
    else:
     self.VViNvh = False
  bufS = self.VVJyPR()
  if bufS:
   stateTxt = bufS
  FFMhbx(self["myPlayMsg"], "#0000ff00" if stateTxt == "Playing" else "#00FF8F5F" )
  self["myPlayMsg"].setText(stateTxt)
 def VVvNzw(self):
  s = CCZv30(self.session)
  s._state = s.state.replace("*", "") or "No system info"
  s._seekable, s._percVal, s._durVal, s._posVal, s._remVal, s._percTxt, s._durTxt, s._posTxt, s._remTxt = CCsmqb.VVKbqb(self)
  s._VVrpMg = "chCode" in s.VVadS0
  s._VVsJsu = CCTe4w.VV9FBH(s.VVadS0)
  s._VVu1Ls = "/timeshift/" in s.VVadS0
  iptv   = s.isIptv or "http" in s.VVadS0
  if   s.isDvb  : s._tColor, cat = "#1100102a", "DVB"
  elif s.isLocal  : s._tColor, cat = "#0a401100", "Local Media"
  elif s._VVrpMg : s._tColor, cat = "#1120002a", "Portal"
  elif s.isFtp  : s._tColor, cat = "#11222222", "FTP"
  elif s._VVu1Ls : s._tColor, cat = "#11223322", self.VVdosY
  elif s._VVsJsu : s._tColor, cat = "#11001c1c", "Playlist"
  elif s.VVlAIM  : s._tColor, cat = "#11223344", "S. Relay"
  elif iptv   : s._tColor, cat = "#11113030", "IPTV"
  else    : s._tColor, cat = "#11111111", "Others"
  s._prov = self.VVdosY if self.VVJvnX else (s.prov or cat)
  if (s.isDvb or s.VVHK1O) and not self.VV2JZb:
   self.VV2JZb = self.tpData.VVFuAx([s.VVq9SN, s.VVHK1O], nonTxt="-")
  for nm1 in ("Txt", "Frm", "Cov", "Bak", "Pic"):
   for nm2 in ("SNR", "AGC", "BER"):
    if s.isDvb or s.VVHK1O : self["mySlider%s%s" % (nm1, nm2)].show()
    else      : self["mySlider%s%s" % (nm1, nm2)].hide()
  s._evName = s._evNameNext = ""
  evLst = CCtAi7.VVvcx2(s.VVq9SN)
  if evLst:
   s._evName, evShort, evDesc, genre, PR, evTime, evTimeTxt, evDur, evDurTxt, evEnd, evEndTxt, evPos, evPosTxt, evRem, evRemTxt, evCom, evComTxt = evLst[0]
   if not s._durVal:
    if len(evLst) > 1:
     s._evNameNext = evLst[1][0]
    if evPos >= evDur:
     s._percVal = 100
     percTxt = "%d %%" % s._percVal
    else:
     s._percVal = float(evPos) * 100.0 / float(evDur)
     percTxt = "%.2f %%" % s._percVal
    s._posVal, s._remVal, s._percTxt, s._durTxt, s._posTxt, s._remTxt = evPos, evRem, percTxt, evDurTxt, evPosTxt, evRemTxt
  s._res = CCpebE.VVBoCX(s.info)
  s._fr, rate = "", FFbhVV(s.info, iServiceInformation.sFrameRate)
  if rate.isdigit() and not rate == "0":
   s._fr = "%d fps" % (int(rate) / 1000)
  s._ratio = CCpebE.VV7pIH(s.info)
  return s
 @staticmethod
 def VVKbqb(SELF):
  percVal = durVal = posVal = remVal = seekable = 0
  percTxt = durTxt = posTxt = remTxt = ""
  isEnded = False
  try:
   service = SELF.session.nav.getCurrentService()
   if service:
    pSeek = service.seek()
    if pSeek:
     seekable = pSeek.isCurrentlySeekable()
     durLst  = pSeek.getLength()
     posLst  = pSeek.getPlayPosition()
     if durLst[0] == 0:
      durVal = durLst[1] / 90000.0
      if durVal:
       durTxt = FFrTEd(durVal)
     if posLst[0] == 0:
      posVal = posLst[1] / 90000.0
      posTxt = FFrTEd(posVal)
     if durVal > 0 and posVal > 0:
      remVal = durVal - posVal + 1
      remTxt = FFrTEd(remVal)
     if durVal > 0:
      if round(posVal) >= int(durVal):
       percVal = 100
       percTxt = "%d %%" % percVal
       posVal = durVal
       posTxt = durTxt
       remTxt = ""
      else:
       percVal = float(posVal) * 100.0 / float(durVal)
       percTxt = "%.2f %%" % percVal
  except:
   pass
  return seekable, percVal, durVal, posVal, remVal, percTxt, durTxt, posTxt, remTxt
 def VVEDpa(self):
  s = self.VVvNzw()
  VV9cxb = []
  c1, c2, c3, c4 = VVU4M8, VVk4x7, VVv8b8, VVWH8U
  VV9cxb.append(("Service Info.", "info"))
  VV9cxb.append(FFH04v("Play with ..."   , "playWith", s.VVq9SN and not s.isDvb, c4))
  VV9cxb.append(FFH04v("Restart Current Service" , "restart" , s.VVq9SN     , c1))
  VV9cxb.append(FFH04v("Stop Current Service"  , "stop" , s.VVq9SN     , c1))
  VV9cxb.append(VVbM5H)
  if s._durTxt and s._posTxt:
   VV9cxb.append((c2 + "Start Subtitle", "VVEMFo"))
   VV9cxb.append(VVbM5H)
  canDownload = s.VVadS0 and s._seekable == 3 and s._durVal > 0
  if canDownload:
   VV9cxb.append((c3 + "File Size (on server)", "fileSize"))
  if self.VVyhra:
   if canDownload:
    VV9cxb.append((c3 + "Start Download"  , "dload_cur" ))
    VV9cxb.append((c3 + "Add to Download List", "addToDload" ))
  show = not CClaHD.VVyZwz()
  VV9cxb.append(FFH04v("Download Manager", "dload_stat", show, c3))
  VV9cxb.append(VVbM5H)
  addSep = False
  fPath, fDir, fName = CC17eA.VVNGSU(self)
  if fPath:
   c = VVWH8U
   if not "VVI6xQ" in globals():
    VV9cxb.append((c + "Open Path in File Manager", "VV1Rsm"))
   VV9cxb.append((c + "Add to Bouquet"            , "VVjRj9" ))
   VV9cxb.append((c + "%s Auto-Repeat" % ("Disable" if self.VVpX0O else "Enable"), "VVVIIn"  ))
   addSep = True
  elif s.isFtp:
   VV9cxb.append((c2 + "Add FTP Media to Bouquet", "VVhGZl"))
   addSep = True
  if addSep: VV9cxb.append(VVbM5H)
  if s.isDvb:
   VV9cxb.append((c4 + "Signal Monitor (Red Button)", "sigMon"))
   VV9cxb.append(VVbM5H)
  if not "VVloQE" in globals() and not "VViaWx" in globals():
   VV9cxb.append((c4 + "IPTV Menu", "iptv"))
   VV9cxb.append(VVbM5H)
  if self.VVNO3H:
   path, lst, err = CCnaRX.VVqFJV()
   if lst:
    VV9cxb.append((c3 + "Movies Resume History", "resume"))
    VV9cxb.append(VVbM5H)
  VV9cxb.append(("Bar Visibility Timeout", "timeout"))
  if CFG.playerPos.getValue() : VV9cxb.append(("Move Bar to Bottom" , "botm"))
  else      : VV9cxb.append(("Move Bar to Top" , "top" ))
  VVF79M = self.VVPrV5
  FFO9kU(self, self.VVw5I9, VV9cxb=VV9cxb, width=650, height=1050, title="Options", VVF79M=VVF79M, VVfWsQ="#22001122", VVB5I5="#11000919")
 def VVw5I9(self, item=None):
  if item:
   if   item == "info"     : self.VVVDQu()
   elif item == "playWith"    : self.VVwFS6()
   elif item == "restart"    : self.VVpl6j()
   elif item == "stop"     : self.VVxgET()
   elif item == "VVEMFo"  : self.VVt5yY()
   elif item == "fileSize"    : CCpebE.VVNiKh(self)
   elif item == "dload_cur"   : CClaHD.VVmKPJ(self)
   elif item == "addToDload"   : CClaHD.VVcinb(self)
   elif item == "dload_stat"   : CClaHD.VVRi6O(self)
   elif item == "VV1Rsm" : self.VVn9xN("VVnlj5")
   elif item == "VVjRj9" : self.VVjRj9()
   elif item == "VVVIIn"  : self.VVVIIn()
   elif item == "VVhGZl" : self.VVhGZl()
   elif item == "sigMon"    : self.VVW3gz()
   elif item == "iptv"     : self.VVn9xN("VVtWsL")
   elif item == "resume"    : self.VVn9xN("VV4EwC")
   elif item == "timeout"    : self.VVrrPs()
   elif item == "botm"     : self.VV9gZO(0)
   elif item == "top"     : self.VV9gZO(1)
 def onExit(self):
  self.VVkgv1.stop()
  CCsmqb.VVfMBZ = None
  if self.cbFnc: self.cbFnc()
  if self.endRef: FF9SoI(self.session, self.endRef)
 def VV3crw(self):
  self.animate.VVSFIH(CFG.playerPos.getValue())
 def VVMoD3(self):
  self.animate.VV1PP3(CFG.playerPos.getValue())
 def VVn9xN(self, act=None):
  if act     : self.close(act)
  elif self.VVYqW3: self.animate.VVBEC5()
  else     : self.close()
 def VVPrV5(self, VVhzhr, txt, ref, ndx):
  FFY7F5(self, "_help_player", "Player Bar (Keys)")
 def VVpl6j(self):
  self.VVWgjO("Restarting Service ...")
  FFvfpL(BF(CC2Ekb.VVIMKA, self.session))
 def VVxgET(self):
  self.VVWgjO("Stopping current service ...")
  FFvfpL(self.VVkI6A)
 def VVkI6A(self):
  fromTbls = self.VVu1kk or self.zapFnc
  zapped = False
  serv = self.session.nav.getCurrentlyPlayingServiceReference()
  if serv:
   path = serv.getPath()
   self.session.nav.stopService()
   self.show()
   self.VV6APK()
   if path.startswith(("/", "http")) or fromTbls:
    zapped = CC2Ekb.VVthPE(self.session)
  if fromTbls : self.VVn9xN()
  elif zapped : self.VV6APK()
  else  : self.VVbZfo(VV17at=serv)
 def VVwFS6(self):
  CCTe4w.VVAMwI(self, self.VV9Syt)
 def VV9Syt(self, rType=None):
  if rType:
   FFvfpL(BF(self.VVQPII, rType))
 def VVQPII(self, rType=None):
  serv = self.session.nav.getCurrentlyPlayingServiceReference()
  if serv : FFQ2Oi(self.session, eServiceReference(rType + ":" + serv.toString().split(":", 1)[1]))
  else : self.VVWgjO("No active service !")
  self.VV6APK()
 def VVjRj9(self):
  fPath, fDir, fName = CC17eA.VVNGSU(self)
  if fPath: picker = CC8i1k(self, self, "Add Current Movie to a Bouquet", BF(self.VVcCca, [fPath]))
  else : FFoTZI(self, "Path not found !", 1500)
 def VVcCca(self, pathLst):
  return CC8i1k.VVoNd2(pathLst)
 def VVhGZl(self):
  picker = CC8i1k(self, self, "Add FTP Media to Bouquet", self.VV5vRJ)
 def VV5vRJ(self):
  VVjgtq = CCZv30(self.session).VVjgtq
  return CC8i1k.VVoNd2([VVjgtq], rType=VVq9SN.split(":", 1)[0])
 def VVVIIn(self):
  ok = False
  if self.VVpX0O:
   self.VVpX0O = False
   txt = "Auto-Repeat OFF"
   ok = True
  else:
   seekable, percVal, durVal, posVal, remVal, percTxt, durTxt, posTxt, remTxt = CCsmqb.VVKbqb(self)
   if seekable and durVal > 0:
    if durVal >= 60:
     self.VVpX0O = True
     txt = "Auto-Repeat ON"
     ok = True
    else: txt = "Too short (min = 1 minute)"
   else: txt = "Cannot Auto-Repeat"
  if self.VVpX0O : self["myPlayRpt"].show()
  else    : self["myPlayRpt"].hide()
  self.VVWgjO(txt, highlight=ok)
 def VV9gZO(self, pos):
  scrSize = getDesktop(0).size()
  scrW = scrSize.width()
  scrH = scrSize.height()
  x  = (scrW - self.instance.size().width()) / 2.0
  if pos == 0 : y = (scrH - self.instance.size().height() - 20)
  else  : y = 20
  self.instance.move(ePoint(int(x), int(y)))
  if not pos == CFG.playerPos.getValue():
   FFBWtx(CFG.playerPos, pos)
  self.animate = CCKlQq(self)
 def VVrrPs(self) : CCLbil.VVZvbO(self, CFG.playerTimeout, "Bar Timeout (Seconds)", cbFnc=self.VVjn0S, isSave=True, width=700)
 def VVjn0S(self): self.VVYv49 = int(CFG.playerTimeout.getValue()) * 1000
 def VVW3gz(self):
  if self.shown:
   s = CCZv30(self.session)
   if s.isDvb : self.VVn9xN("VVxzyo")
   else  : self.VVWgjO("No Signal for Current Service")
 def VVt5yY(self):
  self.session.openWithCallback(self.VVNv0k, CCSLfI, self)
 def VVVe7W(self):
  if self.shown:
   s = self.VVvNzw()
   if s._posTxt and s._durTxt : self.VVt5yY()
   else      : self.VVWgjO("No duration Info. !")
 def VVNv0k(self, reason):
  if reason == "subtCancel":
   return
  self.VV3crw()
  txt = ""
  if   reason == "subtExit" : pass
  elif reason == "subtCancel" : pass
  elif reason == "subtInval" : txt = "Invalid srt file"
  elif reason == "subtZapUp" : self.VVlWRP(True)
  elif reason == "subtZapDn" : self.VVlWRP(False)
  elif reason == "longPlay" : self.VVwFS6()
  elif reason == "pause"  : self.VVntNj()
  elif reason == "audio"  : self.VVNXrm(True)
  elif reason == "subtitle" : self.VVNXrm(False)
  else      : txt = reason
  if txt:
   FFoTZI(self, txt, 2000)
 def VVyuDa(self):
  if self.VVso3m:
   self.VVuDK2()
   self.VVu9HH(self.VViohc)
  elif not self.session.nav.getCurrentlyPlayingServiceReference():
   self.VVbZfo()
  elif self.shown:
   if CCSLfI.VVnB1F(self): self.VVt5yY()
   elif self.shown       : self.VVMoD3()
  else:
   self.VV3crw()
 def cancel(self):
  if self.VVso3m: self.VVuDK2()
  elif self.shown  : self.VVn9xN()
  else    : self.VV3crw()
 def VVVDQu(self):
  CCpebE.VV1v7b(self, VV6tGM=CCpebE.VVbdzi, VVHkge=self.VVHkge, cbFnc=self.VV6APK)
 def VVbZfo(self, VV17at=None):
  CC2Ekb.VVRjb1(self.session, self.VV6APK, VV17at=VV17at)
 def VVntNj(self):
  try: InfoBar.instance.playpauseService()
  except: pass
  self.VVWgjO("Toggling Play/Pause ...")
 def VVYH8Y(self):
  try: InfoBar.instance.unPauseService()
  except: pass
 def VVuDK2(self):
  if self.VVso3m:
   self.VVso3m = False
   self["myPlayMov"].hide()
   self["myPlaySkp"].hide()
 def VVD4P1(self, direc):
  seekable, percVal, durVal, posVal, remVal, percTxt, durTxt, posTxt, remTxt = CCsmqb.VVKbqb(self)
  if percVal == 100:
   self.VVWgjO(self.resetMediaTxt)
  elif seekable and durVal > 0:
   if not self.VVso3m:
    self.VVso3m = True
    self["myPlayMov"].show()
    self["myPlaySkp"].show()
    self.VVAcEx = posVal + direc * self.VV4NMR()
   else:
    self.VVAcEx += direc * self.VV4NMR()
    self.VVAcEx = FFbn8W(self.VVAcEx, 0, durVal)
   minLeft = self["myPlayBar"].getPosition()[0] - 1
   maxLeft = self["myPlayBarBG"].getPosition()[0] + self["myPlayBarBG"].instance.size().width() - self["myPlayMov"].instance.size().width() + 1
   left = int(FFel7I(self.VVAcEx, 0, durVal, minLeft, maxLeft))
   self["myPlayMov"].instance.move(ePoint(left, int(self["myPlayMov"].getPosition()[1])))
   self["myPlaySkp"].setText(FFrTEd(self.VVAcEx))
   self.VViohc = self.VVAcEx * 90000.0
 def VVRgyC(self, val):
  if not self.VVC1po == val:
   self.VVC1po = val
   self["myPlayJmp"].setText(self.VVHtpR())
   FFBWtx(CFG.playerJumpMin, self.VVC1po)
  self.VVWgjO("Changed Seek Time to : %d%s" % (val, self.VV8MmT()))
 def VVHtpR(self):
  return "Seek=%d%s" % (self.VVC1po, self.VV8MmT())
 def VV8MmT(self) : return "s"   if self.VVC1po == 10 else "m"
 def VVKcN7(self): return "sec" if self.VVC1po == 10 else "min"
 def VV4NMR(self) : return 10    if self.VVC1po == 10 else self.VVC1po * 60
 def VVInEX(self):
  chSt = chStTxt = ""
  if "VViIgK_VAL" in globals():
   global VViIgK_VAL
   chSt = VViIgK_VAL
   if chSt != CCsyJ5.VVoJfl:
    chStTxt = chSt
  seekSt = ""
  try:
   inst = InfoBar.instance
   seekSt = {inst.SEEK_STATE_PAUSE: "PAUSED", inst.SEEK_STATE_EOF: "END", inst.SEEK_STATE_PLAY: "Playing"}.get(inst.seekstate, "")
   if chSt == CCsyJ5.VV3Z28:
    seekSt = chSt
  except:
   pass
  return seekSt, chSt, chStTxt
 def VVBspP(self):
  self.VVWgjO("Reading Cut-List ...")
  FFvfpL(self.VVLJA2)
 def VVLJA2(self):
  s = self.VVvNzw()
  if s._percVal == 100:
   self.VVWgjO(self.resetMediaTxt)
   return
  cList = self.VVKze5()
  VV9cxb = []
  title = "Cut List"
  src = 0
  fPath, fDir, fName = CC17eA.VVNGSU(self)
  if cList:
   canPreview = True
   for pts, what in cList:
    txt = FFrTEd(int(pts) / 90000.0)
    if   what == 0 : t = "In"
    elif what == 1 : t = "Out"
    elif what == 2 : t = "Mark"
    elif what == 3 : t = "Last"
    else   : t = ""
    if t: txt += "   %s" % t
    VV9cxb.append((txt, pts))
  elif self["myPlayBlu"].getVisible():
   if fPath:
    VV9cxb = CCM6jS.VVfGXZ(fPath)
   elif s.VVadS0 and s.VVUwmk:
    path, headers = CCM6jS.VVMW8Y(s.VVadS0, s.VVUwmk)
    if path:
     VV9cxb = CCM6jS.VVfGXZ(path, headers)
   if VV9cxb:
    title = "Chapters"
   elif s._durVal > 20:
    for i in range(0, 5):
     pts = min(max((s._durVal * 90000 // 4) * i, 5 * 90000), (s._durVal - 10) * 90000.0)
     subj = "   %s" % (("Start", "1st Quarter", "Half way", "3rd Quarter", "End")[i])
     VV9cxb.append((FFrTEd(pts / 90000.0) + subj, pts))
   fName, fTxt, VVUwmk, VVZWTf = CCZ3EO.VVNS7h(self.session)
   if fName:
    d = CCZ3EO.VV1fKj(CCZ3EO.VVC06L(fName))
    if d: VV9cxb.append((FFrTEd(d["pos"] / 90000.0) + FFKrMM("   Resume Point", VVk4x7), d["pos"]))
   VV9cxb.sort(key=lambda x: x[1])
  if VV9cxb:
   wDir = "%s_Chapters/" % fPath
   VVhzhr = FFO9kU(self, self.VVX7v2, VV9cxb=VV9cxb, title=title, width=1200, VV3an7=5, cornerPicFnc=BF(self.VV3rLK, wDir))
   lst = []
   for txt, ref in VV9cxb:
    picF, tm = self.VVLJV1(wDir, txt)
    if picF and not FFKbVo(picF):
     lst.append((picF, tm))
   self.VV9BAq = (VVhzhr, title, wDir, len(lst), 0, False)
   iThread(name="ajp_chap", target=BF(self.VVUdTc, lst, wDir, fPath)).start()
  else:
   self.VVWgjO("No Cut-List !")
 def VVX7v2(self, pts=None):
  self.VV9BAq = None
  if pts:
   self.VVu9HH(pts)
 def VVUdTc(self, lst, wDir, fPath):
  VVhzhr, title, wDir, totPics, cnt, done = self.VV9BAq
  if FFlonU("mkdir -p '%s';" % wDir):
   for picF, tm in lst:
    if not VVhzhr:
     break
    cnt += 1
    self.VV9BAq = VVhzhr, title, wDir, totPics, cnt, done
    FFlonU("ffmpeg -hide_banner -ss %s -i '%s' -frames:v 1 -vf scale=350:-1 '%s'" % (tm, fPath, picF))
  self.VV9BAq = VVhzhr, title, wDir, totPics, cnt, True
 def VV3rLK(self, wDir, VVhzhr, txt, ref, ndx):
  picF, tm = self.VVLJV1(wDir, txt)
  return picF
 def VVLJV1(self, wDir, txt):
  span = iSearch(r"^(\d\d:\d\d:\d\d)", txt)
  if span:
   tm = span.group(1)
   picF = "%s%s.jpg" % (wDir, tm.replace(":", ""))
   return picF, tm
  return "" ,""
 def VVROcd(self):
  if self.VV9BAq:
   try:
    VVhzhr, title, wDir, totPics, cnt, done = self.VV9BAq
    if   done   : self.VV9BAq = None
    elif totPics >= cnt : title += FFKrMM("   %s/%s" % (cnt, totPics), VV3Hcc)
    if VVhzhr:
     VVhzhr.FFgo5c(title)
     txt, ref, ndx = VVhzhr.VVQOZB()
     picF, tm = self.VVLJV1(wDir, txt)
     if not VVhzhr.VVefsq() and FFKbVo(picF):
      VVhzhr.VVgwPx(picF)
   except:
    pass
 def VVKze5(self):
  try: return InfoBar.instance.cut_list or []
  except: return []
 def VVwtWY(self) : self.VVZWdk(1)
 def VVXrpH(self) : self.VVZWdk(-1)
 def VVZWdk(self, direc):
  try:
   seekable, percVal, durVal, posVal, remVal, percTxt, durTxt, posTxt, remTxt = CCsmqb.VVKbqb(self)
   if percVal == 100:
    self.VVWgjO(self.resetMediaTxt)
   elif durVal > 0:
    maxPts = (durVal - posVal- 10) * 90000.0
    pts = direc * self.VV4NMR() * 90000.0
    pts = min(maxPts, pts)
    self.VVYH8Y()
    inst = InfoBar.instance
    inst.doSeekRelative(int(pts))
    inst.hide()
    if   direc > 0 : txt = "Forawrd"
    else   : txt = "Rewind"
    txt += " (%d %s) ..." % (self.VVC1po, self.VVKcN7())
    self.VVWgjO(txt)
  except:
   self.VVWgjO("Cannot jump")
 def VVu9HH(self, pts, txt=""):
  self.VVWgjO(txt or "Changing Time ...")
  self.VVYH8Y()
  try:
   InfoBar.instance.doSeek(int(pts))
  except:
   pass
 def VVHmjO(self):
  s = self.VVvNzw()
  if s._percVal < 100:
   self.VVu9HH(90000, "Jumping to Start ...")
  else:
   fName, fTxt, s.VVUwmk, VVZWTf = CCZ3EO.VVNS7h(self.session)
   FFnE7j(CCZ3EO.VVC06L(fName))
   self.VVuDK2()
   self.VVpl6j()
 def VV3Bp5(self):
  seekable, percVal, durVal, posVal, remVal, percTxt, durTxt, posTxt, remTxt = CCsmqb.VVKbqb(self)
  if seekable and durVal > 20:
   self.VVu9HH((durVal - 10) * 90000.0, "Jumping to end ...")
  else:
   self.VVWgjO("Movie is too short ...")
 def VVJyPR(self):
  try:
   service = self.session.nav.getCurrentService()
   info = service and service.info()
   if info:
    val = info.getInfo(iServiceInformation.sBuffer)
    if val and val > 0 and not val == 100:
     return "Buffering %d %%" % val
  except:
   pass
  return ""
 def VVlWRP(self, isUp):
  if self.VVinUd:
   self.VVWgjO("Starting Service ...")
   FFvfpL(BF(self.VVnDTA, isUp))
  else:
   self.VVWgjO("Zap Disabled !")
 def VVnDTA(self, isUp):
  self.VVuDK2()
  self["myPlayCc"].hide()
  self["myPlayAud"].hide()
  if self.zapFnc:
   VVq9SN = self.zapFnc(1 if isUp else -1)
   self.VVQAoA(VVq9SN, "")
  elif self.VVu1kk:
   self.VVyT3U(isUp)
  else:
   if "/timeshift/" in CCZv30(self.session).VVadS0:
    c1, c2 = VVCQUS, VVjojy
    self.VVWgjO(c1 + "To zap, click " + c2 + self.VVdosY + c1 + " then " + c2 + "Play Latest")
   else:
    try:
     if isUp : InfoBar.instance.zapDown()
     else : InfoBar.instance.zapUp()
    except:
     pass
    self.VVrDmD()
    self.VVW99n()
 def VVQAoA(self, chUrl, txt):
  if txt:
   self.VVWgjO(txt)
   FFvfpL(BF(self.VV1znT, chUrl))
  else:
   self.VV1znT(chUrl)
 def VV1znT(self, chUrl):
  FF9SoI(self.session, chUrl)
  self.VVW99n()
 def VVW99n(self):
  self.VVPlaL = 0
  self.VV6APK()
 def VVyT3U(self, isUp):
  CCTe4w_inatance, VVAIxO, mode = self.VVu1kk
  if isUp : VVAIxO.VVDGX5()
  else : VVAIxO.VVSmob()
  colList = VVAIxO.VVQDwi()
  VVHkge = ""
  if mode == "localIptv":
   VVUwmk, chUrl = CCTe4w_inatance.VV6W8V(VVAIxO, colList)
  elif mode == "localServer":
   VVUwmk, chUrl, VVHkge = CCTe4w_inatance.VVZ8rX(VVAIxO, colList, isUp)
  elif isinstance(mode, int):
   VVUwmk, chUrl, VVHkge = CCTe4w_inatance.VVpxAq(mode, VVAIxO, colList)
  elif any(x in mode for x in ("itv", "vod", "series")):
   VVUwmk, chUrl, VVHkge = CCTe4w_inatance.VV1cmR(mode, VVAIxO, colList)
  else:
   self.VVWgjO("Cannot Zap")
   return
  self.VVHkge = VVHkge
  self.VVQAoA(chUrl, "")
 def VVCGcn(self, chUrl, endRef="", VVHkge=""):
  self.endRef = endRef
  self.VVHkge = VVHkge
  self.VVQAoA(chUrl, "Starting Service ..." if chUrl else "")
 def VVrDmD(self, forceRefresh=False):
  try:
   if not forceRefresh:
    seekable, percVal, durVal, posVal, remVal, percTxt, durTxt, posTxt, remTxt = CCsmqb.VVKbqb(self)
    if posTxt:
     return
   VVq9SN, VVadS0, VVjgtq, VVVmGQ, VVUwmk = FFLlAM(self)
   if not self.VVRHrB(VVq9SN, VVUwmk, VVadS0, VVVmGQ):
    return
   if forceRefresh or "j.php" in VVadS0:
    self.VVWgjO("Refreshing Portal ...")
    FFvfpL(self.VVBBGW)
  except:
   pass
 def VVBBGW(self):
  self.VViNvh = self.VVj7dt(self.session)
 def VV9Jbl(self):
  VVq9SN, VVadS0, VVjgtq, VVVmGQ, VVUwmk = FFLlAM(self)
  if not VVadS0 or FFn8GR(VVadS0):
   self.VVWgjO("Not a Catch-up TV")
   return
  self.VVWgjO("Checking Catch-up ...")
  uHost = uUser = uPass = streamId = ""
  ok_fnc = None
  if "chCode=" in VVadS0:
   span = iSearch(r"(http.+)\/(.+)\/(.+)\/(\d+)\?play_token.+", VVadS0)
   if span: uHost, uUser, uPass, streamId = span.groups()
  else:
   if "/timeshift/" in VVadS0:
    span = iSearch(r"(.+)\/timeshift\/(.+)\/(.+)\/(.+)\/(.+)\/(\d+)", VVadS0, IGNORECASE)
    if span:
     uHost, uUser, uPass = span.group(1), span.group(2), span.group(3)
     streamId = span.group(6)
     ndx = VVUwmk.find(" >> ")
     if ndx > -1:
      VVUwmk = VVUwmk[:ndx]
   else:
    uType, uHost, uUser, uPass, streamId, uChName = CCTe4w.VVqy70(VVadS0)
  if all([uHost, uUser, uPass, streamId]):
   qUrl = "%s/player_api.php?username=%s&password=%s" % (uHost, uUser, uPass)
   ok_fnc  = BF(self.VVB7nu, VVq9SN, VVUwmk, streamId, uHost, uUser, uPass)
   CCTe4w.VV5KNJ(self, qUrl, VVUwmk, streamId, ok_fnc, rst_fnc=self.VV6APK)
  else:
   self.VVWgjO("Cannot process this channel")
 def VVB7nu(self, VVq9SN, VVUwmk, streamId, uHost, uUser, uPass, VVAIxO, title, txt, colList):
  pTitle, sTime, dur = colList[4], colList[6], colList[8]
  VVAIxO.cancel()
  span = iSearch(r"(\d{4}-\d{2}-\d{2})\s(\d{2}):(\d{2})", sTime)
  if span:
   sTime = span.group(1) + ":" + span.group(2) + "-" + span.group(3)
   chUrl = "%s/timeshift/%s/%s/%s/%s/%s.ts" % (uHost, uUser, uPass, dur, sTime, streamId)
   chUrl = chUrl.replace(":", "%3a")
   chUrl = "%s:%s:%s >> %s" % (VVq9SN, chUrl, VVUwmk, pTitle)
   self.VVQAoA(chUrl, "Changing Program ...")
  else:
   self.VVWgjO("Incorrect Timestamp !")
 def VVNXrm(self, isAudio):
  aud, sub = CCpebE.VVJKB2(self.session), CCpebE.VVG8GI()
  if isAudio:
   if aud < 1:
    self.VVWgjO("No Audio Tracks")
    return
  else:
   if sub < 1:
    self.VVWgjO("No Subtitles")
    return
  try:
   inst = InfoBar.instance
   if inst:
    from Screens.AudioSelection import AudioSelection, SubtitleSelection
    if isAudio : self.session.open(AudioSelection, infobar=inst)
    else  : self.session.open(SubtitleSelection, inst)
  except:
   pass
 @staticmethod
 def VVlWjt(session, mode=None):
  if   mode == "VVxzyo"   : FFlUBp(session, reopen=True)
  elif mode == "VVtWsL"  : session.open(CCTe4w)
  elif mode == "VV4EwC" : session.open(CCnaRX)
  elif mode == "VVnlj5" : session.open(CC17eA, VVeQ50=True)
 @staticmethod
 def VVlIAT(session, **kwargs):
  session.openWithCallback(BF(CCsmqb.VVlWjt, session), CCsmqb, **kwargs)
class CCk8ae(Screen):
 def __init__(self, session, title="", VVqg4G="Continue?", VVi3FS=True, VVv5tA=False):
  self.skin, self.VVmNvK = FFQaOH(VVOuSW, 1200, 800, 50, 20, 20, "#11221122", "#11221122", 30)
  self.session = session
  self["myLine"] = Label()
  self.VVqg4G = VVqg4G
  self.VVv5tA = VVv5tA
  self.maxHeight = 0
  no  = ("No" , "no" )
  yes = ("Yes", "yes")
  if VVi3FS : VV9cxb = [no , yes]
  else   : VV9cxb = [yes, no ]
  FFNhKZ(self, title, VV9cxb=VV9cxb, addLabel=True)
  FFrM8n(self,
  {
   "ok" : self.VVyuDa ,
   "cancel": self.cancel ,
   "red" : self.cancel ,
  })
  self.onShown.append(self.VVf1Ra)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  self.maxHeight = self.instance.size().height()
  self["myLabel"].setText("\n%s\n" % self.VVqg4G)
  if self.VVv5tA:
   self["myLabel"].instance.setHAlign(0)
  self.VVJkSu()
  FFvJ8o(self["myMenu"], fg="#08ffff00", bg="#08223333")
  try: self["myMenu"].instance.setHAlign(1)
  except: FFaGqd(self["myMenu"], 35)
  FFfPCL(self, self["myMenu"])
 def VVyuDa(self):
  item = self["myMenu"].l.getCurrentSelection()[1]
  if item is not None:
   if   item == "no" : self.close(False)
   elif item == "yes" : self.close(True)
  else:
   self.close(False)
 def cancel(self):
  self.close(False)
 def VVJkSu(self):
  vGap = 60 if CCg47Y.VVKvUI() else 0
  winW = self.instance.size().width()
  winH = self.instance.size().height()
  labelW = self["myLabel"].instance.size().width()
  labelH = self["myLabel"].instance.size().height()
  textSize= self["myLabel"].instance.calculateSize()
  diff = textSize.height() - labelH + vGap
  winNewH = winH + diff
  if winNewH < winH:
   screenSize = getDesktop(0).size()
   self["myLabel"].instance.resize(eSize(*(labelW, labelH + diff)))
   self.instance.resize(eSize(*(winW, winNewH)))
   self.instance.move(ePoint((screenSize.width() - winW) // 2, (screenSize.height() - winNewH) // 2))
   names = [ "myMenu", "myLine" ]
   for name in names:
    try:
     obj = self[name]
     pos = obj.getPosition()
     obj.instance.move(ePoint(pos[0], pos[1] + diff))
    except:
     pass
class CCZ5Xa(Screen, CCvFMf):
 def __init__(self, session, title="", VV9cxb=None, width=1000, height=850, VVPYL1=30, VVHRm1="", VV3an7=1, VVwv0z=0.15, VVQ4hk=None, VVF79M=None, VVXpo8=None, VVWt1H=None, VVqj6y=None, VVGbyT=None, cornerPicFnc=None, VVDkqE=False, VVbdOY=False, VV1NnQ=None, VVMUHm=True, VVfWsQ="#22003344", VVB5I5="#22002233", VVfINZ="#08005555"):
  self.skin, self.VVmNvK = FFQaOH(VVNkG2, width, height, 50, 40, 30, VVfWsQ, VVB5I5, VVPYL1, VVSwLg=40, VVwv0z=VVwv0z, VVcmdl=3 if VVF79M else 0, VV05bd=(350, 0))
  self.session   = session
  self.VVHRm1   = VVHRm1
  self.VV3an7   = VV3an7
  self.VVQ4hk   = VVQ4hk
  self.VVF79M   = VVF79M
  self.VVXpo8   = VVXpo8
  self.VVWt1H  = VVWt1H
  self.VVqj6y  = ("Delete File", BF(self.VVjOVc, VV1NnQ)) if not VV1NnQ is None else VVqj6y
  self.VVGbyT   = VVGbyT
  self.cornerPicFnc  = cornerPicFnc
  self.VVDkqE  = VVDkqE
  self.VVbdOY  = VVbdOY
  self.VVfINZ   = VVfINZ
  self.Title    = title
  FFNhKZ(self, title, VV9cxb=VV9cxb)
  CCvFMf.__init__(self)
  FFrM8n(self,
  {
   "ok"  : self.VVyuDa    ,
   "cancel" : self.cancel    ,
   "info"  : self.VVT6tS   ,
   "red"  : self.VV37sY   ,
   "green"  : self.VVkjj7   ,
   "yellow" : self.VVfQiW   ,
   "blue"  : self.VVOPLX   ,
   "pageUp" : self.VVRoOB ,
   "chanUp" : self.VVRoOB ,
   "pageDown" : self.VVzdMl  ,
   "chanDown" : self.VVzdMl  ,
   "0"   : BF(self.VVksaq, 0) ,
   "1"   : BF(self.VVksaq, 1) ,
   "2"   : BF(self.VVksaq, 2) ,
   "3"   : BF(self.VVksaq, 3) ,
   "4"   : BF(self.VVksaq, 4) ,
   "5"   : BF(self.VVksaq, 5) ,
   "6"   : BF(self.VVksaq, 6) ,
   "7"   : BF(self.VVksaq, 7) ,
   "8"   : BF(self.VVksaq, 8) ,
   "9"   : BF(self.VVksaq, 9)
  })
  if VVMUHm:
   CCwyMT(self, self["myMenu"])
  self.onShown.append(self.VVf1Ra)
  self.onClose.append(self.onExit)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  FFvJ8o(self["myMenu"], bg=self.VVfINZ)
  FFNUiO(self, VV3an7=self.VV3an7)
  FFeo1z(self)
  self.VVcPct(self["keyRed"]  , self.VVXpo8 )
  self.VVcPct(self["keyGreen"] , self.VVWt1H )
  self.VVcPct(self["keyYellow"] , self.VVqj6y )
  self.VVcPct(self["keyBlue"]  , self.VVGbyT )
  if self.VVHRm1      : self["myBar"].setText("  %s" % self.VVHRm1)
  elif not self["keyRed"].getVisible(): self["myBar"].setText("  OK = Select")
  else        : self["myBar"].setText("")
  FFuwGk(self)
  if self.cornerPicFnc:
   self.VVmgpR(self.VVOCOD)
 def onExit(self):
  self["myMenu"].onSelectionChanged = []
 def VVcPct(self, btnObj, btnFnc):
  if btnFnc:
   FFi79B(btnObj, btnFnc[0])
 def VVmgpR(self, fnc, callFnc=True):
  self["myMenu"].onSelectionChanged.append(fnc)
  if callFnc:
   fnc()
 def VVOCOD(self):
  item = self.VVQOZB()
  if item:
   txt, ref, ndx = item
   picF = self.cornerPicFnc(self, txt, ref, ndx)
   if FFKbVo(picF):
    if self.VVgwPx(picF):
     return
  self.VV9zlM()
 def VVn0TI(self, fnc=None):
  self.VVWt1H = fnc
  if fnc : self.VVcPct(self["keyGreen"], self.VVWt1H)
  else : self["keyGreen"].hide()
 def VVksaq(self, digit):
  digit = str(digit)
  VV9cxb = self["myMenu"].list
  for ndx, item in enumerate(VV9cxb):
   if len(item) == 2:
    span = iSearch(r"^\[(\d)\]\s.+", FFkEjh(item[0]), IGNORECASE)
    if span and span.group(1) == digit:
     self.VVhINX(ndx)
     self.VVyuDa()
     break
 def VVQOZB(self):
  obj = self["myMenu"].l
  ref = obj.getCurrentSelection()[1]
  if ref is not None:
   txt = obj.getCurrentSelection()[0]
   ndx = obj.getCurrentSelectionIndex()
   return (txt, ref, ndx)
  else:
   return None
 def VVyuDa(self):
  item = self.VVQOZB()
  if item:
   txt, ref, ndx = item
   if self.VVQ4hk:
    self.VVQ4hk((self, txt, ref, ndx))
   else:
    if self.VVDkqE: self.close((txt, ref, ndx))
    else     : self.close(ref)
 def VVT6tS(self):
  item = self.VVQOZB()
  if self.VVF79M and item:
   txt, ref, ndx = item
   self.VVF79M(self, txt, ref, ndx)
 def cancel(self):
  self.close(None)
 def VV37sY(self)  : self.VVNBUG(self.VVXpo8)
 def VVkjj7(self) : self.VVNBUG(self.VVWt1H)
 def VVfQiW(self) : self.VVNBUG(self.VVqj6y)
 def VVOPLX(self) : self.VVNBUG(self.VVGbyT)
 def VVNBUG(self, btnFnc):
  if btnFnc:
   item = self["myMenu"].l.getCurrentSelection()[1]
   fnc = btnFnc[1]
   fnc(self, item)
   if self.VVbdOY:
    self.cancel()
 def VVg78V(self):
  ndx = self["myMenu"].getSelectedIndex()
  VV9cxb = self["myMenu"].list
  VV9cxb.pop(ndx)
  if len(VV9cxb) > 0: self["myMenu"].setList(VV9cxb)
  else    : self.close()
 def VVVN5V(self, data):
  ndx = self["myMenu"].getSelectedIndex()
  VV9cxb = self["myMenu"].list
  VV9cxb[ndx] = data
  self["myMenu"].setList(VV9cxb)
 def VVjOVc(self, basePath, menuObj, fName):
  FF6pUe(self, BF(self.VV04GM, basePath + fName), "Delete this file ?\n\n%s" % fName, title=self.Title)
 def VV04GM(self, path):
  FFnE7j(path)
  if FFKbVo(path) : FFoTZI(self, "Not deleted", 1000)
  else    : self.VVg78V()
 def VVu8w1(self):
  return self["myMenu"].list
 def VVYjmx(self):
  return [x[1] for x in self["myMenu"].list if len(x) > 1]
 def VVj5Gx(self, VV9cxb):
  if len(VV9cxb) > 0:
   newList = []
   for item in VV9cxb:
    newList.append((item, item))
   self["myMenu"].setList(newList)
   FFNUiO(self, VV3an7=self.VV3an7)
  else:
   self.close("")
 def FFgo5c(self, txt):
  self["myTitle"].setText("  %s  " % txt)
 def VVYsr2(self, txt):
  self["myBar"].setText("  %s  " % txt)
 def VVisOz(self, newRow, isSort=False):
  lst = self["myMenu"].list
  lst.append(newRow)
  if isSort:
   lst.sort(key=lambda x: x[0].lower())
  self["myMenu"].setList(lst)
  FFNUiO(self, VV3an7=self.VV3an7)
  for ndx, item in enumerate(self["myMenu"].list):
   if item[1] == newRow[1]:
    self["myMenu"].moveToIndex(ndx)
    break
 def VV2Q7X(self, isUp):
  ndx = self["myMenu"].getSelectionIndex()
  if   isUp and ndx > 0         : newIndex = ndx - 1
  elif not isUp and ndx < len(self["myMenu"].list) - 1 : newIndex = ndx + 1
  else             : return None
  newList = self["myMenu"].list
  newList.insert(newIndex, newList.pop(ndx))
  self["myMenu"].moveToIndex(newIndex)
  newList = []
  for item in self["myMenu"].list:
   newList.append(item[0])
  return newList
 def VVhINX(self, ndx):
  self["myMenu"].moveToIndex(ndx)
 def VVY6ij(self, refTxt):
  for ndx, item in enumerate(self["myMenu"].list):
   if refTxt == item[1]:
    self.VVhINX(ndx)
    break
 def VVhrmd(self, txt):
  for ndx, item in enumerate(self["myMenu"].list):
   if txt == item[0]:
    self.VVhINX(ndx)
    break
 def VVRoOB(self) : self["myMenu"].moveToIndex(0)
 def VVzdMl(self) : self["myMenu"].moveToIndex(len(self["myMenu"].list) - 1)
class CC4ngo(Screen, CCvFMf):
 def __init__(self, session, title="", width=1600, height=900, VVAQi3=50, VVHzN4=10, VVoqL2=5, header=None, VVXpNQ=None, VV4Uoc=None, VV8boH=None, VVPYL1=26, VVHRm1="", VVEk4e="", VVgWi8=False, VVdZd9=False, VVw4QC=3000, VVLdgm=False, VVD4Fx=True, VVpz29=None, VVoNmU=False, VVul85=0, VVUEAa=None, VVYdyj=None, VVj7lw=None, VVmolf=None, VV8OKD=None, VVjW3s=None, VVwqVu=None, VV46TD=None, VViMvb=None, VVMCLR=None, VVDPcX=None, VVpW7I=None, VVUZ91=None, VVMVUB=-1, VVRtfk=0, VVMBr1=0, VVAGe1=None, VVfWsQ="#22003344", VVB5I5="#22002233", VV7aCC="#00dddddd", VVYCun="#11002233", VVzVW9=None, VVmErq="#0a444033", VVypeD=1, VVK8UQ="#0a555555", VVhkiG="#0affffff", VVgSJJ="#11552200", VVFmyL="#0055ff55", VVX9hG="#004488ff"):
  VVdZd9 = VVdZd9 or VVRtfk == 1
  barH = 1 if VVdZd9 else 40
  self.skin, self.VVmNvK = FFQaOH(VVZIqk, width, height, VVAQi3, VVHzN4, VVoqL2, VVfWsQ, VVB5I5, 26, VVSwLg=barH, VVcmdl=2, VVwv0z=0.6, VV05bd=(0, 0))
  self.session    = session
  self.Title     = title
  self.header     = header
  self.VVXpNQ     = VVXpNQ
  self.VVqDHm    = len(VVXpNQ[0])
  self.VVul85   = VVul85
  self.VVUEAa    = VVUEAa
  self.VVYdyj   = VVYdyj
  self.VVsbEx    = VVYdyj[0] if VVYdyj else -1
  self.VVMZc7 = False
  self.VVoNmU   = VVoNmU
  self.VVd9OA   = 0.01
  self.VVH5ad   = 0.02
  self.VVhic3 = 0.03
  self.VVXa6F   = 1
  self.VV8boH = VV8boH
  self.VVLpFM   = []
  self.VVj7lw   = VVj7lw
  self.VV27kQ   = None
  self.VVmolf   = VVmolf
  self.VVjW3s   = VVjW3s
  self.VVwqVu   = VVwqVu
  self.VV46TD  = VV46TD
  self.VViMvb   = VViMvb
  self.VVMCLR    = VVMCLR
  self.VVDPcX   = VVDPcX
  self.VVyoYa   = None
  self.VVpW7I  = VVpW7I
  self.VVUZ91   = VVUZ91
  self.VV8OKD   = VV8OKD
  self.VVMVUB    = VVMVUB
  self.VVRtfk   = VVRtfk
  self.VVMBr1    = VVMBr1
  self.VV4Uoc    = VV4Uoc
  self.VVnVSC    = -1
  self.VVPYL1    = FFP9a3(VVPYL1)
  self.VVHRm1    = VVHRm1
  self.VVEk4e    = VVEk4e
  self.VVgWi8    = VVgWi8
  self.VVw4QC     = VVw4QC
  self.VVLdgm    = VVLdgm
  self.VVD4Fx    = VVD4Fx
  self.VVpz29    = VVpz29 or {}
  self.VVCW3G    = FFkCSf(self.VVPYL1, self.VVmNvK["VVwv0z"])
  self.scrollBarWidth   = self.VVmNvK["scrollBarW"]
  self.VVfWsQ    = VVfWsQ
  self.VVB5I5      = VVB5I5
  self.VV7aCC    = FFcUfR(VV7aCC)
  self.VVYCun    = FFcUfR(VVYCun)
  self.VVzVW9    = VVzVW9
  self.VVmErq    = FFcUfR(VVmErq)
  self.VVypeD   = VVypeD
  self.VVK8UQ   = FFcUfR(VVK8UQ)
  self.VVhkiG    = FFcUfR(VVhkiG)
  self.VVgSJJ    = FFcUfR(VVgSJJ)
  self.VVFmyL   = FFcUfR(VVFmyL)
  self.VVX9hG  = FFcUfR(VVX9hG)
  self.VVGZGK  = False
  self.VVchAV   = 0
  self.VVo9Tf   = FFcUfR("#04764354")
  self.VVAGe1  = VVAGe1 or CFG.lastFindGeneral
  self.VVHlEM  = False
  self.VV2wRZ  = False
  self.VV7VOF  = False
  self.VV8LLf = False
  self.VV8qXd  = False
  self.VVVWuj = CC4ngo.VVvFdD(0, 0, 20, 20, LoadPixmap(VVK8DT + "tick.png"))
  self.VVRbf2 = CC4ngo.VVvFdD(0, 0, 1, 1, LoadPixmap(VVK8DT + "tick_1x1.png"))
  FFNhKZ(self, title)
  CCvFMf.__init__(self)
  if VVdZd9:
   self["myLine"].hide()
  self["myTableH"] = MenuList([], True, eListboxPythonMultiContent)
  self["myTable"]  = MenuList([], True, eListboxPythonMultiContent)
  self["myTotSel"] = Label("Sel = 0")
  self["myTotSel"].hide()
  FFrM8n(self,
  {
   "ok"  : self.VVblf8  ,
   "red"  : self.VVeEh7  ,
   "green"  : self.VVwxG8 ,
   "yellow" : self.VVD4IQ ,
   "blue"  : self.VV97HV  ,
   "menu"  : self.VV93kA ,
   "info"  : self.VVP9DN  ,
   "cancel" : self.VVzT5N  ,
   "up"  : self.VVSmob    ,
   "down"  : self.VVDGX5  ,
   "left"  : self.VVRlRL   ,
   "right"  : self.VV4SSV  ,
   "next"  : self.VVP5Ap  ,
   "last"  : self.VVQDSS  ,
   "home"  : self.VVpTaG  ,
   "pageUp" : self.VVpTaG  ,
   "chanUp" : self.VVpTaG  ,
   "end"  : self.VVbtl9  ,
   "pageDown" : self.VVbtl9  ,
   "chanDown" : self.VVbtl9
  })
  CCwyMT(self, self["myTable"], colNum=self.VVMBr1)
  self.onShown.append(self.VVf1Ra)
  self.onClose.append(self.onExit)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  FFeo1z(self)
  if self.VVHRm1:
   self.VV0rXd(self.VVHRm1)
  if self.VVRtfk:
   self["keyMenu"].hide()
   x, y = self["keyMenu"].getPosition()
   self["keyInfo"].instance.move(ePoint(x, y))
  try:
   self.VV7IAT()
  except Exception as e:
   FFbBGq(self, str(e), title=self.Title)
   self.close(None)
 def onExit(self):
  self["myTable"].onSelectionChanged = []
 def VV7IAT(self):
  FFuwGk(self)
  self.VVcPct(self.VVjW3s , self["keyRed"])
  self.VVcPct(self.VVwqVu , self["keyGreen"])
  self.VVcPct(self.VV46TD, self["keyYellow"])
  self.VVcPct(self.VViMvb , self["keyBlue"])
  if self.VVj7lw:
   if   not self["keyRed"].getVisible() : self.VV27kQ = self["keyRed"]
   elif not self["keyBlue"].getVisible() : self.VV27kQ = self["keyBlue"]
   else         : self.VV27kQ = None
   if self.VV27kQ and self.VVj7lw[0]:
    self.VV27kQ.show()
    self.VV27kQ.setText("OK = %s" % self.VVj7lw[0])
    FFgLA9(self.VV27kQ, "#11000000")
  if self.VVEk4e and not self["keyBlue"].getVisible():
   self["keyBlue"].show()
   self["keyBlue"].setText(self.VVEk4e)
   FFgLA9(self["keyBlue"], "#11000000")
  self["myTableH"].l.setSelectionClip(eRect(0, 0, 0, 0))
  FF0u5o(self["myTableH"], "#00555500", 2)
  self["myTableH"].l.setItemHeight(self.VVCW3G)
  self["myTableH"].l.setFont(0, gFont(VV3IRX, self.VVPYL1))
  self["myTable"].l.setItemHeight(self.VVCW3G)
  self["myTable"].l.setFont(0, gFont(VV3IRX, self.VVPYL1))
  try:
   self["myTable"].instance.setScrollbarSliderBorderWidth(0)
  except:
   pass
  w = self["myTable"].instance.size().width()
  h = self["myTable"].instance.size().height()
  pos = self["myTable"].getPosition()
  if self.header and not self.VVgWi8:
   self["myTableH"].instance.resize(eSize(*(w, self.VVCW3G)))
   self["myTable"].instance.move(ePoint(pos[0], pos[1] + self.VVCW3G))
   self["myTable"].instance.resize(eSize(*(w, h - self.VVCW3G)))
  h  = self["myTable"].instance.size().height()
  pos  = self["myTable"].getPosition()
  part = self["myTable"].instance.size().height() % self.VVCW3G
  half = int(part / 2)
  self["myTable"].instance.resize(eSize(*(w, h - part)))
  self["myTable"].instance.move(ePoint(pos[0], pos[1] + half))
  if self.header:
   pos = self["myTableH"].getPosition()
   self["myTableH"].instance.move(ePoint(pos[0], pos[1] + half))
  menuWidth = self["myTable"].instance.size().width()
  if self.VVCW3G * len(self.VVXpNQ) > self["myTable"].instance.size().height():
   menuWidth = menuWidth - int(self.scrollBarWidth) - 5
  if not self.VV8boH:
   self.VV8boH = ([float(100.0 / self.VVqDHm)] * self.VVqDHm)
  self.VVLpFM = list(self.VV8boH)
  if not self.VVLpFM:
   self.VVLpFM = [menuWidth // self.VVqDHm] * self.VVqDHm
  else:
   for i, item in enumerate(self.VVLpFM):
    self.VVLpFM[i] = int(item * menuWidth / 100)
  if not self.VV4Uoc : self.VV4Uoc = [LEFT | RT_VALIGN_CENTER] * self.VVqDHm
  else     : self.VV4Uoc = [x | RT_VALIGN_CENTER for x in self.VV4Uoc]
  self.VVjeun()
  if self.VVMCLR:
   self.VVMCLR(self)
 def VVcPct(self, btnFnc, btn):
  if btnFnc : FFi79B(btn, btnFnc[0])
  else  : FFi79B(btn, "")
 def VVjeun(self, onlyHeader=False, showProgBar=True, fromRefresh=False):
  if self.header:
   sortedFg = self.VVX9hG if self.VVMZc7 else self.VVFmyL
   self["myTableH"].setList([self.VVZaTb(0, self.header, self.VVhkiG, self.VVgSJJ, None, self.VVgSJJ, sortedFg)])
  if onlyHeader:
   return
  tot = len(self.VVXpNQ)
  if showProgBar and tot > self.VVw4QC:
   CCV3Gw.VVgWD3(self, VVN6I4="Loading Table ( %s row%s ) ..." % (tot, FFaRsj(tot)), endTitle="Loading channels ...", VV32kU=CCV3Gw.VVQFxC, titleBg="#11222222", bodyBg="#11222222", barBg="#06446677"
       , VVuSHu  =  BF(self.VVkcsC, True, fromRefresh)
       , VVhK3C = self.VVSrDG )
  else:
   self.VVkcsC(False, fromRefresh)
 def VVkcsC(self, showProgBar, fromRefresh, VVqeT6=None):
  try:
   if showProgBar:
    VVqeT6.VVfT17(len(self.VVXpNQ))
   self["myTable"].list = []
   for c, row in enumerate(self.VVXpNQ):
    if showProgBar:
     if not VVqeT6 or VVqeT6.isCancelled:
      return
     VVqeT6.VVqE9L(1)
    self["myTable"].list.append(self.VVZaTb(c, row, self.VV7aCC, self.VVYCun, self.VVzVW9, self.VVmErq, None))
   self.VVXpNQ = []
   self["myTable"].setList(self["myTable"].list)
   if self.VVMVUB > -1:
    self["myTable"].moveToIndex(self.VVMVUB)
   if self.VVRtfk and not fromRefresh:
    tableH = self["myTable"].instance.size().height()
    rowsH = self.VVCW3G * len(self["myTable"].list)
    if rowsH < tableH:
     diff = tableH - rowsH
     newH = self.instance.size().height() - diff
     screenSize = getDesktop(0).size()
     width = self.instance.size().width()
     self.instance.resize(eSize(*(width, newH)))
     self.instance.move(ePoint((screenSize.width() - width) // 2, (screenSize.height() - newH) // 2))
     names = [ "keyRed", "keyGreen", "keyYellow", "keyBlue", "myBar", "myLine" ]
     for name in names:
      obj = self[name]
      pos = obj.getPosition()
      obj.instance.move(ePoint(pos[0], pos[1] - diff))
     FFg1s2(self, width, newH)
   if self.VVDPcX:
    self.VVNBUG(self.VVDPcX, None)
   if self.VVyoYa:
    self.VVNBUG(self.VVyoYa, None)
    self.VVyoYa = None
  except AttributeError as attrErr:
   pass
  except Exception as e:
   try:
    FFbBGq(self, str(e), title=self.Title)
    self.close()
   except:
    pass
 def VVSrDG(self, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  if not VV6ZvL:
   self.close()
 def VVZaTb(self, keyIndex, columns, VV7aCC, VVYCun, VVzVW9, VVmErq, VVFmyL):
  row = [keyIndex]
  if VVzVW9:
   VVzVW9 = FFcUfR(VVzVW9)
  posX = 0
  for ndx, entry in enumerate(columns):
   if VVFmyL and (ndx in self.VVpz29 and self.VVpz29[ndx] == self.VVul85) or ndx == self.VVul85:
    textColor = VVFmyL
   else:
    textColor = VV7aCC
   while iMatch(r"^\s*#(f|b)#[a-fA-F0-9]{8}#", entry):
    span = iSearch(r"\s*#(.)(#[a-fA-F0-9]{8})#(.*)", entry, IGNORECASE)
    if span:
     c = FFcUfR(span.group(2))
     if span.group(1) == "f" : textColor = c
     else     : VVYCun = c
     entry = span.group(3)
   if not self.VVLdgm and self.VV4Uoc[ndx] & LEFT:
    entry = " " + entry + " "
   row.append(CC4ngo.VVI3ci(  posX, 0
             , self.VVLpFM[ndx], self.VVCW3G
             , 0
             , self.VV4Uoc[ndx]
             , entry
             , textColor
             , VVYCun
             , VVzVW9 or textColor
             , VVmErq
             , self.VVypeD
             , self.VVK8UQ
             ))
   posX += self.VVLpFM[ndx]
  if not VVFmyL:
   if self.VVUEAa:
    VVM65iCol, picFnc, pathCol = self.VVUEAa
    if   picFnc : png = picFnc(columns)
    elif pathCol: png = columns[pathCol].strip()
    else  : png = ""
    if png.startswith("/"):
     try:
      pngX = sum(self.VVLpFM[:VVM65iCol])
      row.append(CC4ngo.VVvFdD(pngX+2, VVM65iCol+2, self.VVLpFM[VVM65iCol]-4, self.VVCW3G-4, LoadPixmap(png)))
     except:
      pass
   if self.VVYdyj:
    pCol, vCol, pW, pH = self.VVYdyj
    perc = int(columns[vCol])
    pX = sum(self.VVLpFM[:pCol])
    w = int(pW / 100.0 * self.VVLpFM[pCol])
    h = int(pH / 100.0 * self.VVCW3G)
    x = pX + (self.VVLpFM[pCol] - w) // 2
    y = (self.VVCW3G - h) // 2
    row.append(CC4ngo.VVY23h(x, y, w, h, perc, 1, FFcUfR("#00aaccaa")))
   row.append(self.VVRbf2)
  return row
 def VVP9DN(self):
  rowData = self.VV8eLV()
  if rowData:
   title, txt, colList = rowData
   if self.VVmolf:
    fnc  = self.VVmolf[1]
    params = self.VVmolf[2]
    fnc(self, title, txt, colList)
   else:
    FFSMJz(self, txt, title)
 def VVblf8(self):
  if   self.VVGZGK : self.VVSDiu(self.VVoxea(), mode=2)
  elif self.VVj7lw  : self.VVNBUG(self.VVj7lw, None)
  else      : self.VVP9DN()
 def VVeEh7(self) : self.VVNBUG(self.VVjW3s , self["keyRed"])
 def VVwxG8(self) : self.VVNBUG(self.VVwqVu , self["keyGreen"])
 def VVD4IQ(self): self.VVNBUG(self.VV46TD , self["keyYellow"])
 def VV97HV(self) : self.VVNBUG(self.VViMvb , self["keyBlue"])
 def VVNBUG(self, buttonFnc, btnObj):
  if btnObj and not btnObj.getVisible():
   return
  if buttonFnc:
   if len(buttonFnc) > 3 and buttonFnc[3]:
    FFoTZI(self, buttonFnc[3])
    FFvfpL(BF(self.VVXkaZ, buttonFnc))
   else:
    self.VVXkaZ(buttonFnc)
 def VVXkaZ(self, buttonFnc):
  fnc   = buttonFnc[1]
  params  = buttonFnc[2]
  rowData = self.VV8eLV()
  if rowData:
   title, txt, colList = rowData
   if not params : fnc(self, title, txt, colList)
   else   : fnc(self, *params)
 def VVSDiu(self, ndx, mode=0, movDn=True):
  try:  row = self["myTable"].list[ndx]
  except: row = None
  if row:
   isSelected = row[1][10] == self.VVo9Tf
   if mode == 0 or (mode == 2 and isSelected):
    bg = self.VVYCun
    if isSelected:
     self.VVchAV -= 1
   else:
    bg = self.VVo9Tf
    if not isSelected:
     self.VVchAV += 1
   self.VV6Xs1()
   if isSelected: self["myTable"].list[ndx][-1] = self.VVRbf2
   else   : self["myTable"].list[ndx][-1] = self.VVVWuj
   for col in range(1, len(row)):
    cols = list(row[col])
    if cols[0] == eListboxPythonMultiContent.TYPE_TEXT:
     cols[10] = bg
    row[col] = tuple(cols)
   self["myTable"].l.invalidate()
   if movDn and self.VVoxea() < len(self["myTable"].list) - 1:
    self.VVDGX5()
   if self.VVUZ91:
    self.VVUZ91(self)
 def VV6Xs1(self): self["myTotSel"].setText("Sel = %d" % self.VVchAV)
 def VVYHQP(self)  : FF7iMz(self, BF(self.VVOPjS, True ), title="Selecting all ..."  )
 def VVXK4X(self) : FF7iMz(self, BF(self.VVOPjS, False), title="Unselecting all ...")
 def VVOPjS(self, isSel=True):
  if isSel:
   bg = self.VVo9Tf
   self.VVchAV = len(self["myTable"].list)
   self.VVlIC1(True)
  else:
   bg = self.VVYCun
   self.VVchAV = 0
  self.VV6Xs1()
  for ndx, row in enumerate(self["myTable"].list):
   isPainted = row[1][10] == self.VVo9Tf
   if (isSel and not isPainted) or (not isSel and isPainted):
    for col in range(1, len(row)):
     cols = list(self["myTable"].list[ndx][col])
     if cols[0] == eListboxPythonMultiContent.TYPE_TEXT:
      cols[10] = bg
     self["myTable"].list[ndx][col] = tuple(cols)
   if isSel: self["myTable"].list[ndx][-1] = self.VVVWuj
   else : self["myTable"].list[ndx][-1] = self.VVRbf2
  self["myTable"].l.invalidate()
  if self.VVUZ91:
   self.VVUZ91(self)
 def VVlIC1(self, isOn):
  self.VVGZGK = isOn
  if isOn:
   color = "#01883366"
   self["myTotSel"].show()
   self["keyMenu"].hide()
   if self.VVHlEM and self.VVj7lw and self.VV27kQ:
    self.VV27kQ.setText("OK = Select")
   if self.VV2wRZ and self.VVjW3s: self["keyRed"].hide()
   if self.VV7VOF and self.VVwqVu: self["keyGreen"].hide()
   if self.VV8LLf and self.VV46TD: self["keyYellow"].hide()
   if self.VV8qXd and self.VViMvb: self["keyBlue"].hide()
  else:
   color = self.VVfWsQ
   self["myTotSel"].hide()
   self["keyMenu"].show()
   if self.VVHlEM and self.VVj7lw and self.VV27kQ:
    self.VV27kQ.setText("OK = %s" % self.VVj7lw[0])
   if self.VV2wRZ and self.VVjW3s: self["keyRed"].show()
   if self.VV7VOF and self.VVwqVu: self["keyGreen"].show()
   if self.VV8LLf and self.VV46TD: self["keyYellow"].show()
   if self.VV8qXd and self.VViMvb: self["keyBlue"].show()
  FFgLA9(self["myTitle"], color)
  FFgLA9(self["myBar"]  , color)
  if self.VVUZ91:
   self.VVUZ91(self)
 def VVkMgP(self, ndx):
  w = self.VV8boH[ndx]
  return VVSm4H > 1 or (w > self.VVXa6F or w == self.VVd9OA or w == self.VVhic3) and ndx != self.VVsbEx
 def VVd47s(self, ndx):
  w = self.VV8boH[ndx]
  return VVSm4H > 1 or (w > self.VVXa6F or w == self.VVhic3) and ndx != self.VVsbEx
 def VVZ9bG(self, ndx):
  w = self.VV8boH[ndx]
  return VVSm4H > 1 or (w > self.VVXa6F or w == self.VVH5ad) and ndx != self.VVsbEx and ndx not in self.VVpz29.keys()
 def VV8eLV(self):
  item = self["myTable"].getCurrent()
  if item:
   colList = []
   txt = ""
   tot = 0
   for i in range(self.VVqDHm):
    colTxt = item[i + 1][7].strip()
    colList.append(colTxt)
    if self.VVkMgP(i):
     tot += 1
     if self.header : name = self.header[i].strip()
     else   : name = "Column-%d" % (i + 1)
     txt += "%s\t: %s\n" % (name, colTxt)
   if tot == 1:
    txt = colList[0]
   rowNum = "Row Number\t: %d of %d" % (item[0] + 1, len(self["myTable"].list))
   return rowNum, txt, colList
  else:
   return None
 def VVzT5N(self):
  if self.VVGZGK:
   self.VVurYr()
  else:
   if self.VVpW7I : self.VVpW7I(self)
   else     : self.close(None)
 def cancel(self):
  self.close(None)
 def VVAjLb(self):
  return self["myTitle"].getText().strip()
 def VVjp8T(self):
  return self.header
 def VVuSAP(self, title):
  self.Title = title
  self["myTitle"].setText("  " + title.strip() + "  ")
 def VV0rXd(self, txt):
  self["myBar"].setText("  %s  " % txt)
 def VVobkn(self, title, color=None):
  self["myBar"].setText("  " + title.strip() + "  ")
  if color:
   FFMhbx(self["myBar"], color)
 def VVOoFN(self, txt):
  FFoTZI(self, txt)
 def VV2t5o(self, txt, Time=1000):
  FFoTZI(self, txt, Time)
 def VVRysD(self): self["keyRed"].show()
 def VVNfFC(self): self["keyRed"].hide()
 def VVdqRF(self): self["keyGreen"].show()
 def VVQBxV(self): self["keyGreen"].hide()
 def VVRl3T(self): self["keyBlue"].show()
 def VVFKrx(self): self["keyBlue"].hide()
 def VVExV5(self): self["keyYellow"].show()
 def VVKxwu(self): self["keyYellow"].hide()
 def VVznjv(self): return self["keyGreen"].visible
 def VVEL2E(self):
  FFoTZI(self)
 def VVQ4nk(self, fnc, callFnc=True):
  self["myTable"].onSelectionChanged.append(fnc)
  if callFnc:
   fnc()
 def VVCQXG(self):
  return len(self["myTable"].list)
 def VVoxea(self):
  return self["myTable"].l.getCurrentSelectionIndex()
 def VVM62I(self):
  return len(self["myTable"].list)
 def VVMEs4(self):
  return self.VVGZGK
 def VVAGI8(self):
  return self.VVchAV
 def VVC3dh(self):
  self.VVlIC1(True)
 def VVurYr(self):
  self.VVXK4X()
  self.VVlIC1(False)
 def VVlohq(self):
  curRow = self["myTable"].l.getCurrentSelectionIndex()
  self["myTable"].moveToIndex(curRow + 1)
 def VVxxdm(self, colNum):
  if colNum < self.VVqDHm:
   if self.header : subj = self.header[colNum]
   else   : subj = ""
   lst = set()
   for item in self["myTable"].list:
    lst.add(item[colNum + 1][7])
   return subj, str(len(lst))
  else:
   return "", ""
 def VVRghi(self):
  txt  = "Total Rows\t: %d\n\n" % self.VVCQXG()
  txt += FFFGRS("Total Unique Items", VVdLWL)
  for i in range(self.VVqDHm):
   if self.VVkMgP(i):
    name, tot = self.VVxxdm(i)
    txt +=  "%s\t: %s\n" % (name, tot)
  FFSMJz(self, txt)
 def VVYmuZ(self, colNum, isStrip=True):
  item = self["myTable"].getCurrent()
  if item : return item[colNum + 1][7].strip() if isStrip else item[colNum + 1][7]
  else : return None
 def VVQDwi(self):
  return self.VVBWxt(self["myTable"].l.getCurrentSelectionIndex())
 def VVBWxt(self, rowNdx):
  colList = []
  item = self["myTable"].list[rowNdx]
  if item:
   for i in range(1, self.VVqDHm + 1):
    colList.append(item[i][7].strip())
  return colList
 def VVEEBV(self, newList, newTitle="", VVWBXTMsg=True, VVyoYa=None, isSort=True):
  fnc = BF(self.VVXQum, newList, newTitle, VVWBXTMsg, VVyoYa, isSort)
  if VVWBXTMsg : FF7iMz(self, fnc, title="Refreshing ...")
  else   : fnc()
 def VVXQum(self, newList, newTitle, VVWBXTMsg, VVyoYa, isSort):
  try: fake = self.VVoNmU
  except: return
  if newTitle:
   self.VVuSAP(newTitle)
  if newList:
   self.VVXpNQ = newList
   if VVyoYa:
    self.VVyoYa = ("", VVyoYa, [])
   isNum = False
   if self.VVoNmU and self.VVul85 == 0:
    isNum = True
   else:
    for cols in self.VVXpNQ:
     if not FFXclX(cols[self.VVul85]): break
    else:
     isNum = True
   if isSort:
    patt = r"^\s*#(f|b)#[a-fA-F0-9]{8}#"
    if isNum: self.VVXpNQ.sort(key=lambda x: int(x[self.VVul85][12:])  if iMatch(patt, x[0]) else int(x[self.VVul85]) , reverse=self.VVMZc7)
    else : self.VVXpNQ.sort(key=lambda x: x[self.VVul85][12:].lower() if iMatch(patt, x[0]) else x[self.VVul85].lower() , reverse=self.VVMZc7)
   self.VVjeun(showProgBar=False, fromRefresh=True)
  else:
   FFbBGq(self, "Cannot refresh list", title=self.Title)
   self.cancel()
 def VV4hgQ(self, row, moveCurs=True):
  row = self["myTable"].list.append(self.VVZaTb(self.VVM62I(), row, self.VV7aCC, self.VVYCun, self.VVzVW9, self.VVmErq, None))
  self["myTable"].l.setList(self["myTable"].list)
  if moveCurs: self.VVbtl9()
 def VVIB2X(self):
  self["myTable"].list.pop(self.VVoxea())
  if len(self["myTable"].list) > 0: self["myTable"].l.setList(self["myTable"].list)
  else       : self.close()
 def VVsu0I(self, data):
  ndx = self.VVoxea()
  newRow = self.VVZaTb(ndx, data, self.VV7aCC, self.VVYCun, self.VVzVW9, self.VVmErq, None)
  if newRow:
   self["myTable"].list[ndx] = newRow
   self.VVYLpu()
   return True
  else:
   return False
 def VVGSSq(self, tDict):
  ndx = self.VVoxea()
  for colNum, val in tDict.items():
   txt = str(val)
   if not self.VVLdgm and self.VV4Uoc[ndx] & LEFT:
    txt = " %s " % txt.strip()
   col = list(self["myTable"].list[ndx][colNum + 1])
   col[7] = txt
   self["myTable"].list[ndx][colNum + 1] = tuple(col)
  self.VVYLpu()
 def VVUvuG(self, ndx, data):
  if ndx >=0 and ndx < len(self["myTable"].list):
   newRow = self.VVZaTb(ndx, data, self.VV7aCC, self.VVYCun, self.VVzVW9, self.VVmErq, None)
   if newRow:
    self["myTable"].list[ndx] = newRow
    self.VVYLpu()
 def VVvqdM(self, rowNdx, colNDx, part, val):
  row = self["myTable"].list[rowNdx]
  col = list(row[colNDx + 1])
  if col[0] == eListboxPythonMultiContent.TYPE_TEXT:
   if col[part] != val:
    col[part] = val
    row[colNDx + 1] = tuple(col)
    self["myTable"].list[rowNdx] = row
    self.VVYLpu()
 def VVYLpu(self):
  self["myTable"].l.invalidate()
 def VVdVkN(self, colNum=0):
  for ndx, item in enumerate(self["myTable"].list):
   lst = list(self["myTable"].list[ndx][colNum + 1])
   lst[7] = str(ndx + 1)
   self["myTable"].list[ndx][colNum + 1] = tuple(lst)
  self["myTable"].l.setList(self["myTable"].list)
 def VVSepa(self, colNum, textToFind, VVAdNn=False):
  for i in range(len(self["myTable"].list)):
   item = self["myTable"].list[i][colNum + 1][7].strip()
   if textToFind in item:
    self["myTable"].moveToIndex(i)
    break
  else:
   if VVAdNn:
    FFoTZI(self, "Not found", 1000)
 def VV5rHa(self, colDict, VVAdNn=False):
  for i in range(len(self["myTable"].list)):
   for colNum, txt in colDict.items():
    if not txt == self["myTable"].list[i][colNum + 1][7].strip():
     break
   else:
    self["myTable"].moveToIndex(i)
    return
  if VVAdNn:
   FFoTZI(self, "Not found", 1000)
  return False
 def VVEIUC(self, colNum):
  tList = []
  for i in range(len(self["myTable"].list)):
   item = self["myTable"].list[i][colNum + 1][7].strip()
   tList.append(item)
  return tList
 def VViIxP(self, colNum):
  for i in range(len(self["myTable"].list)):
   if not FFXclX(self["myTable"].list[i][colNum + 1][7].strip()):
    return False
  return True
 def VVKa9C(self, colNum, isStrip=True):
  tList = []
  for ndx, row in enumerate(self["myTable"].list):
   if row[1][10] == self.VVo9Tf:
    item = self["myTable"].list[ndx][colNum + 1][7]
    if isStrip: item = item.strip()
    tList.append(item)
  return tList
 def VVSlWK(self):
  if self.VVchAV:
   for ndx, row in enumerate(self["myTable"].list):
    if row[1][10] == self.VVo9Tf:
     return ndx
  return -1
 def VVdxfP(self):
  tList = []
  for ndx, row in enumerate(self["myTable"].list):
   if row[1][10] == self.VVo9Tf:
    item = self["myTable"].list[ndx]
    colList = []
    for i in range(1, self.VVqDHm + 1):
     colList.append(item[i][7].strip())
    tList.append(colList)
  return tList
 def VVDjAB(self, ndx):
  row = self["myTable"].list[ndx]
  if row[1][10] == self.VVo9Tf : return True
  else        : return False
 def VVGpBN(self):
  for ndx, row in enumerate(self["myTable"].list):
   item = self["myTable"].list[ndx]
   colList = []
   for i in range(1, self.VVqDHm + 1):
    colTxt = item[i][7].strip()
    colList.append(colTxt)
   yield colList
 def VV93kA(self):
  if self.VV8OKD:
   self.VVXkaZ(self.VV8OKD)
   return
  if not self["keyMenu"].getVisible() or self.VVRtfk:
   return
  txt  = self.VVAGe1.getValue()
  curRow = self.VVoxea()
  totRows = len(self["myTable"].list)
  itemOf = lambda cond, p1, p2: (p1, p2) if cond else (p1, )
  VV9cxb1, VVqIQu = CCuHRT.VVi0d4(self, False, False)
  VV9cxb = []
  VV9cxb.append(itemOf(txt and curRow < totRows - 1 , "Find Next\t\t>"     , "findNext"  ))
  VV9cxb.append(itemOf(txt and curRow > 0   , "Find Previous\t\t<"    , "findPrev"  ))
  VV9cxb.append(("Find ...\t\t%s" % (FFKrMM(txt, VV1l75) if txt else ""), "findNew"   ))
  VV9cxb.append(itemOf(bool(VV9cxb1)    , "Find (from Filter) ..."   , "filter"   ))
  if self.header:
   VV9cxb.append(VVbM5H)
   VV9cxb.append(("Table Statistcis"            , "tableStat"  ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append((FFKrMM("Export Table to .html"     , VVdLWL) , "VVL8h7" ))
  VV9cxb.append((FFKrMM("Export Table to .csv"     , VVdLWL) , "VVlowo" ))
  VV9cxb.append((FFKrMM("Export Table to .txt (Tab Separated)", VVdLWL) , "VVnaeu" ))
  if self.VVD4Fx:
   sList = []
   tot  = 0
   for i in range(self.VVqDHm):
    if self.VVZ9bG(i):
     tot += 1
     if self.header : name = self.header[i]
     else   : name = "Column-%d" % (i + 1)
     sList.append(("Sort by : %s" % name, i))
   if tot:
    VV9cxb.append(VVbM5H)
    if tot == 1 : VV9cxb.append(("Sort", sList[0][1]))
    else  : VV9cxb += sList
  VVGbyT = ("Keys Help", self.VVNdjo)
  FFO9kU(self, self.VVmnoJ, VV9cxb=VV9cxb, VVPYL1=28,title=self.VVAjLb(), VVGbyT=VVGbyT)
 def VVmnoJ(self, item=None):
  if item is not None:
   title="Exporting ..."
   if   item == "findNext"  : self.VVUL6w()
   elif item == "findPrev"  : self.VVUL6w(isPrev=True)
   elif item == "findNew"  : self.VVCK9E()
   elif item == "filter"  : self.VVnxGN()
   elif item == "tableStat" : self.VVRghi()
   elif item == "VVL8h7": FF7iMz(self, self.VVL8h7, title=title)
   elif item == "VVlowo" : FF7iMz(self, self.VVlowo , title=title)
   elif item == "VVnaeu" : FF7iMz(self, self.VVnaeu , title=title)
   else:
    if self.VVul85 == item: self.VVMZc7 = not self.VVMZc7
    else      : self.VVul85, self.VVMZc7 = item, False
    if self.VVoNmU and self.VVul85 == 0 or self.VViIxP(item):
     self["myTable"].list.sort(key=lambda x: int(x[item + 1][7]), reverse=self.VVMZc7)
    else:
     self["myTable"].list.sort(key=lambda x: x[item + 1][7].lower(), reverse=self.VVMZc7)
    self["myTable"].l.setList(self["myTable"].list)
    self.VVjeun(onlyHeader=True)
 def VVNdjo(self, VVhzhr, path):
  FFY7F5(self, "_help_table", "Table (Keys Help)")
 def VVSmob(self) : self["myTable"].up()
 def VVDGX5(self): self["myTable"].down()
 def VVRlRL(self) : self["myTable"].pageUp()
 def VV4SSV(self): self["myTable"].pageDown()
 def VVpTaG(self)  : self["myTable"].moveToIndex(0)
 def VVbtl9(self)  : self["myTable"].moveToIndex(len(self["myTable"].list) - 1)
 def VVt5t9(self, rowNdx): self["myTable"].moveToIndex(rowNdx)
 def VVP5Ap(self):
  if self.VVAGe1.getValue():
   if self.VVoxea() == len(self["myTable"].list) - 1 : FFoTZI(self, "End reached", 1000)
   else              : self.VVUL6w()
  else:
   FFoTZI(self, 'Set "Find" in Menu', 1500)
 def VVQDSS(self):
  if self.VVAGe1.getValue():
   if self.VVoxea() == 0 : FFoTZI(self, "Top reached", 1000)
   else       : self.VVUL6w(isPrev=True)
  else:
   FFoTZI(self, 'Set "Find" in Menu', 1500)
 def VVJtS0(self, txt):
  FFBWtx(self.VVAGe1, txt)
 def VVCK9E(self):
  FFANcN(self, self.VVQQQ5, title="Find in Table", defaultText=self.VVAGe1.getValue(), message="Enter Text:")
 def VVQQQ5(self, VVV9Cp):
  if not VVV9Cp is None:
   txt = VVV9Cp.strip()
   self.VVJtS0(txt)
   if VVV9Cp: self.VVUL6w(reset=True)
   else  : FFoTZI(self, "Nothing to find !", 1500)
 def VVnxGN(self):
  VV9cxb, VVqIQu = CCuHRT.VVi0d4(self, False, False)
  VVqj6y = ("Edit Filter", BF(self.VVMGi5, VVqIQu))
  if VV9cxb : FFO9kU(self, self.VVl0SC, VV9cxb=VV9cxb, VVqj6y=VVqj6y, title="Find from Filter")
  else  : FFoTZI(self, "Filter Error !", 1500)
 def VVl0SC(self, item=None):
  if item is not None:
   txt = item.strip()
   if txt:
    self.VVJtS0(txt)
    self.VVUL6w(reset=True)
   else:
    FFoTZI(self, "No entry !", 1500)
 def VVMGi5(self, VVqIQu, selectionObj, sel):
  if FFKbVo(VVqIQu) : CCNb3y(self, VVqIQu, VVhK3C=None)
  else       : FFWfGZ(self, VVqIQu)
  selectionObj.cancel()
 def VVUL6w(self, reset=False, isPrev=False):
  curRow = self.VVoxea()
  totRows = len(self["myTable"].list)
  if   reset : row1, row2, steps = 0, totRows, 1
  elif isPrev : row1, row2, steps = curRow - 1, -1, -1
  else  : row1, row2, steps = curRow + 1, totRows, 1
  tupl, asPrefix = CCuHRT.VVzdEZ(self.VVAGe1.getValue())
  if tupl:
   for i in range(row1, row2, steps):
    line = self["myTable"].list[i][self.VVMBr1 + 1][7]
    line = line.strip().lower()
    if asPrefix:
     if line.startswith(tupl):
      self.VVt5t9(i)
      break
    elif any(x in line for x in tupl):
     self.VVt5t9(i)
     break
   else:
    FFoTZI(self, "Not found", 1000)
  else:
   FFoTZI(self, "Check your query", 1500)
 def VVnaeu(self):
  expFile = self.VVMYCn() + ".txt"
  with open(expFile, "w") as f:
   filteredHeader = self.VVWtPt()
   if filteredHeader:
    f.write("\t".join(filteredHeader) + "\n")
   for i in range(len(self["myTable"].list)):
    row = self.VVBWxt(i)
    newRow = []
    for ndx, col in enumerate(row):
     if self.VVd47s(ndx):
      col = self.VV12j8(col)
      col = col.replace("\n", " _ ")
      newRow.append(col)
    f.write("\t".join(newRow) + "\n")
  self.VVNpYk(expFile)
 def VVlowo(self):
  expFile = self.VVMYCn() + ".csv"
  with open(expFile, "w") as f:
   filteredHeader = self.VVWtPt()
   if filteredHeader:
    f.write(",".join(filteredHeader) + "\n")
   pattern = "^[0-9a-fA-F]*$"
   for i in range(len(self["myTable"].list)):
    row = self.VVBWxt(i)
    newRow = []
    for ndx, col in enumerate(row):
     if self.VVd47s(ndx):
      if iMatch(pattern, col) : prefix = "'"
      else     : prefix = ""
      col = self.VV12j8(col)
      col = col.replace(",", ";").replace("\n", " _ ")
      newRow.append(prefix + col)
    f.write(",".join(newRow) + "\n")
  self.VVNpYk(expFile)
 def VVL8h7(self):
  title = FFkEjh(self.VVAjLb()).replace("\t", "&nbsp;" * 4)
  txt   = '<!DOCTYPE html>\n'
  txt  += '<html>\n'
  txt  += ' <head>\n'
  txt  += ' <meta charset="utf-8">\n'
  txt  += ' <meta name="viewport" content="width=device-width, initial-scale=1.0">\n'
  txt  += ' <TITLE>%s - %s (%s)</TITLE>\n' % (title, PLUGIN_NAME, VV8h7S)
  txt  += ' <style>\n'
  txt  += '  table { font-family: arial, sans-serif; border-collapse: collapse; width: 100%; }\n'
  txt  += '  td,th { border: 1px solid #dddddd; text-align: left; padding: 5px; }\n'
  txt  += '  td { font-size: 0.8em; }\n'
  txt  += '  th { color:#006000; background-color:#FFFFaa; font-size: 1.2em; }\n'
  txt  += '  tr:nth-child(even) { background-color: #f8f8f8; }\n'
  txt  += ' </style>\n'
  txt  += ' </head>\n'
  txt  += ' <body>\n'
  txt  += '  <h2 style="color:#006000;">%s</h2>\n' % title
  txt  += '  <table>\n'
  txt  +=     '#colgroup#'
  txt  += '   <tr>#tableHead#</tr>\n'
  txt2  = '  <table>\n'
  txt2 += ' </body>\n'
  txt2 += '</html>\n'
  tableHead  = ""
  filteredHeader = self.VVWtPt()
  if filteredHeader:
   for col in filteredHeader:
    tableHead += '<th>%s</th>' % col
  txt = txt.replace("#tableHead#", tableHead)
  colgroup = ""
  if self.VV8boH:
   colgroup += '   <colgroup>'
   for ndx, w in enumerate(self.VV8boH):
    if self.VVd47s(ndx):
     colgroup += '<col style="width: %d%s;" />' % (w, "%")
   colgroup += "</colgroup>\n"
  txt = txt.replace("#colgroup#", colgroup)
  expFile = self.VVMYCn() + ".html"
  with open(expFile, "w") as f:
   f.write(txt)
   for i in range(len(self["myTable"].list)):
    row = self.VVBWxt(i)
    newRow = "   <tr>"
    for ndx, col in enumerate(row):
     if self.VVd47s(ndx):
      col = self.VV12j8(col)
      newRow += '<td>%s</td>' % col
    newRow += "</tr>\n"
    f.write(newRow)
   f.write(txt2)
  self.VVNpYk(expFile)
 def VVWtPt(self):
  newRow = []
  if self.header:
   for ndx, col in enumerate(self.header):
    if self.VVd47s(ndx):
     newRow.append(col.strip())
  return newRow
 def VV12j8(self, col):
  if col.count(":") > 8:
   col = col.replace(":", "_")
   col = col.rstrip("_")
  col = iSub(r"(#.#[a-fA-F0-9]{8}#)" ,"" , col, flags=IGNORECASE)
  return FFkEjh(col)
 def VVMYCn(self):
  fileName = iSub(r"[^0-9a-zA-Z]+", "_", FFkEjh(self.VVAjLb()))
  fileName = fileName.replace("__", "_")
  expFile  = FFeg8m() + fileName + "_" + FFRIlf()
  return expFile
 def VVNpYk(self, expFile):
  FF0onH(self, "File exported to:\n\n%s" % expFile, title=self.VVAjLb())
 @staticmethod
 def VVI3ci(x, y, w, h, fnt, flg, txt, fg, bg, sFg, sBg, bW, bC):
  return (eListboxPythonMultiContent.TYPE_TEXT, x, y, w, h, fnt, flg, txt, fg, sFg, bg, sBg, bW, bC)
 @staticmethod
 def VVvFdD(x, y, w, h, png, bg=None, bgSel=None):
  typ = eListboxPythonMultiContent.TYPE_PIXMAP_ALPHATEST
  if VVu0iP: return (typ, x, y, w, h, png, bg, bgSel, VVu0iP | CENTER)
  else   : return (typ, x, y, w, h, png, bg, bgSel)
 @staticmethod
 def VVY23h(x, y, w, h, percent, bW, fg):
  return (eListboxPythonMultiContent.TYPE_PROGRESS, x, y, w, h, int(percent), bW, fg)
class CCqCr4():
 def __init__(self, pixmap, VVHkge, VVYCun, fncCb_ok, fncCb_fail):
  self.pixmap   = pixmap
  self.picInst  = pixmap.instance
  self.VVHkge  = VVHkge
  self.VVYCun  = VVYCun or "#2200002a"
  self.fncCb_ok  = fncCb_ok
  self.fncCb_fail  = fncCb_fail
  self.FFdufB  = FFdufB()
 def VVyG0J(self):
  from enigma import ePicLoad
  self.picLoad  = ePicLoad()
  self.picload_conn = None
  if not all((self.pixmap, self.VVHkge, FFKbVo(self.VVHkge))):
   return False
  sz = self.picInst.size()
  self.picLoad.setPara((sz.width(), sz.height(), 1, 1, False, 1, self.VVYCun))
  try:
   if self.FFdufB:
    res = self.picLoad.startDecode(self.VVHkge, False)
    if res == 0:
     return self.VVOIOP()
    else:
     del self.picLoad
     return False
   else:
    try:
     self.picload_conn = self.picLoad.PictureData.connect(self.VVsAoc)
    except:
     self.picLoad.PictureData.get().append(self.VVsAoc)
    res = self.picLoad.startDecode(self.VVHkge)
    return True if res == 0 else False
  except:
   return False
 def VVsAoc(self, pInfo=""):
  ok = self.VVOIOP()
 def VVOIOP(self):
  ok = False
  ptr = self.picLoad.getData()
  if ptr is not None:
   try:
    self.picInst.setPixmap(ptr)
    ok = True
   except:
    pass
  del self.picLoad
  self.picload_conn = None
  if ok and self.fncCb_ok   : self.fncCb_ok()
  if not ok and self.fncCb_fail: self.fncCb_fail()
  return ok
class CCZQAz(Screen):
 def __init__(self, session, VVezFg, title="", showGrnMsg="", fileList=None, VVETIE=0, fakePath=None, cbFnc=None, menuFnc=None):
  scrW, scrH = FFcBkL()
  w = 1700
  h = int(min(w * scrH / scrW + 51, 1040))
  self.skin, self.VVmNvK = FFQaOH(VVa6GH, w, h, 30, 0, 0, "#22000060", "#2200002a", 30, VVcmdl=2 if menuFnc else 3)
  self.session  = session
  self.Title   = title
  self["myPic"]  = Pixmap()
  self.VVezFg = VVezFg
  self.showGrnMsg  = showGrnMsg
  self.fileList  = fileList
  self.VVETIE  = VVETIE
  self.fakePath  = fakePath
  self.cbFnc   = cbFnc
  self.menuFnc  = menuFnc
  FFNhKZ(self)
  FFrM8n(self,
  {
   "ok" : self.close    ,
   "red" : self.close    ,
   "cancel": self.close    ,
   "info" : self.VV3Qe2  ,
   "menu" : self.VV2Aky  ,
   "up" : BF(self.VVX3Ya, -1),
   "down" : BF(self.VVX3Ya,  1),
   "left" : BF(self.VVX3Ya, -1),
   "right" : BF(self.VVX3Ya,  1)
  })
  self.onShown.append(self.VVf1Ra)
  self.onClose.append(self.onExit)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  FFeo1z(self)
  self.VVgbxX()
 def VVgbxX(self):
  self.VVrI3T()
  if os.path.isfile(self.VVezFg) and CC00KO.VVuedz(self.VVezFg) == "pic" and FFLjtI(self.VVezFg) > 0:
   if not FFZ27n(self["myPic"], self.VVezFg, fncCb_ok=self.VVb0uS, fncCb_fail=self.VVUMdW):
    self.VVUMdW()
  else:
   self.VVUMdW()
 def VVb0uS(self):
  if self.showGrnMsg:
   FFxHED(self, self.showGrnMsg, 1500)
 def VVUMdW(self):
  if not FFHTca(self["myPic"], "noPic"):
   FFbBGq(self, "Cannot view picture file:\n\n%s" % self.VVezFg)
   self.close()
 def VVX3Ya(self, direc):
  if self.fileList:
   oldNdx = self.VVETIE
   self.VVETIE += direc
   if direc == -1 and self.VVETIE < 0      : self.VVETIE = len(self.fileList) - 1
   if direc ==  1 and self.VVETIE > len(self.fileList) - 1 : self.VVETIE = 0
   if not oldNdx == self.VVETIE:
    fName = self.fileList[self.VVETIE][1]
    self.VVezFg = FF9Uvy(os.path.dirname(self.VVezFg)) + fName
    self.VVgbxX()
 def onExit(self):
  if self.cbFnc:
   if self.fileList: self.cbFnc(self.VVezFg, self.fileList[self.VVETIE][0])
   else   : self.cbFnc(self.VVezFg)
 def VV3Qe2(self):
  txt = "%s:\n  %s" % (FFKrMM("Path", VVk4x7), self.fakePath or self.VVezFg)
  size, sizeTxt, resTxt, form, mode = CCM6jS.VVQPrD(self.VVezFg)
  if any((size, sizeTxt, resTxt, form, mode)):
   txt += "\n\n%s:\n" % FFKrMM("Properties", VVk4x7)
   if sizeTxt: txt += "  File Size\t: %s\n" % sizeTxt
   if resTxt : txt += "  Dimensions\t: %s\n" % resTxt
   if form   : txt += "  Format\t: %s\n"  % form
   if mode   : txt += "  Mode\t: %s\n"   % mode
  FFSMJz(self, txt, title="File Information")
 def VV2Aky(self):
  if self.menuFnc:
   self.menuFnc(self)
 def VVrI3T(self):
  if self.fileList: title = "%d/%d : %s" % (self.VVETIE + 1, len(self.fileList), self.fileList[self.VVETIE][1])
  elif self.Title : title = self.Title
  else   : title = os.path.basename(self.VVezFg)
  self["myTitle"].setText("  %s  " % title)
 @staticmethod
 def VVRX4k(SELF, VVezFg, **kwargs):
  SELF.session.open(CCZQAz, VVezFg, **kwargs)
class CCBldl(Screen):
 def __init__(self, session, mviFile=None):
  self.skin, self.VVmNvK = FFQaOH(VV7rcW, 400, 55, 30, 0, 0, "#22004455", "#00ff0000", 30)
  self.session  = session
  self.mviFile  = mviFile
  FFNhKZ(self, "Click Cancel to exit", addCloser=True)
  self.onShown.append(self.VVf1Ra)
  self.onClose.append(self.onExit)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  self.curServ = CCZv30(self.session).servRef
  self.session.nav.stopService()
  if FFlonU("showiframe %s" % self.mviFile):
   self.instance.move(ePoint(20, 20))
  else:
   self.close(-1)
 def onExit(self):
  if self.curServ:
   self.session.nav.playService(self.curServ, checkParentalControl=False, forceRestart=False)
 @staticmethod
 def VV9Ayb(SELF, mviFile):
  SELF.session.openWithCallback(BF(CCBldl.VVjZ5W, SELF), CCBldl, mviFile)
 @staticmethod
 def VVjZ5W(SELF, reason=None):
  if reason == -1: FFbBGq(SELF, "Error while viewing mvi file.", title="MVI Viewer")
class CCLbil(Screen, ConfigListScreen):
 def __init__(self, session):
  self.skin, self.VVmNvK = FFQaOH(VVPZ7F, 1400, 1075, 50, 15, 15, "#11201010", "#11101010", 28, VVSwLg=40, VVcmdl=1, VVwv0z=0.1)
  self.session  = session
  self.Title   = "%s Settings" % PLUGIN_NAME
  FFNhKZ(self, title=self.Title)
  FFi79B(self["keyGreen"], "Save")
  sep = SEP * 3
  lst = []
  lst.append(getConfigListEntry("Show in Main Menu"         , CFG.showInMainMenu   ))
  lst.append(getConfigListEntry("Show in Extensions Menu"        , CFG.showInExtensionMenu  ))
  lst.append(getConfigListEntry("Show in Channel List Context Menu"     , CFG.showInChannelListMenu  ))
  lst.append(getConfigListEntry("Show in Events Info Menu"       , CFG.EventsInfoMenu   ))
  lst.append(getConfigListEntry("Input Type"           , CFG.keyboard     ))
  lst.append(getConfigListEntry("Exit-Button Action (in File Manager and FTP)"  , CFG.FileManagerExit   ))
  lst.append(getConfigListEntry("Player Bar Hotkey"         , CFG.hotkey_signal    ))
  lst.append(getConfigListEntry("Screenshot"           , CFG.screenshotFType   ))
  lst.append(getConfigListEntry("Subtitle Files Encoding Priority"     , CFG.subtDefaultEnc   ))
  lst.append(getConfigListEntry(sep             ,         ))
  lst.append(getConfigListEntry("Default IPTV Reference Type (defines the player)" , CFG.iptvAddToBouquetRefType ))
  lst.append(getConfigListEntry("Auto Reset Frozen IPTV Channels"      , CFG.autoResetFrozenIptvChan ))
  lst.append(getConfigListEntry("Skip Adults Channels (from IPTV Server)"    , CFG.hideIptvServerAdultWords ))
  lst.append(getConfigListEntry("Remove IPTV Channel Name Prefix (|EN| , |AR|Drama|)" , CFG.hideIptvServerChannPrefix ))
  lst.append(getConfigListEntry("Portal Servers Connection Timeout (seconds)"   , CFG.portalConnTimeout   ))
  lst.append(getConfigListEntry("IPTV Hosts Files Path (Playlist, Portal, M3U)"  , CFG.iptvHostsMode    ))
  lst.append(getConfigListEntry(sep             ,         ))
  lst.append(getConfigListEntry("Auto Resume (Movies)"        , CFG.resumeMovies    ))
  lst.append(getConfigListEntry("Local Movies and IPTV Download Path"     , CFG.MovieDownloadPath   ))
  lst.append(getConfigListEntry("PIcons Path"           , CFG.PIconsPath    ))
  lst.append(getConfigListEntry("Custom Menu Path"         , CFG.customMenuPath   ))
  lst.append(getConfigListEntry(sep             ,         ))
  lst.append(getConfigListEntry("Main Working Path (Backup/Restore/Screenshot/etc.)" , CFG.backupPath    ))
  ConfigListScreen.__init__(self, lst, session)
  self.VVwEeA()
  self.onShown.append(self.VVf1Ra)
 def VVwEeA(self):
  kList = {
    "ok" : self.VVyuDa   ,
    "green" : self.VVPaKL ,
    "menu" : self.VVM9PS ,
    "cancel": self.VVjSYf
    }
  kLeft = kRight = None
  try:
   from Components.config import ConfigSubList, KEY_LEFT as kLeft, KEY_RIGHT as kRight
  except:
   try:
    from Components.config import ConfigSubList, ACTIONKEY_LEFT as kLeft, ACTIONKEY_RIGHT as kRight
   except:
    pass
  if not (kLeft == kRight == None):
   kList["left"] = BF(self["config"].handleKey, kLeft)
   kList["right"] = BF(self["config"].handleKey, kRight)
   try:
    kList["chanUp"]  = self["config"].pageUp
    kList["chanDown"] = self["config"].pageDown
   except:
    try:
     kList["chanUp"]  = BF(self["config"].VVc6HO, 0)
     kList["chanDown"] = BF(self["config"].VVc6HO, len(self["config"].list) - 1)
    except:
     pass
   FFrM8n(self, kList, name="config_actions")
  else:
   FFrM8n(self, kList, name="actions")
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  FFeo1z(self)
  FFvJ8o(self["config"])
  FFNUiO(self, self["config"])
  FFuwGk(self)
  self["config"].onSelectionChanged.append(self.VVccsV)
  self.VVccsV()
  FFgLA9(self["keyRed"], "#11000000")
  self["keyRed"].show()
 def VVccsV(self):
  cfg = self["config"].getCurrent()[1]
  if isinstance(cfg, ConfigDirectory) and cfg != CFG.subtDefaultEnc: txt = "Change Path"
  else                : txt = "Show Choices"
  self["keyRed"].setText("OK = %s" % txt)
 def VVyuDa(self):
  title, item = self["config"].getCurrent()
  if item:
   if   item == CFG.iptvHostsMode   : self.VVIFu4()
   elif item == CFG.MovieDownloadPath   : self.VVnU7o(item, self["config"].getCurrent()[0])
   elif item == CFG.subtDefaultEnc   : self.VVOw1t()
   elif isinstance(item, ConfigDirectory) : self.VVsQkV(item)
   else         : CCLbil.VVZvbO(self, item, title, width=1100)
 @staticmethod
 def VVZvbO(SELF, confItem, title, lst=None, cbFnc=None, isSave=False, width=800):
  if not lst:
   if   isinstance(confItem, ConfigYesNo)  : lst = [(True, "ON"), (False, "OFF")]
   elif isinstance(confItem, ConfigSelectionNumber):
    lst = confItem.choices.choices
    if not isinstance(lst[0], tuple)  : lst = [(x, x) for x in lst]
   elif isinstance(confItem, ConfigSelection) : lst = confItem.choices.choices
   elif isinstance(confItem, ConfigInteger) : lst = [(x, str(x)) for x in range(confItem.limits[0][0], confItem.limits[0][1] + 1, 1)]
   else          : return
  curNdx = defNdx = -1
  VV9cxb = []
  for ndx, item in enumerate(lst):
   if len(item) == 1:
    val, txt = ("dum",SEP)
   else:
    val, txt = item
    if   val == confItem.value : curNdx, txt = ndx, VV1l75 + txt
    elif val == confItem.default: defNdx, txt = ndx, VVjojy + txt
   VV9cxb.append((txt, val))
  if defNdx == -1: defNdx = curNdx
  VVGbyT  = ("Current", BF(CCLbil.VVXpAD, curNdx))
  VVqj6y = ("Default", BF(CCLbil.VVXpAD, defNdx))
  VVhzhr = FFO9kU(SELF, BF(CCLbil.VVh4Ch, confItem, cbFnc, isSave), VV9cxb=VV9cxb, width=width, VVqj6y=VVqj6y, VVGbyT=VVGbyT, title=title, VVfWsQ="#22221111", VVB5I5="#22110011", VVfINZ="#11550000")
  VVhzhr.VVhINX(curNdx)
 @staticmethod
 def VVh4Ch(confItem, cbFnc, isSave, item=None):
  if not item == None:
   confItem.setValue(item)
   if isSave: FFBWtx(confItem, item)
   if cbFnc: cbFnc()
 @staticmethod
 def VVXpAD(ndx, selectionObj, item):
  selectionObj.VVhINX(ndx)
 @staticmethod
 def VVd6gX(confItem, lst):
  for ndx, item in enumerate(lst):
   if item[0] == confItem.value:
    return ndx
  return -1
 def VVnU7o(self, item, title):
  tot = CClaHD.VVTYUj()
  if tot : FFbBGq(self, "Cannot change while downloading.", title=title)
  else : self.VVsQkV(item)
 def VVOw1t(self):
  curEnc = CFG.subtDefaultEnc.getValue()
  lst = CC6ntZ.VVP96x(self, "", curEnc)
  if lst:
   VVqj6y = ("Default", self.VV6fHD)
   VVGbyT  = ("Current", self.VVEn66)
   VVhzhr = FFO9kU(self, self.VVNqTM, title="Select Priority Encoding", VV9cxb=lst, width=1000, height=1000, VVGbyT=VVGbyT, VVqj6y=VVqj6y, VVfWsQ="#22220000", VVB5I5="#22220000", VVDkqE=True)
   VVhzhr.VVY6ij(curEnc)
 def VVNqTM(self, item=None):
  if item:
   txt, enc, ndx = item
   CFG.subtDefaultEnc.setValue(enc)
 def VV6fHD(self, VVhzhr, item): VVhzhr.VVY6ij(VVgDRh)
 def VVEn66(self, VVhzhr, item): VVhzhr.VVY6ij(CFG.subtDefaultEnc.getValue())
 def VVIFu4(self):
  VV9cxb = []
  VV9cxb.append(("Auto Find" , "auto"))
  VV9cxb.append(("Custom Path" , "cust"))
  FFO9kU(self, self.VVYgIM, VV9cxb=VV9cxb, title="IPTV Hosts Files Path")
 def VVYgIM(self, item=None):
  if item:
   if item == "auto":
    CFG.iptvHostsMode.setValue(VV6RVR)
   elif item == "cust":
    VVuGUx = self.VVlzMY()
    if VVuGUx : self.VV7ATA(VVuGUx)
    else  : self.session.openWithCallback(self.VVjSc5, BF(CC17eA, mode=CC17eA.VVAcq8, VVqNQm="/"))
 def VV7ATA(self, VVuGUx):
  VVpW7I = self.VVwIfU
  VVjW3s = ("Remove"  , self.VVfiis , [])
  VV46TD = ("Add "  , self.VVbcIN, [])
  header   = ("Directory" , "Remarks" )
  widths   = (80   , 20  )
  VV4Uoc  = (LEFT   , LEFT  )
  FFCXsL(self, None, title="IPTV Hosts Search Paths", header=header, VVXpNQ=VVuGUx, width=1200, height=700, VV4Uoc=VV4Uoc, VV8boH=widths, VVPYL1=26, VVpW7I=VVpW7I, VVjW3s=VVjW3s, VV46TD=VV46TD
    , VVfWsQ="#22220000", VVB5I5="#22110000", VVYCun="#22110011", VVmErq="#11223025", VVK8UQ="#0a333333", VVgSJJ="#11400040")
 def VVwIfU(self, VVAIxO):
  if CFG.iptvHostsDirs.getValue():
   CFG.iptvHostsMode.setValue(VVdfOm)
  VVAIxO.cancel()
 def VVjSc5(self, path):
  if path:
   FFBWtx(CFG.iptvHostsDirs, FF9Uvy(path.strip()))
   VVuGUx = self.VVlzMY()
   if VVuGUx : self.VV7ATA(VVuGUx)
   else  : FFoTZI(self, "Cannot add dir", 1500)
 def VVoojz(self):
  lst = CFG.iptvHostsDirs.getValue().split(",")
  lst = list(set(list(map(str.strip, lst))))
  if len(lst) == 0 or len(lst[0]) == 0 or lst[0] == VV6RVR:
   return []
  return lst
 def VVlzMY(self):
  lst = self.VVoojz()
  if lst:
   VVuGUx = []
   for Dir in lst:
    VVuGUx.append((Dir, "#f#0000ff00#Dir exists" if VVkY7E(Dir) else "#f#00ffa000#Not found"))
   VVuGUx.sort(key=lambda x: x[0].lower())
   return VVuGUx
  else:
   return []
 def VVbcIN(self, VVAIxO, title, txt, colList):
  sDir = parent = os.path.abspath(os.path.join(colList[0], os.pardir))
  self.session.openWithCallback(BF(self.VVpL1H, VVAIxO)
         , BF(CC17eA, mode=CC17eA.VVAcq8, VVqNQm=sDir))
 def VVpL1H(self, VVAIxO, path):
  if path:
   path = FF9Uvy(path.strip())
   if self.VVzDRG(VVAIxO, path):
    FFoTZI(VVAIxO, "Already added", 1500)
   else:
    lst = self.VVoojz()
    lst.append(path)
    FFBWtx(CFG.iptvHostsDirs, ",".join(lst))
    VVuGUx = self.VVlzMY()
    VVAIxO.VVEEBV(VVuGUx, VVyoYa=BF(self.VVt0dJ, path))
 def VVt0dJ(self, path, VVAIxO, title, txt, colList):
  self.VVzDRG(VVAIxO, path)
 def VVzDRG(self, VVAIxO, path):
  for ndx, row in enumerate(VVAIxO.VVGpBN()):
   if row[0].strip() == path.strip():
    VVAIxO.VVt5t9(ndx)
    return True
  return False
 def VVfiis(self, VVAIxO, title, txt, colList):
  path = colList[0]
  FF6pUe(self, BF(self.VVG4u3, VVAIxO), "Remove this path from list?\n\n%s" % path, title="Remove path from list")
 def VVG4u3(self, VVAIxO):
  row = VVAIxO.VVQDwi()
  path, rem = row[0], row[1]
  VVuGUx = []
  lst = []
  for ndx, row in enumerate(VVAIxO.VVGpBN()):
   tPath, tRem = row[0].strip(), row[1].strip()
   if not path == tPath:
    lst.append(tPath)
    VVuGUx.append((tPath, tRem))
  if len(VVuGUx) > 0:
   FFBWtx(CFG.iptvHostsDirs, ",".join(lst))
   VVAIxO.VVEEBV(VVuGUx)
   FFoTZI(VVAIxO, "Deleted", 1500)
  else:
   FFBWtx(CFG.iptvHostsMode, VV6RVR)
   FFBWtx(CFG.iptvHostsDirs, "")
   VVAIxO.cancel()
   FFvfpL(BF(FFoTZI, self, "Changed to Auto-Find", 1500))
 def VVsQkV(self, configObj):
  sDir = configObj.getValue()
  self.session.openWithCallback(BF(self.VVPaxp, configObj)
         , BF(CC17eA, mode=CC17eA.VVAcq8, VVqNQm=sDir))
 def VVPaxp(self, configObj, path):
  if len(path) > 0:
   configObj.setValue(path)
 def VVjSYf(self):
  for x in self["config"].list:
   if len(x) == 2 and FFHY8B(x[1]):
    FF6pUe(self, self.VVPaKL, "Save Changes ?", callBack_No=self.cancel, title=self.Title)
    break
  else:
   self.cancel()
 def VVPaKL(self):
  for x in self["config"].list:
   if len(x) == 2 and FFHY8B(x[1]):
    x[1].save()
  self.VVBKv1()
  self.close()
 def cancel(self):
  for x in self["config"].list:
   try:
    x[1].cancel()
   except:
    pass
  self.close()
 def VVM9PS(self):
  c1, c2, c3 = VVdLWL, VVWH8U, VVk4x7
  VV9cxb = []
  VV9cxb.append(("Change Text Color Scheme (fix Transparent Text)", "changeColorScheme" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append((c1 + "Reset %s Settings" % PLUGIN_NAME, "VV8DI7"))
  VV9cxb.append(VVbM5H)
  VV9cxb.append((c2 + "Backup %s Settings" % PLUGIN_NAME , "VVqeKL"))
  VV9cxb.append((c2 + "Restore %s Settings" % PLUGIN_NAME, "VVr99k"))
  VV9cxb.append(VVbM5H)
  if CFG.checkForUpdateAtStartup.getValue() : txt, ref = "Disable", "disableChkUpdate"
  else          : txt, ref = "Enable", "enableChkUpdate"
  VV9cxb.append((c3 + '%s Checking for Update' % txt, ref    ))
  VV9cxb.append((c3 + "Reinstall %s" % PLUGIN_NAME , "VVpc1L" ))
  VV9cxb.append((c3 + "Update %s" % PLUGIN_NAME  , "VVryNZ"  ))
  FFO9kU(self, self.VVbTVM, VV9cxb=VV9cxb, title="Config. Options")
 def VVbTVM(self, item=None):
  if item:
   title = "%s Settings" % PLUGIN_NAME
   if  item == "changeColorScheme": self.session.open(CCEsU0)
   elif item == "VV8DI7"  : FF6pUe(self, BF(self.VV8DI7, True), "Clear all settings (including File Manager bookmarks) ?", title=title)
   elif item == "VVqeKL" : self.VVqeKL()
   elif item == "VVr99k" : self.VVr99k()
   elif item == "enableChkUpdate" : FFBWtx(CFG.checkForUpdateAtStartup, True)
   elif item == "disableChkUpdate" : FFBWtx(CFG.checkForUpdateAtStartup, False)
   elif item == "VVpc1L" : self.VVLQ8r(True )
   elif item == "VVryNZ"  : self.VVLQ8r(False)
 def VVqeKL(self):
  path = "%sajpanel_settings_%s" % (FFJv8S(), FFRIlf())
  FFZZgw("grep .%s. %s > %s" % (PLUGIN_NAME, VVlLfA, path))
  FF0onH(self, "Saved to file:\n\n%s" % path, title="Export %s Settings" % PLUGIN_NAME)
 @FFJRPn("Searching for Settings ...")
 def VVr99k(self):
  title = "Import %s Settings" % PLUGIN_NAME
  name  = "ajpanel_settings_"
  files = FFQ1wB("find / %s -iname '%s*' | grep %s" % (FFbt47(1), name, name))
  if files:
   err = CC17eA.VVUDvl(files)
   if err:
    FF6pUe(self, BF(self.VVJRQQ, title), "No valid settings files found !\n\nLocate Manually ?", title=title)
   else:
    try:
     files = sorted(files, key=lambda t: -os.stat(t).st_mtime)
    except Exception as e:
     FFbBGq(self, "Error:\n\n%s" % str(e), title=title)
     return
    VV9cxb = []
    for line in files:
     VV9cxb.append((line, line))
    FFO9kU(self, BF(self.VVb5tK, title), title=title, VV9cxb=VV9cxb, width=1200, VV1NnQ="")
  else:
   FFbBGq(self, "No settings files found !", title=title)
 def VVJRQQ(self, title, path=None):
  sDir = "/"
  for path in (FFJv8S(), "/media/usb/", "/media/hdd/", "/media/"):
   if VVkY7E(path):
    sDir = path
    break
  self.session.openWithCallback(BF(self.VVb5tK, title), BF(CC17eA, VV8JM3="ajpSet", VVqNQm=sDir))
 def VVb5tK(self, title, path=None):
  if path:
   if VVkY7E(path):
    lines  = FF2kXa(path)
    self.VV8DI7()
    for line in lines:
     name, _, val = line.partition("=")
     try:
      confItem = eval(name)
      if confItem is not None:
       if   isinstance(confItem, ConfigInteger)  : val = int(val)
       elif isinstance(confItem, ConfigSelectionNumber): val = int(val)
       elif isinstance(confItem, ConfigYesNo)   : val = { "true": True, "false": False }.get(val.lower())
       if not val is None:
        confItem.setValue(val)
        confItem.save()
     except:
      pass
    FFrxHY(self)
    self.VVBKv1()
    FFxHED(self, "Done", 1500)
   else:
    FFWfGZ(self, path, title=title)
 def VV8DI7(self, exit=False):
  for (key, cfg) in CFG.content.items.items():
   cfg.setValue(cfg.default)
  for x in self["config"].list:
   try:
    x[1].save()
   except:
    pass
  FFrxHY()
  self.VVBKv1()
  if exit:
   self.close()
 def VVBKv1(self):
  configfile.save()
  self.VVLma7(CFG.showInExtensionMenu.getValue(), iPlugins.getPlugins(PluginDescriptor.WHERE_EXTENSIONSMENU), [FFni3h(), FFcNlu(), FFC2ni(), FFAuFx(), FF8JUs(), FFRrQ4(), FFlNFN(), FFJfv8()])
  self.VVLma7(CFG.EventsInfoMenu.getValue(), iPlugins.getPlugins(PluginDescriptor.WHERE_EVENTINFO), [ FFoGZv() ])
 @staticmethod
 def VVLma7(setVal, pluginList, dList):
  try:
   if setVal:
    for item in dList:
     if not item in pluginList:
      iPlugins.addPlugin(item)
   else:
    for item in dList:
     if item in pluginList:
      iPlugins.removePlugin(item)
  except:
   pass
  FFLgRo()
 @FFJRPn("Checking Server ...")
 def VVLQ8r(self, force):
  pre = "Reinstall" if force else "Update"
  title = "%s %s (from server)" % (pre, PLUGIN_NAME)
  curVer, webVer, url, isHigher, err = CCLbil.VVKPzl()
  if   err    : FFbBGq(self, err, title)
  elif isHigher or force : FF6pUe(self, BF(self.VVD0Tc, webVer, url, title, force), "%s v%s and Restart ?" % ("Reinstall" if force else "Upgrade to", webVer), title=title)
  else     : FF0onH(self, FFKrMM("No update required.", VVOQkl) + "\n\nCurrent Version = v%s\n\nWeb Version = v%s" % (curVer, webVer), title)
 @FFJRPn()
 def VVD0Tc(self, webVer, url, title, force):
  fName = "enigma2-plugin-extensions-ajpanel_v%s_all.%s" % (webVer, "deb" if FFJMbF() == "dpkg" else "ipk")
  path, err = FFUzwU(url + fName, fName, timeout=2)
  if path:
   if force: cmd = FF4zTV(VVNtuq, path)
   else : cmd = FF4zTV(VVT1hn, path)
   if cmd:
    cmd = "%s && echo -e '\nSUCCESSFUL' || echo -e '\nERROR FOUND !'; rm -rf '%s'" % (cmd, path)
    FF6NKJ(self, cmd, title=title)
   else:
    FFWaiD(self, title=title)
  else:
   FFbBGq(self, err, title=title)
 @staticmethod
 def VVKPzl():
  url = CCLbil.VVv9JN()
  curVer = VV8h7S
  path, err = FFUzwU(url + "version", "ajp_tmp.ver", timeout=2)
  if err or not FFKbVo(path):
   return curVer, "", url, False, "Cannot get version file from server."
  else:
   webVer = FFmx8y(path)
   FFnE7j(path)
   cVer, wVer, isHigher = CCz0DD.VVQmy3(curVer, webVer)
   return cVer, wVer, url, isHigher, ""
 @staticmethod
 def VVSHHu(): return "https://github.com/AMAJamry/AJPanel"
 @staticmethod
 def VVv9JN(): return "https://raw.githubusercontent.com/AMAJamry/AJPanel/main/"
class CCEsU0(Screen):
 def __init__(self, session):
  self.skin, self.VVmNvK = FFQaOH(VVTxiS, 1200, 620, 50, 20, 0, "#22002020", "#22001122", 30)
  self.cursorPos = VVfsez
  self.Title  = "Select Color Scheme (for areas with mixed-color text)"
  self.session = session
  FFNhKZ(self, title=self.Title)
  sp = "    "
  self["myColorF"] = Label()
  for i in range(4):
   txt = "\n"
   txt += self.VVqEsg(r"\c00FFFFFF", i) + sp + "WHITE\n"
   txt += self.VVqEsg(r"\c00888888", i) + sp + "GREY\n"
   txt += self.VVqEsg(r"\c005A5A5A", i) + sp + "DARK GREY\n"
   txt += self.VVqEsg(r"\c00FF0000", i) + sp + "RED\n"
   txt += self.VVqEsg(r"\c00FF5000", i) + sp + "ORANGE\n"
   txt += self.VVqEsg(r"\c00FFFF00", i) + sp + "YELLOW\n"
   txt += self.VVqEsg(r"\c00FFFFAA", i) + sp + "B. YELLOW\n"
   txt += self.VVqEsg(r"\c0000FF00", i) + sp + "GREEN\n"
   txt += self.VVqEsg(r"\c000066FF", i) + sp + "BLUE\n"
   txt += self.VVqEsg(r"\c0000FFFF", i) + sp + "CYAN\n"
   txt += self.VVqEsg(r"\c00FA55E7", i) + sp + "PURPLE\n"
   txt += self.VVqEsg(r"\c00FF8F5F", i) + sp + "PEACH\n"
   self["myColor%s" % i] = Label(txt)
  FFrM8n(self,
  {
   "ok" : self.VVyuDa ,
   "green" : self.VVyuDa ,
   "left" : self.VVDDr1 ,
   "right" : self.VVksC6 ,
   "cancel": self.close
  })
  self.onShown.append(self.VVf1Ra)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  self.VVjU4p()
 def VVyuDa(self):
  if self.cursorPos == 0 : txt = "No Colors"
  else     : txt = "Color Scheme-%d" % self.cursorPos
  FF6pUe(self, self.VV9CNL, "Change to : %s" % txt, title=self.Title)
 def VV9CNL(self):
  FFBWtx(CFG.mixedColorScheme, self.cursorPos)
  global VVfsez
  VVfsez = self.cursorPos
  self.VVf00P()
  self.close()
 def VVDDr1(self):
  self.cursorPos -= 1
  if self.cursorPos < 0:
   self.cursorPos = 3
  self.VVjU4p()
 def VVksC6(self):
  self.cursorPos += 1
  if self.cursorPos > 3:
   self.cursorPos = 0
  self.VVjU4p()
 def VVjU4p(self):
  left = []
  for i in range(4):
   left.append(self["myColor%s" % i].getPosition()[0])
  left = left[self.cursorPos] - 4
  top = self["myColor0"].getPosition()[1] - 4
  self.cursorPos
  self["myColorF"].instance.move(ePoint(left, top))
 @staticmethod
 def VVqEsg(color, mode):
  if   mode == 1 : return color
  elif mode == 2 : return color.replace("A", "9").replace("B", "9").replace("C", "9").replace("D", "9").replace("E", "9").replace("F", "9")
  elif mode == 3 : return color.replace("A", ":").replace("B", ";").replace("C", "<").replace("D", "=").replace("E", ">").replace("F", "?")
  else   : return ""
 @staticmethod
 def VVUvkG(color):
  if VVjojy: return "\\" + color
  else    : return ""
 @staticmethod
 def VVf00P():
  global VV3Hcc, VV0p9P, VVPI2q, VVU4M8, VVdLWL, VVWJEN, VV0MNp, VVaWxS, VVOQkl, VVWH8U, VVjojy, VVk4x7, VV1l75, VVv8b8, VV2jvK, VVCQUS
  VVCQUS   = CCEsU0.VVqEsg(r"\c00FFFFFF", VVfsez)
  VV0p9P    = CCEsU0.VVqEsg(r"\c00888888", VVfsez)
  VV3Hcc  = CCEsU0.VVqEsg(r"\c005A5A5A", VVfsez)
  VVaWxS    = CCEsU0.VVqEsg(r"\c00FF0000", VVfsez)
  VVPI2q   = CCEsU0.VVqEsg(r"\c00FF5000", VVfsez)
  VVU4M8   = CCEsU0.VVqEsg(r"\c00FFBB66", VVfsez)
  VVjojy   = CCEsU0.VVqEsg(r"\c00FFFF00", VVfsez)
  VVk4x7 = CCEsU0.VVqEsg(r"\c00FFFFAA", VVfsez)
  VVOQkl   = CCEsU0.VVqEsg(r"\c0000FF00", VVfsez)
  VVWH8U  = CCEsU0.VVqEsg(r"\c00AAFFAA", VVfsez)
  VV0MNp    = CCEsU0.VVqEsg(r"\c000066FF", VVfsez)
  VV1l75    = CCEsU0.VVqEsg(r"\c0000FFFF", VVfsez)
  VVv8b8  = CCEsU0.VVqEsg(r"\c00AAFFFF", VVfsez)  #
  VV2jvK   = CCEsU0.VVqEsg(r"\c00FA55E7", VVfsez)
  VVdLWL    = CCEsU0.VVqEsg(r"\c00FF8F5F", VVfsez)
  VVWJEN  = CCEsU0.VVqEsg(r"\c00FFC0C0", VVfsez)
CCEsU0.VVf00P()
class CC8i1k():
 VVUtF2  = "666"
 VVVr1v   = "888"
 def __init__(self, SELF, waitMsgSELF, title, servRefListFnc, VVLpD7=""):
  self.SELF     = SELF
  self.waitMsgSELF   = waitMsgSELF
  self.Title     = title
  self.servRefListFnc   = servRefListFnc
  self.VVLpD7    = VVLpD7
  self.VVhzhr   = None
  self.VV1tVC()
 def VV1tVC(self):
  VV9cxb = CC8i1k.VVtTm6()
  bNames = [x[0] for x in VV9cxb if len(x) == 2]
  if VV9cxb:
   VVqj6y = ("Create New", BF(self.VVBW5x, bNames))
   self.VVhzhr = FFO9kU(self.SELF, self.VVeK7V, VV9cxb=VV9cxb, title=self.Title, VVqj6y=VVqj6y, VVDkqE=True, VVfWsQ="#22222233", VVB5I5="#22222233")
  else:
   self.VVBW5x("")
 def VVeK7V(self, item):
  if item:
   bName, bRef, ndx = item
   self.VVZHYc(bName, bRef)
  else:
   CC8i1k.VVUe0I(self)
 def VVBW5x(self, bNames, selectionObj=None, item=None):
  name = self.VVLpD7
  if not name:
   name = "Bouquet1"
   c = 1
   while name in bNames:
    c += 1
    name = "Bouquet%s" % c
  FFANcN(self.SELF, BF(self.VV0RAr), defaultText=name, title="Create New Bouquet", message="Enter Bouquet Name:")
 def VV0RAr(self, bName):
  if bName:
   bName = bName.strip()
   if bName:
    if self.VVhzhr:
     self.VVhzhr.cancel()
    self.VVZHYc(bName, "")
   else:
    FFoTZI(self.VVhzhr, "Incorrect Bouquet Name !", 2000)
    CC8i1k.VVUe0I(self)
 def VVZHYc(self, bName, bRef):
  FF7iMz(self.waitMsgSELF, BF(self.VVWHUm, bName, bRef), title="Adding Services ...")
 def VVWHUm(self, bName, bRef):
  CC8i1k.VVWTLg(self.SELF, self.Title, bName, bRef, self.servRefListFnc())
 @staticmethod
 def VVUe0I(classObj):
  del classObj
 @staticmethod
 def VVWTLg(SELF, title, bName, bRef, servRefLst, showRes=True):
  if not servRefLst:
   FFbBGq(SELF, "No services to add !", title=title)
   return
  tvBouquetFile = VVgVTn + "bouquets.tv"
  if not FFKbVo(tvBouquetFile):
   FFWfGZ(SELF, tvBouquetFile, title=title)
   return
  if bRef:
   bFile = CC8i1k.VVRPbd(bRef)
   bPath = VVgVTn + bFile
  else:
   fName = CCTe4w.VVXxU8(bName)
   bFile = "userbouquet.%s.tv" % fName
   bPath = VVgVTn + bFile
   num   = 0
   while FFKbVo(bPath):
    num += 1
    bFile = "userbouquet.%s_%d.tv" % (fName, num)
    bPath = VVgVTn + bFile
   with open(bPath, "w") as f:
    f.write("#NAME %s\n" % bName)
  FF03ch(bPath)
  with open(bPath, "a") as f:
   for chUrl in servRefLst:
    serv = eServiceReference(chUrl)
    VVUwmk = serv and serv.getName() or ""
    try:
     VVUwmk = VVUwmk.encode("UTF-8", "replace").decode()
    except:
     VVUwmk = FFvKOW(VVUwmk, r"?")
    f.write("#SERVICE %s\n"  % chUrl)
    f.write("#DESCRIPTION %s\n" % VVUwmk)
  if not bRef and FFKbVo(bPath):
   FF03ch(tvBouquetFile)
   with open(tvBouquetFile, "a") as f:
    f.write('#SERVICE 1:7:1:0:0:0:0:0:0:0:FROM BOUQUET "%s" ORDER BY bouquet\n' % bFile)
  totPicons = 0
  piconPath = CCRGqC.VV5G3P()
  for chUrl in servRefLst:
   span = iSearch(r"((?:[A-Fa-f0-9]+:){10})", chUrl.rstrip(":"))
   if span:
    serv = eServiceReference(chUrl)
    if serv:
     picon = piconPath + span.group(1).strip(":").replace(":", "_").upper() + ".png"
     fPath = serv.getPath()
     fNameNoExt = os.path.splitext(serv.getPath())[0]
     for ext in ("png", "jpg", "bmp", "gif", "jpe", "jpeg"):
      poster = "%s.%s" % (fNameNoExt, ext)
      if FFKbVo(poster):
       totPicons += 1
       FFlonU("cp -f '%s' '%s'" % (poster, picon))
       FFlonU(CCpebE.VV4mAF(picon))
       break
  FFANYL()
  if showRes:
   txt  = "Bouquet Name\t\t: %s\n"  % bName
   txt += "Added Services\t\t: %d\n" % len(servRefLst)
   if totPicons:
    txt += "Added PIcons\t\t: %s" % totPicons
   FFSMJz(SELF, txt, title=title)
 @staticmethod
 def VVGOEc(bName):
  mode = CCM4Rv.VVsFRh(default=-1)
  modeTxt = "tv" if mode == 0 else "radio"
  fName = CCTe4w.VVXxU8(bName)
  bFile = "userbouquet.%s.%s" % (fName, modeTxt)
  num   = 0
  while FFKbVo(VVgVTn + bFile):
   num += 1
   bFile = "userbouquet.%s_%d.%s" % (fName, num, modeTxt)
  with open(VVgVTn + bFile, "w") as f:
   f.write("#NAME %s\n" % bName)
  mainBFile = "%sbouquets.%s" % (VVgVTn, modeTxt)
  if FFKbVo(mainBFile):
   FF03ch(mainBFile)
   with open(mainBFile, "a") as f:
    f.write('#SERVICE 1:7:1:0:0:0:0:0:0:0:FROM BOUQUET "%s" ORDER BY bouquet\n' % bFile)
 @staticmethod
 def VVpWeM(ref, bName):
  bFile = CC8i1k.VVRPbd(ref)
  ok = False
  if bFile:
   bFile = VVgVTn + bFile
   if FFKbVo(bFile):
    lines = FF2kXa(bFile, keepends=True)
    with open(bFile, "w") as f:
     for line in lines:
      if line.startswith("#NAME "):
       f.write("#NAME %s\n" % bName)
       ok = True
      else:
       f.write(line)
  return ok
 @staticmethod
 def VVtTm6(mode=2, showTitle=True, prefix="", onlyIptv=False):
  VV9cxb = []
  if mode in (0, 2): VV9cxb.extend(CC8i1k.VVxIrJ(0, showTitle, prefix, onlyIptv))
  if mode in (1, 2): VV9cxb.extend(CC8i1k.VVxIrJ(1, showTitle, prefix, onlyIptv))
  return VV9cxb
 @staticmethod
 def VVxIrJ(mode, showTitle, prefix, onlyIptv):
  VV9cxb = []
  lst = CC8i1k.VVHRNT(mode)
  if onlyIptv:
   lst = CC8i1k.VVofI8(lst)
  if lst:
   if showTitle:
    VV9cxb.append(FFT7cF("TV Bouquets" if mode == 0 else "Radio Bouquets"))
   if prefix:
    for item in lst : VV9cxb.append((item[0], prefix + item[0]))
   else:
    for item in lst : VV9cxb.append((item[0], item[1].toString()))
  return VV9cxb
 @staticmethod
 def VVofI8(lst):
  fLst = CCTe4w.VVcN0J(onlyFileName=True)
  newLst = []
  if fLst:
   for item in lst:
    span = iSearch(r".+(userbouquet\..+\.(tv|radio))", item[1].toString())
    if span and span.group(1) in fLst:
     newLst.append(item)
  return newLst
 @staticmethod
 def VVLzVr():
  lst = CC8i1k.VVHRNT(0)
  lst.extend(CC8i1k.VVHRNT(1))
  return lst
 @staticmethod
 def VVHRNT(mode=0):
  bList = []
  VV2RgF = InfoBar.instance
  VVVnHH = VV2RgF and VV2RgF.servicelist
  if VVVnHH:
   curMode = VVVnHH.mode
   CC8i1k.VVgU0P(VVVnHH, mode)
   bList.extend(VVVnHH.getBouquetList() or [])
   CC8i1k.VVgU0P(VVVnHH, curMode)
  return bList
 @staticmethod
 def VVgU0P(VVVnHH, mode):
  if not mode == VVVnHH.mode:
   if   mode == 0: VVVnHH.setModeTv()
   elif mode == 1: VVVnHH.setModeRadio()
 @staticmethod
 def VV2aLp(isAll=True, onlyMain=False):
  bLst = []
  inst = InfoBar.instance
  if inst:
   csel = inst.servicelist
   if csel:
    root = csel.bouquet_root
    VVimsO = eServiceCenter.getInstance()
    if onlyMain:
     info = VVimsO.info(root)
     if info:
      bLst.append((info.getName(root), root.toString()))
    else:
     list = VVimsO and VVimsO.list(root)
     if list:
      while True:
       s = list.getNext()
       if not s.valid():
        break
       if isAll or (s.flags & eServiceReference.isDirectory and not s.flags & eServiceReference.isInvisible):
        info = VVimsO.info(s)
        if info:
         bLst.append((info.getName(s), s.toString()))
  return bLst
 @staticmethod
 def VVvCo4():
  lst = []
  types = ('*.*.tv', '*.*.radio')
  for f in types:
   lst.extend(iGlob(VVgVTn + f))
  return lst
 @staticmethod
 def VVRPbd(bRef):
  span = iSearch(r'BOUQUET\s+"(.+)"\s+ORDER', bRef, IGNORECASE)
  if span : return span.group(1)
  else : return ""
 @staticmethod
 def VV3qvy(ref, dstFile):
  dstFile = VVgVTn + dstFile
  if FFKbVo(dstFile):
   FF03ch(dstFile)
   bLine = ""
   VV4A6n = CC8i1k.VVRPbd(ref)
   if VV4A6n:
    span = iSearch(r"\.(.+)\.(tv|radio)", VV4A6n, IGNORECASE)
    if span:
     fName, fType = span.group(1), span.group(2)
     newName = "userSubBouquet.%s.%s" % (fName, fType)
     num = 0
     while FFKbVo(VVgVTn + newName):
      num += 1
      newName = "userSubBouquet.%s_%d.%s" % (fName, num, fType)
     subFile = VVgVTn + newName
     FFlonU("cp -f '%s%s' '%s'" % (VVgVTn, VV4A6n, subFile))
     if FFKbVo(subFile):
      bLine = '1:7:1:0:0:0:0:0:0:0:FROM BOUQUET "%s" ORDER BY bouquet' % newName
   else:
    bLine = ref
   if bLine:
    if FFKbVo(dstFile):
     with open(dstFile, "a") as f:
      f.write("#SERVICE %s\n" % bLine)
     return True
  return False
 @staticmethod
 def VVPik6():
  try:
   fName = CC8i1k.VVRPbd(InfoBar.instance.servicelist.getRoot().toString())
   path = "%s%s" % (VVgVTn, fName)
   if FFKbVo(path):
    return path
  except:
   pass
  return ""
 @staticmethod
 def VVW657():
  path = CC8i1k.VVPik6()
  if path:
   txt = FFmx8y(path, maxSize=300)
   span = iSearch(r"#NAME\s+(.*)", txt, IGNORECASE)
   if span:
    return span.group(1).strip()
  return ""
 @staticmethod
 def VV2lFz(mode=0):
  return FFM85b(InfoBar.instance.servicelist.getRoot(), mode)
 @staticmethod
 def VVkiEP():
  lst = []
  for b in CC8i1k.VVLzVr():
   bName = b[0]
   bRef  = b[1].toString()
   path = VVgVTn + CC8i1k.VVRPbd(bRef)
   if FFKbVo(path):
    lines = FF2kXa(path)
    for line in lines:
     if line.startswith("#SERVICE"):
      if not line.startswith("#SERVICE 1:64:"):
       break
    else:
     if not "userbouquet.favourites." in bRef:
      lst.append((bName, bRef))
  return lst
 @staticmethod
 def VV2HhD(SID, stripRType):
  if stripRType: return r"(?:[A-Fa-f0-9]+:)((?:[A-Fa-f0-9]+:){2}%s:(?:[A-Fa-f0-9]+:){6})" % SID
  else   : return r"((?:[A-Fa-f0-9]+:){3}%s:(?:[A-Fa-f0-9]+:){6})" % SID
 @staticmethod
 def VVXaQN(SID="", stripRType=False):
  if SID : patt = CC8i1k.VV2HhD(SID, stripRType)
  else : patt = r"((?:[A-Fa-f0-9]+:){10})"
  lst = []
  for b in CC8i1k.VVLzVr():
   for service in FFM85b(b[1]):
    span = iSearch(patt, service[0])
    if span:
     lst.append(span.group(1).upper())
  return lst
 @staticmethod
 def VV0t8D():
  patt = r"((?:[A-Fa-f0-9]+:){10})http.+"
  lst = []
  for b in CC8i1k.VVLzVr():
   for service in FFM85b(b[1]):
    span = iSearch(patt, service[0])
    if span:
     lst.append(span.group(1).upper().rstrip(":"))
  return lst
 @staticmethod
 def VVjNDz():
  patt = r"((?:[A-Fa-f0-9]+:){10})http.+"
  lst = []
  for b in CC8i1k.VVLzVr():
   for service in FFM85b(b[1]):
    span = iSearch(patt, service[0])
    if span:
     lst.append((span.group(1).upper().rstrip(":"), service[1]))
  return lst
 @staticmethod
 def VV3nfz(rType, SID, refLst, startId, startNS):
  for Id in range(max(6, startId), 65535):
   hexId = ("%1x" % Id).upper()
   for NS in range(startNS, 65535):
    hexNS = ("FFF%04x" % NS).upper()
    tRef = "0:1:%s:%s:%s:%s:0:0:0:" % (SID, hexId, hexId, hexNS)
    if not tRef in refLst:
     VVq9SN = "%s:0:1:%s:%s:%s:%s:0:0:0:" % (rType, SID, hexId, hexId, hexNS)
     if NS < 65535 - 1: NS += 1
     else    : NS, Id = 6, Id + 1
     return VVq9SN, Id, NS
  return "", 0, 0
 @staticmethod
 def VVoNd2(pathLst, rType=""):
  refLst = CC8i1k.VVXaQN(CC8i1k.VVUtF2, stripRType=True)
  chUrlLst = []
  startId  = startNS = 0
  rType  = rType or CFG.iptvAddToBouquetRefType.getValue()
  for path in pathLst:
   VVq9SN, startId, startNS = CC8i1k.VV3nfz(rType, CC8i1k.VVUtF2, refLst, startId, startNS)
   if VVq9SN:
    VVUwmk = os.path.splitext(os.path.basename(path))[0].replace("-", " ").replace("_", " ").replace(".", " ")
    chUrl = "%s%s:%s" % (VVq9SN, path, VVUwmk)
    chUrlLst.append(chUrl)
   else:
    break
  return chUrlLst
class CC17eA(Screen, CCvFMf):
 VVkDQs   = 0
 VVD8zE  = 1
 VVAcq8  = 2
 VVKzxn = 3
 VVdHom  = 4
 VVxiUy    = 20
 VV1LRK   = 0
 VVXp19   = 1
 VVC1x4   = 2
 def __init__(self, session, VVqNQm="/", mode=VVkDQs, VVhKiJ="Select", width=1400, height=920, VVPYL1=30, VVfWsQ="#22001111", VVB5I5="#22000000", pickTitleBG="#11001144", pickBodyBG="#08002244", VVfINZ="#06004444", VVeQ50=False, VVNzrh="", VV8JM3="", VVVh8u=False):
  self.skin, self.VVmNvK = FFQaOH(VVNkG2, width, height, 30, 40, 20, VVfWsQ, VVB5I5, VVPYL1, VVSwLg=40, VVcmdl=2, VV05bd=(0, 0))
  self.session   = session
  self.VVfWsQ   = VVfWsQ
  self.VVB5I5    = VVB5I5
  self.pickTitleBG  = pickTitleBG
  self.pickBodyBG   = pickBodyBG
  FFNhKZ(self)
  FFi79B(self["keyRed"] , "Exit")
  FFi79B(self["keyYellow"], "More Options")
  FFi79B(self["keyBlue"] , "Bookmarks")
  CCvFMf.__init__(self, gapX=10, gapY=10)
  self.VV8v3X  = 1000
  self.mode    = mode
  self.VVhKiJ = VVhKiJ
  self.VVNzrh   = VVNzrh
  self.VV8JM3  = VV8JM3
  self.VVeQ50   = VVeQ50
  self.VV2QTT  = None
  self.VVYTPr   = 300
  self.VVfINZ   = VVfINZ
  self.VV9Hdq = False
  self.VVVh8u   = VVVh8u
  VVtXmu = None
  if VV8JM3:
   self.mode = self.VVKzxn
   if   VV8JM3 == "srt"  : VVtXmu = (r"^.*\.srt$"    , IGNORECASE)
   elif VV8JM3 == "ajpSet" : VVtXmu = (r"^.*\/ajpanel_settings_" , 0    )
   elif VV8JM3 == "poster" : VVtXmu = (r"^.*\.(jpg|png)$"    , IGNORECASE)
   elif VV8JM3 == "pkgCtrl": VVtXmu = (r"^.*\/(control|preinst|prerm|postinst|postrm)$", 0)
   elif VV8JM3 == "movies" : VVtXmu = (r"^.*\.(%s)$" % "|".join(CC00KO.VVgJJJ()["mov"]), IGNORECASE)
   elif VV8JM3 == "custMnu": VVtXmu = (r"^.*\/ajpanel_menu.*\.xml$", 0)
   else       : VVtXmu = None
  if self.VV8aL9():
   FFi79B(self["keyRed"], "Cancel")
  if   self.VVNzrh       : VVhkMl, self.VVqNQm = True , FFdwbd(self.VVNzrh, True) or "/"
  elif self.VVeQ50        : VVhkMl, self.VVqNQm = True , CC17eA.VVNGSU(self)[1] or "/"
  elif self.mode == self.VVkDQs  : VVhkMl, self.VVqNQm = True , CFG.browserStartPath.getValue()
  elif self.mode == self.VVAcq8 : VVhkMl, self.VVqNQm = False, VVqNQm
  elif self.mode == self.VVKzxn : VVhkMl, self.VVqNQm = True , VVqNQm
  elif self.mode == self.VVdHom : VVhkMl, self.VVqNQm = True , VVqNQm
  else           : VVhkMl, self.VVqNQm = True , VVqNQm
  self.VVqNQm = FF9Uvy(self.VVqNQm)
  self["myMenu"] = CC00KO(  directory   = None
         , VVtXmu = VVtXmu
         , VVhkMl   = VVhkMl
         , VVOVCO = True
         , enableWrapAround = True
         , VV2InR   = self.VVmNvK["width"]
         , VVPYL1   = self.VVmNvK["VVYvMU"]
         , VVCW3G  = self.VVmNvK["bodyLineH"] )
  FFrM8n(self,
  {
   "ok"  : self.VVyuDa    ,
   "red"  : self.VVMGAU   ,
   "green"  : self.VVetHK  ,
   "yellow" : self.VV1lLK  ,
   "blue"  : self.VVmBrp ,
   "menu"  : self.VVh5VM  ,
   "info"  : self.VV5oL7  ,
   "cancel" : self.VVvf8t    ,
   "fav"  : self.VVrEVf,
   "back"  : self.VV6J3p   ,
   "pageUp" : self.VV6J3p   ,
   "chanUp" : self.VV6J3p   ,
   "pageDown" : self.VVdc2h  ,
   "chanDown" : self.VVdc2h  ,
   "last"  : self.VVpTaG   ,
   "next"  : self.VVbtl9
  })
  CCwyMT(self, self["myMenu"])
  self.onShown.append(self.VVf1Ra)
  self.onClose.append(self.onExit)
  self["myMenu"].onSelectionChanged.append(self.VVaIZP)
  global VVI6xQ
  VVI6xQ = True
 def onExit(self):
  self["myMenu"].onSelectionChanged = []
  if self.mode == self.VVkDQs:
   FF0JpZ("VVI6xQ")
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  self.onShown.append(self.VVaIZP)
  FFeo1z(self)
  FFvJ8o(self["myMenu"], bg=self.VVfINZ)
  FFuwGk(self)
  self.VV8v3X = self["keyInfo"].getPosition()[0] - 40
  if self.VV8aL9():
   FFi79B(self["keyGreen"], self.VVhKiJ)
   self.VVYxXT(self.VVXp19)
  self.VVaIZP()
  w  = self["myMenu"].instance.size().width()
  h  = self["myMenu"].instance.size().height()
  pos  = self["myMenu"].getPosition()
  part = self["myMenu"].instance.size().height() % self.VVmNvK["bodyLineH"]
  half = int(part / 2)
  self["myMenu"].instance.resize(eSize(*(w, h - part)))
  self["myMenu"].instance.move(ePoint(pos[0], pos[1] + half))
  if self.VVj9qQ(self.VVqNQm) > self.VVYTPr: FF7iMz(self, self.VVFpfm, title="Changing directory...")
  else              : self.VVFpfm()
 def VVFpfm(self):
  if self.VVNzrh : self.VVsvYH(FF9Uvy(self.VVNzrh) if os.path.isdir(self.VVNzrh) else self.VVNzrh)
  elif self.VVeQ50 : self.VVXM3U(chDir=False)
  else    : self["myMenu"].VVH4by(self.VVqNQm)
 def VV8aL9(self):
  return self.mode in (self.VVAcq8, self.VVKzxn, self.VVdHom)
 def VVt5t9(self, rowNdx):
  self["myMenu"].moveToIndex(rowNdx)
 @FFJRPn("Refreshing list ...")
 def VVrF6V(self):
  isSel = self["myMenu"].VVNWgQ()
  if not isSel:
   self.VVbVlh(False)
  FFLgRo()
 def VVXwx1(self, saved):
  if saved: self.VVrF6V()
 def VVj9qQ(self, path):
  try:
   return len(os.listdir(path))
  except:
   return 0
 def VVyuDa(self, isUp=False):
  if self.VV9Hdq:
   if self.mode == self.VVKzxn and os.path.isdir(self.VVLS0u(self.VVjCx4())):
    FFoTZI(self, "Files only", 500)
   elif self["myMenu"].VVEBz0(isUp):
    self.VVtK2m()
   else:
    FFoTZI(self, "Cannot select item", 500)
  elif self["myMenu"].VVOG6X(): self.VVYom7()
  else       : self.VVbyVd()
 def VV6J3p(self):
  if self.VV9Hdq:
   self.VVyuDa(isUp=True)
  else:
   self["myMenu"].moveToIndex(0)
   if self["myMenu"].VVQ3ha():
    self.VVYom7()
 def VVdc2h(self):
  if self.VV9Hdq:
   self.VVyuDa(isUp=False)
  elif self["myMenu"].VVOG6X() and self["myMenu"].getSelectionIndex() > 0:
   self.VVYom7()
 def VVpTaG(self) : self["myMenu"].moveToIndex(0)
 def VVbtl9(self) : self["myMenu"].moveToIndex(len(self["myMenu"].list) - 1)
 def VVYom7(self, isDirUp=False):
  if self["myMenu"].VVOG6X():
   if not self["myMenu"].getSelection() is None: path = self["myMenu"].getSelection()[0]
   else          : path = self.VVLS0u(self.VVjCx4())
   if self.VVj9qQ(path) > self.VVYTPr : FF7iMz(self, self.VVvRcA, title="Changing directory...")
   else           : self.VVvRcA()
 def VVvRcA(self):
  self["myMenu"].descent()
  self.VVaIZP()
 def VVvf8t(self):
  if   self.VV9Hdq     : self.VVbVlh(False, True)
  elif CFG.FileManagerExit.getValue() == "e" : self.VVMGAU()
  else          : self.VV6J3p()
 def VVMGAU(self):
  if not FFNMah(self):
   self.close("")
 def VVNCYk(self):
  FFY7F5(self, "_help_fman", "File Manager (Keys)")
 def VVetHK(self):
  if self["keyGreen"].getVisible():
   if self.VVVh8u and self.VV9Hdq:
    lst = []
    path = self["myMenu"].VVFQA1()
    for row in self["myMenu"].list:
     if row[2][6]:
      lst.append(os.path.join(path, row[0][0]))
    if lst : self.close(lst)
    else : FFoTZI(self, "Nothing selected", 500)
   else:
    path = self.VVLS0u(self.VVjCx4())
    isDir = os.path.isdir(path)
    chkFile = False
    if   self.mode == self.VVAcq8 : self.close(path)
    elif self.mode == self.VVKzxn : chkFile = True
    elif self.mode == self.VVdHom :
     if isDir: self.close(path)
     else : chkFile = True
    if chkFile:
     if os.path.isfile(path) : self.close(path)
     else     : FFoTZI(self, "Cannot access this file", 1000)
 @FFJRPn("Calculating size ...")
 def VV5oL7(self):
  path = self.VVLS0u(self.VVjCx4())
  param = self.VVjIzP(path)
  if not param:
   FFbBGq(self, "Cannot access information !")
   return
  def VVPiNc(key, val, color=""):
   lineTxt = "%s\t: %s\n" % (key, str(val))
   return FFKrMM(lineTxt, color) if color else lineTxt
  c1, c2, c3, c4, c5 = VVWJEN, VVk4x7, VVWH8U, VVCQUS, VVv8b8
  path, typeStr, typeChar, iNode, permUser, permGroup, permOther, permExtra, hLinks, owner, group, size, slTarget, slBroken, hLinkedFiles = param
  mnt_fs = mnt_typ = ""
  contents = totSize = freeSize = ""
  if typeChar == "d":
   exclude = r"-type d \( -ipath '/media' -o -ipath '/mnt' -o -ipath '*boot*' -o -ipath '*/ba' \) -prune -o"
   result = FF2ndj("totDirs=$(find '%s' %s -type d -print | wc -l); totFiles=$(find '%s' %s ! -type d | wc -l); echo $totDirs','$totFiles" % (path, exclude, path, exclude))
   if iMatch("^[0-9]*,[0-9]*", result):
    parts = result.split(",")
    contents += VVPiNc("Directories" , format(int(parts[0]), ',d'), c4)
    contents += VVPiNc("Files"   , format(int(parts[1]), ',d'), c4)
   if os.path.ismount(path):
    inf = CC17eA.VVLSXg().get(FF9Uvy(os.path.realpath(path)), "")
    if inf:
     mnt_fs, mnt_typ, isNet = inf
    typeStr += " (Mount)"
    totSize  = CC17eA.VVdLTI(path)
    freeSize = CC17eA.VVj8Uc(path)
    size = totSize - freeSize
    totSize  = CC17eA.VVxNgx(totSize)
    freeSize = CC17eA.VVxNgx(freeSize)
   else:
    size = FFxsAV(path)
  usedSize = CC17eA.VVxNgx(size)
  if len(path) < 58 : pathTxt = path
  else    : pathTxt = "\n" + path
  pathTxt = pathTxt+ "\n"
  if slBroken : fileTime = self.VVFrp5(path)
  else  : fileTime = self.VVigHY(path)
  txt = ""
  txt += VVPiNc("Path"    , pathTxt, c1)
  txt += VVPiNc("Type"    , typeStr, c2)
  if mnt_fs and mnt_typ:
   txt += VVPiNc("Files System" , mnt_fs, c2)
   txt += VVPiNc("VFS Type"  , mnt_typ, c2)
  if len(slTarget) > 0:
   txt += VVPiNc("Target"   , slTarget)
  if os.path.ismount(path):
   txt += VVPiNc("Total Size"  , "%s" % totSize, c3)
   txt += VVPiNc("Used Size"  , "%s" % usedSize, c3)
   txt += VVPiNc("Free Size"  , "%s" % freeSize, c3)
  else:
   txt += VVPiNc("Size"   , "%s" % usedSize, c3)
  txt += contents
  txt += "\n"
  txt += VVPiNc("Owner"    , owner, c5)
  txt += VVPiNc("Group"    , group, c5)
  txt += VVPiNc("Perm. (User)"  , permUser, c5)
  txt += VVPiNc("Perm. (Group)"  , permGroup, c5)
  txt += VVPiNc("Perm. (Other)"  , permOther, c5)
  if len(permExtra) > 0:
   txt += VVPiNc("Perm. (Ext.)" , permExtra)
  txt += "\n"
  txt += VVPiNc("iNode"    , iNode)
  txt += VVPiNc("Hard Links"   , hLinks)
  txt += fileTime
  if hLinkedFiles:
   txt += "\n%s\nHard Linked Files (files with same iNode)\n%s\n" % (SEP, SEP)
   txt += hLinkedFiles
  txt += self.VVCsMy(path)
  txt += CCM6jS.VVqVLH(path)
  FFSMJz(self, txt, height=1000, titleBg="#22001010", VVYCun="#11000a1a")
 def VVjIzP(self, path):
  path = path.strip()
  path = FFsxFo(path)
  result = FF2ndj("FILE='%s'; BROKEN=$(if [ ! -e \"$FILE\" ]; then echo 'yes'; else echo 'no'; fi); LINE=$(ls -lid \"$FILE\" 2> /dev/null); PARAM=$(echo $LINE | awk '{print $1\",\"$2\",\"$3\",\"$4\",\"$5\",\"$6}'); SLINK=$(echo $LINE | awk '{$1=$2=$3=$4=$5=$6=$7=$8=$9=\"\";print}'  | sed 's/ -> /,/g' | xargs); echo $PARAM','$BROKEN','$SLINK" % path)
  parts = result.split(",")
  if not all(parts):
   return None
  if len(parts) > 7:
   iNode  = parts[0]
   perm  = parts[1]
   hLinks  = parts[2]
   owner  = parts[3]
   group  = parts[4]
   size  = parts[5]
   slBroken = parts[6]
   fName  = parts[7]
   slTarget = ""
   if len(parts) > 8:
    slTarget = parts[8]
   size = int(size)
   def VVmQu8(perm, start, end):
    val = perm[start : end]
    p  = { "---": "0" , "--x": "1" , "-w-": "2" , "-wx": "3" , "r--": "4" , "r-x": "5" , "rw-": "6" , "rwx": "7" , "+": "ACL" }
    if val in p : return "%s\t%s" % (val, p[val])
    else  : return val
   permUser = VVmQu8(perm, 1, 4)
   permGroup = VVmQu8(perm, 4, 7)
   permOther = VVmQu8(perm, 7, 10)
   permExtra = VVmQu8(perm, 10, 100)
   typeChar = perm[0:1]
   typeStr = {"-":"File", "b":"Block Device File", "c":"Character Device File", "d":"Directory", "e":"External Link", "l":"Symbolic Link", "n":"Network File", "p":"Named Pipe", "s":"Local Socket File"}.get(typeChar, "Unknown")
   if "yes" in slBroken:
    slBroken = True
    typeStr  = "Broken Symlink (target not found)"
   else:
    slBroken = False
   hLinkedFiles = ""
   if typeChar != "d" and int(hLinks) > 1:
    hLinkedFiles = FF4aqG("find / %s -inum %s -print0 2> /dev/null | xargs -0 ls -i 2> /dev/null | grep %s | awk '{$1=\"\"; print $0}' | awk '{$1=$1};1'" % (FFbt47(0, ["/dev", "/hdd", "/newroot", "/sys/class"]), iNode, iNode))
   return path, typeStr, typeChar, iNode, permUser, permGroup, permOther, permExtra, hLinks, owner, group, size, slTarget, slBroken, hLinkedFiles
  else:
   return None
 def VVCsMy(self, path):
  txt  = ""
  res  = FF2ndj("lsattr -d %s" % path)
  span = iSearch(r"([acdeijstuACDST-]{13})\s", res, IGNORECASE)
  if span:
   res = span.group(1)
   tDict = {"a": "Append only", "c": "Compressed", "d": "No dump", "e": "Extent format", "i": "Immutable", "j": "Data journalling", "s": "Secure deletion (s)", "t": "Tail-merging", "u": "Undeletable", "A": "No atime updates", "C": "No copy on write", "D": "Synchronous directory updates", "S": "Synchronous updates", "T": "Top of directory hierarchy", "h": "Huge file", "E": "Compression error", "I": "Indexed directory", "X": "Compression raw access", "Z": "Compressed dirty file"}
   lst = []
   for key, val in tDict.items():
    if key in res:
     lst.append("%s  ( %s )\n" % (val, key))
   if lst:
    lst.sort()
    for item in lst:
     txt += "    %s" % item
    txt = "\n%s\n%s" % (FFKrMM("File Attributes:", VV2jvK), txt)
  return txt
 def VVigHY(self, path):
  txt = "\n"
  txt += "Access time\t: %s\n" % FFG6of(os.path.getatime(path))
  txt += "Modified time\t: %s\n" % FFG6of(os.path.getmtime(path))
  txt += "Change time\t: %s\n" % FFG6of(os.path.getctime(path))
  return txt
 def VVFrp5(self, path):
  txt = "\n"
  txt += "Access time\t: %s\n" % FF2ndj("stat -c %%x '%s'" % path).replace(".000000000", "")
  txt += "Modified time\t: %s\n" % FF2ndj("stat -c %%y '%s'" % path).replace(".000000000", "")
  txt += "Change time\t: %s\n" % FF2ndj("stat -c %%z '%s'" % path).replace(".000000000", "")
  return txt
 def VVLS0u(self, currentSel):
  currentDir  = self["myMenu"].VVFQA1()
  if currentDir is None:
   path = currentSel
  elif currentSel is None:
   path = currentDir
  else:
   if currentSel == "/":
    path = currentDir
   else:
    if not self["myMenu"].VVOG6X():
     path = currentDir + currentSel
    else:
     if len(currentDir) > len(currentSel):
      path = currentDir
     else:
      path = currentSel
  return str(path)
 def VVmxpl(self):
  return self["myMenu"].VVFQA1() or self.VVLS0u(self.VVjCx4())
 def VVjCx4(self):
  sel = self["myMenu"].getSelection()
  if sel : return sel[0]
  else : return None
 def VVaIZP(self):
  path = self.VVLS0u(self.VVjCx4())
  self["myTitle"].setText("  " + path)
  if self["myTitle"].instance:
   textW = self["myTitle"].instance.calculateSize().width()
   if textW > self.VV8v3X:
    length = len(path)
    tmpPath = path[4:]
    for i in range(length, 40, -1):
     self["myTitle"].setText("  .." + tmpPath)
     textW = self["myTitle"].instance.calculateSize().width()
     if textW > self.VV8v3X: tmpPath = tmpPath[1:]
     else       : break
  self.VViPSW()
  if self.mode == self.VVkDQs:
   if len(path) > 0: self["keyMenu"].show()
   else   : self["keyMenu"].hide()
  self["keyGreen"].hide()
  if self.VV8aL9():
   if self.VV9Hdq:
    if self["myMenu"].VVWAEY() > 0:
     self["keyGreen"].show()
   else:
    if self.mode == self.VVKzxn:
     if os.path.isfile(path):
      self["keyGreen"].show()
    else:
     self["keyGreen"].show()
  FFdBYP(self, 30, self.VV8SBo)
 def VV8SBo(self):
  path = self.VVLS0u(self.VVjCx4())
  self.VVgwPx(path)
 def VVh5VM(self):
  c1, c2, c3 = VVWJEN, VVk4x7, VVv8b8
  totSel = 0
  menuW = 1000
  title = "Options"
  VV9cxb= []
  path = self.VVLS0u(self.VVjCx4())
  isLink = os.path.islink(path)
  if self.VV9Hdq:
   menuW = 850
   totSel = self["myMenu"].VVWAEY()
   if totSel > 0:
    if iTar:
     txt1 = "Archive to .tar.gz"
     txt2 = " (Preserve Path Structure)"
     title = "Options  (%d item%s)" % (totSel, FFaRsj(totSel))
     VV9cxb.append((c1 + txt1      , "VVsWnH1"  ))
     VV9cxb.append((c1 + txt1 + txt2    , "VVsWnH2"  ))
     VV9cxb.append(VVbM5H)
    VV9cxb.append(("[6] Copy"       , "copyFileOrDir" ))
    VV9cxb.append(("[7] Move"       , "moveFileOrDir" ))
    VV9cxb.append(("[8] %sDELETE" % VVdLWL , "VV7Ny2"  ))
   else:
    FFoTZI(self, "Nothing selected", 700)
    return
  elif self.VV8aL9():
   VV9cxb.append(("Properties", "properties" ))
   VV9cxb.append(VVbM5H)
   VV9cxb.append((c3 + "Create New Directory (in current directory)" , "createNewDir"))
  else:
   menuW = 1050
   path  = self.VVLS0u(self.VVjCx4())
   isEditable = self["myMenu"].VVVu0W()
   if not FFqXDL(path):
    FFbBGq(self, "Cannot access this object.")
    return
   VV9cxb.append(("Properties", "properties"))
   if os.path.isdir(path):
    addSep = True
    if FFdwbd(path, True) in (VVxQ5s, VVISpi):
     VV9cxb.append(VVbM5H)
     VV9cxb.append((c1 + "Show Related Package", "VVoawZ"))
     addSep = False
    if isEditable:
     if addSep:
      VV9cxb.append(VVbM5H)
     VV9cxb.append((c1 + "Archive/Package Tools", "VVdQFK_dir"))
     addSep = False
   elif os.path.isfile(path):
    selFile = self.VVjCx4()
    isArch = selFile.endswith((".tar", ".gz", ".tar.bz2", "tar.xz", "tar.zst", ".zip", ".rar", ".7z"))
    if not isArch:
     VV9cxb.append((c1 + "Archive ...", "VVdQFK_file"))
    isText = False
    txt = ""
    if isArch:
     VV9cxb.extend(self.VVARkb(path, True))
    elif selFile.endswith((".ipk", ".deb")) :
     txt = "Package Tools"
    elif selFile.endswith((".m3u", ".m3u8")):
     VV9cxb.extend(self.VVA43p(True))
    elif selFile.endswith((".sh", ".py", ".pyo", ".pyc")):
     VV9cxb.extend(self.VVC9nb(path, True))
     isText = selFile.endswith((".sh", ".py"))
    elif selFile.endswith(".svg"):
     pass
    elif not isLink and selFile.endswith(".tif"):
     VV9cxb.append((c2 + "Save as ...", "VVBHiz"))
    elif not isLink and self["myMenu"].VVuedz(path) == "pic":
     VV9cxb.append(VVbM5H)
     VV9cxb.append((c2 + "Set as PIcon (for current channel)", "VV8P2N" ))
     path = self.VVLS0u(self.VVjCx4())
     VV9cxb.append(VVbM5H)
     VV9cxb.append((c2 + "Rotate Image", "VV07wU"   ))
     VV9cxb.append((c2 + "Flip Image" , "VVmmo3"   ))
     VV9cxb.append((c2 + "Save as ..." , "VVBHiz" ))
     VV9cxb.append(VVbM5H)
     VV9cxb.append((c2 + "Convert to Base64 String", "VV3ESR" ))
     if FFW91j("ffmpeg") and selFile.lower().endswith((".jpg", ".png")):
      VV9cxb.append((c2 + "Convert to MVI (1280 x 720 )", "VVsVcJHd" ))
      VV9cxb.append((c2 + "Convert to MVI (1920 x 1080)", "VVsVcJFhd" ))
    elif selFile.endswith((".py", ".xml", ".txt", ".htm", ".html", ".cfg", ".conf")) or not CC17eA.VVLpYt(path):
     VV9cxb.append(VVbM5H)
     VV9cxb.append((c2 + "View"     , "textView_def"))
     VV9cxb.append((c2 + "View (Select Encoder)" , "textView_enc"))
     VV9cxb.append((c2 + "Edit"     , "text_Edit" ))
     isText = True
    elif selFile.endswith(CC17eA.VVYj8q(addDot=True)):
     if selFile.endswith(".mvi"):
      if FFW91j("showiframe"):
       VV9cxb.append(VVbM5H)
       VV9cxb.append((c2 + "View as Bootlogo (will interrupt the playing service)", "viewAsBootlogo"))
      if FFW91j("ffmpeg"):
       VV9cxb.append((c2 + "Convert to jpg", "mv2jpg"))
       VV9cxb.append((c2 + "Convert to png", "mv2png"))
     else:
      VV9cxb.append(VVbM5H)
      VV9cxb.append((c2 + "Add Media File to a Bouquet"    , "VVeSI80" ))
      VV9cxb.append((c2 + "Add all Media in Directory to a Bouquet" , "VVeSI81" ))
      VV9cxb.append((c2 + "Play with ..."       , "playWith"    ))
    if isText:
     VV9cxb.append((c1 + "Save as UTF-8 ..."      , "textSave_encUtf8"))
     VV9cxb.append((c1 + "Save as other Encoding ..."    , "textSave_encOthr"))
     VV9cxb.append((c1 + "Convert Line-Breaks to Unix Format..." , "VVS0Xp" ))
    if len(txt) > 0:
     VV9cxb.append(VVbM5H)
     VV9cxb.append((c1 + txt, "VVbyVd"))
   VV9cxb.append(VVbM5H)
   VV9cxb.append(("[4] Create SymLink", "VVfUxk"))
   if isEditable:
    VV9cxb.append(("[5] Rename"      , "VVeoJV" ))
    VV9cxb.append(("[6] Copy"       , "copyFileOrDir" ))
    VV9cxb.append(("[7] Move"       , "moveFileOrDir" ))
    VV9cxb.append(("[8] %sDELETE" % VVdLWL , "VVozlP" ))
    if FFKbVo(path):
     VV9cxb.append(VVbM5H)
     perm = oct(os.stat(path).st_mode)[-3:]
     if   perm == "644" : show644, show755, show777 = False, True , True
     elif perm == "755" : show644, show755, show777 = True , False , True
     elif perm == "777" : show644, show755, show777 = True , True , False
     else    : show644, show755, show777 = True , True , True
     chmodTxt = "Change Permissions (from %s to " % perm
     if show644 : VV9cxb.append((chmodTxt + "644)", "chmod644"))
     if show755 : VV9cxb.append((chmodTxt + "755)", "chmod755"))
     if show777 : VV9cxb.append((chmodTxt + "777)", "chmod777"))
   VV9cxb.append(VVbM5H)
   VV9cxb.append((c3 + "Create New File (in current directory)"  , "createNewFile"))
   VV9cxb.append((c3 + "Create New Directory (in current directory)" , "createNewDir" ))
   fPath, fDir, fName = CC17eA.VVNGSU(self)
   if fPath:
    VV9cxb.append(VVbM5H)
    VV9cxb.append((c2 + "Go to Current Movie Dir", "VVXM3U"))
  FFO9kU(self, self.VVerX1, width=menuW, height=1050, title=title, VV9cxb=VV9cxb, VVwv0z=0.01, VVMUHm=False, VVfWsQ="#00101020", VVB5I5="#00101A2A")
 def VVerX1(self, item=None):
  if item is not None:
   path = self.VVLS0u(self.VVjCx4())
   if   item == "VVsWnH1"    : self.VVsWnH(False)
   elif item == "VVsWnH2"    : self.VVsWnH(True)
   elif item == "copyFileOrDir"   : self.VVI1wL(False)
   elif item == "moveFileOrDir"   : self.VVI1wL(True)
   elif item == "VV7Ny2"    : self.VV7Ny2()
   elif item == "properties"    : self.VV5oL7()
   elif item == "VVoawZ"  : self.VVoawZ(path)
   elif item == "VVdQFK_dir" : self.VVdQFK(path, True)
   elif item == "VVdQFK_file" : self.VVdQFK(path, False)
   elif item == "VVJlm7"  : self.VVJlm7(path)
   elif item == "VVE97s"  : self.VVE97s(path)
   elif item == "2gz"       : self.VVUwm4(path, "gz")
   elif item == "2xz"       : self.VVUwm4(path, "xz")
   elif item.startswith("extract_")  : self.VVxL26(path, item)
   elif item.startswith("script_")   : self.VVPEDN(path, item)
   elif item.startswith("m3u_")   : self.VVxFYu(path, item)
   elif item.startswith("textView_def") : FFjTOc(self, path)
   elif item.startswith("textView_enc") : self.VVvn4t(path)
   elif item.startswith("text_Edit")  : CCNb3y(self, path, VVhK3C=self.VVXwx1)
   elif item.startswith("textSave_encUtf8"): self.VV8Thr(path, "Save as UTF-8"   , True)
   elif item.startswith("textSave_encOthr"): self.VV8Thr(path, "Save as Other Encoding", False)
   elif item.startswith("VVS0Xp") : self.VVS0Xp(path)
   elif item == "viewAsBootlogo"   : self.VVvyqP(path, True)
   elif item == "mv2jpg"     : self.VVK7yJ(path, 0)
   elif item == "mv2png"     : self.VVK7yJ(path, 1)
   elif item == "VVeSI80" : self.VVeSI8(path, False)
   elif item == "VVeSI81" : self.VVeSI8(path, True)
   elif item == "playWith"     : self.VVZik7(path)
   elif item == "VV8P2N" : self.VV8P2N(path)
   elif item == "VV07wU"   : self.VV07wU(path)
   elif item == "VVmmo3"    : self.VVmmo3(path)
   elif item == "VVBHiz" : self.VVBHiz(path)
   elif item == "VVsVcJHd"   : self.VVsVcJ(path, False)
   elif item == "VVsVcJFhd"   : self.VVsVcJ(path, True)
   elif item == "VV3ESR"   : self.VV3ESR(path)
   elif item == "VVfUxk"   : self.VVfUxk(path)
   elif item == "VVeoJV"   : self.VVeoJV(path)
   elif item == "VVozlP"   : self.VVozlP(path)
   elif item == "chmod644"     : self.VVViCP(path, "644")
   elif item == "chmod755"     : self.VVViCP(path, "755")
   elif item == "chmod777"     : self.VVViCP(path, "777")
   elif item == "createNewFile"   : self.VVTUgX(path, True)
   elif item == "createNewDir"    : self.VVTUgX(path, False)
   elif item == "VVXM3U"   : self.VVXM3U()
   elif item == "VVbyVd"    : self.VVbyVd()
 def VVbyVd(self):
  if self.mode == self.VVKzxn and not self.VV8JM3 == "poster":
   return
  path = self.VVLS0u(self.VVjCx4())
  if os.path.isfile(path):
   cat = self["myMenu"].VVuedz(path)
   if   cat == "pic"        : self.VVFLyB(path)
   elif cat == "txt"        : FFjTOc(self, path)
   elif cat == "m3u"        : self.VVToFA(path)
   elif cat in ("scr", "py")      : self.VVKtXC(path)
   elif cat in ("tar", "rar", "zip", "p7z", "zst") : self.VVwkYm(path)
   elif cat in ("ipk", "deb")      : self.VVGAnH(path)
   elif cat in ("mov", "mus")      : self.VVvyqP(path)
   elif not CC17eA.VVLpYt(path)  : FFjTOc(self, path)
 @FFJRPn()
 def VVFLyB(self, path):
  VVETIE = 0
  curFile = os.path.basename(path)
  lst = []
  for ndx, item in enumerate(self["myMenu"].list):
   if not item[0][1]:
    category = self["myMenu"].VVuedz(item[1][7])
    if category == "pic":
     if curFile == item[1][7]:
      VVETIE = len(lst)
     lst.append((ndx, item[1][7]))
  CCZQAz.VVRX4k(self, path, fileList=lst, VVETIE=VVETIE, cbFnc=self.VVwROr)
 def VVwROr(self, path, ndx):
  self["myMenu"].moveToIndex(ndx)
 def VVvyqP(self, path, asLogo=False):
  if asLogo : CCBldl.VV9Ayb(self, path)
  else  : FF7iMz(self, BF(self.VVGtUI, self, path), title="Playing Media ...")
 def VVmBrp(self):
  if self["keyBlue"].getVisible():
   VVXpNQ = self.VVTFfD()
   if VVXpNQ:
    path = self.VVLS0u(self.VVjCx4())
    enableGreenBtn = False if path in self.VVTFfD() else True
    newList = []
    for line in VVXpNQ:
     newList.append((line, line))
    VVXpo8  = ("Delete"    , self.VVSsOK    )
    VVWt1H  = ("Add Current Dir"   , BF(self.VVTp5G, path) ) if enableGreenBtn else None
    VVqj6y = ("Move Up"     , self.VVpxlg    )
    VVGbyT  = ("Move Down"   , self.VVYjGs    )
    self.VV2QTT = FFO9kU(self, self.VVtPLb, width=1200, title="Bookmarks", VV9cxb=newList, VV3an7=10 ,VVXpo8=VVXpo8, VVWt1H=VVWt1H, VVqj6y=VVqj6y, VVGbyT=VVGbyT, VVfWsQ="#00000022", VVB5I5="#00000022")
 def VVSsOK(self, VVhzhr=None, path=None):
  VVXpNQ = self.VVTFfD()
  if VVXpNQ:
   while path in VVXpNQ:
    VVXpNQ.remove(path)
   self.VVgccz(VVXpNQ)
  if self.VV2QTT:
   self.VV2QTT.VVj5Gx(VVXpNQ)
   self.VV2QTT.VVn0TI(("Add Current Dir", BF(self.VVTp5G, path)))
  else:
   FFoTZI(self, "Removed", 800)
  self.VViPSW()
 def VVTp5G(self, path, VVhzhr=None, item=None):
  VVXpNQ = self.VVTFfD()
  if len(VVXpNQ) >= self.VVxiUy:
   FFbBGq(SELF, "Max bookmarks reached (max=%d)." % self.VVxiUy)
  elif not path in VVXpNQ:
   if not os.path.isdir(path):
    path = FFdwbd(path, True)
   newList = [path] + VVXpNQ
   self.VVgccz(newList)
   if self.VV2QTT:
    self.VV2QTT.VVj5Gx(newList)
    self.VV2QTT.VVn0TI()
   else:
    FFoTZI(self, "Added", 800)
  self.VViPSW()
 def VVpxlg(self, selectionObj, path):
  if self.VV2QTT:
   VVXpNQ = self.VV2QTT.VV2Q7X(True)
   if VVXpNQ:
    self.VVgccz(VVXpNQ)
 def VVYjGs(self, selectionObj, path):
  if self.VV2QTT:
   VVXpNQ = self.VV2QTT.VV2Q7X(False)
   if VVXpNQ:
    self.VVgccz(VVXpNQ)
 def VVtPLb(self, path=None):
  if path:
   path = FF9Uvy(path)
   self.VV3ejW(path)
  self.VVaIZP()
 @FFJRPn("Changing directory ...")
 def VV3ejW(self, path):
  self["myMenu"].VVH4by(path)
  self["myMenu"].moveToIndex(0)
 def VVTFfD(self):
  line = CFG.browserBookmarks.getValue().strip()
  while " ," in line : line.replace(" ,", ",")
  while ", " in line : line.replace(", ", ",")
  if   "," in line : return line.split(",")
  elif len(line) > 0 : return [line]
  else    : return []
 def VVX66n(self):
  return True if VVTFfD() else False
 def VVgccz(self, VVXpNQ):
  line = ",".join(VVXpNQ)
  FFBWtx(CFG.browserBookmarks, line)
 def VVsvYH(self, path):
  if FFKbVo(path):
   fDir  = FF9Uvy(os.path.dirname(path))
   if fDir:
    self["myMenu"].VVH4by(fDir)
   fName = os.path.basename(path)
   for ndx, item in enumerate(self["myMenu"].list):
    if fName == item[0][0]:
     self["myMenu"].moveToIndex(ndx)
     break
  else:
   FFoTZI(self, "Not found", 1000)
 def VVXM3U(self, chDir=True):
  fPath, fDir, fName = CC17eA.VVNGSU(self)
  self.VVsvYH(fPath)
 def VV1lLK(self):
  path = self.VVLS0u(self.VVjCx4())
  isAdd = False if path in self.VVTFfD() else True
  dirTxt = "Selected" if os.path.isdir(path) else "Current"
  c1, c2, c3 = VV1l75, VVWH8U, VVk4x7
  VV9cxb = []
  VV9cxb.append(("Find Files ..." , "find"))
  VV9cxb.append(("Sort ..."   , "sort"))
  VV9cxb.append(VVbM5H)
  if isAdd: VV9cxb.append((c1 + "Add %s Dir to Bookmarks"  % dirTxt, "addBM"))
  else : VV9cxb.append((c1 + "Remove %s Dir from Bookmarks" % dirTxt, "remBM"))
  VV9cxb.append(    (c2 + 'Set %s Dir as "Startup Dir"' % dirTxt, "start"))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Keys (Shortcuts)", "help"))
  if self.mode == self.VVkDQs or self.VVVh8u:
   VV9cxb.append(VVbM5H)
   if self.VV9Hdq: VV9cxb.append( (c3 + "Disable Multi-Select ", "multiOff"))
   else     : VV9cxb.append( (c3 + "Enable Multi-Select"  , "multiOn" ))
   VV9cxb.append(       (c3 + "Select all"    , "selAll"  ))
  FFO9kU(self, BF(self.VV7wqL, path), width=750, title="More Options", VV9cxb=VV9cxb, VVfWsQ="#00221111", VVB5I5="#00221111")
 def VV7wqL(self, path, item):
  if item:
   if   item == "find"  : self.VVbCCE(path)
   elif item == "sort"  : self.VVPVPe()
   elif item == "addBM" : self.VVTp5G(path)
   elif item == "remBM" : self.VVSsOK(None, path)
   elif item == "help"  : self.VVNCYk()
   elif item == "start" : self.VV2DY0(path)
   elif item == "multiOn" : self.VVbVlh(True)
   elif item == "multiOff" : self.VVbVlh(False)
   elif item == "selAll" : self.VVbVlh(True, True)
 def VVbVlh(self, isOn, isAll=False):
  self.VV9Hdq = isOn
  if isAll or not isOn:
   FF7iMz(self, BF(self["myMenu"].VVm4Gc, isOn, self.mode, cbFnc=self.VVtK2m), title="Selecting ..." if isOn else "Unselecting ...")
  if isOn      : color = self.VVC1x4
  elif self.VV8aL9() : color = self.VVXp19
  else      : color = self.VV1LRK
  self.VVYxXT(color)
  self.VVaIZP()
 def VVtK2m(self):
  self["keyBlue"].setText(self.VVUy0e())
 def VVYxXT(self, mode=0):
  if   mode == self.VVXp19 : titBg, bodBg = self.pickTitleBG, self.pickBodyBG
  elif mode == self.VVC1x4: titBg, bodBg = "#01883366", "#11002233"
  else        : titBg, bodBg = self.VVfWsQ, self.VVB5I5
  FFgLA9(self["myTitle"], titBg)
  FFgLA9(self["myBar"], titBg)
  FFgLA9(self["myBody"], bodBg)
  FFgLA9(self["myMenu"], bodBg)
  if self.VV9Hdq: bg, txt = "#01883366", self.VVUy0e()
  else     : bg, txt = VVAKzT[3], "Bookmarks"
  FFi79B(self["keyBlue"], txt)
  FFgLA9(self["keyBlue"], bg)
  self.VViPSW()
 def VVUy0e(self):
  return "Selected Items = %d" % self["myMenu"].VVWAEY()
 def VViPSW(self):
  if self.VVTFfD() or self.VV9Hdq: self["keyBlue"].show()
  else            : self["keyBlue"].hide()
 def VVbCCE(self, path):
  VV9cxb = []
  VV9cxb.append(("Find in Current Directory"    , "findCur"  ))
  VV9cxb.append(("Find in Current Directory (recursive)" , "findCurR" ))
  VV9cxb.append(("Find in all Storage Systems"    , "findAll"  ))
  FFO9kU(self, BF(self.VVLcKh, path), width=700, title="Find File/Pattern", VV9cxb=VV9cxb, VVDkqE=True, VVbdOY=True, VVfWsQ="#00221111", VVB5I5="#00221111")
 def VVLcKh(self, path, item):
  if item:
   title, item, ndx = item
   if   item == "findCur" : self.VVU2BD(0, path, title)
   elif item == "findCurR" : self.VVU2BD(1, path, title)
   elif item == "findAll" : self.VVU2BD(2, path, title)
 def VVU2BD(self, mode, path, title):
  if CFG.lastFileManFindPatt.getValue(): txt = CFG.lastFileManFindPatt.getValue()
  else         : txt = "*.ipk"
  FFANcN(self, BF(self.VV4wPE, mode, path, title), defaultText=txt, title=title, message="Enter Name/Pattern:")
 def VV4wPE(self, mode, path, title, filePatt):
  if filePatt is not None:
   filePatt = filePatt.strip()
   FFBWtx(CFG.lastFileManFindPatt, filePatt)
   badLst = filePatt.replace(" ", "") in ("*.*", "*.", ".*")
   if not filePatt : FFoTZI(self, "No entery", 1500)
   elif badLst  : FFoTZI(self, "Too many file !", 1500)
   else   : self.VV1m8h(mode, path, title, filePatt)
 @FFJRPn("Searching ...")
 def VV1m8h(self, mode, path, title, filePatt):
  lst = FFux9U("find '%s' %s -type f -iname '%s' %s -print 2> /dev/null" % ("/" if mode==2 else path, FFbt47(0), filePatt, "-maxdepth 1" if mode == 0 else ""))
  if lst:
   err = CC17eA.VVUDvl(lst)
   if err:
    FFbBGq(self, err)
   else:
    for ndx, path in enumerate(lst):
     lst[ndx] = (os.path.basename(path), os.path.dirname(path))
    lst.sort(key=lambda x: x[0].lower())
    header = ("File", "Directory" )
    widths = (50 , 50   )
    VVmolf = (""     , self.VVzbo8 , [])
    VVwqVu = ("Go to File Location", self.VVxQCl  , [])
    FFCXsL(self, None, title="%s : %s" % (title, filePatt), header=header, VVXpNQ=lst, VV8boH=widths, VVPYL1=26, VVmolf=VVmolf, VVwqVu=VVwqVu)
  else:
   FF8bV6(self, "Not found !", 2000)
 def VVxQCl(self, VVAIxO, title, txt, colList):
  path = os.path.join(colList[1], colList[0])
  if FFKbVo(path):
   VVAIxO.cancel()
   self.VVsvYH(path)
  else:
   FFoTZI(VVAIxO, "Path not found !", 1000)
 def VVzbo8(self, VVAIxO, title, txt, colList):
  txt = "%s\n%s\n\n" % (FFKrMM("File:"  , VVk4x7), colList[0])
  txt += "%s\n%s"  % (FFKrMM("Directory:", VVk4x7), FF9Uvy(colList[1]))
  FFSMJz(VVAIxO, txt, title=title)
 def VVPVPe(self):
  nameAlpMode, nameAlpTxt, nameNumMode, nameNumTxt , dateMode, dateTxt, typeMode, typeTxt, txt = self["myMenu"].VVejxx()
  VV9cxb = []
  VV9cxb.append(("Name\t%s" % nameAlpTxt, "nameAlp"))
  VV9cxb.append(("Name\t%s" % nameNumTxt, "nameNum"))
  VV9cxb.append(("Date\t%s" % dateTxt, "dateAlp"))
  VV9cxb.append(("Type\t%s" % typeTxt, "typeAlp"))
  VVGbyT = ("Mix", BF(self.VVdfU8, True))
  FFO9kU(self, BF(self.VVZ5O9, False), VVHRm1=txt, width=650, title="Sort Options", VV9cxb=VV9cxb, VVGbyT=VVGbyT, VVbdOY=True, VVfWsQ="#00221111", VVB5I5="#00221111")
 def VVdfU8(self, isMix, VVhzhr, item):
  self.VVZ5O9(True, item)
 def VVZ5O9(self, isMix, item):
  if item:
   nameAlpMode, nameAlpTxt, nameNumMode, nameNumTxt , dateMode, dateTxt, typeMode, typeTxt, txt = self["myMenu"].VVejxx()
   if   item == "nameAlp": mode, isNum =  nameAlpMode, False
   elif item == "nameNum": mode, isNum =  nameNumMode, True
   elif item == "dateAlp": mode, isNum =  dateMode , False
   elif item == "typeAlp": mode, isNum =  typeMode , False
   else      : return
   FF7iMz(self, BF(self["myMenu"].VVJC3E, mode, isMix, isNum), title="Sorting ... ")
 def VVrEVf(self):
  path = self.VVLS0u(self.VVjCx4())
  self.VV2DY0(path)
 def VV2DY0(self, path):
  if not os.path.isdir(path):
   path = FFdwbd(path, True)
  FFBWtx(CFG.browserStartPath, path)
  FFxHED(self, "Saved as Startup", 1500)
 def VVARkb(self, path, calledFromMenu):
  color = VVk4x7 if calledFromMenu else ""
  VV9cxb = []
  if path.endswith(".gz") and not path.endswith(".tar.gz") or path.endswith(".xz") and not path.endswith(".tar.xz"):
   VV9cxb.append((color + "Extract Here", "VVfYUu"))
  else:
   if path.endswith(".zst") and not FFW91j("unzstd"):
    return []
   if calledFromMenu: VV9cxb.append(VVbM5H)
   VV9cxb.append((color + "List Archived Files", "extract_listFiles"))
   VV9cxb.append(VVbM5H)
   VV9cxb.append((color + 'Extract to "%s"' % self.VV8HvU(os.path.basename(path)) , "extract_toDir"  ))
   VV9cxb.append((color + 'Extract to Root Directory "/"  (recommended for plugins)'  , "extract_toRoot"  ))
   VV9cxb.append((color + "Extract Here"             , "extract_here"  ))
   if iTar and iZip:
    if path.endswith(".zip"):
     if not calledFromMenu: VV9cxb.append(VVbM5H)
     VV9cxb.append((color + "Convert .zip to .tar.gz", "VVJlm7" ))
    elif path.endswith(".tar.gz"):
     if not calledFromMenu: VV9cxb.append(VVbM5H)
     VV9cxb.append((color + "Convert .tar.gz to .zip", "VVE97s" ))
   if path.endswith((".tar.gz", ".tar.xz", ".tar.zst")):
    VV9cxb.append(VVbM5H)
    if   path.endswith(".gz"): VV9cxb.append((color + "Convert to .tar.xz", "2xz"))
    elif path.endswith(".xz"): VV9cxb.append((color + "Convert to .tar.gz", "2gz"))
    elif path.endswith(".zst"):
     cond = FFW91j("zstd")
     VV9cxb.append(FFH04v("Convert to .tar.gz", "2gz", cond, color))
     VV9cxb.append(FFH04v("Convert to .tar.xz", "2xz", cond, color))
  return VV9cxb
 def VVwkYm(self, path):
  title = "Archived File Options"
  VV9cxb = self.VVARkb(path, False)
  if VV9cxb : FFO9kU(self, BF(self.VVxL26, path), title=title, VV9cxb=VV9cxb, width=1050)
  else  : FF6pUe(self, BF(self.VVhVOq, self), 'Missing "zstd" package.\n\nInstall "zstd" ?')
 @staticmethod
 def VVhVOq(SELF):
  cmd = FF4zTV(VVw2da, "zstd")
  if cmd : FF6NKJ(SELF, cmd, title="Installing zstd")
  else : FFWaiD(SELF)
 def VVxL26(self, path, item=None):
  if item is not None:
   if   item == "VVfYUu"         : self.VVfYUu(item, path)
   elif item == "extract_listFiles"        : self.VVNPy2(path)
   elif item == "VVJlm7" and path.endswith(".zip")  : self.VVJlm7(path)
   elif item == "VVE97s" and path.endswith(".tar.gz") : self.VVE97s(path)
   elif item == "2gz"             : self.VVUwm4(path, "gz")
   elif item == "2xz"             : self.VVUwm4(path, "xz")
   elif path.endswith((".zip", ".rar", ".7z"))      : self.VVE25y(item, path)
   else               : self.VV3ErR(item, path)
 def VV8HvU(self, path, addSep=False):
  for ext in (".tar.gz", ".tar.xz", ".tar.bz2", ".tar.zst"):
   if path.endswith(ext):
    print(len(ext))
    return path[:-len(ext)]
  return os.path.splitext(path)[0]
 def VVNPy2(self, path):
  ext = os.path.splitext(os.path.basename(path))[1]
  linux_sep = "echo -e %s;" % SEP
  if ext in (".zip", ".rar", ".7z"):
   if   ext == ".zip": mainC, totC, instC = "unzip -l", "tail -n 1 | awk '{ print $2 }'"     , FF61q5("unzip", "unzip", "Unzip")
   elif ext == ".rar": mainC, totC, instC = "unrar l" , "tail -n 2 | grep -v \"^$\" | awk '{ print $2 }'" , FF61q5("unrar", "unrar", "Unrar")
   elif ext == ".7z" : mainC, totC, instC = "7za l" , "tail -n 1 | awk '{ print $5 }'"     , FF61q5("7za", "p7zip", "P7Zip")
   listC = "%s '%s'" % (mainC, path)
   tooMany = "Will only show first and last 100 files..."
   cmd  = linux_sep
   cmd += instC
   cmd += 'if [ "$allOK" -eq "1" ]; then '
   cmd += " TOTF=$(%s | %s);" % (listC, totC)
   cmd += " echo ''; echo 'Archived Files :'$TOTF;"
   cmd +=   linux_sep
   cmd += " if [ $TOTF -gt 300 ]; then"
   cmd += "  echo -e '%s' %s;"  % (tooMany, FFuLAo(tooMany, VVjojy))
   cmd +=    linux_sep
   cmd += "  %s | head -n 100;" % listC
   cmd += "  echo ''; echo ' ... MANY LINES COME HERE ... '; echo '';"
   cmd += "  echo '';"
   cmd += "  %s | tail -n 100;" % listC
   cmd += " else"
   cmd += "  %s;" % listC
   cmd += " fi;"
   cmd += "fi;"
  else:
   cmd  = "echo -e 'Archive:\n%s\n\n';" % path
   cmd += "totFiles=$(tar -tf '%s' | wc -l);" % path
   cmd += "if (( $totFiles > 300 )); then moreInf='  ... Will list the first 300 only ...'; else moreInf=''; fi;"
   cmd += "echo -e '\n%s\n--- Contents (Total='$totFiles')'$moreInf'\n%s';" % (SEP, SEP)
   cmd += "tar -tf '%s' | head -n300;" % path
   cmd += "if (( $totFiles > 300 )); then echo '\n... Only the first 300 are listed ...'; fi;"
  cmd += "echo '';"
  cmd += linux_sep
  FF75rg(self, cmd)
 def VVfYUu(self, item, path):
  FF7iMz(self, BF(self.VVlFJL, item, path), title="Extracting ...")
 def VVlFJL(self, item, path):
  title = os.path.basename(path)
  res = FF2ndj("RES=$(%s -dk '%s') && echo ok || echo $RES" % ("gzip" if path.endswith("gz") else "xz", path))
  if res == "ok":
   FF0onH(self, "Extracted File:\n\n%s" % path[:-3], title=title)
   self.VVrF6V()
  else:
   FFbBGq(self, "Error:\n\n%s" % res, title=title)
 def VV3ErR(self, item, path):
  fName = os.path.basename(path)
  lastP = FFiZj6(self.VV8HvU(path))
  parent = FFdwbd(path, False)
  if   item == "extract_toDir" : destP, txt = lastP , " to : %s" % lastP
  elif item == "extract_toRoot" : destP, txt = "/"  , ' to Root Directory ("/")'
  elif item == "extract_here"  : destP, txt = parent, " Here"
  else       : return
  FF6pUe(self, BF(self.VV61fg, item, path, fName, lastP, parent, destP), "Extract %s ?" % txt, title="File : %s" % fName)
 def VV61fg(self, item, path, fName, lastP, parent, destP):
  if item == "extract_toDir":
   cmd  = "cd '%s';" % parent
   cmd += FFQWwc("mkdir '%s'"   % lastP)
   cmd += 'if [ -d "%s" ]; then '  % lastP
   cmd += " tar -xf '%s' -C '%s';" % (path, lastP)
   cmd += "else"
   cmd += " echo -e 'Cannot create directory:\n%s';" % lastP
   cmd += "fi"
   destTxt = " : \n\n%s" % os.path.join(parent, destP)
  elif item == "extract_toRoot":
   cmd  = "cd '%s';" % parent
   cmd += "tar -C / -xf '%s'" % path
   destTxt = ' Root Directory ("/")'
  elif item == "extract_here":
   cmd  = "cd '%s';" % parent
   cmd += "tar -xf '%s'" % path
   destTxt = ": \n\n%s" % os.path.join(parent, destP)
  res = FF4aqG(cmd)
  if res : FFSMJz(self, "Error while extracting:\n\n%s\n\n%s\n\nError:\n\n%s" % (fName, SEP, res), isErr=True)
  else : FF0onH(self, "Successfully Extracted to%s" % destTxt, title=fName)
  self.VVrF6V()
 def VVE25y(self, item, path):
  fName = os.path.basename(path)
  FF6pUe(self, BF(self.VVPjph, item, path, fName), "Extract file ?\n\n%s" % fName)
 def VVPjph(self, item, path, fName):
  parent  = FFdwbd(path, False)
  destPath = self.VV8HvU(path)
  archCmd  = ""
  if path.endswith(".zip"):
   cmd = FF61q5("unzip", "unzip", "Unzip")
   if   item == "extract_toDir" : archCmd += " cd '%s'; [ ! -d '%s' ] && mkdir '%s';" % (parent,destPath, destPath)
   elif item == "extract_toRoot": destPath = "/"
   elif item == "extract_here"  : destPath = parent
   archCmd += " unzip -o -q '%s' -d '%s' > /dev/null;" % (path, destPath)
  elif path.endswith(".rar"):
   cmd = FF61q5("unrar", "unrar", "Unrar")
   if   item == "extract_toDir" : destPath = FF9Uvy(destPath)
   elif item == "extract_toRoot" : destPath = "/"
   elif item == "extract_here"  : destPath = parent
   archCmd += " unrar x -o+ '%s' '%s' > /dev/null;" % (path, destPath)
  elif path.endswith(".7z"):
   cmd = FF61q5("7za", "p7zip", "P7Zip")
   if   item == "extract_toDir" : destPath = destPath
   elif item == "extract_toRoot" : destPath = "/"
   elif item == "extract_here"  : destPath = parent
   archCmd += "7za x '%s' -o'%s' -y > /dev/null;" % (path, destPath)
  cmd += 'if [ "$allOK" -eq "1" ]; then '
  cmd += "echo '';"
  cmd += "echo 'Extracting content ...';"
  cmd +=   archCmd
  cmd += " echo -e 'Done.\n\nExtracted to:\n%s\n' %s;" % (destPath, FFuLAo(destPath, VVOQkl))
  cmd += "fi;"
  FFClck(self, cmd, VVu7vM=self.VVrF6V)
 def VVKtXC(self, path):
  FFO9kU(self, BF(self.VVPEDN, path), title="File Options", VV9cxb=self.VVC9nb(path))
 def VVC9nb(self, path, addSep=False):
  isText = path.endswith((".sh", ".py"))
  c1 = VVk4x7
  VV9cxb = []
  if addSep: VV9cxb.append(VVbM5H)
  if isText: VV9cxb.append((c1 + "View"  , "script_View"  ))
  VV9cxb.append((c1 + "Execute in Terminal" , "script_Execute" ))
  if isText: VV9cxb.append((c1 + "Edit"  , "script_Edit"  ))
  if VVSm4H:
   VV9cxb.append(VVbM5H)
   VV9cxb.append((VVPI2q + "Fix SH", "VVVJte"))
  return VV9cxb
 def VVPEDN(self, path, item=None):
  if item is not None:
   if   item == "script_View"  : FFjTOc(self, path)
   elif item == "script_Execute" : FF6pUe(self, BF(FF7iMz, self, BF(self.session.openWithCallback, self.VVrF6V, CCu5WO, VVruJa=path)), "Run File ?\n\n%s" % os.path.basename(path))
   elif item == "script_Edit"  : CCNb3y(self, path, VVhK3C=self.VVXwx1)
   elif item == "VVVJte"  : self.VVVJte(path)
 def VVVJte(self, path):
  txt = FFmx8y(path)
  var, ev, scr = txt.partition("eval")
  if ev:
   outF = path + "__.sh"
   var, scr = var.strip(), scr.strip()
   if FFZZgw("%s\necho -e %s > '%s'" % (var, scr, outF)):
    FF0onH(self, "Saved to:\n\n%s" % outF)
    self.VVrF6V()
   else: FFbBGq(self, "Converstion Error")
  else: FFbBGq(self, "No Eval")
 def VVA43p(self, addSep=False):
  VV9cxb = []
  if addSep:
   VV9cxb.append(VVbM5H)
  VV9cxb.append((VVk4x7 + "Play / Browse Channels", "m3u_Browse" ))
  VV9cxb.append((VVk4x7 + "Edit"     , "m3u_Edit" ))
  VV9cxb.append((VVk4x7 + "View"     , "m3u_View" ))
  return VV9cxb
 def VVToFA(self, path):
  FFO9kU(self, BF(self.VVxFYu, path), title="M3U/M3U8 File Options", VV9cxb=self.VVA43p(), width=550)
 def VVxFYu(self, path, item=None):
  if item is not None:
   if   item == "m3u_Browse" : CCGSVa(self, CCGSVa.VVLmXB, m3uF=path)
   elif item == "m3u_Edit"  : CCNb3y(self, path, VVhK3C=self.VVXwx1)
   elif item == "m3u_View"  : FFjTOc(self, path)
 def VVvn4t(self, path):
  if FFKbVo(path) : FF7iMz(self, BF(CC6ntZ.VVuzBx, self, path, BF(self.VVGY6R, path)), title="Loading Codecs ...")
  else    : FFWfGZ(self, path)
 def VVGY6R(self, path, item=None):
  if item:
   FFjTOc(self, path, encLst=item)
 def VV8Thr(self, path, title, asUtf8):
  if FFKbVo(path) : FF7iMz(self, BF(CC6ntZ.VVuzBx, self, path, BF(self.VVVBJD, path, title, asUtf8), title="Original Encoding"), title="Loading Codecs ...")
  else    : FFWfGZ(self, path)
 def VVVBJD(self, path, title, asUtf8, fromEnc=None):
  if fromEnc:
   if asUtf8: self.VVhydC(path, title, fromEnc, "UTF-8")
   else  : CC6ntZ.VVS4qb(self, BF(self.VVhydC, path, title, fromEnc), title="Convert to Encoding")
 def VVhydC(self, path, title, fromEnc, toEnc):
  if toEnc:
   if not FFKbVo(path):
    FFoTZI(self, "Cannot open file", 2000)
    return
   try:
    outFile = "%s_%s%s" % (path, toEnc, os.path.splitext(path)[1])
    with ioOpen(path, "r", encoding=fromEnc) as src:
     BLOCK_1MB = 1048576
     with ioOpen(outFile, "w", encoding=toEnc) as dest:
      while True:
       cont = src.read(BLOCK_1MB)
       if not cont:
        break
       dest.write(cont)
     txt  = FFKrMM("Successful\n\n", VVOQkl)
     txt += FFKrMM("From Encoding (%s):\n" % fromEnc, VVjojy)
     txt += "%s\n\n" % path
     txt += FFKrMM("To Encoding (%s):\n" % toEnc, VVjojy)
     txt += "%s\n\n" % outFile
     FFSMJz(self, txt, title=title)
   except:
    FFnE7j(outFile)
    FFbBGq(self, 'Cannot encode the file:\n%s\n\nFrom "%s" to "%s"' % (path, fromEnc, toEnc), title=title)
   self.VVrF6V()
 def VVS0Xp(self, path):
  title = "File Line-Break Conversion"
  FF6pUe(self, BF(self.VVInfE, path, title), "Convert Line-Breaks to Unix for the file:\n\n%s" % path, title=title)
 def VVInfE(self, path, title):
  if FFKbVo:
   with open(path, 'rb') as f:
    data = f.read()
   done = False
   if data:
    CRLF, LF, To = b"\r\n", b"\r", b"\n"
    totCRLF = data.count(CRLF)
    totLF = data.count(LF)
    if totCRLF or totLF:
     done = True
     with open(path, 'wb') as f:
      f.write(data.replace(CRLF, To).replace(LF, To))
   if done : txt = "%s\n\n%s" % (FFKrMM("File converted:", VVOQkl), path)
   else : txt = "Nothing to convert in:\n\n%s" % path
   FF0onH(self, txt, title=title)
  else:
   FFWfGZ(self, path, title=title)
 def VVViCP(self, path, newChmod):
  FF6pUe(self, BF(self.VVypPN, path, newChmod), "Change Permission to %s ?\n\n%s" % (newChmod, os.path.basename(path)))
 def VVypPN(self, path, newChmod):
  cmd = "chmod %s '%s' %s" % (newChmod, path, VVDs4N)
  result = FF2ndj(cmd)
  if result == "Successful" : FF0onH(self, result)
  else      : FFbBGq(self, result)
 def VVfUxk(self, path):
  parent = FFdwbd(path, False)
  self.session.openWithCallback(self.VVnuBM, BF(CC17eA, mode=CC17eA.VVAcq8, VVqNQm=parent, VVhKiJ="Create Symlink here"))
 def VVnuBM(self, newPath):
  if len(newPath) > 0:
   target = self.VVLS0u(self.VVjCx4())
   target = FFsxFo(target)
   linkName = FFiZj6(target)
   dotIndex = linkName.find(".")
   if dotIndex > -1:
    linkName = linkName[:dotIndex]
   newPath = FF9Uvy(newPath)
   link = newPath + linkName
   if   os.path.islink(FFsxFo(link)) : txt = ""
   elif os.path.ismount(link)     : txt = "MOUNT:"
   elif os.path.isfile(link)     : txt = "FILE:"
   elif os.path.isdir(link)     : txt = "DIRECTORY:"
   else          : txt = ""
   if len(txt) > 0:
    FFbBGq(self, "Name already used for %s\n\n%s" % (txt, link))
    return
   txt  = "-> TARGET:\n%s\n\n" % target
   txt += "<- LINK:\n%s"  % link
   FF6pUe(self, BF(self.VViHe6, target, link), "Create Soft Link ?\n\n%s" % txt, VVv5tA=True)
 def VViHe6(self, target, link):
  cmd = "LINK='%s'; if [ -e $LINK ]; then rm $LINK; fi; ln -sfv '%s' '%s' &>/dev/null %s" % (link, target, link, VVDs4N)
  result = FF2ndj(cmd)
  if result == "Successful" : FF0onH(self, result)
  else      : FFbBGq(self, result)
 def VVeoJV(self, path):
  lastPart = FFiZj6(path)
  FFANcN(self, BF(self.VVvS7S, path), title="Rename", defaultText=lastPart, message="Enter New Name:")
 def VVvS7S(self, path, VVV9Cp):
  if VVV9Cp:
   parent = FFdwbd(path, True)
   if os.path.isdir(path):
    path = FFsxFo(path)
   newName = parent + VVV9Cp
   cmd = "mv '%s' '%s' %s" % (path, newName, VVDs4N)
   if VVV9Cp:
    if os.path.basename(path) != VVV9Cp:
     message = "%s\n\nTo:\n\n%s" % (path, newName)
     FF6pUe(self, BF(self.VVnbrQ, cmd), message, title="Rename file?")
    else:
     FFbBGq(self, "Cannot use same name!", title="Rename")
 def VVnbrQ(self, cmd):
  result = FF2ndj(cmd)
  if "Fail" in result:
   FFbBGq(self, result)
  self.VVrF6V()
 def VVsWnH(self, preserve):
  title="Archive to .tar.gz"
  CCV3Gw.VVgWD3(self, VVN6I4=title, titleBg="#22003344", bodyBg="#22001122"
      , VVuSHu  = BF(self.VVhAhp, title, preserve)
      , VVhK3C = BF(self.VVYAvh, title))
 def VVhAhp(self, title, preserve, VVqeT6):
  totSel = self["myMenu"].VVWAEY()
  totOk = totFail = 0
  VVqeT6.VVfT17(totSel)
  VVqeT6.VVL8uX = ["", totSel, totOk, totFail, ""]
  VVqeT6.VVX5nT("Prepareing targz file")
  VVpGvX = self["myMenu"].VVFQA1()
  lastPart = FFiZj6(VVpGvX) or "archive"
  outF = os.path.join(VVpGvX, lastPart + ".tar.gz")
  c = 0
  while FFKbVo(outF):
   c += 1
   outF = os.path.join(VVpGvX, lastPart + "_%d.tar.gz" % c)
  totOk = totFail = 0
  path = ""
  try:
   with iTar.open(outF, mode="w:gz") as tarF:
    for row in self["myMenu"].list:
     if not VVqeT6 or VVqeT6.isCancelled:
      return
     if row[2][6]:
      VVqeT6.VVqE9L(1)
      name  = FFsxFo(row[0][0])
      lastPath = FFiZj6(name)
      path  = os.path.join(VVpGvX, name)
      tarF.add(path, arcname=None if preserve else lastPath)
      totOk += 1
      if VVqeT6:
       VVqeT6.VVL8uX = [outF, totSel, totOk, totFail, path]
       VVqeT6.VVLgGj(totOk, lastPath)
  except:
   totFail += 1
   if VVqeT6:
    VVqeT6.VVL8uX = [outF, totSel, totOk, totFail, path]
 def VVYAvh(self, title, VV6ZvL, VVL8uX, threadCounter, threadTotal, threadErr):
  outF, totSel, totOk, totFail, path = VVL8uX
  txt  = "%s:\n%s\n\n"   % (FFKrMM("Output File", VVOQkl), outF)
  txt += "Total\t: %d\n"  % totSel
  txt += "Archived\t: %d\n" % totOk
  if totFail   : txt += FFKrMM("Failed\t: %d\n" % totFail, VVdLWL)
  if not VV6ZvL: txt += "%s\n%s" % (FFKrMM("\nCancelled while copying:", VVdLWL), path)
  FFSMJz(self, txt, title=title)
  self.VVrF6V()
 @FFJRPn()
 def VVI1wL(self, isMove):
  lst = []
  srcDir = self["myMenu"].VVFQA1()
  totSel = self["myMenu"].VVWAEY()
  if totSel == 0:
   ndx = self["myMenu"].l.getCurrentSelectionIndex()
   row = self["myMenu"].list[ndx]
   lst = [FFiZj6(row[0][0])]
  else:
   for row in self["myMenu"].list:
    if row[2][6]:
     lst.append(FFiZj6(row[0][0]))
  if lst:
   sDir = CFG.lastCopyMoveDir.getValue() or self["myMenu"].VVFQA1()
   self.session.openWithCallback(BF(self.VVK4Nj, isMove, lst, srcDir), BF(CC17eA, mode=CC17eA.VVAcq8, VVqNQm=sDir, VVhKiJ="Move to here" if isMove else "Paste here"))
  else:
   FF8bV6(self, "Nothing selected", 1500)
 def VVK4Nj(self, isMove, lst, srcDir, dstDir):
  if dstDir:
   FFBWtx(CFG.lastCopyMoveDir, dstDir)
   FF7iMz(self, BF(self.session.openWithCallback, self.VVgSaC, CCVlLA, isMove, lst, srcDir, dstDir))
 def VVgSaC(self):
  self.VVrF6V()
 def VV7Ny2(self):
  tot = self["myMenu"].VVWAEY()
  FF6pUe(self, BF(FF7iMz, self, self.VVhdLQ, title="Deleting ...", clearMsg=False), "Delete %d item%s ?" % (tot, FFaRsj(tot)), title="Delete Selection")
 def VVhdLQ(self):
  path = self["myMenu"].VVFQA1()
  for row in self["myMenu"].list:
   if row[2][6]:
    FFy8Vf(os.path.join(path, row[0][0]))
  FFoTZI(self)
  self.VVrF6V()
 def VVozlP(self, path):
  fileName = os.path.basename(path)
  typ = FF1cqE(path)
  FF6pUe(self, BF(FF7iMz, self, BF(self.VV0P1d, path), title="Deleting ...", clearMsg=False), "%s\n\nDelete %s ?" % (path, typ), title="Delete %s" % typ)
 def VV0P1d(self, path):
  FFy8Vf(path)
  FFoTZI(self)
  self.VVrF6V()
 def VVTUgX(self, path, isFile):
  VVpGvX = self.VVmxpl()
  if isFile:
   name = CC17eA.VVzaQJ(VVpGvX, "file")
  else:
   fPath, fExt = os.path.splitext(path)
   if fPath and fExt and not VVkY7E(fPath) : name = os.path.basename(fPath)
   else          : name = CC17eA.VVzaQJ(VVpGvX, "dir")
  self.VVRmkW(VVpGvX, name, isFile)
 def VVRmkW(self, VVpGvX, name, isFile):
  subj = "File" if isFile else "Directory"
  title = "Create New %s" % subj
  FFANcN(self, BF(self.VVjcxC, VVpGvX, name, isFile, title), title=title, defaultText=name, message="Enter %s Name:" % subj)
 def VVjcxC(self, VVpGvX, name, isFile, title, nName):
  if not nName or not nName.strip(): return
  nName = nName.strip()
  path = os.path.join(VVpGvX, nName)
  if nName != FFDJVB(nName):
   self.VVRmkW(VVpGvX, nName, isFile)
   FFbBGq(self, "Unallowed characters in name", title)
  elif FFKbVo(path):
   self.VVRmkW(VVpGvX, nName, isFile)
   FFbBGq(self, "Already exists:\n\n%s" % VVpGvX, title)
  else:
   if isFile: cmd = "touch '%s' %s" % (path, VVDs4N)
   else  : cmd = "mkdir '%s' %s" % (path, VVDs4N)
   result = FF2ndj(cmd)
   if not "Successful" in result:
    FFbBGq(self, result, title)
   self.VVrF6V()
 def VVGAnH(self, path):
  c1, c2, c3, c4 = VVWH8U, VVk4x7, VVWJEN, VV0p9P
  VV9cxb = []
  VV9cxb.append((c1 + "List Package Files"         , "VVuvPG"     ))
  VV9cxb.append((c1 + "Package Information"         , "package_Info"     ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append((c2 + "Install Package"          , "VVW1yr_CheckVersion" ))
  VV9cxb.append((c2 + "Install Package (force reinstall)"     , "VVW1yr_ForceReinstall" ))
  VV9cxb.append((c2 + "Install Package (force overwrite)"     , "VVW1yr_ForceOverwrite" ))
  VV9cxb.append((c2 + "Install Package (force downgrade)"     , "VVW1yr_ForceDowngrade" ))
  VV9cxb.append((c2 + "Install Package (ignore failed dependencies)"  , "VVW1yr_IgnoreDepends" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append((c3 + "Remove Related Package"        , "VVn0NA_ExistingPackage" ))
  VV9cxb.append((c3 + "Remove Related Package (force remove)"    , "VVn0NA_ForceRemove"  ))
  VV9cxb.append((c3 + "Remove Related Package (ignore failed dependencies)" , "VVn0NA_IgnoreDepends" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Generate Feed Listing Info."        , "VVy18R"    ))
  VV9cxb.append(("Convert to %s" % ("DEB" if path[-3:] == "ipk" else "IPK") , "VVBPQY1"     ))
  VV9cxb.append(("Convert to .tar.gz %s(data part only)" % c4    , "VVBPQY2"     ))
  VV9cxb.append(("Extract Files"           , "VVOQa0"     ))
  VV9cxb.append(("Unbuild Package"           , "VVt7QT"     ))
  FFO9kU(self, BF(self.VVlyiG, path), VV9cxb=VV9cxb, VVPYL1=28, height=1000)
 def VVlyiG(self, path, item=None):
  if item is not None:
   if   item == "VVuvPG"      : self.VVuvPG(path)
   elif item == "package_Info"      : FF7iMz(self, BF(CCz0DD.VVHbAQ, self, path))
   elif item == "VVW1yr_CheckVersion"  : self.VVW1yr(path, VVw2da     )
   elif item == "VVW1yr_ForceReinstall" : self.VVW1yr(path, VVNtuq )
   elif item == "VVW1yr_ForceOverwrite" : self.VVW1yr(path, VVT1hn )
   elif item == "VVW1yr_ForceDowngrade" : self.VVW1yr(path, VVhy5N )
   elif item == "VVW1yr_IgnoreDepends" : self.VVW1yr(path, VVV9EQ )
   elif item == "VVn0NA_ExistingPackage" : self.VVn0NA(path, VVBjy1    )
   elif item == "VVn0NA_ForceRemove"  : self.VVn0NA(path, VVeNPM )
   elif item == "VVn0NA_IgnoreDepends"  : self.VVn0NA(path, VVbseS )
   elif item == "VVy18R"     : self.VVy18R(path)
   elif item == "VVBPQY1"     : self.VVBPQY(path, False)
   elif item == "VVBPQY2"     : self.VVBPQY(path, True)
   elif item == "VVOQa0"     : self.VVOQa0(path)
   elif item == "VVt7QT"     : self.VVt7QT(path)
 def VVuvPG(self, path):
  cTxt = lambda x: " echo -e '\n%s' %s;" % (x, FFuLAo(x, VVjojy))
  txt  = FFKrMM("Package File:\n", VVjojy)
  txt += "%s\n\n" % path
  txt += FFKrMM("Contents\n", VVjojy)
  txt += "\n".join(FFQ1wB("ar -t '%s';" % path))
  FFSMJz(self, txt)
 def VVy18R(self, path):
  if CCz0DD.VVLDCy(self):
   txt, mTime = CCz0DD.VVsFbw(path)
   pFile = "%s-Packages-File.txt" % path
   tFile = "%s-Packages.stamps.txt" % path
   with open(pFile, "w") as pF: pF.write("%s\n" % txt)
   with open(tFile, "w") as tF: tF.write("%s\n" % mTime)
   self.VVrF6V()
   txt  = "Result files:\n\n"
   txt += "%s\n\n" % os.path.basename(pFile)
   txt += "%s" % os.path.basename(tFile)
   FFSMJz(self, txt)
 def VVOQa0(self, path):
  dest = FFdwbd(path, True) + os.path.basename(path)[:-4]
  cmd  =  FF6SON()
  cmd += 'if [ "$allOK" -eq "1" ]; then '
  cmd +=    FFQWwc("mkdir '%s'" % dest)
  cmd +=    FFQWwc("cd '%s'" % dest)
  cmd += "  echo 'Extrcting files ...';"
  cmd += "  ar -xo '%s';" % path
  cmd += "  echo -e 'Done.\n';"
  cmd += "  echo -e 'Output Directory:\n%s' %s;" % (dest, FFuLAo(dest, VVOQkl))
  cmd += "fi;"
  FF6NKJ(self, cmd, VVu7vM=self.VVrF6V)
 def VVt7QT(self, path):
  outP = path + "_"
  VVihW2 = "DEBIAN" if path.endswith(".deb") else "CONTROL"
  binCmd = "&& rm -f \"$FILE\";"
  dataCmd = "\"$FILE\" -C '%s' && rm -f \"$FILE\";" % outP
  contCmd = "\"$FILE\" -C \"$CONTPATH\" && rm -f \"$FILE\";"
  zstCmd = "--use-compress-program=unzstd"
  zstErr = "NOTE: zstd not installed to decompress :"
  cmd  = FF6SON()
  cmd += 'if [ "$allOK" -eq "1" ]; then '
  cmd += "  rm -rf '%s' > /dev/null 2>&1;" % outP
  cmd += "  mkdir '%s';"      % outP
  cmd += "  CONTPATH='%s/%s';"    % (outP, VVihW2)
  cmd += '  mkdir "$CONTPATH";'
  cmd += "  cd '%s';"       % outP
  cmd += "  echo 'Unpacking ...';"
  cmd += "  ar -x '%s';"      % path
  cmd += "  FILE='%s/debian-binary';  [ -f \"$FILE\" ]             %s"  % (outP, binCmd)
  cmd += "  FILE='%s/data.tar.gz';    [ -f \"$FILE\" ] && tar -xzf %s"  % (outP, dataCmd)
  cmd += "  FILE='%s/control.tar.gz'; [ -f \"$FILE\" ] && tar -xzf %s"  % (outP, contCmd)
  cmd += "  FILE='%s/data.tar.xz';    [ -f \"$FILE\" ] && tar -xJf %s"  % (outP, dataCmd)
  cmd += "  FILE='%s/control.tar.xz'; [ -f \"$FILE\" ] && tar -xJf %s"  % (outP, contCmd)
  if FFW91j("unzstd"):
   cmd += "  FILE='%s/data.tar.zst';   [ -f \"$FILE\" ] && tar %s -xf  %s" % (outP, zstCmd, dataCmd)
   cmd += "  FILE='%s/control.tar.zst';[ -f \"$FILE\" ] && tar %s -xf  %s" % (outP, zstCmd, contCmd)
  else:
   cmd += "  FILE='%s/data.tar.zst';   [ -f \"$FILE\" ] && echo '%s data.tar.zst' %s;" % (outP, zstErr, FFuLAo(zstErr, VVPI2q))
   cmd += "  FILE='%s/control.tar.zst';[ -f \"$FILE\" ] && echo '%s control.tar.zst' %s;" % (outP, zstErr, FFuLAo(zstErr, VVPI2q))
  cmd += "  echo -e 'Done.\n';"
  cmd += "  echo -e '\nOutput Directory:\n%s' %s;" % (outP, FFuLAo(outP, VVOQkl))
  cmd += "fi;"
  FF6NKJ(self, cmd, VVu7vM=self.VVrF6V)
 def VVBPQY(self, path, toTar):
  if CCz0DD.VVLDCy(self):
   outF = path[:-3]
   if toTar:
    title = "Convert to tar.gz"
    outF += "tar.gz"
   elif path.endswith(".ipk"):
    title = "Convert to DEB"
    outF += "deb"
   else:
    title = "Convert to IPK"
    outF += "ipk"
   if FFKbVo(path):
    fnc = BF(FF7iMz, self, BF(self.VVOYIA, path, outF, toTar, title), title="Converting ...")
    if FFKbVo(outF) : FF6pUe(self, fnc, "File already exists:\n\n%s\n\nOverwrite ?" % os.path.basename(outF))
    else    : fnc()
   else:
    FFWfGZ(self, path)
 def VVOYIA(self, path, outF, toTar, title):
  wDir = "/tmp/ajp_tmpDir"
  def VV0lQf():
   FFlonU("rm -rf '%s'" % wDir)
  def VVJf3H(txt):
   FFbBGq(self, txt, title=title)
  def VVoAaj():
   FF0onH(self, "Converted to:\n\n%s" % outF, title=title)
   VV0lQf()
   self.VVrF6V()
  VV0lQf()
  FFlonU("rm -f '%s'" % outF)
  if not FFlonU("mkdir -p '%s';" % wDir):
   VVJf3H("Cannot create working dir.")
   return
  if not FFlonU("cd '%s'; ar -x '%s'" % (wDir, path)):
   VVJf3H("Cannot extract package files.")
   return
  files = FFQ1wB("find '%s' -type f" % wDir)
  if files:
   for fil in files:
    if   fil.endswith(".gz"): tool = "gzip"
    elif fil.endswith(".xz"): tool = "xz"
    else     : tool = ""
    if tool:
     if not FFZZgw("which %s" % tool):
      VVJf3H("You need to install : %s" % tool)
      return
     if not FFZZgw("%s -d '%s'" % (tool, fil)):
      VVJf3H("Cannot decompress file:\n\n%s" % os.path.basename(fil))
      return
  else:
   VVJf3H("No files extracted from package.")
   return
  if toTar:
   fName = os.path.basename(path)
   dFile = os.path.join(wDir, "data.tar")
   if FFKbVo(dFile):
    if FFZZgw("gzip < '%s' > '%s'" % (dFile, outF)):
     VVoAaj()
    else:
     VVJf3H("Cannot create .tar.gz file for:\n\n%s" % fName)
   else:
    VVJf3H("No data in package file:\n\n%s" % fName)
   return
  tool = "gzip" if outF.endswith("ipk") else "xz"
  for fil in FFQ1wB("find '%s' -type f" % wDir):
   if fil.endswith(".tar"):
    if not FFZZgw("%s '%s'" % (tool, fil)):
     VVJf3H("Cannot compress file:\n\n%s" % os.path.basename(fil))
     return
  files = FFQ1wB("find '%s' -type f" % wDir)
  if not files :
   VVJf3H("Not enough files in package.")
   return
  debF = ctrlF = dataF = ""
  for fil in files:
   fName = os.path.splitext(os.path.basename(fil))[0]
   if   fName == "debian-binary" : debF = fil
   elif fName == "control.tar"  : ctrlF = fil
   elif fName == "data.tar"  : dataF = fil
  if   not debF : err = "debian-binary"
  elif not ctrlF : err = "control"
  elif not dataF : err = "data"
  else   : err = ""
  if err :
   VVJf3H("Missing '%s' file." % err)
   return
  if FFlonU("ar -r '%s' '%s' '%s' '%s'" % (outF, debF, ctrlF, dataF)):
   VVoAaj()
  else:
   VVJf3H("Cannot create package ('ar' failed).")
 def VVW1yr(self, path, cmdOpt):
  cmd = FF4zTV(cmdOpt, path)
  if cmd:
   cmd = "%s && echo -e '\nSUCCESSFUL' || echo -e '\nERROR FOUND !'" % cmd
   FF6pUe(self, BF(FF6NKJ, self, cmd, VVu7vM=FFLgRo), "Install Package ?\n\n%s" % os.path.basename(path))
  else:
   FFWaiD(self)
 def VVn0NA(self, path, cmdOpt):
  FF7iMz(self, BF(self.VVzDjg, path, cmdOpt))
 def VVzDjg(self, path, cmdOpt):
  infCmd = FF4zTV(VV68Kk, path)
  if not infCmd:
   FFWaiD(self)
   return
  pkg = FF4aqG("%s | grep Package" % infCmd)
  pkg = pkg.partition(":")[2].strip()
  if not pkg:
   FFbBGq(self, "Cannot read Package Name from file.")
   return
  if CCz0DD.VVsyhp(pkg):
   cmd = FF4zTV(cmdOpt, pkg)
   FF6pUe(self, BF(FF6NKJ, self, cmd, VVu7vM=FFLgRo), "Remove Package:\n\n%s" % pkg)
  else:
   FFbBGq(self, "Package not installed:\n( %s )\n\nFrom file:\n%s" % (pkg, os.path.basename(path)))
 @FFJRPn()
 def VVoawZ(self, path):
  title = FFiZj6(path)
  pkg, err = CCz0DD.VVRgRC(path)
  if pkg : CCz0DD.VVHbAQ(self, pkg, title)
  else : FFbBGq(self, "No package info.", title)
 def VVdQFK(self, path, isDir):
  txt1 = "Archive to "
  txt2 = "Archive (Preserve Path Structure) to "
  VV9cxb = []
  VV9cxb.append(("%s.tar"  % txt1 , "archDir_tar"  ))
  VV9cxb.append(("%s.tar.gz" % txt1 , "archDir_tar_gz" ))
  VV9cxb.append(("%s.tar.xz" % txt1 , "archDir_tar_xz" ))
  VV9cxb.append(("%s.tar.bz2" % txt1 , "archDir_tar_bz2" ))
  VV9cxb.append(("%s.zip"  % txt1 , "archDir_zip"  ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("%s.tar"  % txt2 , "archPath_tar" ))
  VV9cxb.append(("%s.tar.gz" % txt2 , "archPath_tar_gz" ))
  VV9cxb.append(("%s.tar.xz" % txt2 , "archPath_tar_xz" ))
  VV9cxb.append(("%s.tar.bz2" % txt2 , "archPath_tar_bz2"))
  VV9cxb.append(("%s.zip"  % txt2 , "archPath_zip" ))
  if isDir and not self.VV9Hdq:
   VV9cxb.append(VVbM5H)
   VV9cxb.append(('Convert to "ipk" Package', "convertDirToIpk" ))
   VV9cxb.append(('Convert to "deb" Package', "convertDirToDeb" ))
  if isDir: c1, c2, title = "#11003322", "#11002222", "Archive Directory"
  else : c1, c2, title = "#11003344", "#11002244", "Archive File"
  FFO9kU(self, BF(self.VV7MV1, path, isDir, title), VV9cxb=VV9cxb, title=title, VVfWsQ=c1, VVB5I5=c2)
 def VV7MV1(self, path, isDir, title, item):
  if item is not None:
   if   item == "archDir_tar"  : self.VVY5pq(title, path, isDir, ".tar" , False)
   elif item == "archDir_tar_gz" : self.VVY5pq(title, path, isDir, ".tar.gz" , False)
   elif item == "archDir_tar_xz" : self.VVY5pq(title, path, isDir, ".tar.xz" , False)
   elif item == "archDir_tar_bz2" : self.VVY5pq(title, path, isDir, ".tar.bz2", False)
   elif item == "archDir_zip"  : self.VVY5pq(title, path, isDir, ".zip" , False)
   elif item == "archPath_tar"  : self.VVY5pq(title, path, isDir, ".tar" , True)
   elif item == "archPath_tar_gz" : self.VVY5pq(title, path, isDir, ".tar.gz" , True)
   elif item == "archPath_tar_xz" : self.VVY5pq(title, path, isDir, ".tar.xz" , True)
   elif item == "archPath_tar_bz2" : self.VVY5pq(title, path, isDir, ".tar.bz2", True)
   elif item == "archPath_zip"  : self.VVY5pq(title, path, isDir, ".zip" , True)
   elif item == "convertDirToIpk" : self.VVCgzK(path, False)
   elif item == "convertDirToDeb" : self.VVCgzK(path, True)
 def VVCgzK(self, path, VV8uHX):
  self.session.openWithCallback(self.VVrF6V, CC63Xr, path=path, VV8uHX=VV8uHX)
 def VVY5pq(self, title, path, isDir, fileExt, preserveDirStruct):
  parent  = FFdwbd(path, True)
  lastPart = FFiZj6(path)
  archFile = lastPart + fileExt
  resultFile = parent + archFile
  if preserveDirStruct:
   archFile = resultFile
   targetDir = parent + lastPart
  else:
   targetDir = lastPart
  if isDir: outFile, srcTxt = archFile , "Source Directory"
  else : outFile, srcTxt = resultFile , "Source File"
  if   fileExt == ".tar"  : archCmd, toolCmd = "tar -cvf"  , "allOK='1';"
  elif fileExt == ".tar.gz" : archCmd, toolCmd = "tar -cvzf" , "allOK='1';"
  elif fileExt == ".tar.xz" : archCmd, toolCmd = "tar -cvJf" , FF4AtW()
  elif fileExt == ".tar.bz2" : archCmd, toolCmd = "tar -cvjf" , FF61q5("bzip2" , "bzip2" , "BZip2" )
  elif fileExt == ".zip"  : archCmd, toolCmd = "zip -r"  , FF61q5("zip" , "zip"  , "Zip"  )
  if preserveDirStruct:
   if archCmd.startswith("tar") and targetDir.startswith("/") : archCmd = "%s '%s' -C / '%s';" % (archCmd, outFile, targetDir[1:])
   else              : archCmd = "%s '%s' '%s';"    % (archCmd, outFile, targetDir)
  else:
   if isDir: archCmd = "cd '%s'; %s '../%s' *;" % (path, archCmd, outFile)
   else : archCmd = "cd '%s'; %s '%s' '%s';" % (parent, archCmd, outFile, os.path.basename(path))
  failed = "Process failed !"
  sep  = " echo -e '%s';" % SEP
  cmd  = toolCmd
  cmd += 'if [ "$allOK" -eq "1" ]; then '
  cmd += " echo -e 'Archiving ...\n';"
  cmd +=   sep
  cmd +=   FFQWwc("rm -f '%s'" % archFile)
  cmd +=   archCmd
  cmd += " cd '%s';"      % parent
  cmd +=   sep
  cmd += " if [ $? -ne 0 ]; then "
  cmd += "  echo -e '\n%s\n' %s;"   % (failed, FFuLAo(failed, VVU4M8))
  cmd += "  rm -f '%s' > /dev/null 2>&1;" % archFile
  cmd += " elif [ -f '%s' ]; then "  % archFile
  cmd += "  chmod 644 '%s';"    % archFile
  cmd += "  echo -e '\nDONE\n';"
  cmd += "  echo -e '%s:' %s;"   % (srcTxt, FFuLAo(srcTxt, VV1l75))
  cmd += "  echo -e '%s\n';"    % path
  cmd += "  echo -e '%s:' %s;"   % ("Output", FFuLAo("Output", VVOQkl))
  cmd += "  echo -e '%s\n';"    % outFile
  cmd += " else"
  cmd += "  echo -e '\n%s\n' %s;"   % (failed, FFuLAo(failed, VVPI2q))
  cmd += "  rm -f '%s' > /dev/null 2>&1;" % archFile
  cmd += " fi;"
  cmd +=   sep
  cmd += "fi;"
  FFUKoP(self, cmd, VVu7vM=self.VVrF6V, title=title)
 def VVeSI8(self, path, isAll):
  if isAll: title, pathLst = "Add all Media in Directory to a Bouquet", CC17eA.VVmED9(FFdwbd(path, True))
  else : title, pathLst = "Add Media File to a Bouquet"   , [path]
  picker = CC8i1k(self, self, title, BF(self.VVcCca, pathLst))
 def VVcCca(self, pathLst):
  return CC8i1k.VVoNd2(pathLst)
 def VVJlm7(self, VV107U):
  title = "Convert .zip to .tar.gz"
  if iZip.is_zipfile(VV107U):
   tarPath = os.path.splitext(VV107U)[0] + ".tar.gz"
   fnc  = BF(self.VV3Rlf, VV107U, tarPath, title)
   txt  = "Converting ..."
   if FFKbVo(tarPath) : FF6pUe(self, BF(FF7iMz, self, fnc, title=txt), "File already exists:\n\n%s\n\nOverwrite ?" % os.path.basename(tarPath), title=title)
   else     : FF7iMz(self, fnc, title=txt)
  else:
   FFbBGq(self, "Invalid zip file:\n\n%s" % os.path.basename(VV107U), title=title)
 def VV3Rlf(self, VV107U, tarPath, title):
  try:
   with iZip.ZipFile(VV107U) as zipF:
    with iTar.open(tarPath, "w:gz") as tarF:
     for zipInfo in zipF.infolist():
      tarInfo = iTar.TarInfo(name=zipInfo.filename)
      tarInfo.size = zipInfo.file_size
      tarInfo.mtime = mktime(tuple(list(zipInfo.date_time) + [-1, -1, -1]))
      tarF.addfile(tarinfo=tarInfo, fileobj=zipF.open(zipInfo.filename))
   ok = True
  except:
   ok = False
  if ok and FFKbVo(tarPath):
   FFSMJz(self, "Done\n\nSource File\t: %s\nOutput File\t: %s" % (os.path.basename(VV107U), os.path.basename(tarPath)), title=title)
   self.VVrF6V()
  else:
   FFnE7j(tarPath)
   FFbBGq(self, "Error while converting.", title=title)
 def VVE97s(self, tarPath):
  title = "Convert .tar.gz to .zip"
  if iTar.is_tarfile(tarPath):
   VV107U = tarPath[:-7] + ".zip"
   fnc  = BF(self.VVEkkT, tarPath, VV107U, title)
   txt  = "Converting ..."
   if FFKbVo(tarPath) : FF6pUe(self, BF(FF7iMz, self, fnc, title=txt), "File already exists:\n\n%s\n\nOverwrite ?" % os.path.basename(tarPath), title=title)
   else     : FF7iMz(self, fnc, title=txt)
  else:
   FFbBGq(self, "Invalid tar file:\n\n%s" % os.path.basename(tarPath), title=title)
 def VVEkkT(self, tarPath, VV107U, title):
  try:
   with iTar.open(tarPath) as tar:
    with iZip.ZipFile(VV107U, mode='w', compression=iZip.ZIP_DEFLATED) as zipF:
     for mem in tar.getmembers():
      if mem.isfile():
       mtime = datetime.fromtimestamp(mem.mtime)
       zipInfo = iZip.ZipInfo(filename=mem.name, date_time=(mtime.year, mtime.month, mtime.day, mtime.hour, mtime.minute, mtime.second))
       zipF.writestr(zipInfo, tar.extractfile(mem).read(), compress_type=iZip.ZIP_DEFLATED)
   ok = True
  except:
   ok = False
  if ok and FFKbVo(tarPath):
   FFSMJz(self, "Done\n\nSource File\t: %s\nOutput File\t: %s" % (os.path.basename(tarPath), os.path.basename(VV107U)), title=title)
   self.VVrF6V()
  else:
   FFnE7j(VV107U)
   FFbBGq(self, "Error while converting.", title=title)
 def VVUwm4(self, path, ext2):
  FF7iMz(self, BF(self.VVOGML, path, ext2))
 def VVOGML(self, path, ext2):
  title = "Convert to .%s" % ext2
  p1, ext1 = os.path.splitext(path)
  p2 = "%s.%s" % (p1, ext2)
  if   ext1 == ".zst" : cmd1 = "zstd"
  elif ext1 == ".xz" : cmd1 = "xz"
  else    : cmd1 = "gzip"
  cmd2 = ext2 if ext2 == "xz" else "gzip"
  cmd  = FFQWwc("rm -f '%s'" % p2)
  cmd += "%s -d < '%s' | %s > '%s'" % (cmd1, path, cmd2, p2)
  if FFZZgw(cmd):
   FF0onH(self, "Result:\n\n%s" % os.path.basename(p2), title=title)
   self.VVrF6V()
  else:
   FFbBGq(self, "Could not convert:\n\n%s" % path, title=title)
 @FFJRPn()
 def VVsVcJ(self, path, isFhd):
  size = "1920x1080" if isFhd else "1280x720"
  title = "Convert to MVI (%s)" % size
  Dir  = FF9Uvy(os.path.dirname(path))
  filName = os.path.splitext(os.path.basename(path))[0]
  m1v  = "%s%s_%s.m1v" % (Dir, filName, size)
  mvi  = "%s%s_%s.mvi" % (Dir, filName, size)
  FFlonU("rm -f '%s' '%s'" % (m1v, mvi))
  if FFlonU("ffmpeg -i '%s' -r 25 -b:v 20000 -s %s '%s'" % (path, size, m1v)) and FFKbVo(m1v):
   FFlonU("mv -f '%s' '%s'" % (m1v, mvi))
   self.VVrF6V()
   FF0onH(self, "Converted to:\n\n%s" % os.path.basename(mvi), title=title)
  else:
   FFbBGq(self, "Cannot convert this file !", title=title)
 def VV07wU(self, path):
  VV9cxb, title, degS = [], "Rotate Image", str(u"\u00b0")
  if CCM6jS.VVWpl0(self, title, False, install=True):
   for i in range(90, 360, 90): VV9cxb.append(("%s%s" % (i, degS), str(i)))
   VV9cxb.append(VVbM5H)
   for i in range(1, 360): VV9cxb.append(("%s%s" % (i, degS), str(i)))
   VVGbyT = ("Expand", BF(self.VVVW6c, path, title))
   FFO9kU(self, BF(self.VVjhIF, path, title), VV9cxb=VV9cxb, width=700, VVGbyT=VVGbyT, VVbdOY=True, VVHRm1="OK = Same Size", title=title)
 def VVVW6c(self, path, title, VVhzhr, angle):
  self.VVjhIF(path, title, angle, rotExp=True)
 def VVmmo3(self, path):
  VV9cxb, title = [], "Flip Image"
  if CCM6jS.VVWpl0(self, title, False, install=True):
   VV9cxb.append(("Horizontally" , "h"))
   VV9cxb.append(("Vertically" , "v"))
   FFO9kU(self, BF(self.VVjhIF, path, title), VV9cxb=VV9cxb, width=500, title=title)
 def VVjhIF(self, path, title, item, rotExp=False):
  if item:
   FF7iMz(self, BF(self.VVAvDZ, path, title, item, rotExp))
 def VVAvDZ(self, path, title, item, rotExp):
  rotTxt = "rotated_%s%s" % (item, "_exp" if rotExp else "")
  flpTxt = "flipped_"
  try:
   from PIL import Image, ImageOps
   im = Image.open(path)
   if   item == "h" : res, im = flpTxt + "H", ImageOps.mirror(im)
   elif item == "v" : res, im = flpTxt + "V", ImageOps.flip(im)
   else    : res, im = rotTxt  , im.rotate(-int(item), expand=rotExp, resample=3)
   fil, ext = os.path.splitext(path)
   outF = "%s_%s%s" % (fil, res, ext)
   im.save(outF)
   self.VVrF6V()
   FF0onH(self, "Saved to:\n\n%s" % outF, title=title)
  except Exception as e:
   FFbBGq(self, str(e), title=title)
 def VVBHiz(self, path):
  title = "Save as"
  if CCM6jS.VVWpl0(self, title, False, install=True):
   fil, ext = os.path.splitext(path)
   VV9cxb = []
   for s in ("png", "jpg", "gif", "tif", "bmp"):
    VV9cxb.append((s, ) if s == ext[1:] else (s, s))
   FFO9kU(self, BF(self.VVj1nV, path, title), VV9cxb=VV9cxb, width=500, title=title)
 def VVj1nV(self, path, title, dstExt):
  if dstExt:
   FF7iMz(self, BF(self.VVKz0c, path, title, dstExt))
 def VVKz0c(self, path, title, dstExt):
  try:
   from PIL import Image, ImageSequence
   im = Image.open(path)
   outTyp = "RGBA" if dstExt == "png" else "RGB"
   srcF, srcExt = os.path.splitext(path)
   if srcExt in (".tif", ".gif"):
    txt = "Saved tif Frames:\n\n"
    name = "page" if srcExt == ".tif" else "frame"
    for i, page in enumerate(ImageSequence.Iterator(im), start=1):
     outF = "%s_%s_%03d.%s" % (path, name, i, dstExt)
     page = page.convert(outTyp)
     page.save(outF)
     txt += "  %s\n" % os.path.basename(outF)
    self.VVrF6V()
    FFSMJz(self, txt, title=title)
   else:
    im = im.convert(outTyp)
    outF = "%s.%s" % (srcF, dstExt)
    fnc = BF(self.VVxpcN, title, im, outF)
    if FFKbVo(outF) : FF6pUe(self, fnc, "Overwrite existing file ?\n\n%s" % outF, title=title)
    else    : fnc()
  except Exception as e:
   FFbBGq(self, str(e), title=title)
 def VVxpcN(self, title, im, outF):
  try:
   im.save(outF)
   self.VVrF6V()
   FF0onH(self, "Saved to:\n\n%s" % outF, title=title)
  except Exception as e:
   FFbBGq(self, str(e), title=title)
 @FFJRPn()
 def VVK7yJ(self, path, mode):
  ext = "png" if mode == 1 else "jpg"
  title = "Convert to %s" % ext
  outF = path[:-3] + ext
  FFnE7j(outF)
  res = FF4aqG('ffmpeg -hide_banner -i "%s" -frames:v 1 "%s"' % (path, outF))
  if FFKbVo(outF):
   FF0onH(self, "Saved to:\n\n%s" % outF, title=title)
   self.VVrF6V()
  elif "unhandled version" in res : FFbBGq(self, "Your ffmpeg cannot handle mvi.", title=title)
  else       : FFbBGq(self, "Conversion Error", title=title)
 @FFJRPn()
 def VV3ESR(self, path):
  title = "Convert to Base64 String"
  try:
   ext = os.path.splitext(path)[1][1:].lower().replace("jpg", "jpeg")
   outF = os.path.join(os.path.dirname(path), os.path.basename(path) + "_base64.txt")
   with open(path, "rb") as f: b64 = b64encode(f.read()).decode()
   with open(outF, "w") as f: f.write("data:image/%s;base64,%s" % (ext, b64))
   FF0onH(self, "Saved to : %s\n\n" % outF, title=title)
   self.VVrF6V()
  except Exception as e:
   FFbBGq(self, str(e), title=title)
 def VV8P2N(self, path):
  title = "Set as PIcon for current channel"
  pPath = CCRGqC.VV5G3P()
  if VVkY7E(pPath):
   if CCM6jS.VVWpl0(self, title, False, cbFnc=BF(self.VV8P2N, path)):
    picon = "%s%s.png" % (pPath, CCZv30(self.session).VVF8zm.strip(":").replace(":", "_").upper())
    VV9cxb = []
    for item in ((50,30),(96,64),(100,60),(220,132),(400,160),(400,240),(500,300)):
     VV9cxb.append(("%d x %d" % (item), item))
    VVF79M = self.VVz401
    VVGbyT = ("Stretch", BF(self.VVRKyT, title, path, picon))
    VVhzhr = FFO9kU(self, BF(self.VVbpyK, title, path, picon, False), VV9cxb=VV9cxb, width=700, title='PIcon Max. Size', VVF79M=VVF79M, VVGbyT=VVGbyT, VVHRm1="OK = Fit within size")
    VVhzhr.VVhINX(3)
  else:
   FFbBGq(self, "PIcons path not found:\n\n%s\n\n( You can change it in Settings )" % pPath, title=title)
 def VVRKyT(self, title, path, picon, selectionObj, item):
  self.VVbpyK(title, path, picon, True, item)
  selectionObj.cancel()
 def VVbpyK(self, title, path, picon, stretch, sz=None):
  if sz:
   try:
    from PIL import Image
    im = Image.open(path)
    if stretch: im = im.resize(sz, Image.ANTIALIAS)
    else   : im.thumbnail(sz)
    im.save(picon)
    CCpebE.VV1v7b(self, VV6tGM=CCpebE.VVbdzi)
   except Exception as e:
    FFbBGq(self, "Image Processing error:\n\n%s" % e)
 def VVz401(self, VVhzhr, txt, ref, ndx):
  FFY7F5(self, "_help_resize", "Picture File Resizing")
 def VVZik7(self, path):
  CCTe4w.VVAMwI(self, BF(self.VVJbid, path))
 def VVJbid(self, path, rType=None):
  if rType:
   FF7iMz(self, BF(self.VVGtUI, self, path, rType), title="Playing Media ...")
 @staticmethod
 def VVGtUI(SELF, path, rType=""):
  if   rType     : prefix = rType
  elif path.endswith(".ts") : prefix = "1"
  else      : prefix = CFG.iptvAddToBouquetRefType.getValue()
  VVq9SN = "%s:%s%s" % (prefix, "0:" * 9, path)
  CCsmqb.VVlIAT(SELF.session, VVinUd=False, VVyhra=False, VVdxJv=VVq9SN)
 @staticmethod
 def VVNGSU(SELF):
  serv = SELF.session.nav.getCurrentlyPlayingServiceReference()
  fPath = serv and serv.getPath()
  if fPath and FFKbVo(fPath):
   fDir, fName = os.path.split(fPath)
   return fPath, FF9Uvy(fDir), fName
  return "", "", ""
 @staticmethod
 def VVdLTI(path):
  Stat = os.statvfs(path)
  return Stat.f_frsize * Stat.f_blocks
 @staticmethod
 def VVj8Uc(path):
  Stat = os.statvfs(path)
  return Stat.f_frsize * Stat.f_bfree
 @staticmethod
 def VVxNgx(size, mode=0):
  txt = CC17eA.VVnlHr(size)
  if size >= 1024 :
   commaSize = format(size, ',d')
   if mode == 1: return "%s (%s)"   % (txt, commaSize)
   if mode == 2: return "%s (%s)"   % (commaSize, txt)
   if mode == 3: return "%s (%s)"   % (size, txt)
   if mode == 4: return "%s"    % txt
   else  : return "%s  ( %s bytes )" % (txt, commaSize)
  else:
   return txt
 @staticmethod
 def VVnlHr(bytes):
  kilo, unit = 1024.0, ("B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB")
  if bytes < kilo:
   return "%d B" % bytes
  i = int(iFloor(iLog(bytes, 1024)))
  s = str("%.2f" % (bytes / (kilo ** i))).rstrip(".0")
  return "%s %s" % (s, unit[i])
 @staticmethod
 def VVLpYt(path):
  rangeList = list(range(0x20, 0x100))
  try:
   with open(path, 'rb') as f:
    bytes = f.read(1024)
   textchars = bytearray({7,8,9,10,12,13,27} | set(rangeList) - {0x7f})
   return bool(bytes.translate(None, textchars))
  except:
   return True
 @staticmethod
 def VV9kj1(SELF, path, title=""):
  try:
   with ioOpen(path, "r", encoding="UTF-8") as f:
    txt = f.read()
   return True
  except:
   if title:
    FFbBGq(SELF, "File is not in 'UTF-8' Encoding:\n\n%s" % path, title=title.strip())
   return False
 @staticmethod
 def VVYj8q(addDot=False):
  tDict = CC00KO.VVgJJJ()
  lst = list(tDict["mov"])
  lst.extend(list(tDict["mus"]))
  if addDot: lst = ["." + x for x in lst]
  return tuple(lst)
 @staticmethod
 def VVmED9(path):
  lst = []
  for ext in CC17eA.VVYj8q():
   lst.extend(FFYvtE(path, "*.%s" % ext))
  return sorted(lst, key=FFlhXH(FFZoJv))
 @staticmethod
 def VVcnM6(path):
  return FFlonU("tar -tzf '%s'" % path)
 @staticmethod
 def VVXQIL(path):
  path = os.path.abspath(path)
  while not os.path.ismount(path):
   path = os.path.dirname(path)
  return path
 @staticmethod
 def VVLSXg(addTrailingSlash=True):
  Dict = {}
  for line in FF2kXa("/proc/mounts"):
   parts = line.split(" ")
   if len(parts) > 2:
    fs, mp, typ = parts[:3]
    if addTrailingSlash and os.path.isdir(mp):
     mp = FF9Uvy(mp)
    isNet = ":" in fs or fs.startswith("//")
    Dict[mp] = (fs, typ, isNet)
  return Dict
 @staticmethod
 def VVUUll():
  lst = []
  for key, val in CC17eA.VVLSXg().items():
   if val[2]: lst.append(key)
  return lst
 @staticmethod
 def VVUDvl(lst, fromFind=True):
  if len(lst) == 1 and lst[0] == VVadcU:
   return VVadcU
  elif fromFind:
   for line in lst:
    span = iSearch(r"find:\s*(.+):\s*Input\/output error", line, IGNORECASE)
    if span:
     return 'Filesystem Error in:\n\n%s' % span.group(1)
  return ""
 @staticmethod
 def VVzaQJ(path, name):
  c = 0
  newNm = name
  while VVkY7E(os.path.join(path, newNm)):
   c += 1
   newNm = "%s%s" % (name, c)
  return newNm
class CC00KO(MenuList):
 VVNvGC   = 0
 VV5U3E   = 1
 VVNXFX   = 2
 VVOJOt   = 3
 VVEqWs   = 4
 VVG5pG   = 5
 VV8akq   = 6
 VV06Ky   = 7
 VVKa95   = "<List of Storage Devices>"
 VVDRmr  = "<Parent Directory>"
 VVorGJ   = 0
 VVyBPa   = 1
 VV6d3L = 2
 VVEoE6  = 3
 VVfoGB   = 4
 VVCIOb   = 5
 FILE_TYPE_LINK   = 6
 VV2JVW  = 7
 PROHIBITED_FILES  = ["/%s/" % x for x in ("DEBIAN","bin","boot","dev","etc","hdd","home","lib","media","mnt","network","proc","run","sbin","sys","tmp","usr","var")]
 def __init__(self, enableWrapAround=False, directory="/", VVPSVp=True, VVhkMl=True, VVOVCO=True, VVtXmu=None, VV8Chg=False, VVp0ul=False, isTop=False, VVkSSt=None, VV2InR=1000, VVPYL1=30, VVCW3G=30):
  MenuList.__init__(self, list, enableWrapAround, eListboxPythonMultiContent)
  self.VVPSVp  = VVPSVp
  self.VVhkMl    = VVhkMl
  self.VVOVCO  = VVOVCO
  self.VVtXmu  = VVtXmu
  self.VV8Chg   = VV8Chg or []
  self.VVp0ul   = VVp0ul or []
  self.isTop     = isTop
  self.additional_extensions = VVkSSt
  self.VV2InR    = VV2InR
  self.VVPYL1    = VVPYL1
  self.VVCW3G    = VVCW3G
  self.VVimsO   = eServiceCenter.getInstance()
  self.mountpoints   = []
  self.networkMounts   = CC17eA.VVUUll()
  self.current_directory  = None
  self.current_mountpoint  = None
  self.multiSelect_color  = FFcUfR("#11ff4444")
  self.l.setFont(0, gFont(VV3IRX, self.VVPYL1))
  self.l.setItemHeight(self.VVCW3G)
  self.png_mntN   = CC00KO.VVjXJx("mntN")
  self.png_mntL   = CC00KO.VVjXJx("mntL")
  self.png_mem   = CC00KO.VVjXJx("mem")
  self.png_usb   = CC00KO.VVjXJx("usb")
  self.png_fil   = CC00KO.VVjXJx("fil")
  self.png_dir   = CC00KO.VVjXJx("dir")
  self.png_dirup   = CC00KO.VVjXJx("dirup")
  self.png_slwfil   = CC00KO.VVjXJx("slwfil")
  self.png_slbfil   = CC00KO.VVjXJx("slbfil")
  self.png_slwdir   = CC00KO.VVjXJx("slwdir")
  self.VVBVQn()
  self.VVH4by(directory)
 @staticmethod
 def VVjXJx(category):
  return LoadPixmap("%s%s.png" % (VVK8DT, category), getDesktop(0))
 @staticmethod
 def VVgJJJ():
  return {"pic":("bmp","gif","jpe","jpeg","jpg","png","svg"),"mov":("3g2","3gp","asf","avi","divx","flv","ifo","iso","m2ts","m4v","mkv","mod","mov","mp4","mpe","mpeg","mpg","mts","mvi","ogm","ogv","pva","rm","rmvb","stream","ts","vob","webm","wmv","wtv","h264","h265","mjpeg","mk3d","mks","xvid"),"mus":("aac","ac3","alac","amr","ape","au","dts","flac","m2a","m4a","mid","mka","mp2","mp3","oga","ogg","wav","wave","wma","wv","m4b","m4p","mpc","wpl"),"txt":("cfg","conf","htm","html","txt","xml"),"py":("py","pyo","pyc"),"tar":("bz2","gz","tar","xz"),"rar":("rar",),"zip":("zip",),"p7z":("7z",),"zst":("zst",),"ipk":("ipk",),"deb":("deb",),"scr":("sh",),"m3u":("m3u","m3u8")}
 def VVSEcc(self, name, absolute=None, isDir=False, typ=None, png=None):
  if absolute and isDir:
   path = absolute
   path = FFsxFo(path)
   if os.path.islink(path) and not name in (self.VVKa95, self.VVDRmr):
    png = self.png_slwdir
    name += FFKrMM(" -> " , VVjojy) + FFKrMM(os.readlink(path), VVOQkl)
  tableRow = [ (absolute, isDir, typ) ]
  tableRow.append((eListboxPythonMultiContent.TYPE_TEXT, self.VVCW3G + 10, 0, self.VV2InR, self.VVCW3G, 0, LEFT | RT_VALIGN_CENTER, name))
  if png is not None:
   tableRow.append(CC4ngo.VVvFdD(0, 2, self.VVCW3G-4, self.VVCW3G-4, png))
  return tableRow
 @staticmethod
 def VVuedz(path):
  ext = os.path.splitext(path)[1]
  if ext:
   ext = ext.lstrip(".").lower()
   for cat, lst in CC00KO.VVgJJJ().items():
    if ext in lst:
     return cat
  return ""
 def VVBVQn(self):
  self.mountpoints = [os.path.join(p.mountpoint, "") for p in harddiskmanager.getMountedPartitions()]
  self.mountpoints.sort(reverse=True)
 def VV33sI(self, file):
  file = os.path.join(os.path.realpath(file), "")
  for m in self.mountpoints:
   if file.startswith(m):
    return m
  return False
 def VVbo2F(self, file):
  if os.path.realpath(file) == file:
   return self.VV33sI(file)
  else:
   if file[-1] == "/":
    file = file[:-1]
   mp = self.VV33sI(file)
   last = file
   file = os.path.dirname(file)
   while last != "/" and mp == self.VV33sI(file):
    last = file
    file = os.path.dirname(file)
   return os.path.join(last, "")
 def getSelection(self):
  if self.l.getCurrentSelection() is None:
   return None
  return self.l.getCurrentSelection()[0]
 def VVEBz0(self, isUp):
  ndx = self.l.getCurrentSelectionIndex()
  row = self.list[ndx]
  bg = self.multiSelect_color if row[2][6] == None else None
  ndx = self.getSelectionIndex()
  if isUp:
   if ndx > 0:
    self.moveToIndex(self.getSelectionIndex() - 1)
  else:
   if ndx < len(self.list) - 1:
    self.moveToIndex(self.getSelectionIndex() + 1)
  iconData = self.VVRKya(row, bg)
  if iconData:
   row[2] = iconData
   self.l.setList(self.list)
   return True
  else:
   return False
 def VVm4Gc(self, isSel, fManMode, cbFnc):
  bg = self.multiSelect_color if isSel else None
  if isSel and fManMode in (CC17eA.VVKzxn, CC17eA.VVAcq8):
   VVpGvX = self.VVFQA1()
   for ndx, row in enumerate(self.list):
    if row[0][0]:
     path = os.path.join(VVpGvX, row[0][0])
     isDir = os.path.isdir(path)
     if fManMode == CC17eA.VVKzxn and not isDir or fManMode == CC17eA.VVAcq8 and isDir:
      iconData = self.VVRKya(row, bg)
      if iconData:
       row[2] = iconData
  else:
   for ndx, row in enumerate(self.list):
    iconData = self.VVRKya(row, bg)
    if iconData:
     row[2] = iconData
  self.l.setList(self.list)
  cbFnc()
 def VVRKya(self, row, bg):
  if self.VVc6WE(row):
   iconData = list(row[2])
   iconData[6] = bg
   iconData[7] = bg
   return tuple(iconData)
  else:
   return None
 def VVc6WE(self, row):
  if not row[0][0] in self.mountpoints:
   if   row[0][2] in (self.VVCIOb, self.FILE_TYPE_LINK): return True
   elif row[0][2] == self.VVfoGB:
    if   VVIlCj           : return True
    elif not row[0][0] in self.PROHIBITED_FILES    : return True
  return False
 def VVVu0W(self):
  return self.VVc6WE(self.list[self.l.getCurrentSelectionIndex()])
 def VVWAEY(self):
  tot = 0
  for row in self.list:
   if row[2][6]:
    tot += 1
  return tot
 def VVKiB1(self, dir, parents):
  dir = os.path.realpath(dir)
  for p in parents:
   if dir.startswith(p):
    return True
  return False
 def VVH4by(self, directory, selItem=None):
  self.list = []
  directories = []
  files = []
  if self.current_directory is None:
   if directory and self.VVOVCO:
    self.current_mountpoint = self.VVbo2F(directory)
   else:
    self.current_mountpoint = None
  self.current_directory = directory
  if directory is None:
   if self.VVOVCO:
    for p in harddiskmanager.getMountedPartitions():
     path = os.path.join(p.mountpoint, "")
     if path not in self.VVp0ul and not self.VVKiB1(path, self.VV8Chg):
      if path == "/" : png = self.png_mem
      else   : png = self.png_usb
      self.list.append(self.VVSEcc(name=p.description, absolute=path, isDir=True, typ=self.VVorGJ, png=png))
    path = "/"
    if path not in self.VVp0ul and not self.VVKiB1(path, self.VV8Chg):
     for item in self.list:
      if path == item[0][0]:
       break
     else:
      self.list.append(self.VVSEcc(name="INTERNAL FLASH", absolute="/", isDir=True, typ=self.VVyBPa, png=self.png_mem))
  else:
   if FFKbVo(directory):
    try:
     files = os.listdir(directory)
    except:
     files = []
    tmpfiles = files[:]
    for x in tmpfiles:
     tPath = directory + x
     if os.path.isdir(tPath):
      directories.append(tPath + "/")
      files.remove(x)
     elif not FFqXDL(tPath):
      files.remove(x)
  if directory is not None and self.VVPSVp and not self.isTop:
   if directory == self.current_mountpoint and self.VVOVCO:
    self.list.append(self.VVSEcc(name=self.VVKa95, absolute=None, isDir=True, typ=self.VV6d3L, png=self.png_dirup))
   elif (directory != "/") and not (self.VVp0ul and self.VV33sI(directory) in self.VVp0ul):
    self.list.append(self.VVSEcc(name=self.VVDRmr, absolute='/'.join(directory.split('/')[:-2]) + '/', isDir=True, typ=self.VVEoE6, png=self.png_dirup))
  if self.VVPSVp:
   for x1 in directories:
    if not (self.VVp0ul and self.VV33sI(x1) in self.VVp0ul) and not self.VVKiB1(x1, self.VV8Chg):
     name = x1.split('/')[-2]
     x2 = FF9Uvy(os.path.realpath(x1))
     if os.path.ismount(x2):
      if   x2 in self.mountpoints  : png = self.png_usb
      elif x2 in self.networkMounts : png = self.png_mntN
      else       : png = self.png_mntL
     else        : png = self.png_dir
     self.list.append(self.VVSEcc(name=name, absolute=x1, isDir=True, typ=self.FILE_TYPE_LINK if os.path.islink(FFsxFo(x1)) else self.VVfoGB, png=png))
  if self.VVhkMl:
   for x in files:
    path = directory + x
    name = x
    png  = self.png_fil
    if os.path.islink(FFsxFo(path)):
     try:
      target = os.readlink(path)
      if FFKbVo(target):
       png = self.png_slwfil
       name += FFKrMM(" -> " , VVjojy) + FFKrMM(target, VVOQkl)
      else:
       png = self.png_slbfil
       name += FFKrMM(" -> " , VVjojy) + FFKrMM(target, VVPI2q)
     except:
      png = self.png_slbfil
    elif "." in name:
     category = self.VVuedz(name)
     if category:
      png = LoadPixmap("%s%s.png" % (VVK8DT, category))
    elif not FFqXDL(path):
     png = LoadPixmap("%serr.png" % VVK8DT)
    if (self.VVtXmu is None) or iCompile(self.VVtXmu[0], flags=self.VVtXmu[1]).search(path):
     self.list.append(self.VVSEcc(name=name, absolute=x , isDir=False, typ=self.VVCIOb, png=png))
  if self.VVOVCO and len(self.list) == 0:
   self.list.append(self.VVSEcc(name=FFKrMM("No USB connected", VV0p9P), absolute=None, isDir=False, typ=self.VV2JVW, png=self.png_usb))
  self.l.setList(self.list)
  self.VVJC3E()
  if selItem is not None:
   i = 0
   self.moveToIndex(0)
   for x in self.list:
    p = x[0][0]
    if isinstance(p, eServiceReference): p = p.getPath()
    if p == selItem: self.moveToIndex(i)
    i += 1
 def VVFQA1(self):
  return self.current_directory
 def VVOG6X(self):
  if self.getSelection() is None:
   return False
  return self.getSelection()[1]
 def VVQ3ha(self):
  return self.VVy394() and self.VVFQA1()
 def VVy394(self):
  return self.list[0][1][7] in (self.VVKa95, self.VVDRmr)
 def descent(self):
  if self.getSelection() is None:
   return
  self.VVH4by(self.getSelection()[0], self.current_directory)
 def VV0cQ6(self):
  if self.getSelection() is None:
   return None
  x = self.getSelection()[0]
  if isinstance(x, eServiceReference):
   x = x.getPath()
  return x
 def execBegin(self):
  harddiskmanager.on_partition_list_change.append(self.VV9VzU)
 def execEnd(self):
  harddiskmanager.on_partition_list_change.remove(self.VV9VzU)
 def VV9VzU(self, action, device):
  self.VVBVQn()
  if self.current_directory is None:
   self.VVNWgQ()
 def VVNWgQ(self):
  tDict = {}
  for row in self.list:
   if row[2][6]:
    tDict[row[0][0]] = 1
  fName = self.VV0cQ6()
  self.VVH4by(self.current_directory, fName if FFKbVo(os.path.join(self.current_directory, fName)) else None)
  isSel = 0
  if tDict:
   for row in self.list:
    if tDict.get(row[0][0], 0):
     row[2] = list(row[2])
     row[2][6] = row[2][7] = self.multiSelect_color
     row[2] = tuple(row[2])
     isSel = 1
   self.l.setList(self.list)
  return isSel
 def VVejxx(self):
  mode = CFG.browserSortMode.getValue()
  mix  = CFG.browserSortMix.getValue()
  sAZ, sZA, s09, s90, sNO, sON = "A > Z", "Z > A", "0 > 9", "9 > 0", "New > Old", "Old > New"
  if mode == self.VVNvGC : nameAlpMode, nameAlpTxt = self.VV5U3E, sZA
  else       : nameAlpMode, nameAlpTxt = self.VVNvGC, sAZ
  if mode == self.VVNXFX : nameNumMode, nameNumTxt = self.VVOJOt, s90
  else       : nameNumMode, nameNumTxt = self.VVNXFX, s09
  if mode == self.VVEqWs : dateMode, dateTxt = self.VVG5pG, sON
  else       : dateMode, dateTxt = self.VVEqWs, sNO
  if mode == self.VV8akq : typeMode, typeTxt = self.VV06Ky, sZA
  else       : typeMode, typeTxt = self.VV8akq, sAZ
  if   mode in (self.VVNvGC, self.VV5U3E): txt = "Name (%s)" % (sAZ if mode == self.VVNvGC else sZA)
  elif mode in (self.VVNXFX, self.VVOJOt): txt = "Name (%s)" % (s09 if mode == self.VVNvGC else s90)
  elif mode in (self.VVEqWs, self.VVG5pG): txt = "Date (%s)" % (sNO if mode == self.VVEqWs else sON)
  elif mode in (self.VV8akq, self.VV06Ky): txt = "Type (%s)" % (sAZ if mode == self.VV8akq else sZA)
  if mix:
   txt += " .. Mixed"
  return nameAlpMode, nameAlpTxt, nameNumMode, nameNumTxt, dateMode, dateTxt, typeMode, typeTxt, "Cur = by %s" % txt
 def VVJC3E(self, mode=None, isMix=False, isNum=False):
  if not mode is None:
   FFBWtx(CFG.browserSortMode, mode)
   FFBWtx(CFG.browserSortMix, isMix)
  if self.list:
   if self.VVy394() : item0, topRow = 1, self.list[0]
   else    : item0, topRow = 0, None
   mode = CFG.browserSortMode.getValue()
   isMix = CFG.browserSortMix.getValue()
   if mode in (self.VVNvGC, self.VV5U3E):
    rev = True if mode == self.VV5U3E else False
    if isMix: self.list = sorted(self.list[item0:], key=lambda x: x[1][7]         , reverse=rev)
    else : self.list = sorted(self.list[item0:], key=lambda x: (x[0][1] if rev else not x[0][1], x[1][7]), reverse=rev)
   elif mode in (self.VVNXFX, self.VVOJOt):
    rev = True if mode == self.VVOJOt else False
    self.list = sorted(self.list[item0:], key=FFlhXH(BF(self.VVeAw8, isMix, rev)), reverse=rev)
   elif mode in (self.VVEqWs, self.VVG5pG):
    rev = True if mode == self.VVG5pG else False
    self.list = sorted(self.list[item0:], key=FFlhXH(BF(self.VVfdRx, isMix)), reverse=rev)
   else:
    rev = True if mode == self.VV06Ky else False
    if isMix: self.list = sorted(self.list[item0:], key=lambda x: os.path.splitext(x[1][7])[1]            , reverse=rev)
    else : self.list = sorted(self.list[item0:], key=lambda x: (x[0][1] if rev else not x[0][1], os.path.splitext(x[1][7])[1], x[1][7]) , reverse=rev)
   if topRow:
    self.list.insert(0, topRow)
   self.l.setList(self.list)
 def VVeAw8(self, mix, rev, p1, p2):
  dir1, name1 = p1[0][1], p1[1][7]
  dir2, name2 = p2[0][1], p2[1][7]
  if mix:
   return FFZoJv(name1.lower(), name2.lower())
  else:
   if rev: dir1, dir2 = dir2, dir1
   return FFevFd(dir2, dir1) or FFZoJv(name1, name2)
 def VVfdRx(self, mix, p1, p2):
  dir1 = p1[0][1]
  dir2 = p2[0][1]
  if mix or dir1 == dir2:
   path1 = "" if dir1 else self.current_directory
   path2 = "" if dir2 else self.current_directory
   try:
    stat1 = os.stat(path1 + p1[0][0])
    stat2 = os.stat(path2 + p2[0][0])
    if mix : return FFevFd(stat2.st_ctime, stat1.st_ctime)
    else : return FFevFd(dir2, dir1) or FFevFd(stat2.st_ctime, stat1.st_ctime)
   except:
    pass
  return 0
class CCybrT(Screen):
 def __init__(self, session, defFG="", defBG="", onlyBG=False, isBgMode=True):
  self.skin, self.VVmNvK = FFQaOH(VVAFxx, 900, 700, 35, 10, 14, "#22333333", "#22333333", 30, VVSwLg=40)
  self.session  = session
  self.onlyBG   = onlyBG
  self.Title   = "Color"
  self.VVz8of  = 6
  self.VVatGZ  = 8
  self.VVXpNQ   = []
  self.curRow   = 0
  self.curCol   = 0
  self.isBgMode  = isBgMode
  self.defFG   = self.VVNSzd(defFG, "#00FFFFFF")
  self.defBG   = self.VVNSzd(defBG, "#11000000")
  self.transpFg  = int(self.defFG[1:3], 16)
  self.transpBg  = int(self.defBG[1:3], 16)
  self.colors   = (   ("FFFFFF", "FFC0C0", "FFE0C0", "FFFFC0", "C0FFC0", "C0FFFF", "C0C0FF", "FFC0FF")
        , ("E0E0E0", "FF8080", "FFC080", "FFFF80", "80FF80", "80FFFF", "8080FF", "FF80FF")
        , ("C0C0C0", "FF0000", "FF8000", "FFFF00", "00FF00", "00FFFF", "0000FF", "FF00FF")
        , ("808080", "C00000", "C04000", "C0C000", "00C000", "00C0C0", "0000C0", "C000C0")
        , ("404040", "800000", "804000", "808000", "008000", "008080", "000080", "800080")
        , ("000000", "400000", "804040", "404000", "004000", "004040", "000040", "400040")
        )
  FFNhKZ(self, self.Title)
  self["keyRed"].show()
  FFi79B(self["keyGreen"] , "< > Transp.")
  FFi79B(self["keyYellow"], "Foreground")
  FFi79B(self["keyBlue"] , "Background")
  if self.onlyBG:
   self["keyYellow"].hide()
   self["keyBlue"].hide()
  for row in range(self.VVz8of):
   for col in range(self.VVatGZ):
    self["myColor%d%d" % (row, col)] = Label()
  self["myColorPtr"] = Label()
  self["myColorTst"] = Label("This is a test message.\n0123456789")
  FFrM8n(self,
  {
   "ok"   : self.VVuV7E     ,
   "green"   : self.VVuV7E     ,
   "yellow"  : BF(self.VVKeZB, False)  ,
   "blue"   : BF(self.VVKeZB, True)  ,
   "up"   : self.VVCdU6       ,
   "down"   : self.VV41MG      ,
   "left"   : self.VVDDr1      ,
   "right"   : self.VVksC6      ,
   "last"   : BF(self.VVcLhO, -5) ,
   "next"   : BF(self.VVcLhO, 5) ,
   "cancel"  : BF(self.close, None, None)
  })
  self.onShown.append(self.VVf1Ra)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  for row in range(self.VVz8of):
   for col in range(self.VVatGZ):
    FFgLA9(self["myColor%d%d" % (row, col)], "#11%s" % self.colors[row][col])
  c = "#11333333"
  FFgLA9(self["keyRed"] , c)
  FFgLA9(self["keyGreen"] , c)
  self.VVYluS()
  self.VVdxLD()
  FFPvX5(self["myColorTst"], self.defFG, self.defBG)
  self.VVY8wb(0, 0)
 def VVNSzd(self, color, defColor):
  color = color.upper()
  span = iSearch(r"([#][a-fA-F0-9]{8})", color, IGNORECASE)
  if span : return color
  else : return defColor
 def VVdxLD(self):
  for row in range(self.VVz8of):
   for col in range(self.VVatGZ):
    color = self.colors[row][col]
    found = False
    if self.isBgMode:
     if self.defBG[3:] == self.colors[row][col]:
      found = True
    else:
     if self.defFG[3:] == self.colors[row][col]:
      found = True
    if found:
     self.curRow = row
     self.curCol = col
     self.VVY8wb(0, 0)
     return
 def VVuV7E(self):
  self.close(self.defFG, self.defBG)
 def VVCdU6(self): self.VVY8wb(-1, 0)
 def VV41MG(self): self.VVY8wb(1, 0)
 def VVDDr1(self): self.VVY8wb(0, -1)
 def VVksC6(self): self.VVY8wb(0, 1)
 def VVY8wb(self, row, col):
  self.curRow += row
  self.curCol += col
  if   self.curRow > self.VVz8of -1 : self.curRow = 0
  elif self.curRow < 0     : self.curRow = self.VVz8of - 1
  if   self.curCol > self.VVatGZ -1 : self.curCol = 0
  elif self.curCol < 0     : self.curCol = self.VVatGZ - 1
  color = self.VVhXQb()
  self["keyRed"].setText(color)
  if self.isBgMode: self.defBG = color
  else   : self.defFG = color
  gap = int(self.VVmNvK["VVvs2f"] / 2)
  pos = self["myColor%d%d" % (self.curRow, self.curCol)].getPosition()
  self["myColorPtr"].instance.move(ePoint(pos[0] - gap - 2, pos[1] - gap - 2))
  self.VVEsoI()
 def VVYluS(self):
  self["myTitle"].setText("  %s %s" % ("Background" if self.isBgMode else "Foreground", self.Title))
 def VVEsoI(self):
  color = self.VVhXQb()
  if self.isBgMode: FFgLA9(self["myColorTst"], color)
  else   : FFMhbx(self["myColorTst"], color)
 def VVKeZB(self, isBg):
  if not self.onlyBG:
   self.isBgMode = isBg
   self.VVYluS()
   self.VVdxLD()
 def VVcLhO(self, val):
  if self.isBgMode: self.transpBg = FFbn8W(self.transpBg + val, 0, 255)
  else   : self.transpFg = FFbn8W(self.transpFg + val, 0, 255)
  self. VVY8wb(0, 0)
 def VVpf3Y(self):
  if self.isBgMode: return hex(self.transpBg)[2:].zfill(2)
  else   : return hex(self.transpFg)[2:].zfill(2)
 def VVhXQb(self):
  return ("#%s%s" % (self.VVpf3Y(), self.colors[self.curRow][self.curCol])).upper()
class CCSLfI(Screen, CC3TwO):
 def __init__(self, session, playerObj=None):
  self.skin, self.VVmNvK = FFQaOH(VVx4YV, 1860, 1030, 20, 20, 30, "#33002233", "#33002233", 25, VVcmdl=2)
  self.session   = session
  self.playerObj   = playerObj
  self.VVfj1l  = eTimer()
  self.VVL6Hj  = eTimer()
  self.VVV0rp  = eTimer()
  self.VVGrzq = eTimer()
  self.subtLinesTable  = None
  self.subtLinesTableNdx = -1
  self.subtList   = []
  self.curSubtFullData = None
  self.lastSubtInfo  = ""
  self.lastSubtFile  = ""
  self.lastSubtEnc  = ""
  self.settingShown  = False
  self.CursorPos   = 0
  self.Title    = "Subtitle Settings"
  self.VVhzhr  = None
  self.subtMenuFromPlayer = True
  if FFdufB() and CCg47Y.VVvjvY() == "Gemini":
   self.VVuE4N = 400
   self.VVruCK = 0.4
  else:
   self.VVuE4N = 50
   self.VVruCK = 0.18
  self.minDelay, self.maxDelay = self.VV3U9c()
  self.diac    = u"\u0610\u0611\u0612\u0613\u0614\u0615\u0616\u0617\u0618\u0619\u061a\u064b\u064c\u064d\u064e\u064f\u0650\u0651\u0652\u0653\u0654\u0655\u0656\u0657\u0658\u0659\u065a\u065b\u065c\u065d\u065e\u0670\u06d6\u06d7\u06d8\u06d9\u06da\u06db\u06dc\u06df\u06e0\u06e1\u06e2\u06e3\u06e4\u06e7\u06e8\u06ea\u06eb\u06ec\u06ed"
  CC3TwO.__init__(self)
  FFNhKZ(self, title="%s%s%s" % (self.Title, " " * 10, FFKrMM("Change values with Up , Down, < , 0 , >", VV0p9P)))
  self["mySubtCover"] = Label()
  self.ctrlBtns = ("keyRed", "keyGreen", "keyYellow", "keyBlue")
  subj = ("Reset All", "Save", "Reset Delay", "Pick Line")
  for i, name in enumerate(self.ctrlBtns):
   self[name] = Label(subj[i])
  self["mySubtCursor"] = Label()
  subj = ("Delay", "BG Trans %", "Text Color", "Text Font", "Text Size", "Alignment", "Shadow Color", "Shadow Size", "Position")
  self.settingLabels = ["Del", "BGTr", "TxtFg", "TxtFnt", "TxtSiz", "Align", "ShadFg", "ShadSiz", "Pos"]
  self.settingLabels1 = list(self.settingLabels)
  for i, name in enumerate(self.settingLabels):
   self.settingLabels[i]  = "mySubt%s"   % name
   self.settingLabels1[i] = "mySubt%s1"  % name
   self[self.settingLabels[i]]  = Label(subj[i])
   self[self.settingLabels1[i]] = Label(subj[i])
  self["mySubtFr"] = Label()
  for i in range(3): self["mySubt%d"  % i] = Label()
  for i in range(4): self["mySubtSep%d" % i] = Label()
  for i in range(4): self["mySubtChng%d" % i] = Label()
  self["mySubtChng1"].setText("Line (Left/Right) , Delay (Up/Down)")
  self["myRest1"] = Label("Reset")
  self.VV7ZGr()
  FFrM8n(self,
  {
   "ok"  : self.VVyuDa      ,
   "cancel" : self.VV3iIJ      ,
   "info"  : self.VVw8f6    ,
   "red"  : self.VVc2Xn  ,
   "green"  : self.VVwKcn   ,
   "yellow" : BF(self.VVERq8, 0)  ,
   "blue"  : self.VVprWd    ,
   "menu"  : self.VV1ruq      ,
   "left"  : BF(self.VVwFzR, -1),
   "right"  : BF(self.VVwFzR, 1) ,
   "last"  : self.VV1DcW     ,
   "next"  : self.VVdepp     ,
   "0"   : self.VVFcLw    ,
   "up"  : self.VVCdU6       ,
   "down"  : self.VV41MG      ,
   "pageUp" : BF(self.VVrLwe, True) ,
   "pageDown" : BF(self.VVrLwe, False) ,
   "chanUp" : BF(self.VVrLwe, True) ,
   "chanDown" : BF(self.VVrLwe, False) ,
   "longPlay" : BF(self.VVtCsI, "longPlay") ,
   "play"  : BF(self.VVtCsI, "pause")  ,
   "pause"  : BF(self.VVtCsI, "pause")  ,
   "playPause" : BF(self.VVtCsI, "pause")  ,
   "stop"  : BF(self.VVtCsI, "pause")  ,
   "audio"  : BF(self.VVtCsI, "audio")  ,
   "subtitle" : BF(self.VVtCsI, "subtitle") ,
   "rewind" : BF(self.VVEKTQ, "rewind") ,
   "forward" : BF(self.VVEKTQ, "forward") ,
   "rewindDm" : BF(self.VVEKTQ, "rewind") ,
   "forwardDm" : BF(self.VVEKTQ, "forward")
  })
  self.VVqz7H()
  self.onShown.append(self.VVf1Ra)
  self.onClose.append(self.VVbJwi)
 def VVqz7H(self):
  lst = []
  for fil in FFYvtE(resolveFilename(SCOPE_FONTS), "*.[tToO][tT][fF]"):
   name = os.path.splitext(os.path.basename(fil))[0]
   lst.append((fil, name))
  if lst:
   lst.sort(key=lambda x: x[1].lower())
   default = CFG.subtTextFont.default
   if default == VVT0uN:
    for path, name in lst:
     if "almateen" in name.lower():
      default = name
      break
   CFG.subtTextFont = ConfigSelection(default=default, choices=lst)
 def VVf1Ra(self):
  self.onShown.remove(self.VVf1Ra)
  FFuwGk(self)
  FFeo1z(self)
  FF0u5o(self["myRest1"], "#000000", 3)
  for i in range(3):
   self["mySubt%d" % i].hide()
  self.VV5tDZ()
  self.VVN3Vk()
  srtCfgPath = CCSLfI.VVvn5L(self)
  FFlonU("mv -f '%s.dis' '%s'" % (srtCfgPath, srtCfgPath))
  self.VVEMFo()
 def VVbJwi(self):
  self.VVfj1l.stop()
  self.VVL6Hj.stop()
  self.VVV0rp.stop()
  self.VVGrzq.stop()
 def VVx6gg(self):
  self.settingShown = True
  for name in self.ctrlBtns: self[name].show()
  for name in self.settingLabels : self[name].show()
  for name in self.settingLabels1: self[name].show()
  for i in range(4): self["mySubtSep%d" % i].show()
  self["myTitle"].show()
  self["mySubtFr"].show()
  FFgLA9(self["myBody"], "#33002233")
  self["keyMenu"].show()
  self["keyInfo"].show()
  self["mySubtCover"].hide()
  self.VVhvML()
 def VV5tDZ(self):
  self.settingShown = False
  for name in self.ctrlBtns: self[name].hide()
  for name in self.settingLabels : self[name].hide()
  for name in self.settingLabels1: self[name].hide()
  for i in range(4): self["mySubtSep%d" % i].hide()
  self["myTitle"].hide()
  self["mySubtFr"].hide()
  FFgLA9(self["myBody"], "#ff000000")
  self["keyMenu"].hide()
  self["keyInfo"].hide()
  self["mySubtCover"].show()
 def VVyuDa(self):
  if self.settingShown:
   confItem = self.VV0qwm()[self.CursorPos]
   title = self[self.settingLabels[self.CursorPos]].getText()
   CCLbil.VVZvbO(self, confItem, title, cbFnc=self.VVzLUm)
  elif self.VV9IzV():
   self.VV7ZGr()
  else:
   self.close("subtExit")
 def VVzLUm(self):
  self.VVhvML()
  self.VVN3Vk()
  self.VVZxij(True)
 def VV3iIJ(self):
  for confItem in self.VV0qwm():
   if FFHY8B(confItem):
    FF6pUe(self, BF(self.VVS1uf, cbFnc=self.VVRj9L), "Save Changes ?", callBack_No=self.VV39K2, title=self.Title)
    break
  else:
   self.VVRj9L()
 def VVRj9L(self):
  if  self.settingShown   : self.VV5tDZ()
  elif self.VV9IzV() : self.VV7ZGr()
  else       : self.close("subtExit")
 def VV39K2(self):
  for confItem in self.VV0qwm(): confItem.cancel()
  if self.settingShown:
   self.VVhvML()
   self.VVN3Vk()
   self.VV5tDZ()
  else:
   self.close("subtExit")
 def VV1ruq(self):
  if self.settingShown   : self.VVNp9o()
  elif self.VV9IzV() : pass
  else       : self.VVx6gg()
 def VVwFzR(self, pos):
  if self.settingShown:
   self.CursorPos += pos
   if   self.CursorPos > len(self.settingLabels) - 1: self.CursorPos = 0
   elif self.CursorPos < 0        : self.CursorPos = len(self.settingLabels) - 1
   inst = self[self.settingLabels[self.CursorPos]].instance
   left = inst.position().x() - 5
   inst = self["mySubtCursor"].instance
   inst.move(ePoint(left, int(inst.position().y())))
  else:
   self.VVQikK(pos)
 def VVQikK(self, pos):
  posVal, durVal = self.VVurf5()
  if pos == -1: ndx = self.VV9xRR(posVal)
  else  : ndx = self.VVQ8Y2(posVal)
  if   ndx < 0      : FFoTZI(self, "No lines"  , 500)
  elif ndx == 0      : FFoTZI(self, "First line", 500)
  elif ndx == len(self.subtList) - 1 : FFoTZI(self, "Last line" , 500)
  else:
   capNum, frmSec, toSec, subtLines = self.subtList[ndx]
   delay, color, allow = self.VVPxDd(frmSec)
   if allow:
    if self.VV9IzV():
     self.VVERq8(delay, True)
     self.VVZxij(force=True)
    else:
     self.VVsVpP(delay, frmSec)
   else:
    FFoTZI(self, "Delay out of range", 800)
 def VVFToq(self, val):
  self.VVERq8(CFG.subtDelaySec.getValue() + val)
  self.VVZxij(force=True)
 def VVsVpP(self, delay, frmSec):
  self["mySubtChng2"].setText("Line Time = %s" % FFrTEd(frmSec))
  self["mySubtChng3"].setText("Delay = %s second%s" % (delay, FFaRsj(delay)))
  for i in range(4): self["mySubtChng%d" % i].show()
  self["myRest1"].show()
  try: self.VVGrzq_conn = self.VVGrzq.timeout.connect(self.VV0koC)
  except: self.VVGrzq.callback.append(self.VV0koC)
  self.VVGrzq.start(100, False)
 def VV0koC(self):
  if self.curSubtFullData:
   capNum, frmSec, toSec, subtLines, VVETIE = self.curSubtFullData
   if frmSec > 0 and toSec - frmSec > 0:
    self["mySubtChng2"].setText("Line %s      %s" % (capNum, FFrTEd(frmSec)))
    self["mySubtChng3"].setText("Delay = %s Sec" % CFG.subtDelaySec.getValue())
 def VV7ZGr(self):
  self.VVGrzq.stop()
  for i in range(4): self["mySubtChng%d" % i].hide()
  self["myRest1"].hide()
 def VV9IzV(self):
  return self["mySubtChng1"].getVisible()
 def VVrLwe(self, isUp):
  if not self.settingShown and not self.VV9IzV():
   self.close("subtZapUp" if isUp else "subtZapDn")
 def VVtCsI(self, reason):
  if not self.settingShown:
   self.close(reason)
 def VVEKTQ(self, act):
  if self.playerObj:
   if   act == "rewind" : self.playerObj.VVXrpH()
   elif act == "forward" : self.playerObj.VVwtWY()
 def VV1DcW(self) : self.VVBBqo(5)
 def VVdepp(self) : self.VVBBqo(6)
 def VVFcLw(self) : self.VVBBqo(-1)
 def VVCdU6(self):
  if  self.settingShown   : self.VVBBqo(1)
  elif self.VV9IzV() : self.VVFToq(1)
  else       : self.VVrLwe(True)
 def VV41MG(self):
  if self.settingShown: self.VVBBqo(0)
  elif self.VV9IzV() : self.VVFToq(-1)
  else    : self.VVrLwe(False)
 def VVBBqo(self, direction):
  if self.settingShown:
   confItem = self.VV0qwm()[self.CursorPos]
   if direction == -1:
    confItem.setValue(confItem.default)
   else:
    if direction in (0, 1) and confItem in (CFG.subtTextFg, CFG.subtTextFont, CFG.subtTextAlign, CFG.subtShadowColor, CFG.subtVerticalPos):
     direction = 0 if direction == 1 else 1
    confItem.handleKey(direction)
   if confItem is CFG.subtTextAlign:
    align = CFG.subtTextAlign.getValue()
    boxWidth= self.instance.size().width()
    for i in range(3):
     inst = self["mySubt%d" % i].instance
     w   = inst.calculateSize().width() + 50
     if   align == "0" : left = 0
     elif align == "2" : left = boxWidth - w
     else    : left = int((getDesktop(0).size().width() - w) / 2.0)
     inst.move(ePoint(left, int(inst.position().y())))
   self.VVhvML()
   self.VVN3Vk()
   self.VVZxij(True)
 def VV0qwm(self):
  return (  CFG.subtDelaySec
    , CFG.subtBGTransp
    , CFG.subtTextFg
    , CFG.subtTextFont
    , CFG.subtTextSize
    , CFG.subtTextAlign
    , CFG.subtShadowColor
    , CFG.subtShadowSize
    , CFG.subtVerticalPos)
 def VVc2Xn(self):
  if self.settingShown:
   FF6pUe(self, self.VVVzwX, "Reset Subtitle Settings to default ?", title=self.Title)
 def VVVzwX(self):
  for confItem in self.VV0qwm(): confItem.setValue(confItem.default)
  self.VVS1uf()
  self.VVhvML()
  self.VVN3Vk()
 def VVERq8(self, delay, force=False):
  if self.settingShown or self.VV9IzV() or force:
   FFBWtx(CFG.subtDelaySec, delay)
   self.VVabpl()
   self.VVhvML()
   self.VVN3Vk()
   if  self.settingShown and delay == 0: FFxHED(self, 'Reset to "0"', 800)
   elif self.VV9IzV()   : self.VV0koC()
 def VVuGDB(self):
  Max = CFG.subtDelayMax.getValue() * 60
  CFG.subtDelaySec = ConfigSelectionNumber(default=0, stepwidth=1, min=-Max, max=Max, wraparound=False)
  FFBWtx(CFG.subtDelaySec, 0)
  self.minDelay, self.maxDelay = self.VV3U9c()
  self.VVS1uf()
  self.VVhvML()
 def VVwKcn(self):
  if self.settingShown:
   self.VVS1uf()
   self.VV5tDZ()
 def VVS1uf(self, cbFnc=None):
  for confItem in self.VV0qwm(): confItem.save()
  configfile.save()
  self.VVabpl()
  FFxHED(self, "Saved")
  if cbFnc:
   cbFnc()
 def VVhvML(self):
  cfgLst = self.VV0qwm()
  for i, name in enumerate(self.settingLabels1):
   self[name].setText(str(cfgLst[i].getText()))
 def VVN3Vk(self):
  path = CFG.subtTextFont.getValue()
  if FFKbVo(path):
   fnt = "AJP_Subtitle"
   FF1GWp(path, fnt, isRepl=1)
  else:
   fnt = VV3IRX
  lineH = 0
  top = self["mySubt0"].instance.position().y()
  bg = int(FFel7I(CFG.subtBGTransp.getValue(), 0, 100, 0, 255))
  try:
   for i in range(3):
    obj = self["mySubt%d" % i]
    inst = obj.instance
    if CFG.subtTextFg.getValue().startswith("#"):
     FFMhbx(obj, CFG.subtTextFg.getValue())
    VVYvMU = CFG.subtTextSize.getValue()
    inst.setFont(gFont(fnt, VVYvMU))
    FFgLA9(obj, "#%0.2X000000" % bg)
    FF0u5o(self["mySubt%d" % i], CFG.subtShadowColor.getValue(), int(CFG.subtShadowSize.getValue()))
    lineH = FFkCSf(VVYvMU, self.VVruCK)
    inst.resize(eSize(*(int(inst.size().width()), lineH)))
    if i > 0:
     inst.move(ePoint(int(inst.position().x()), int(top + lineH * i + i * 1 )))
   for i in range(1, 4):
    inst = self["mySubtSep%d" % i].instance
    inst.move(ePoint(int(inst.position().x()), int(top + lineH * i + i * 1 )))
  except:
   pass
  inst = self["mySubt2"].instance
  winH = inst.position().y() + inst.size().height() + 2
  winW = self.instance.size().width()
  self.instance.resize(eSize(*(int(winW), int(winH))))
  y = int(FFel7I(CFG.subtVerticalPos.getValue(), 0, 100, 0, FFcBkL()[1] - winH))
  self.instance.move(ePoint(int(self.instance.position().x()), y))
  FFg1s2(self, winW, winH)
 def VVw8f6(self):
  sp = "    "
  txt  = "%s\n"   % FFKrMM("Subtitle File:", VVk4x7)
  txt += sp + "%s\n\n" % self.lastSubtFile
  txt += "%s\n"     % FFKrMM("Subtitle Settings:", VVk4x7)
  txt += sp + "Encoding\t: %s\n" % (self.lastSubtEnc or "Default")
  txt += sp + "Delay\t: %s sec\n" % CFG.subtDelaySec.getValue()
  if self.subtList:
   posVal, durVal = self.VVurf5()
   capNum1, frmSec1, toSec1, subtLines1 = self.subtList[0]
   capNum2, frmSec2, toSec2, subtLines2 = self.subtList[len(self.subtList) - 1]
   time1 = FFrTEd(frmSec1)
   time2 = FFrTEd(toSec2)
   txt += "\n"
   txt += "%s\n"       % FFKrMM("Timing:", VVk4x7)
   txt += sp + "Captions\t: %s - %s\n"  % (capNum1, capNum2)
   txt += sp + "Subt. Time\t: %s - %s\n" % (time1, time2)
   txt += sp + "Event Dur.\t: %s\n"  % FFrTEd(durVal)
   txt += sp + "Progress\t: %s\n" % FFrTEd(posVal)
   err = self.VVTOAb(posVal)
   if err:
    txt += sp + "Remarks\t: %s\n" % FFKrMM(err, VVdLWL)
  FFSMJz(self, txt, title="Current Subtitle")
 def VVEMFo(self, path="", delay=0, enc=""):
  FF7iMz(self, BF(self.VVBvIB, path=path, delay=delay, enc=enc), "Checking Subtitle ...", clearMsg=False)
 def VVBvIB(self, path="", delay=0, enc=""):
  FFoTZI(self)
  try:
   self.VVfj1l.stop()
   if path:
    subtList, err = self.VVcqKA(path, enc=enc)
    if err    : self.close(err)
    elif not subtList : self.close("subtInval")
    else    :
     self.subtList = subtList
     CFG.subtDelaySec.setValue(int(delay))
     FFBWtx(CFG.subtDelaySec, int(delay))
     self.VVhvML()
     self.VVON6a()
   else:
    path, delay, enc = CCSLfI.VVTU5P(self)
    if path:
     self.VVEMFo(path=path, delay=delay, enc=enc)
    else:
     self.VVNp9o()
  except:
   pass
 def VVON6a(self):
  CCSLfI.VVV5ny(None)
  try: self.VVfj1l_conn = self.VVfj1l.timeout.connect(self.VVZxij)
  except: self.VVfj1l.callback.append(self.VVZxij)
  self.VVfj1l.start(500, False)
  try: self.VVL6Hj_conn = self.VVL6Hj.timeout.connect(self.VVCOXq)
  except: self.VVL6Hj.callback.append(self.VVCOXq)
  err = self.VVTOAb()
  if err : FFxHED(self, err)
  else : FFxHED(self, "Subtitle started", 700)
 def VVTOAb(self, posVal=None):
  if posVal == None:
   posVal, durVal = self.VVurf5()
  capNum2, frmSec2, toSec2, subtLines2 = self.subtList[len(self.subtList) - 1]
  return "Subtitle end reached" if (posVal - int(CFG.subtDelaySec.getValue()) > toSec2) else ""
 def VVRPXi(self, posVal, margin=0):
  capNum2, frmSec2, toSec2, subtLines2 = self.subtList[len(self.subtList) - 1]
  if posVal + self.maxDelay > toSec2:
   path = CCSLfI.VVvn5L(self)
   FFxHED(self, "End of subtitle reached")
   return True
  else:
   return False
 def VVNp9o(self):
  c1, c2, c3, c4, c5, c6 = VVk4x7, VVWH8U, VVv8b8, VV2jvK, VVWJEN, VVdLWL
  fPath, fDir, fName = CC17eA.VVNGSU(self)
  txt1 = FFKrMM("... from Favourite Path", VV3Hcc)
  VV9cxb = []
  VV9cxb.append(("Select from Favourites Path"     , "listFav"  ))
  VV9cxb.append(("Select from All Paths"      , "listAll"  ))
  VV9cxb.append((c1 + "Select from File Manager"    , "listFMan" ))
  VV9cxb.append(FFH04v("Select from Current Movie Path" , "listCur", fPath, c2 ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Set Maximum Delay (Minutes)"     , "setMaxDelay" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append((c3 + "Set Favourite Path"      , "setFavPath" ))
  VV9cxb.append((c3 + "Set Auto-Find Event Name Language"  , "setFavLang" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append((c3 + "Suggest files (%s35%%%s match) %s" % (c4, c3, txt1), "sugSrt0.35"))
  VV9cxb.append((c3 + "Suggest files (%s50%%%s match) %s" % (c4, c3, txt1), "sugSrt0.50"))
  VV9cxb.append((c3 + "Suggest files (%s80%%%s match) %s" % (c4, c3, txt1), "sugSrt0.80"))
  if self.settingShown:
   VV9cxb.append(VVbM5H)
   VV9cxb.append((c5 + "Change Subtitle File Encoding" , "enc"  ))
   VV9cxb.append(VVbM5H)
   VV9cxb.append((c6 + "Disable Current Subtitle"  , "disb" ))
   VV9cxb.append(VVbM5H)
   VV9cxb.append(("Help (Keys)"       , "help" ))
  VVQ4hk = self.VVosBe
  FFO9kU(self, self.VVQ1UO, VV9cxb=VV9cxb, width=900, height=1000, title='Find Subtitle "srt" File', VVQ4hk=VVQ4hk, VVfWsQ="#22001122", VVB5I5="#11000509", VVfINZ="#08554455")
 def VVosBe(self, item=None):
  if item:
   VVhzhr, title, item, ndx = item
   self.VVhzhr = VVhzhr
   title = FFkEjh(title).partition("...")[0].strip()
   if   item == "listFav"   : self.VVpvKy(0, title)
   elif item == "listAll"   : self.VVpvKy(1, title)
   elif item == "listFMan"   : self.session.openWithCallback(self.VVbNFS, BF(CC17eA, VV8JM3="srt", VVqNQm=CFG.lastSubtFManFindDir.getValue()))
   elif item == "listCur"   : self.VVpvKy(2, title)
   elif item == "setMaxDelay"  : CCLbil.VVZvbO(self, CFG.subtDelayMax, "Subtitle Delay Limit (Minutes)", cbFnc=self.VVuGDB, isSave=True, width=700)
   elif item == "setFavPath"  : self.session.openWithCallback(self.VVcmTa, BF(CC17eA, mode=CC17eA.VVAcq8, VVqNQm=CFG.subtitleFavPath.getValue()))
   elif item == "setFavLang"  : CCLbil.VVZvbO(self, CFG.subtitleEventLang, "Event Name Search Language", cbFnc=BF(FFxHED, self.VVhzhr or self, "Saved"), isSave=True, width=700)
   elif item.startswith("sugSrt") : self.VVpvKy(3, title, coeff=float(item[6:]))
   elif item == "enc":
    if self.lastSubtFile and FFKbVo(self.lastSubtFile) : FF7iMz(self. VVhzhr or self, BF(CC6ntZ.VVuzBx, self, self.lastSubtFile, self.VVAsES, self.lastSubtEnc or CFG.subtDefaultEnc.getValue()), title="Loading Codecs ...")
    else             : FFoTZI(self, "SRT File error", 1000)
   elif item == "disb"    : self.VVTTBY()
   elif item == "help"    : FFY7F5(self, "_help_subt", "Subtitle (Keys)")
 def VVTTBY(self, item=None):
  subtRefFile = CCSLfI.VVvn5L(self)
  fPath, fDir, fName = CC17eA.VVNGSU(self)
  if fPath and subtRefFile:
   fPath += ".ajp"
   if FFKbVo(fPath):
    FFlonU("mv -f '%s' '%s.dis'" % (fPath, fPath))
  else:
   FFnE7j(subtRefFile)
  self.VVhON2()
  self.close("subtExit")
 def VVQ1UO(self, item=None):
  if not self.settingShown and self.subtMenuFromPlayer:
   self.close("subtCancel")
 def VVhON2(self):
  self.subtMenuFromPlayer = False
  if self.VVhzhr: self.VVhzhr.cancel()
  if self.settingShown: self.VV5tDZ()
 def VVAsES(self, item=None):
  if item:
   self.VVhON2()
   FF7iMz(self.VVhzhr or self, BF(self.VVEMFo, path=self.lastSubtFile, delay=CFG.subtDelaySec.getValue(), enc=item), title="Loading Subtitle ...")
 def VVbNFS(self, path):
  if path:
   self.VVhON2()
   FFBWtx(CFG.lastSubtFManFindDir, os.path.dirname(path))
   self.VVEMFo(path=path)
 def VVcmTa(self, path):
  if path:
   FFBWtx(CFG.subtitleFavPath, path)
   FFxHED(self.VVhzhr or self, "Saved")
 def VVpvKy(self, mode, title, coeff=0.25):
  FF7iMz(self.VVhzhr or self, BF(self.VVyvZg, mode, title, coeff), title="Searching for srt files")
 def VVyvZg(self, mode, title, coeff):
  evName = CCtAi7.VVwEcY(self).strip()
  if mode == 3 and not evName:
   FF8bV6(self.VVhzhr or self, "No event Name", 2000)
   return
  if   mode == 0: sPath = CFG.subtitleFavPath.getValue()
  elif mode == 1: sPath = "/"
  elif mode == 2: sPath = CC17eA.VVNGSU(self)[1]
  elif mode == 3: sPath = CFG.subtitleFavPath.getValue()
  srtList = FFux9U(r'find "%s" %s \( -iname "*.srt" \) | grep -i "\.srt"' % (sPath, FFbt47(1)))
  if srtList and srtList[0].startswith("find:"):
   FFbBGq(self, "Error in path:\n\n%s" % sPath, title=title)
   return
  if not srtList:
   FF8bV6(self.VVhzhr or self, "No srt files", 1500)
   return
  srtList.sort(key=lambda x: x.lower())
  if mode == 3:
   trName = evName
   if CFG.subtitleEventLang.getValue() == "s":
    trName = CCtAi7.VVpz2a(evName, "en")[0] or evName
   title = "%s %s\t%s %s" % (title, VV0p9P, VVjojy, trName)
   self.VVUE79(self.VVhzhr or self, BF(self.VV0kJA, mode, evName, trName, title), trName, srtList, 20, coeff)
  else:
   self.VV0kJA(mode, evName, "", title, srtList, "")
 def VV0kJA(self, mode, evName, trName, title, srtList, err):
  if mode == 3:
   if not srtList: err = err or "No Similar Names"
   if err:
    if evName == trName : FF8bV6(self.VVhzhr or self, err, 2000)
    else    : FFbBGq(self, err, title="Event : %s" % trName)
    return
  VVuGUx = []
  curColor = "#f#0000FF00#"
  for path in srtList:
   fName, Dir = os.path.basename(path), FF9Uvy(os.path.dirname(path))
   if self.lastSubtFile == Dir + fName:
    fName, Dir = curColor + fName, curColor + Dir
   VVuGUx.append((fName, Dir))
  VVj7lw  = ("Select"    , self.VVF2EY        , [])
  VVmolf = (""     , self.VVcCUF          , [])
  VVDPcX = (""     , BF(self.VVLMPg, self.lastSubtFile, False) , [])
  VVwqVu = ("Find Current File" , BF(self.VVLMPg, self.lastSubtFile, True) , [])
  header   = ("File" , "Directory" )
  widths   = (60  , 40   )
  FFCXsL(self, None, title=title, header=header, VVXpNQ=VVuGUx, VV8boH=widths, VVPYL1=28, VVj7lw=VVj7lw, VVmolf=VVmolf, VVDPcX=VVDPcX, VVwqVu=VVwqVu, VVAGe1=CFG.lastFindSubtitle
    , VVfWsQ="#11002222", VVB5I5="#22001111", VVYCun="#22001111", VVzVW9="#11ffff00", VVmErq="#11552233", VVK8UQ="#22222222", VVgSJJ="#11002233")
 def VVcCUF(self, VVAIxO, title, txt, colList):
  fName, Dir = colList
  FFSMJz(VVAIxO, "%s\n\n%s%s" % (FFKrMM("Path:", VVk4x7), Dir, fName), title=title)
 def VVLMPg(self, path, VVAdNn, VVAIxO, title, txt, colList):
  for ndx, row in enumerate(VVAIxO.VVGpBN()):
   if path == row[1].strip() + row[0].strip():
    VVAIxO.VVt5t9(ndx)
    break
  else:
   if VVAdNn:
    FFoTZI(VVAIxO, "Not in list !", 1000)
 def VVF2EY(self, VVAIxO, title, txt, colList):
  VVAIxO.cancel()
  self.VVhON2()
  path = "%s%s" % (colList[1].strip(), colList[0].strip())
  FF7iMz(self.VVhzhr, BF(self.VVEMFo, path=path))
 def VVcqKA(self, path, enc=None):
  if enc and CC6ntZ.VVAYqs(path, enc)      : enc = enc
  elif CC6ntZ.VVAYqs(path, CFG.subtDefaultEnc.getValue()): enc = CFG.subtDefaultEnc.getValue()
  else                   : enc = None
  if not FFKbVo(path):
   return [], "File not found"
  if (FFLjtI(path) > 1024 * 700):
   return [], "File too big"
  frmSec = toSec = bold = italic = under = 0
  capNum  = ""
  capFound = True
  color  = ""
  subtLines = []
  subtList = []
  lines  = FF2kXa(path, encLst=enc)
  lastNdx  = len(lines) - 1
  for ndx, line in enumerate(lines):
   line = str(line).strip()
   if line:
    if line.isdigit():
     capNum = line
    else:
     span = iSearch(r'(\d{2}:\d{2}:\d{2},\d{3})\s*\-->\s*(\d{2}:\d{2}:\d{2},\d{3})', line, IGNORECASE)
     if span:
      p  = list(map(int, span.group(1).replace(",", ":").split(":")))
      frmSec = p[0] * 3600 + p[1] * 60 + p[2] + p[3] / 1000.0
      p  = list(map(int, span.group(2).replace(",", ":").split(":")))
      toSec = p[0] * 3600 + p[1] * 60 + p[2] + p[3] / 1000.0
      subtLines = []
     else:
      span = iSearch(r'<font color="(.+)">(.+)', line, IGNORECASE)
      if span:
       color = self.VVBTXV(span.group(1))
       line = span.group(2)
      if "<b>" in line: bold = 1
      if "<i>" in line: italic = 1
      if "<u>" in line: under = 1
      line = line.replace("</font>", "").replace("</b>", "").replace("</i>", "").replace("</u>", "")
      line = line.replace("<b>", "").replace("<i>", "").replace("<u>", "")
      span = iSearch(r"{\\a\d}(.+)", line, IGNORECASE)
      if span:
       line = span.group(1)
      line = self.VVD5Iu(line)
      subtLines.append((line.strip(), color, bold, italic, under))
      if ndx == lastNdx and subtList and (toSec - frmSec) > 0 and not subtList[len(subtList) - 1] == (capNum, frmSec, toSec, subtLines):
       subtList.append((capNum, frmSec, toSec, subtLines))
   else:
    if toSec > frmSec and subtLines:
     subtList.append((capNum, frmSec, toSec, subtLines))
    frmSec = toSec = bold = italic = under = 0
    capNum  = ""
    color  = ""
    subtLines = []
  if subtList:
   self.lastSubtFile = path
   self.lastSubtEnc  = enc
   self.VVabpl()
  return subtList, ""
 def VVD5Iu(self, line):
  line = line.replace(u"\u202A", "")
  line = line.replace(u"\u202B", "")
  line = line.replace(u"\u202C", "")
  for char in line:
   if 0x600 <= ord(char) <= 0x6FF and char in self.diac:
    line = line.replace(char, "")
  line = line.replace("\r", "..").replace("\n", "..")
  return str(line)
 def VVBTXV(self, color):
  lst = { "black": "#000000", "blue": "#0000ff", "brown":"#a52a2a", "cyan":"#00ffff", "darkblue": "#0000a0", "gray":"#808080", "green":"#008000", "grey": "#808080", "lightblue":"#add8E6", "lime":"#00ff00", "magenta":"#ff00ff", "maroon":"#800000", "olive":"#808000", "orange":"#ffa500", "purple":"#800080", "red":"#ff0000", "silver":"#c0c0c0", "white":"#ffffff", "yellow":"#ffff00"}
  code = lst.get(color.lower(), "")
  if code:
   return code
  else:
   span = iSearch(r"(#[A-Fa-f0-9]{6})", color, IGNORECASE)
   if span : return span.group(1)
   else : return ""
 def VVabpl(self):
  path = CCSLfI.VVvn5L(self)
  if path:
   try:
    with open(path, "w") as f:
     f.write("srt=%s\n" % self.lastSubtFile)
     f.write("delay=%s\n" % CFG.subtDelaySec.getValue())
     if self.lastSubtEnc:
      f.write("enc=%s\n" % self.lastSubtEnc)
   except:
    pass
 def VVZxij(self, force=False):
  posVal, durVal = self.VVurf5()
  err = self.VVTOAb(posVal)
  if err:
   return
  VVETIE = self.VVxgbd(posVal)
  if VVETIE < 0:
   return
  txtDur = 0
  if posVal:
   capNum, frmSec, toSec, subtLines = self.subtList[VVETIE]
   if force or not self.lastSubtInfo == subtLines:
    self.lastSubtInfo = subtLines
    self.curSubtFullData = (capNum, frmSec, toSec, subtLines, VVETIE)
    settingColor = ""
    if CFG.subtTextFg.getValue().startswith("#"):
     settingColor = CFG.subtTextFg.getValue()
    self.VVCOXq()
    subtLines = list(subtLines)
    l = len(subtLines)
    for i in range(3 - len(subtLines)):
     subtLines.insert(0, ("", "", 0, 0, 0))
    align = CFG.subtTextAlign.getValue()
    boxWidth= self.instance.size().width()
    txtDur = int(toSec * 1000 - frmSec * 1000)
    if txtDur > 0:
     for ndx, (line, color, bold, italic, under) in enumerate(subtLines):
      if line:
       if   bold   : newColor = "#aaffff"
       elif italic   : newColor = "#aaaaaa"
       elif under   : newColor = "#ffffaa"
       elif settingColor : newColor = settingColor
       elif color   : newColor = color
       else    : newColor = ""
       if ndx < 3:
        obj  = self["mySubt%d" % ndx]
        inst = obj.instance
        if newColor:
         FFMhbx(obj, newColor)
        obj.setText(line)
        obj.show()
        w = inst.calculateSize().width() + self.VVuE4N
        inst.resize(eSize(*(w, inst.size().height())))
        if   align == "0" : left = 0
        elif align == "2" : left = boxWidth - w
        else    : left = int((getDesktop(0).size().width() - w) / 2.0)
        inst.move(ePoint(left, int(inst.position().y())))
    if txtDur > 0:
     self.VVL6Hj.start(txtDur, True)
 def VVurf5(self):
  seekable, percVal, durVal, posVal, remVal, percTxt, durTxt, posTxt, remTxt = CCsmqb.VVKbqb(self)
  if not durVal and not posVal:
   evName, evTime, evDur, evShort, evDesc, genre, PR = CCtAi7.VVoo5Y(self)
   if evTime and evDur:
    posVal, durVal = iTime() - evTime, evDur
  return posVal, durVal
 def VVxgbd(self, posVal):
  if posVal > 0:
   delay = CFG.subtDelaySec.getValue()
   for ndx, item in enumerate(self.subtList):
    frmSec = item[1] + delay
    toSec = item[2] + delay
    if posVal > frmSec and posVal < toSec:
     return ndx
  return -1
 def VV9xRR(self, posVal):
  if posVal > 0:
   delay = CFG.subtDelaySec.getValue()
   for ndx, item in enumerate(self.subtList):
    frmSec = item[1] + delay
    toSec = item[2] + delay
    if toSec > posVal:
     return ndx -1
  return -1
 def VVQ8Y2(self, posVal):
  if posVal > 0:
   delay = CFG.subtDelaySec.getValue()
   for ndx, item in enumerate(self.subtList):
    frmSec = item[1] + delay
    toSec = item[2] + delay
    if frmSec > posVal:
     return ndx
  return -1
 def VVCOXq(self):
  for i in range(3):
   self["mySubt%d" % i].setText("")
   FFMhbx(self["mySubt%d" % i], "#00ffffff")
   self["mySubt%d" % i].hide()
 def VVprWd(self):
  if not self.VV9IzV():
   self.VVlImo()
 @FFJRPn("Loading Lines ...")
 def VVlImo(self):
  VVuGUx = []
  for cap, frm, to, lines in self.subtList:
   firstLine = lines[0][0] if lines else ""
   VVuGUx.append((cap, FFrTEd(frm), str(frm), firstLine))
  if VVuGUx:
   title = "Select Current Subtitle Line"
   VVpW7I = self.VVSBX8
   VVDPcX = (""    , self.VVe8zr , [])
   VVj7lw  = ("Select"   , self.VVLfOp , [title])
   VVwqVu = ("Current Line" , self.VVgEdj , [True])
   VV46TD = ("Reset Delay" , self.VVGJ4m , [])
   header   = ("Cap" , "Time", "Time Val", "Subtitle Text" )
   widths   = (8  , 15 , 0    , 77    )
   VV4Uoc  = (CENTER , CENTER, CENTER , LEFT    )
   VVAIxO = FFCXsL(self, None, title=title, header=header, VVXpNQ=VVuGUx, VV4Uoc=VV4Uoc, VV8boH=widths, VVPYL1=28, VVDPcX=VVDPcX, VVpW7I=VVpW7I, VVj7lw=VVj7lw, VVwqVu=VVwqVu, VV46TD=VV46TD
          , VVfWsQ="#33002222", VVB5I5="#33001111", VVYCun="#33110011", VVzVW9="#11ffff00", VVmErq="#0a334455", VVK8UQ="#22222222", VVgSJJ="#33002233")
   err = self.VVTOAb()
   if err:
    VVAIxO.VVbtl9()
    FFoTZI(VVAIxO, err, 1500)
  else:
   FF8bV6(self, "Cannot read lines !", 2000)
 def VVe8zr(self, VVAIxO, title, txt, colList):
  self.subtLinesTable = VVAIxO
  if int(CFG.subtDelaySec.getValue()):
   VVAIxO["keyYellow"].show()
   VVAIxO["keyYellow"].setText("Reset Delay (%s sec)" % CFG.subtDelaySec.getValue())
  else:
   VVAIxO["keyYellow"].hide()
  VVAIxO["keyBlue"].setText("New Delay: %s sec" % CFG.subtDelaySec.getValue())
  VVAIxO["keyBlue"].show()
  FFgLA9(VVAIxO["keyBlue"], "#22222222")
  VVAIxO.VVQ4nk(BF(self.VVzCQp, VVAIxO))
  self.VVgEdj(VVAIxO, False)
  try: self.VVV0rp_conn = self.VVV0rp.timeout.connect(self.VVU9pj)
  except: self.VVV0rp.callback.append(self.VVU9pj)
  self.VVV0rp.start(500, False)
 def VVSBX8(self, VVAIxO):
  self.VVV0rp.stop()
  self.subtLinesTable  = None
  self.subtLinesTableNdx = -1
  VVAIxO.cancel()
 def VVU9pj(self):
  if self.subtLinesTable:
   VVAIxO = self.subtLinesTable
   posVal, durVal = self.VVurf5()
   color = "#b#11551111#"
   if posVal > 0:
    curTime = posVal - float(CFG.subtDelaySec.getValue())
    VVETIE = self.VVxgbd(posVal)
    if VVETIE > -1:
     if self.subtLinesTableNdx > -1:
      row = VVAIxO.VVBWxt(self.subtLinesTableNdx)
      row[0] = row[0].replace(color, "")
      VVAIxO.VVUvuG(self.subtLinesTableNdx, row)
     row = VVAIxO.VVBWxt(VVETIE)
     row[0] = color + row[0]
     VVAIxO.VVUvuG(VVETIE, row)
     self.subtLinesTableNdx = VVETIE
 def VVLfOp(self, VVAIxO, Title):
  delay, color, allow = self.VVJxjF(VVAIxO)
  if allow:
   self.VVSBX8(VVAIxO)
   self.VVERq8(delay, True)
  else:
   FFoTZI(VVAIxO, "Delay out of range", 1500)
 def VVgEdj(self, VVAIxO, VVAdNn, onlyColor=False):
  if VVAIxO:
   posVal, durVal = self.VVurf5()
   if posVal > 0:
    curTime = posVal - float(CFG.subtDelaySec.getValue())
    VVETIE = self.VVxgbd(posVal)
    if VVETIE > -1:
     VVAIxO.VVt5t9(VVETIE)
    else:
     ndx = self.VV9xRR(posVal)
     if ndx > -1:
      VVAIxO.VVt5t9(ndx)
 def VVGJ4m(self, VVAIxO, title, txt, colList):
  if VVAIxO["keyYellow"].getVisible():
   self.VVERq8(0, True)
   VVAIxO["keyYellow"].hide()
   self.VVgEdj(VVAIxO, False)
 def VVzCQp(self, VVAIxO):
  delay, color, allow = self.VVJxjF(VVAIxO)
  VVAIxO["keyBlue"].setText("%sNew Delay: %s sec" % (color, delay))
 def VVJxjF(self, VVAIxO):
  lineTime = float(VVAIxO.VVQDwi()[2].strip())
  return self.VVPxDd(lineTime)
 def VVPxDd(self, lineTime):
  posVal, durVal = self.VVurf5()
  delay, color, allow = 0, "", False
  if posVal > 0:
   val = int(round(posVal - lineTime))
   if self.minDelay <= val <= self.maxDelay: allow, color = True , VVWH8U
   else          : allow, color = False, VVU4M8
   delay = FFbn8W(val, self.minDelay, self.maxDelay)
  return delay, color, allow
 def VV3U9c(self):
  lst = CFG.subtDelaySec.choices.choices
  tMin = lst[0]
  tMax = lst[len(lst) - 1]
  if isinstance(tMin, tuple):
   tMin = tMin[0]
   tMax = tMax[0]
  return int(tMin), int(tMax)
 @staticmethod
 def VVnB1F(SELF):
  srtCfgPath = CCSLfI.VVvn5L(SELF)
  if srtCfgPath and FFKbVo(srtCfgPath + ".dis"):
   return False
  path, delay, enc = CCSLfI.VVTU5P(SELF)
  return True if path else False
 @staticmethod
 def VVTU5P(SELF):
  path, delay, enc = CCSLfI.VV5oAz(SELF)
  if not path:
   path = CCSLfI.VVxmvF(SELF)
  return path, delay, enc
 @staticmethod
 def VV5oAz(SELF):
  srtCfgPath = CCSLfI.VVvn5L(SELF)
  path = enc = ""
  delay = 0
  if srtCfgPath:
   if FFKbVo(srtCfgPath):
    lines = FF2kXa(srtCfgPath)
    for line in lines:
     line = line.strip()
     if   line.startswith("srt=") : path = line.split("=")[1].strip()
     elif line.startswith("delay=") : delay = line.split("=")[1].strip()
     elif line.startswith("enc=") : enc = line.split("=")[1].strip()
  if path and FFKbVo(path):
   try:
    delay = int(delay)
   except:
    pass
   return path, delay, enc
  else:
   return "", 0, ""
 @staticmethod
 def VVvn5L(SELF):
  fPath, fDir, fName = CC17eA.VVNGSU(SELF)
  if not fPath:
   evName, evTime, evDur, evShort, evDesc, genre, PR = CCtAi7.VVoo5Y(SELF)
   if evName.strip() and evTime and evDur:
    fPath = "/tmp/" + evName[:30].strip()
  if not fPath:
   VVUwmk = CCZv30(SELF.session).VVUwmk.strip()
   if VVUwmk:
    fPath = "/tmp/" + VVUwmk
  if fPath: return fPath + ".ajp"
  else : return ""
 @staticmethod
 def VVxmvF(SELF):
  bestRatio = 0
  fPath, fDir, fName = CC17eA.VVNGSU(SELF)
  if fName:
   bestSrt = os.path.splitext(fPath)[0] + ".srt"
   if FFKbVo(bestSrt):
    return bestSrt
   else:
    movName = os.path.splitext(fName)[0]
    paths = CCSLfI.VV7gLP(SELF)
    nm = CC3TwO()
    bLst, err = nm.VVbNkN(movName, paths, 1, 0.3)
    if bLst:
     return bLst[0]
  return ""
 @staticmethod
 def VV7gLP(SELF):
  fPath, fDir, fName = CC17eA.VVNGSU(SELF)
  if VVkY7E(fDir):
   files = FFYvtE(fDir, "*.srt")
   if files:
    return files
  return []
 @staticmethod
 def VVhC0D():
  try:
   return InfoBar.instance.selected_subtitle
  except:
   try:
    return InfoBar.instance.__selected_subtitle
   except:
    return None
 @staticmethod
 def VVV5ny(subt):
  if subt and isinstance(subt, tuple) and len(subt) >= 4 : state = True
  else             : subt, state = None, False
  try:
   InfoBar.instance.enableSubtitle(subt)
  except:
   try:
    if state:
     InfoBar.instance.__selected_subtitle = subt
    InfoBar.instance.setSubtitlesEnable(state)
   except:
    pass
  CCSLfI.VV2yhW()
 @staticmethod
 def VV2yhW():
  try:
   if config.subtitles.show.value : InfoBar.instance.subtitle_window.show()
   else       : InfoBar.instance.subtitle_window.hide()
  except:
   pass
class CC2Y8z(ScrollLabel):
 def __init__(self, VV5mVu, text="", VVj5rH=True):
  ScrollLabel.__init__(self, text)
  self.VVj5rH   = VVj5rH
  self.long_text    = None
  self.scrollbar    = None
  self.message    = text
  self.instance    = None
  self.VVYdbN  = 0
  self.curPos     = 0
  self.pageHeight    = 0
  self.pageLines    = 0
  self.column     = 0
  self.outputFileToSave  = ""
  self.VV5mVu    = VV5mVu
  self.isResizable   = None
  self.fontFamily    = None
  self.VVPYL1    = None
  self.parentW    = None
  self.parentH    = None
  self.wrapEnabled   = True
  self.addNewLine    = True
  self.maxChars    = 0
  self.VVRNLK  = 50 if FFdufB() else 0
  VV5mVu["keyRedTop"]  = Label("Menu")
  VV5mVu["keyGreenTop"] = Label("Reset")
  VV5mVu["keyYellowTop"] = Label("Font -")
  VV5mVu["keyBlueTop"] = Label("Font +")
  VV5mVu["keyRedTop1"] = Label()
  VV5mVu["keyGreenTop1"] = Label()
  VV5mVu["keyYellowTop1"] = Label()
  VV5mVu["keyBlueTop1"] = Label()
  FFrM8n(VV5mVu,
  {
   "ok"   : VV5mVu.close  ,
   "cancel"  : VV5mVu.close  ,
   "menu"   : self.VVPDVY ,
   "green"   : self.VVRi7w ,
   "yellow"  : self.VV9VVg ,
   "blue"   : self.VVunBk ,
   "up"   : self.VVRlRL   ,
   "down"   : self.VV4SSV  ,
   "left"   : self.VVRlRL   ,
   "right"   : self.VV4SSV  ,
   "last"   : BF(self.VVy3hc, 0) ,
   "0"    : BF(self.VVy3hc, 1) ,
   "next"   : BF(self.VVy3hc, 2) ,
   "pageUp"  : self.VVW9mX   ,
   "chanUp"  : self.VVW9mX   ,
   "pageDown"  : self.VVyGzv   ,
   "chanDown"  : self.VVyGzv
  })
 def VVesH9(self, isResizable=True, VV4n1E=False, outputFileToSave="", addNewLine=True, hideBtns=False, maxChars=0):
  self.outputFileToSave = outputFileToSave
  self.addNewLine = addNewLine
  self.maxChars = maxChars
  if hideBtns:
   for b in ("keyRedTop", "keyGreenTop", "keyYellowTop", "keyBlueTop", "keyRedTop1", "keyGreenTop1", "keyYellowTop1", "keyBlueTop1"):
    self.VV5mVu[b].hide()
  FFPvX5(self.VV5mVu["keyRedTop"], "#00FFFF55" if outputFileToSave else "#00FFFFFF", "#11000000")
  FFuwGk(self.VV5mVu, True)
  self.isResizable = isResizable
  if VV4n1E:
   self.long_text.setHAlign(1)
  size    = self.VV5mVu.instance.size()
  self.parentW  = size.width()
  self.parentH  = size.height()
  font    = self.long_text.getFont()
  self.fontFamily  = font.family
  self.VVPYL1  = font.pointSize
  try:  self.scrollbar.setBorderColor(parseColor("#11555555"))
  except: pass
  try:  self.scrollbar.setForegroundColor(parseColor("#11AA8E48"))
  except: pass
  try:  self.scrollbar.setBackgroundColor(parseColor("#11111111"))
  except: pass
  color = self.VV5mVu.VVmNvK["VViaEk"]
  FFgLA9(self, color)
 def VVaxMF(self, color):
  self.long_text.setBackgroundColor(parseColor(color))
 def applySkin(self, desktop, parent):
  import skin
  from enigma import eLabel, eSlider
  self.long_text = eLabel(self.instance)
  self.scrollbar = eSlider(self.instance)
  skin.applyAllAttributes(self.long_text, desktop, self.skinAttributes, parent.scale)
  self.pageWidth = self.long_text.size().width()
  VVCW3G  = int(fontRenderClass.getInstance().getLineHeight(self.long_text.getFont())) or 30
  self.pageLines = int(self.long_text.size().height() / VVCW3G)
  margin   = int(VVCW3G / 6)
  self.pageHeight = int(self.pageLines * VVCW3G)
  self.instance.move(self.long_text.position())
  self.instance.resize(eSize(self.pageWidth, self.pageHeight + margin))
  w = 20
  self.scrollbar.move(ePoint(self.pageWidth - w, 0))
  self.scrollbar.resize(eSize(w, self.pageHeight + margin))
  self.scrollbar.setOrientation(eSlider.orVertical)
  self.scrollbar.setRange(0, 100)
  self.scrollbar.setBorderWidth(1)
  return True
 def setPos(self, pos):
  self.curPos = max(0, min(pos, self.VVYdbN - self.pageHeight))
  self.long_text.move(ePoint(0, -self.curPos))
  self.VVA59O()
 def VVRlRL(self):
  if self.VVYdbN > self.pageHeight:
   self.setPos(self.curPos - self.pageHeight)
 def VV4SSV(self):
  if self.VVYdbN > self.pageHeight:
   self.setPos(self.curPos + self.pageHeight)
 def VVW9mX(self):
  self.setPos(0)
 def VVyGzv(self):
  self.setPos(self.VVYdbN-self.pageHeight)
 def VVNkAa(self):
  return self.VVYdbN <= self.pageHeight or self.curPos == self.VVYdbN - self.pageHeight
 def getText(self):
  return self.message
 def VVA59O(self):
  try:
   vis = int(max(100 * self.pageHeight / self.VVYdbN, 3))
   start = int((100 - vis) * self.curPos / (self.VVYdbN - self.pageHeight))
   self.scrollbar.setStartEnd(start, start + vis)
  except:
   pass
 def setText(self, text, VV5wgt=VVfI5z):
  old_VVNkAa = self.VVNkAa()
  self.message = str(text)
  if self.maxChars > 0 and len(self.message) > self.maxChars:
   self.message = self.message[-self.maxChars:]
   if "\n" in self.message[:100]:
    self.message = self.message[self.message.index("\n"):]
  if self.pageHeight:
   if self.addNewLine and len(self.message.splitlines()) < self.pageLines - 2:
    if not self.message.startswith("\n"):
     self.message = "\n" + self.message
    self.message = self.message.rstrip() + "\n"
   self.long_text.setText(self.message)
   self.VVYdbN = self.long_text.calculateSize().height()
   if self.VVj5rH and self.VVYdbN > self.pageHeight:
    self.scrollbar.show()
    self.VVA59O()
    w = self.VV5mVu.VVmNvK["scrollBarW"] + 5
    pageWidth  = self.instance.size().width() - w
    self.long_text.resize(eSize(pageWidth, self.VVYdbN))
    self.VVYdbN = self.long_text.calculateSize().height()
    self.long_text.resize(eSize(pageWidth, self.VVYdbN))
   else:
    self.scrollbar.hide()
   if   VV5wgt == VVhlSe: self.setPos(0)
   elif VV5wgt == VVoR3b : self.VVyGzv()
   elif old_VVNkAa    : self.VVyGzv()
 def appendText(self, text, VV5wgt=VVoR3b):
  self.setText(self.message + str(text), VV5wgt=VV5wgt)
 def VV9VVg(self):
  size = int(self.long_text.getFont().pointSize * 0.8)
  if size > 5:
   self.VV0KY9(size)
 def VVunBk(self):
  size = int(self.long_text.getFont().pointSize * 1.2)
  if size < 80:
   self.VV0KY9(size)
 def VVRi7w(self):
  self.VV0KY9(self.VVPYL1)
 def VV0KY9(self, VVPYL1):
  self.long_text.setFont(gFont(self.fontFamily, VVPYL1))
  self.setText(self.message, VV5wgt=VVfI5z)
  self.VVJS7j()
 def VVy3hc(self, align):
  self.long_text.setHAlign(align)
 def VVPDVY(self):
  VV9cxb = []
  VV9cxb.append(("%s Wrapping" % ("Disable" if self.wrapEnabled else "Enable"), "wrap" ))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Align Left" , "left" ))
  VV9cxb.append(("Align Center" , "center" ))
  VV9cxb.append(("Align Right" , "right" ))
  if self.outputFileToSave:
   VV9cxb.append(VVbM5H)
   VV9cxb.append((FFKrMM("Save to File", VVk4x7), "save"))
  VV9cxb.append(VVbM5H)
  VV9cxb.append(("Keys (Shortcuts)", "help"))
  FFO9kU(self.VV5mVu, self.VVr6XQ, VV9cxb=VV9cxb, title="Text Option", width=500)
 def VVr6XQ(self, item=None):
  if item:
   if item == "wrap"  : self.VVj9Ll()
   elif item == "left"  : self.VVy3hc(0)
   elif item == "center" : self.VVy3hc(1)
   elif item == "right" : self.VVy3hc(2)
   elif item == "save"  : self.VVBMaN()
   elif item == "help"  : FFY7F5(self.VV5mVu, "_help_txt", "Text Viewer (Keys)")
 def VVpi6g(self, isOn):
  self.wrapEnabled = isOn
  self.long_text.setNoWrap(not isOn)
 def VVj9Ll(self):
  self.VVpi6g(not self.wrapEnabled)
 def VVBMaN(self):
  title = "%s Log File" % self.outputFileToSave.capitalize()
  expPath = FFeg8m()
  try:
   outF = "%sAJPanel_log_%s_%s.txt" % (FF9Uvy(expPath), self.outputFileToSave, FFRIlf())
   with open(outF, "w") as f:
    f.write(FFkEjh(self.message))
   FF0onH(self.VV5mVu, "Saved to:\n\n%s" % outF, title=title)
  except:
   FFbBGq(self.VV5mVu, "Could not save to:\n\n%s" % expPath, title=title)
 def VVJS7j(self, minHeight=0):
  if self.isResizable:
   VVCW3G = int(fontRenderClass.getInstance().getLineHeight(self.long_text.getFont()))
   textH = min(self.pageHeight, VVCW3G * (len(self.message.splitlines()) + 1))
   if textH < self.pageHeight and self.VVYdbN < self.pageHeight:
    textH = max(textH, self.VVYdbN) + self.VVRNLK
   self.resize(eSize(*(self.instance.size().width(), textH + 6)))
   diff = self.pageHeight - textH
   newH = self.parentH - diff
   if diff < 0:
    newH = self.parentH
   if minHeight > 0:
    newH = max(newH, minHeight + self.VV5mVu.VVmNvK["titleH"] + self.VV5mVu.VVmNvK["VVXAYU"] * 2 + 1)
   screenSize = getDesktop(0).size()
   self.VV5mVu.instance.resize(eSize(*(self.parentW, min(self.parentH, newH))))
   self.VV5mVu.instance.move(ePoint((screenSize.width() - self.parentW) // 2, (screenSize.height() - newH) // 2))
